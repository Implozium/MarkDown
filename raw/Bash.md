Основы
======

## Основные понятия

**Сценарии командной строки** - это наборы команд, которые можно вводить с клавиатуры, собранные в файлы и объединённые некоей общей целью. При этом результаты работы команд могут представлять либо самостоятельную ценность, либо служить входными данными для других команд.

### Запуск

Для того чтобы сценарий запускался ему необходимо установить разрешение, сделать его выполняемым:  
`chmod +x ./<имя_файла>`  
`./<имя_файла>` - запускает скрипт

### Строение файла скрипта

Первая строка должна быть такого вида:  
`#!/bin/bash`

Команды оболочки отделяются знаком перевода строки или знаком точки с запятой `;`, комментарии выделяют знаком решётки `#`.

`echo [-n] "<текст>"` - выводит текст в консоль, для вывода знака `$` нужно писать `\$`, [`-n` - без перехода на новую строку].

## Переменные

`<имя_переменной>=<значение>` - установка значения переменной.  
`$<имя_переменной>` - возвращает значение переменной, это можно использовать также в строке.  
`${<имя_переменной>}` - аналогично.  
``<имя_переменной>=`<команда>` `` - записывает результат вывода команды в переменную.  
`<имя_переменной>=$(<команда>)` - аналогично.  
`<имя_переменной>=$((<математические_операции>))` - выполняет математические операции и записывает результат в переменную.
`<имя_переменной>=$[<математические_операции>]` - аналогично.

## Конструкция if-then-else

```bash
if <команда>
then
    <комманды>
[elif <команда>
then
    <комманды>]
[else
    <комманды>]
fi
```

Если выполнение команды `<команда>` завершится успешно, а именно будет возвращено нуль, то выполнятся комманды от `then` и до `elif/else/fi` [, иначе выполнятся комманды от `else` и до `fi`]

### Сравнения и проверки

`[` - является синонимом команды `test`, и является встроенной командой, `[<выражение>]`. Условие, находящееся внутри квадратных скобок может быть проверено без использования оператора `if`.

`[[<выражение>]]` - расширенный вариант команды `test`, которая выполняет сравнение более стандартным способом, пишущим на других языках программирования.

Круглые скобки `((<выражение>))` и предложение `let <выражение>` возвращают код 0, если результатом арифметического выражения является ненулевое значение.

Выражение должно быть заключено в квадратные скобки `[<выражение>]` и использоваться вместо команды `<команда>`.
Операторы `&&`, `||`, `<` и `>` внутри `[[ ]]` вполне допустимы, в то время как внутри `[ ]` порождают сообщения об ошибках.

#### Сравнение чисел

- `<число1> -eq <число2>` - возвращает истинное значение, если `<число1>` равно `<число2>`;
- `<число1> -ge <число2>` - возвращает истинное значение, если `<число1>` больше или равно `<число2>`;
- `<число1> -gt <число2>` - возвращает истинное значение, если `<число1>` больше `<число2>`;
- `<число1> -le <число2>` - возвращает истинное значение, если `<число1>` меньше или равно `<число2>`;
- `<число1> -lt <число2>` - возвращает истинное значение, если `<число1>` меньше `<число2>`;
- `<число1> -ne <число2>` - возвращает истинное значение, если `<число1>` не равно `<число2>`.

Вместо чисел можно использовать переменные.

#### Сравнение строк

- `"<строка1>" = "<строка2>"` - проверяет строки на равенство, возвращает истину, если строки идентичны;
- `"<строка1>" != "<строка2>"` - возвращает истину, если строки не идентичны. ;
- `"<строка1>" \< "<строка2>"` - возвращает истину, если `<строка1>` меньше, чем `<строка2>`;
- `"<строка1>" \> "<строка2>"` - возвращает истину, если `<строка1>` больше, чем `<строка2>`;
- `-n "<строка>"` - возвращает истину, если длина `<строка>` больше нуля;
- `-z "<строка>"` - возвращает истину, если длина `<строка>` равна нулю.

Вместо строк можно использовать переменные, но их нужно заключать в кавычки `"`.

#### Проверки файлов

- `-d <файл>` - проверяет, существует ли файл, и является ли он директорией;
- `-e <файл>` - проверяет, существует ли файл;
- `-f <файл>` - проверяет, существует ли файл, и является ли он файлом;
- `-r <файл>` - проверяет, существует ли файл, и доступен ли он для чтения;
- `-s <файл>` - проверяет, существует ли файл, и не является ли он пустым;
- `-w <файл>` - проверяет, существует ли файл, и доступен ли он для записи;
- `-x <файл>` - проверяет, существует ли файл, и является ли он исполняемым;
- `<файл1> -nt <файл2>` - проверяет, новее ли `<файл1>`, чем `<файл2>`;
- `<файл1> -ot <файл2>` - проверяет, старше ли `<файл1>`, чем `<файл2>`;
- `-O <файл>` - проверяет, существует ли файл, и является ли его владельцем текущий пользователь;
- `-G <файл>` - проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя;
- `<файл>` - должен выглядеть как путь к файлу, если в нем есть пробелы, то он должен быть заключен в кавычки.

Вместо файл можно использовать переменные.

## Циклы

Циклы можно вкладывать друг в друга.

### Цикл `for`

```bash
for <имя_переменной> in <список>
do
    <комманды>
done
```

В каждой итерации цикла в переменную `<имя_переменной>` будет записываться следующее значение из списка `<список>`.

Список может быть набором значений разделенных разделителем полей (пробел, знак табуляции, знак перевода строки) или результатом вывода команды.

### Установка разделителей полей

Для этого нужно изменить переменную среды `IFS`:  
`IFS=$'\n'` - устанавливает в качестве разделителя - символ новой строки.  
`IFS=<символ>` - установка произвольного символа.  
`IFS="<символ>[...]"` - установка произвольных символов

### Обход директорий

В качестве списка может быть указано путь к директории, подстановочный знак `*` - обозначает все.

### Цикл `for` в стиле C

```bash
for ((<начальное_значение_переменной>; <условие_окончания_цикла>; <изменение переменной>))
do
    <комманды>
done
```

> ```bash
> for (( i=1; i <= 10; i++ ))
> ```

### Цикл `while`

```bash
while <команда>
do
    <комманды>
done
```

Будет выполнять тело цикла до тех пор, пока проверяемое условие возвращает ноль, или сигнал успешного завершения некоей операции.

Вместо команды `<команда>`, можно использовать выражение.

### Команда `break`

Эта команда позволяет прервать выполнение цикла.

### Команда `continue`

Эта команда завершает текущую итерацию досрочно и начинает следующую, при этом выхода из цикла не происходит.

### Перенаправление вывода цикла

После слова `done`, на той же сточке можно указать перенаправление в файл.

## Параметры командной строки

Параметры командной строки разделяются из переменной `IFS`.

**Специальные переменные** - позиционные параметры, введённые при вызове скрипта параметры командной строки, можно получить:
- `$0` - имя скрипта;
- `$1` - первый параметр.;
- `$<n>` - n-ый параметр, вплоть до переменной $9;
- `${<n>}` - n-ый параметр, от 10;
- `$#` - содержит количество параметров, переданных сценарию при вызове;
- `${!#}` - содержит последний параметр;
- `$*` - содержит все параметры командной строки, в виде единого "*слова*";
- `$@` - содержит все параметры командной строки, где параметры разбиты на отдельные "*слова*". Эти параметры можно перебирать в циклах.

### Команда `shift`

Она, по умолчанию, сдвигает значения позиционных параметров влево: `$<n>` становится `$<n-1>`, при этом `$0`, не меняется.

## Конструкция case

```bash
case "<ключ>" in
<значение_1>) <комманды> ;;
...
*) <комманды_при_не_совпадении> ;;
esac
```

Сверяет `<ключ>` со значениями и выполняет указанные команды при соответствии значения с ключом. Если соответствия не найдется, будет исполнена ветвь `*`.

Последовательность - двойное тире `--` - признак окончания ключей.

## Стандартные ключи Linux

- `-a` - вывести все объекты;
- `-c` - произвести подсчёт;
- `-d` - указать директорию;
- `-e` - развернуть объект;
- `-f` - указать файл, из которого нужно прочитать данные;
- `-h` - вывести справку по команде;
- `-i` - игнорировать регистр символов;
- `-l` - выполнить полноформатный вывод данных;
- `-n` - использовать неинтерактивный (пакетный) режим;
- `-o` - позволяет указать файл, в который нужно перенаправить вывод;
- `-q` - выполнить скрипт в quiet-режиме;
- `-r` - обрабатывать папки и файлы рекурсивно;
- `-s` - выполнить скрипт в silent-режиме;
- `-v` - выполнить многословный вывод;
- `-x` - исключить объект;
- `-y` - ответить `yes` на все вопросы.

## Ввод значений от пользователя

`read [-p "<текст>"] [-t <время_ожидания>] [-s] <имя_переменной> [...]` - позволяет принимать введённые данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов, после получения данных, эта команда помещает их в указанную переменную, [`-s` - не отображать вывод].

Если, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды `REPLY`.

`read` может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится.

`read line` - такая команда может быть использована в цикле `while` в качестве команды условия, для построчного чтения файла и записи строки в переменную `line`.

## Дескрипторы файлов

Всё в Linux - это файлы, в том числе - ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2. Вот что они означают:

- `0`, `STDIN` - стандартный поток ввода. Для терминала стандартный ввод - это клавиатура. Когда в сценариях используют символ перенаправления ввода - `<`, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры;
- `1`, `STDOUT` - стандартный поток вывода. По умолчанию это - экран. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда `>>`, или перезаписать его содержимое новым, для этого служит команда `>`;
- `2`, `STDERR` - стандартный поток ошибок. По умолчанию этот дескриптор указывает на то же самое, на что указывает `STDOUT`.

### Перенаправление потоков ошибок и вывода

`<команда> [1> <дескриптор>] [2> <дескриптор>]` - перенаправляет потоки вывод и ошибки. Для того чтобы перенаправить `STDERR`, и `STDOUT` в один и тот же файл, воспользовавшись командой `&>`.
Где `<дескриптор>` - может быть путь к файлу или дескриптором `&<номер>`.

### Временное перенаправление вывода

`<команда> >&1` - перенаправление вывода команды в поток вывода.  
`<команда> >&2` - перенаправление вывода команды в поток ошибки.

### Постоянное перенаправление вывода

`exec 1> <дескриптор>` - перенаправляет весь вывод в определённый дескриптор на время выполнения скрипта.  
`exec 2> <дескриптор>` - перенаправляет все ошибки в определённый дескриптор на время выполнения скрипта.

### Перенаправление ввода в скриптах

`exec 0< <дескриптор>` - перенаправляет весь ввод из определённого дескриптора на время выполнения скрипта.

### Создание собственного перенаправления вывода

Шесть дескрипторов с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.

`exec <дескриптор_номер>><дескриптор_источник>`  
`exec <дескриптор_номер><<дескриптор_источник>`

Где `<дескриптор_источник>` - может быть путь к файлу или дескриптором `&<номер>`.

`exec <дескриптор_номер>>&-` - закрывает дескриптор, его потом можно открыть по новой.

### Получение сведений об открытых дескрипторах

`$$` - содержит текущий PID.
`lsof -a -p <PID> -d <дескриптор_номер>[, ...]` - выводит сведения о каждом дескрипторе, открытом в системе. Ключ `-a` используется для выполнения операции логического И над результатами, возвращёнными благодаря использованию двух других ключей.

### Подавление вывода

Для этого можно перенаправить вывод в `/dev/null`.

`cat /dev/null > <файл>` - очищает файл, не удаляя его.  
`: > <файл>` - аналогичное действие.

## Конвеер Pipe `|`

**Pipe** (конвеер) - это однонаправленный канал межпроцессного взаимодействия, используя символ конвеера `|`. Конвеер обеспечивает асинхронное выполнение команд с использованием буферизации ввода/вывода. Таким образом все команды в конвейере работают параллельно, каждая в своем процессе.

Размер буфера начиная с ядра версии 2.6.11 составляет 65536 байт (64Кб) и равен странице памяти в более старых ядрах. При попытке чтения из пустого буфера процесс чтения блокируется до появления данных. Аналогично при попытке записи в заполненный буфер процесс записи будет заблокирован до освобождения необходимого места.

Важно, что несмотря на то, что конвейер оперирует файловыми дескрипторами потоков ввода/вывода, все операции выполняются в памяти, без нагрузки на диск.

`<команда> | <команда> | ...`

> `cat *.txt | sort | uniq > result-file.txt`

## Сигналы Linux

### Основные сигналы

- `1` - `SIGHUP` - закрытие терминала;
- `2` - `SIGINT` - сигнал остановки процесса пользователем с терминала (`CTRL + C`);
- `3` - `SIGQUIT` - сигнал остановки процесса пользователем с терминала (`CTRL + \`) с дампом памяти;
- `9` - `SIGKILL` - безусловное завершение процесса;
- `15` - `SIGTERM` - сигнал запроса завершения процесса;
- `17` - `SIGSTOP` - принудительная приостановка выполнения процесса, но не завершение его работы;
- `18` - `SIGTSTP` - приостановка процесса с терминала (`CTRL + Z`), но не завершение работы;
- `19` - `SIGCONT` - продолжение выполнения ранее остановленного процесса.

### Временная остановка процесса

Сигнал `SIGTSTP` - приостанавливает работу процесса, но не завершает его выполнение. Такой процесс остаётся в памяти. Оболочка возвращает число в квадратных скобках - это номер задания, который оболочка назначает процессу. Оболочка рассматривает процессы, выполняющиеся в ней, как задания с уникальными номерами. Первому процессу назначается номер 1, второму - 2, и так далее.

`ps -l` - выводит приостановленные задания.  
`jobs` - выводит текущие задания и приостановленные задания.  
`jobs -l` - выводит приостановленные задания с их идентификаторами.  
`disown <идентификатор>` - убирает приостановленное задание по идентификатору.  
`fg <номер>` - возобновляет приостановленное задание по номеру в списке.

### Перехват сигналов

`trap "<команды>" <СИГНАЛ> [...]` - перехватывает указанные сигналы и вызывает указанные команды, для перехвата выхода из скрипта нужно указать имя сигнала `EXIT`.

Для модификации перехваченных скриптом сигналов можно выполнить команду `trap` с новыми параметрами.

`trap -- <СИГНАЛ> [...]` - отменяет перехват указанных сигналов.

## Выполнение сценариев командной строки в фоновом режиме

Для это нужно запустить его, указав после имени символ амперсанда `&`. Скрипт будет запущен в фоновом процессе, в терминал выведется его идентификатор, а когда его выполнение завершится, выведется сообщение об этом. При этом скрипт продолжает использовать терминал для вывода сообщений в `STDOUT` и `STDERR`. Если выйти из терминала, скрипт, выполняющийся в фоне, так же завершит работу.

`nohup <скрипт> &` - позволяет запустить программу, блокируя сигналы `SIGHUP`, отправляемые процессу и отвязывает процесс от терминала, что значит что процесс потеряет ссылки на `STDOUT` и `STDERR` и `nohup` автоматически перенаправляет сообщения, поступающие в `STDOUT` и в `STDERR`, в файл `nohup.out` в текущем каталоге; если это невозможно сделать, то перенаправление происходит в файл `$HOME/nohup.out`. Если и это невозможно сделать, то команда не запускается совсем.

`jobs -l` - выводит текущие задания, которые выполняются в оболочке.

## Планирование запуска скриптов

`at [-f <файл>] <время>` - запускает файл в указанное время, где время может быть в виде: `HH:MM`, `now`, `noon`, `midnight`, `MMDDYY`, `MM/DD/YY`, или `DD.MM.YY`.

Ключ `-M` при вызове `at` используется для отправки того, что выведет скрипт, по электронной почте, если система соответствующим образом настроена. Если отправка электронного письма невозможна, этот ключ просто подавит вывод.

`atq` - возвращает список заданий.  
`atrm <номер_задания>` - удаляет задание под указанным номером.

## Запуск скриптов по расписанию

`crontab -l` - выводит существующую таблицу заданий `cron` в консоль.

`crontab -e` - выводит существующую таблицу заданий `cron` в редакторе по умолчанию (`vi`) и позволяет редактировать его.

`<минута> <час> <день_месяца> <месяц> <день_недели> <скрипт>` - запускает указанный скрипт по расписанию в указаное время запуска, т.е. когда время будет равно заданой структуре. Единицы измерения:
- минуты (0-59);
- часы (0-23);
- дни месяца (1-31);
- месяцы (1-12) (jan feb mar apr may jun jul aug sep oct nov dec);
- дни недели (0-6 (0=воскресенье)) (sun mon tue wed thu fri sat).

Единицы измерения можно указывать в виде:
- `<число>` - числа;
- `<число_от>-<число_до>` - диапазон;
- `<число1>[,<число2>[,...]]` - перечисление;
- `*/<шаг>` - шаг (когда остаток от деления на `<шаг>` будет равен 0);
- `<число_от>-<число_до>/<шаг>` - шаг (когда остаток от деления минус `<число_от>` на `<шаг>` будет равен 0);
- `*` - любое значение.

Диапазоны и перечисления можно комбинировать.

Комментарий начинается с `#` и это задание не будет исполняться.

> `10 12 * * * script.sh` - скрипт выполнится в 12 часов 10 минут.  
> `0 22 * * 1-5 echo "Пора домой" | mail -s "Уже 22:00" john` - скрипт выполнится в 22 часа 00 минут по будням.  
> `1-59/2 * * * * echo "Выполняется по нечетным минутам"` - скрипт выполнится по нечетным минутам.

`crontab -r` - удаляет файл текущего расписания.

В `.bashrc` - содержатся скрипты, которые запускаются при открытии терминала.  
В `.bash_profile` - при входе в систему.

## Функции

Объявление функции, имена для функций, должны быть уникальными, так как новая функция затирает старую.

```bash
function <имяФункции>[()] {
	<код>
	[return <значение>]
}
```
`return <значение>` - позволяет задавать возвращаемый функцией целочисленный код завершения.

Имя функции хранится внутри функции в параметре `$0`, первый переданный ей аргумент - в `$1`, второй - в `$2`, и так далее, а количество переданных аргументов в `$#`, `$@` - содержит все аргументы в виде массива.

`<имяФункции> [<аргумент> [...]]` - вызов функции

В переменной `$?` хранится код возврата последней выполненной команды в том числе и функции, тогда максимальное число, которое может вернуть команда `return` - `255`.

`<переменная>=$(<имяФункции> [<аргумент> [...]])` - записывает в переменную результат функции.

Внутри функции можно вызвать саму функцию по имени.

### Переменные

**Глобальные переменные** - это переменные, которые видны из любого места bash-скрипта. По умолчанию все объявленные в скриптах переменные глобальны.  
**Локальные переменные** - их объявляют и используют внутри функции. Если за пределами функции есть переменная с таким же именем, это на неё не повлияет.

`local <имя_переменной>=<значение>` - установка значения локальной переменной.

### Массив

`<имя_переменной>= (<значение> [...])` - объявление массива (списка).  
`${<имя_переменной>[<индекс>]}` - возвращает указанный индекс элемента массива, `*` (`@`) - все.  
`${!<имя_переменной>[@]}` - возвращает индексы массива.  
`${#<имя_переменной>[@]}` - возвращает размер массива.  
`<имя_переменной>[<индекс>]=<значение>` - перезаписывает элемент массива.  
`<имя_переменной>+=(<значение>)` - присоединяет к массиву значения.  
`<имя_переменной>=$(<команда>)` - сохраняет вывод команды в виде строки в переменную.  
`<имя_переменной>=( $(<команда>) )` - сохраняет вывод команды в виде массива.  
`${<имя_переменной>[@]:s:n}` - возвращает элементы массива начиная с элемента с индексом `s` до элемента с индексом `s+(n-1)`.

> `str=$(ls)`  
> `arr=( $(ls) )`

Для передачи массива в функцию из него надо извлечь имеющиеся в нём данные и передать их функции как самостоятельные аргументы - `${<имя_переменной>[*]}`.

## Создание и использование библиотек

`source <путь_к_скрипту>` - подключает скрипт как библиотеку к скрипту и в результате функции, объявленные в библиотеке, становятся доступными в скрипте.  
`. <путь_к_скрипту>` - аналогично.

`sed`
=====

Утилита `sed` называется потоковым текстовым редактором, поточно обрабатывает строки. Схема вызова команды:  
`sed <опции> [<файл>]`

По умолчанию `sed` применяет указанные при вызове правила, выраженные в виде набора команд, к `STDIN`. Это позволяет передавать данные непосредственно `sed` через `|`.

## Опции

`'s/<шаблон_поиска>/<шаблон_замены>/[<флаги>]'` - производит потоковую замену найденных шаблонов.

> `'s/search/replace/'`

Для выполнения нескольких действий с данными, используется ключ `-e` при вызове и опции разделяются символом точкой с запятой `;`, при этом между окончанием команды и точкой с запятой не должно быть пробела:  
`sed -e <опции> [<файл>]`

Для того, чтобы указать `sed` файл, содержащий команды, используют ключ `-f`:  
`sed -f <файл_с_командами> [<файл>]`

### Дополнительные ключи

- `-n` - указанный при вызове sed, подавляет обычный вывод;
- `-e` - добавление скрипта или regex в исполняемые команды;
- `-r` - использовать расширенный синтаксис регулярных выражений (спец символы активны по умолчанию);
- `-d` - удалить;
- `-s` - заменить;
- `-p` - распечатать найденную строку;
- `-i` - выполнять изменения непосредственно в файле.

### Флаги

При передаче номера учитывается порядковый номер вхождения шаблона в строку, заменено будет именно это вхождение.

Флаг `g` указывает на то, что нужно обработать все вхождения шаблона, имеющиеся в строке.  
Флаг `p` указывает на то, что нужно вывести содержимое исходной строки.  
Флаг вида `w <файл>` указывает команде на то, что нужно записать результаты обработки текста в файл.

### Символы-разделители

Разделителем считается первый символ, который будет встречен после `s`:  
`'s<символ_разделитель><шаблон_поиска><символ_разделитель><шаблон_замены><символ_разделитель>[<флаги>]'`

> `'s:as:like:'`

### Выбор фрагментов текста для обработки

Перед `s` можно указать номер строки для обработки:  
`'<номер_строки>s/<шаблон_поиска>/<шаблон_замены>/'`  
`'<номер_строки_начала>,<номер_строки_конца>s/<шаблон_поиска>/<шаблон_замены>/'` - воздействует на диапазон строк. Где концом может выступать символ `$`, означающий номер последней строки.

> `'2,$s/find/replace/'`

`'/<шаблон_строки>/s/<шаблон_поиска>/<шаблон_замены>/'` - только строки, которые удовлетворяют указанному шаблону.

> `'/filter/s/find/replace/'`

### Удаление строк

`'<номер_строки>d'` - удаляет указанную строку из потока вывода.  
`'<номер_строки_начала>,<номер_строки_конца>d'` - удаляет указанный диапазон строк из потока вывода. Где концом может выступать символ `$`, означающий номер последней строки.  
`'/<шаблон_строки>/[,...]d'` - только строки, которые удовлетворяют указанному шаблону [одному из них].

### Вставка текста в поток

`'[<номер_строки>]i\<строка>'` - добавляет новую строку перед заданной.  
`'[<номер_строки>]a\<строка>'` - добавляет новую строку после заданной.

### Замена строк

`'<номер_строки>c\<строка>'` - заменяет указанную строку переданной.  
`'/<шаблон_строки>/c/<строка>'` - заменяет строки удовлетворяющие указанному шаблону переданной.

### Замена символов

`'y/<символы>/<символы_замены>/'` - заменяет символы в соответствии символам замены.

### Вывод номеров строк

`=` - выводит номер строки.  
`'/<шаблон_строки>/='` - выводит номер строки удовлетворяющей указанному шаблону.

### Чтение данных для вставки из файла

`'[<номер_строки>]r <файл>'` - вставляет содержимое файла после [указанной строки] в поток данных.  
`'/<шаблон_строки>/r <файл>'` - вставляет содержимое файла после строк удовлетворяющих указанному шаблону в поток данных.

### Регулярные выражения

Все шаблоны поиска могут представлять из себя регулярное выражение.

`awk`
=====

Утилита **awk** похожа на **sed** , но более разнообразна.

Awk воспринимает поступающие к нему данные в виде **набора записей**. Записи представляют собой наборы полей. **Запись** - это строка. **Поле** - это слово в строке.

Awk обрабатывает текст из потока ввода построчно.

`awk [<опции>] [<программа>] [<файл> [ ...]]`

## Опции

- `-F <символ>` - позволяет указать символ-разделитель для полей в записи;
- `-f <файл>` - указывает имя файла, из которого нужно прочесть awk-скрипт;
- `-v <переменная>=<значение>`- позволяет объявить переменную и задать её значение по умолчанию, которое будет использовать awk;
- `-mf <кол>` - задаёт максимальное число полей для обработки в файле данных;
- `-mr <кол>` - задаёт максимальный размер записи в файле данных;
- `-W <режим>` - позволяет задать режим совместимости или уровень выдачи предупреждений awk.

## Программа

Скрипты awk, которые можно писать прямо в командной строке, оформляются в виде текстов команд, заключённых в фигурные скобки. Кроме того, awk предполагает, что скрипт представляет собой текстовую строку, его нужно заключить в одинарные кавычки.

`'{<команда> [; ...]}'`

Для того, чтобы завершить работу awk, нужно передать ему символ конца файла (*EOF*, *End-of-File*). С помощью сочетания клавиш `CTRL + D`.

`print <текст> [, ...]` - печатает текст, он может состоять из строк и переменных.

`"<текст>"` - строка.

### Позиционные переменные, хранящие данные полей

По умолчанию `awk` назначает следующие переменные каждому полю данных, обнаруженному им в записи:
- `$0` - представляет всю строку текста (запись);
- `$1` - первое поле;
- `$2` - второе поле;
- `$n` - n-ное поле.

Поля выделяются из текста с использованием **символа-разделителя**. По умолчанию - это пробельные символы вроде пробела или символа табуляции.

### Файл скрипта

В файле скрипта может содержаться множество команд, при этом каждую из них достаточно записывать с новой строки, ставить после каждой точку с запятой не требуется.

Внутри скрипта можно объявлять переменные.

### Выполнение команд до начала обработки данных

`BEGIN {<команда> [; ...]}` - выполнит указанную секцию команд до начала обработки данных.

### Выполнение команд после окончания обработки данных

`END {<команда> [; ...]}` - выполнит указанную секцию команд после начала обработки данных.

### Встроенные переменные

- `FIELDWIDTHS` - разделённый пробелами список чисел, определяющий точную ширину каждого поля данных с учётом разделителей полей;
- `FS="<символ>"` - позволяет указать символ-разделитель для полей в записи;
- `RS="<символ>"` - переменная, которая позволяет задавать символ-разделитель записей;
- `OFS="<символ>"` - разделитель полей на выводе awk-скрипта;
- `ORS="<символ>"` - разделитель записей на выводе awk-скрипта;
- `ARGC` - количество аргументов командной строки;
- `ARGV` - массив с аргументами командной строки (`ARGV[<n>]`);
- `ARGIND` - индекс текущего обрабатываемого файла в массиве `ARGV`;
- `ENVIRON` - ассоциативный массив с переменными окружения и их значениями (`ENVIRON["<ключ>"]`);
- `ERRNO` - код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов;
- `FILENAME` - имя входного файла с данными;
- `FNR` - номер текущей записи в файле данных;
- `IGNORECASE` - если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов;
- `NF` - общее число полей данных в текущей записи, $NF позволяет обращаться к последнему полю данных в записи, не зная его точной позиции;
- `NR` - общее число обработанных записей.

### Условный оператор

`if (<условие>) <команда> [; else <команда>]`
```
if (<условие>)
{
    <команды>
}[ else {
    <команды>
}]
```

Операторы сравнения:
- `==` - равно;
- `!=` - не равно;
- `>` - больше;
- `<` - меньше;
- `<=` - больше или равно;
- `>=` - меньше или равно.


### Цикл while

```
while (<условие>)
{
    <команды>
}
```
В циклах `while` можно использовать команды `break` и `continue`.

### Цикл for

```
for (<начало>; <условие>; <итерация>)
{
    <команды>
}
```

## Форматированный вывод данных

Команда `printf` в awk позволяет выводить форматированные данные:  
`printf "<текст_со_спецификаторами>" [, <переменная> [, ...]]`

Первый спецификатор соответствует первой переменной, второй спецификатор - второй, и так далее.

`%[<модификатор>]<символ_спецификатора>` - спецификатор.

### Символы

- `c` - воспринимает переданное ему число как код ASCII-символа и выводит этот символ;
- `d` - выводит десятичное целое число;
- `i` - то же самое, что и d;
- `e` - выводит число в экспоненциальной форме;
- `f` - выводит число с плавающей запятой;
- `g` - выводит число либо в экспоненциальной записи, либо в формате с плавающей запятой, в зависимости - от того, как получается короче;
- `o` - выводит восьмеричное представление числа;
- `s` - выводит текстовую строку.

### Модификаторы

Могут комбинироваться и писаться в указанном порядке.

- `-` - выравнивание по левой стороне;
- ` ` - отрицательные числа пишутся со знака минуса, положительные с пробела;
- `+` - отрицательные числа пишутся со знака минуса, положительные с плюса;
- `0` - дополняет слева число нулями;
- `<число>` - минимальная ширина поля;
- `.<число>` - максимальная ширина поля.

## Встроенные математические функции

- `cos(x)` - косинус x (x выражено в радианах);
- `sin(x)` - синус x;
- `exp(x)` - экспоненциальная функция;
- `int(x)` - возвращает целую часть аргумента;
- `log(x)` - натуральный логарифм;
- `rand()` - возвращает случайное число с плавающей запятой в диапазоне 0 - 1;
- `sqrt(x)` - квадратный корень из x.

## Строковые функции

Используются аналогично математическим.

## Пользовательские функции

Объявляются до всех секций.

```
function <функция>()
{
    <команды>
}
```

`<функция>()` - использование.

Регулярные выражения
====================

Утилита **sed** поддерживает часть стандарта *POSIX Basic Regular Expression* (BRE).  
Регулярное выражение может находиться в шаблоне.

Утилита **awk** поддерживает стандарт *POSIX Extended Regular Expression* (ERE).  
Регулярное выражение может находиться в перед списком команд:  
`/<регулярное_выражение>/{<команда> [; ...]}`

Специальные символы экранируются с помощью обратной косой черты (обратного слэша) - `\`.

## Специальные классы символов

В BRE имеются специальные классы символов, которые можно использовать при написании регулярных выражений:
- `[[:alpha:]]` - соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре;
- `[[:alnum:]]` - соответствует любому алфавитно-цифровому символу, а именно - символам в диапазонах 0-9, A-Z, a-z;
- `[[:blank:]]` - соответствует пробелу и знаку табуляции;
- `[[:digit:]]` - любой цифровой символ от 0 до 9;
- `[[:upper:]]` - алфавитные символы в верхнем регистре - A-Z;
- `[[:lower:]]` - алфавитные символы в нижнем регистре - a-z;
- `[[:print:]]` - соответствует любому печатаемому символу;
- `[[:punct:]]` - соответствует знакам препинания;
- `[[:space:]]` - пробельные символы, в частности - пробел, знак табуляции, символы NL, FF, VT, CR.

`tar`
=====

## Запаковывание

`tar [-<ключи>] [<название_архива>] [<путь_что_запаковать>]`

Значения ключей:
- `с` - "create" - создать файл архива;
- `v` - "verbose" - выводить информацию в процессе выполнения;
- `z` - "gzip" - запаковать файл при помощи gzip;
- `f` - "file" - использовать имя файла архива указаное после ключей. Если не указать ключ `f` то команда будет использовать настройки по умолчанию либо выведет результат прямо в консоль.

> `tar -zcvf prog-1-jan-2005.tar.gz /home/jerry/prog`

## Распаковывание

`tar [-<ключи>] [<название_архива>]`

Значения ключей:
- `x` - "eXtract' - извлечь файлы;
- `v` - "verbose' - выводить информацию в процессе выполнения;
- `f` - "file' - использовать имя файла архива для распаковки указаное после ключей.

> `tar -zxvf prog-1-jan-2005.tar.gz -C /tmp`

`wget`
======

Загрузка всех URL, указанных в локальном или внешнем ФАЙЛЕ:  
`wget -i <файл>`

Скачивание файлов в указанный каталог `-P`:  
`wget -P <каталог> <ссылка>`

Использование имени пользователя и пароля на FTP/HTTP (вариант 1):  
`wget ftp://<логин>:<пароль>@<ссылка>`

Использование имени пользователя и пароля на FTP/HTTP (вариант 2):  
`wget --user=<логин> --password=<пароль> <ссылка>`

Скачивание в фоновом режиме `-b`:  
`wget -b <ссылка>`

Продолжить (`-c` continue) загрузку ранее не полностью загруженного файла:  
`wget -c <ссылка>`

Скачать содержимое каталога <ссылка> и всех его подкаталогов, при этом не поднимаясь по иерархии каталогов выше:  
`wget -r --no-parent <ссылка>`

Идентификация на сервере:
```
wget --save-cookies <файл_с_куками> \
--post-data '<POST_данные>' \
<ссылка>
```

Скачать весь сайт целиком:  
`wget -r -l <глубина рекурсии> -k -o <файл_лога> -p <ссылка>`

Где:
- `-r`, `--recursive` - включение рекурсивной загрузки;
- `-l`, `--level=<число>` - глубина рекурсии (`inf` и `0` - бесконечность);
- `-k`, `--convert-links` - делать ссылки локальными в загруженном HTML или CSS;
- `-o`, `--output-file=<файл>` - записывать сообщения (логи) в `<файл>`;
- `-p`, `--page-requisites` - загрузить все изображения и проч., необходимые для отображения HTML-страницы;
- `-m`, `--mirror` - короткий параметр, эквивалентный `-N -r -l inf --no-remove-listing`.

`grep`
======

Утилита командной строки, которая находит на вводе строки, отвечающие заданному регулярному выражению, и выводит их, если вывод не отменён специальным ключом.

Поиск строки в файле:  
`cat <файл> | grep [<опции>] <строка_поиска>`  
`grep [<опции>] <строка_поиска> <файл>`

Опции:
- `-c` - выводит количество отобранных строк;
- `-w` - ищет по слову целиком;
- `-C <количество>` - выводит заданное количество строк сверху и снизу от искомой;
- `-A <количество>` - выводит заданное количество строк снизу от искомой;
- `-B <количество>` - выводит заданное количество строк сверху от искомой;
- `-E` - интерпретировать строку поиска как регулярное выражение и по ней искать;
- `-oE` - интерпретировать строку поиска как регулярное выражение и по ней искать и выводить только полное совпадение регулярному выражению;
- `-v` - все строки только без искомой;
- `-n` - выводит номер строки;
- `-r` - ищет по всем файлам каталога;
- `--colour` - подсвечивает искомую строку.

Формирование строки поиска:
- `'\<<строка_поиска>'` - поиск по началу слова;
- `'<строка_поиска>\>'` - поиск по концу слова;
- `'^<строка_поиска>'` - поиск по началу строки;
- `'<строка_поиска>$'` - поиск по концу строки.

Для удобства пользования делают цепочки поисков:  
`... | grep <строка_поиска1> | grep <строка_поиска2> | ...`

`grep -rnw '<путь>/' -e '<строка_поиска>'` - рекурсивно ищет строку во всех файлах.

Процессы
========

## `ps`

Программа в UNIX, Unix-подобных и других POSIX-совместимых операционных системах, выводящая отчёт о работающих процессах.

`ps [<опции>]`

Опции, отбирающие процессы для отчёта:
- `-A` - все процессы;
- `-a` - связанные с конкретным терминалом, кроме главных системных процессов сеанса, часто используемая опция;
- `-N` - отрицание выбора;
- `-d` - все процессы, кроме главных системных процессов сеанса;
- `-e` - все процессы;
- `-f` - расширение информации
- `T` - все процессы на конкретном терминале;
- `a` - процессы, связанные с текущим терминалом, а также процессы других пользователей;
- `r` - информация только о работающих процессах;
- `x` - процессы, отсоединённые от терминала.

## Выводимая информация

Столбцы:
- **UID** - идентификатор пользователя;
- **PID** - идентификатор процесса;
- **PPID** - идентификатор родительского процесса;
- **C** - приоритет процесса, используемый планировщиком задач;
- **STIME** - время старта процесса;
- **TTY** - терминал, с которым связан данный процесс;
- **TIME** - процессорное время, занятое этим процессом;
- **CMD** - команда, запустившая данный процесс "с некоторыми опциями выводит и каталог откуда процесс был запущен";
- **STAT** - состояние, в котором на данный момент находится процесс. Параметры **STAT**:
    + **R** - процесс выполняется в данный момент;
    + **S** - процесс ожидает (т.е. спит менее 20 секунд);
    + **I** - процесс бездействует (т.е. спит больше 20 секунд);
    + **D** - процесс ожидает ввода-вывода (или другого недолгого события), непрерываемый;
    + **Z** - *zombie* или *defunct* процесс, то есть завершившийся процесс, код возврата которого пока не считанный родителем;
    + **T** - процесс остановлен;
    + **W** - процесс в свопе;
    + **<** - процесс в приоритетном режиме;
    + **N** - процесс в режиме низкого приоритета;
    + **L** - *real-time* процесс, имеются страницы, заблокированные в памяти;
    + **s** - лидер сессии.

Опция o позволяет указать набор столбцов в ответе:
`ps o [<имя_столбца> [, <имя_столбца> [, ...]]]`

## `kill`

Завершает работу процесса, фактически посылает процессу сигнал.

`kill [<сигнал>] [<опция>] <PID1>[ <PID2>[ ...]]`

Основные сигналы:
- `SIGTERM` - этот сигнал запрашивает остановку работы процесса. Он может быть проигнорирован. Процессу дается время на корректное завершение;
- `SIGKILL` - этот сигнал заставляет процесс прекратить работу немедленно. Программа не может проигнорировать этот сигнал. Несохраненные результаты будут потеряны.

Вывод всех видов сигналов: `kill -l`.  
Сигнал по умолчанию (если он не задан) - `SIGTERM`.

> `kill -9 3629`  
> `kill SIGKILL 3629`

## `pkill`

Команда `pkill` позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID можно завершить приложение, введя имя его процесса.

> `pkill firefox`

## `killall`

Команда `killall` позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID можно завершить приложение, введя имя его процесса и завершить все экземпляры процесса с этим именем.

> `killall firefox`

`ssh`
=====

`ssh-keygen -t rsa [-f <имя_файла>]` - генерирование пары ключей RSA, создаст ключи по умолчанию:
- `~/.ssh/id_rsa.pub` - открытый ключ;
- `~/.ssh/id_rsa` - закрытый ключ.

В каталоге пользователя, под которым нужно зайти, если создать файл: `~/.ssh/authorized_keys` и положить туда открытый ключ, то можно будет заходить без пароля, права на файл не должны давать возможность писать в этот файл посторонним пользователям, иначе `ssh` его не примет. В ключе последнее поле - `user@server`. Оно не имеет никакого отношения к авторизации и служит только для удобства определения где чей ключ, это поле может быть поменяно (или даже удалено) без нарушения структуры ключа.

`ssh-copy-id [-i ~/.ssh/id_rsa.pub] "[-p <port> ]<user>@<server>"` - копирует ключ на машину при этом не редактируя файлы вручную.

`~/.ssh/known_hosts` - хранятся ключи сервера, с которыми есть связь. Узнать, где какой ключ нельзя.

`ssh-keygen -R <server>` - удаляет известный ключ сервера, также необходимо сделать это и для IP, так как они хранятся раздельно: `ssh-keygen -R <IP>`.

Ключ сервера хранится в `/etc/ssh/ssh_host_rsa_key` и `/etc/ssh/ssh_host_rsa_key.pub`.

`scp <путь_к_локальному_файлу> <user>@<server>:<путь_к_каталогу_на_сервере>` - осуществляет копирование файла через ssh-сессию на сервер.

`scp <user>@<server>:<путь_к_файлу_на_сервере> <путь_к_локальному_каталогу>` - осуществляет копирование файла через ssh-сессию с сервера.

`ssh <user>@<server> [-t] <команда>[ <аргумент1>[ ...]]` - выполняет команду на удалённом сервере и тут же закрывает соединение [с управляющим терминалом для команд]. Для таких команд можно использовать pipe `|`, stdin `<`, stout `>` как для простых программ.

> `ssh user@8.8.8.8 command > my_file`  
> `mycommand | ssh user@8.8.8.8 "scp - user@10.1.1.2:/path/to/file"` - позволяет прокидывать файлы с сервера на сервер.  
> `ssh example.com -t "cd /www/example.com && git status -sb | head -1"`

В файле `~/.ssh/config` позволяет задать параметры подключения, в том числе специальные для каждого из серверов, а также задать им алиасы и так для каждого из серверов:
```
Host <алиас>
    Hostname <server>
    User <user>
    ForwardX11 yes
    Compression yes
    PasswordAuthentication no
```

Настройки соединения по умолчанию с помощью конструкции `Host *`.

В файле `/etc/ssh/ssh_config` задаются для всех.

`ssh -D localhost:<port> <user>@<server>` - задает туннелирование порта, заключается в том, что создается сокет для прослушивания порта на локальной машине, привязанный (необязательно) к конкретному адресу. Когда создается соединение к этому порту, это соединение туннелируется по зашифрованному каналу, и протокол приложения затем используется, чтобы определить, куда соединяться с удаленной машиной. При этом SSH работает как SOCKS сервер.

`ssh -L [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<user>@]<server>` - все соединения на `<локальный_адрес>:<локальный_порт>` будут переадресовываться удаленному серверу, который будет соединяться с `<удаленный_адрес>:<удаленный_порт>` от своего имени. По умолчанию `<локальный_адрес>` соответствует `127.0.0.1`. Возможно использование нескольких ключей `-L` в одном клиенте.

`ssh -R [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<user>@]<server>` - работает также как и `-L`, только соединения перебрасываются с удаленной машины на локальную.

`ssh -A <user1>@<server1> ssh <user2>@<server2>` - пробрасывает авторизацию на удалённый сервер.

`ssh -vT <user>@<server>` - пытается подключиться к серверу и выводит информацию (дебаг) по попыткам подключения к нему. `-1` - файл не существует, `1` - существует.

`screen`
========

Позволяет сворачивать в фон программы, которые сами этого не умеют, с возможностью последующего возврата к ним.

`screen` - создает новый скрин, в котором откроет сессию командной оболочки.  
`screen <команда>` - создает новый скрин, в котором откроет указаную команду.

Для сворачивания запущенного скрина вместе со всем, что в нем работает необходимо нажать `Ctrl+A`, которая переведет `screen` в командный режим, а затем нажать `D`, которая даст команду свернуть текущий скрин.

Для завершения запущенного скрина вместе со всем, что в нем работает необходимо нажать `Ctrl+A`, которая переведет `screen` в командный режим, а затем нажать `K`, которая даст команду завершить текущий скрин, а затем подтвердить, нажать `y`.

`screen -r` - возвращает к заранее сернутому скрину.

Для выхода из скрина необходимо написать `exit`.

`screen -S <имя> <команда>` - создает новый именованный скрин, в котором откроет указаную команду.  
`screen -r <имя>` - возвращает к заранее сернутому именному скрину.

`screen -list` - выводит список запущенных скринов.

wildcards - шаблоны замены
==========================

Командный интерпретатор линукс поддерживает возможность указания множества файлов используя шаблоны. Bash и другие команды линукс выбирают только те файлы, которые совпадают с шаблоном. Шаблоны:
- `*` - соответствует нулю или большему количеству символов;
    > `/tmp/my*1` - все файлы в директории `/tmp` имена которых начинаются с `my` и заканчиваются на `1` (включая файл с именем "my1")
    - `**` - соответствует всем файлам и нулю или более директорий и поддиректорий в пути
    - `/**` - соответствует нулю или более директорий и поддиректорий
        > `org/**/servlet/bla.jsp` - все файлы в директории `org/` пути которых заканчиваются на `/servlet/bla.jsp`
- `?` - заменяет один любой символ;
    > `/tmp/notes?txt` - соответствует файлам с именами "`notes.txt`" и "`notes_txt`" (если они существуют в `/tmp/`)
- `[<диапазон>]` - совпадает с одним символом из тех что указаны в скобках. Также в скобках можно указать диапазон символов, для этого используется символ `-` или несколько диапазонов подряд, тогда шаблон будет совпадать с одним любым символом из этого диапазона;
    > `/tmp/[A-Za-z]*` - все файлы в директории `/tmp/` имена которых начинаются с буквы (заглавной или прописной)
- `[[<диапазон>]` - похожа на `[]`, за исключением того что она соответствует единичному символу, не упомянутому между `[[` и `]`;
    > `myfile[[9]` - удалит все файлы, имена которых состоят из слова `myfile` и идущей за ним одной цифрой, кроме файла `myfile9`

Так как bash интерпретирует символы `?`, `[`, `]`, `*` как шаблоны замены, то для использования их как сивмолов их экранировать, т.е. поставить знак `\` перед ними или взять строку в одинарные кавычки `'`. Чтобы указать текстовый символ `\` можно заключить его в одинарные кавычки или написать `'\\\'`.

`find`
======

`find <каталог>` - выводит список всех файлов в каталоге и его подкаталогах. Опции:
- `-name <имя>` - только те, которые соответствуют имени;
- `-iname <имя>` - только те, которые соответствуют имени, но без учета регистра в названии файлов;
- `-type f` - только файлы;
- `-type d` - только каталоги;
- `-atime [<мод>]<n>` - производит поиск по дате создания или последнего доступа к ним, где `<n>` - количество суток, в пределах `<n>` и `<n> + 1` дней [при модификаторе `<мод>` равным `-` - меньше `<n>` дней, при `+` - больше `<n>` дней];
- `-ctime [<мод>]<n>` - производит поиск по  дате создания или изменения статуса файла или папки;
- `-mtime [<мод>]<n>` - производит поиск файлов, которые были изменены (редактированы, или созданы);
- `-amin [<мод>]<n>` - аналогично `-atime`, только `<n>` - означает количество минут;
- `-cmin [<мод>]<n>` - аналогично `-ctime`, только `<n>` - означает количество минут;
- `-mmin [<мод>]<n>` - аналогично `-mtime`, только `<n>` - означает количество минут;
- `-exec <команда>[<аргумент1>[ ...]] {} \;` - используется для указания другой команды, которую надо выполнить над каждым аргументом результат поиска, где `{}` - заменяет список найденных аргументов, а `\;` - конец команды;
- `-size {+ | -}<n>{c | w | b | k | M | G}` - выводит только файлы, которые больше при знаке `+` или меньше при `-` определенного размера `<n>` в величине измерении (`c` - в байтах).

> `find . -type d -atime +2`  
> `find . -size +2048k`  
> `find .` - выводит список всех файлов в текущем каталоге и его подкаталогах.  
> `find /home/nobody/public_html -type f -exec chmod 644 {} \;` - меняет права на все файлы в папке.  
> `find . -type f -size +100M | xargs ls -lh` - выводит все файлы, размер которых больше 100 Мегабайт.

Другие команды
==============

`cd <каталог>` - перемещение в указанный каталог.  
`cd` - перемещение в домашний каталог.

`~` - специальное имя, указывающее в bash на домашнюю директорию пользователя.

`ls [<опции>] {<каталог> | <файл>}` - выводит на экран список файлов хранящихся в указанном каталоге (текущем, если не указан) или информацию о файле. Опции:
- `-a` - все файлы, включая скрытые (имена которых начинаются с точки);
- `-l` - выводит подробную информацию, такую как: права на файл, имя владельца, время последнего изменения файла и его размер, если это ссылка, то после знака `–>` стоит имя объекта на который она ссылается;
- `-h` - вместе с `-l` выводит размер фалов в удобочитаемом формате;
- `-d` - только каталоги;
- `-R` - рекурсивный вывод всех файлов находящихся в директории;
- `-i` - показывает **инод** (inode number) - уникальный номер;
- `-1` - выдавать в одноколоночном формате.

`pwd` - показать текущую директорию.

`cp <откуда> <куда>` - копирует файлы.  
`cp <файл>{,.copy}` - быстрое создание резервной копии файла.

`rsync -av --progress <откуда> <куда>[ --exclude <исключение>[ ...]]` - копирует файлы.

`mv <откуда>[ ...] <куда>` - перемещает или переименовывает файлы, если `<куда>` - существующая директория, то перемещает файл в нее.

`ln <имя> <файл>` - создает жесткую ссылку на файл. Таким образом, получается что файл присутствует в системе под несколькими разными именами. Файл существует до тех пор, пока с его инодом связано хотя бы одно имя. Понятия "*жёсткая ссылка на файл*" и "*имя файла*" являются синонимами.

`ln -s <имя> <объект>` - создает символьную ссылку на любой объект (файл, директория, сокет...) любой файловой системы. *Симлинк* это специальный вид файла, который ссылается на другой файл по имени, а не напрямую на инод. Симлинки не предохраняют файл от удаления.

`locate <файл>` - выводит все места расположения файла с таким именем.

`rm <файл>[ ...]` - удаляет файлы. Опции:
- `-i` - запрашивает у пользователя подтверждение удаления каждого файла;
- `-f` - без подтверждения.

`rmdir <каталог>` - удаляет **пустой** каталог.  
`rm -rf <каталог>` - удаляет рекурсивно файлы и каталоги в указаном каталоге.

`<команда> | xargs <команда> [<начальный_аргумент>[ ...]]` - объединяет зафиксированный набор заданных в командной строке начальных аргументов с аргументами, прочитанными со стандартного ввода, и выполняет указанную команду.
> `ls -1 | xargs git diff`

Просмотр записи в текстовый файл в реальном времени:  
`tailf <файл>`  
`tail -f <файл>`

`head -n <количество_строк> <файл>` - выводит только указаное количество первых строк.

`tail -n <количество_строк> <файл>` - выводит только указаное количество последних строк.

`df [-h]` - показывает список всех файловых систем по именам устройств, сообщает их размер, занятое и свободное пространство и точки монтирования [отобразит размер в человеко-читаемом формате, добавив названия единиц].

Узнать время выполнения команды:  
`time <команда>`

Слежение за изменениями в выводе команды:  
`watch <команда>`

`touch <файл>` - создание файла.  
`> <файл>` - очистка файла или его создание.

Создание директории и всех вложенных директорий, если они отсутствуют:  
`mkdir -p <путь>`

Вывод файла в консоль:  
`cat <файл>`  
`more <файл>`

Преобразование символов из входящего потока в исходящий:  
`tr "<строка1>" "<строка2>"` - замена каждого символа из входящего потока, который соответствует символу из `"<строка1>"` на соответствующий ему символ по позиции из `"<строка2>"`.  
`tr -d "<строка>"` - удаляет все вхождения символов, указанных в `"<строка>"`.

`su -` - запускает в текущей консоли командную оболочку c правами другого пользователя, по умолчанию - рута.  
`sudo <команда>` - позволяет запустить одиночную команду с правами другого пользователя (по умолчанию - рута).  
Чтобы вернуться в оболочку обычного пользователя, нужно дать команду `exit`, `logout` или нажать `Ctrl-D`.

`sort` - сортирует данные в соответствии с какими-либо критериями, например, арифметически по второму столбцу.

`uniq` - удаляет повторяющиеся строки. Или (с ключом `-с`) не просто удалить, а написать сколько таких строк было. Учитываются только подряд идущие одинаковые строки, поэтому часто данные сортируются перед тем как отправить их на вход программе.

`host <dns_домен>` - возвращает ip-адрес указаного домена и все его dns-алиасы.

`md5sum <файл>` - возвращает md5-хеш для файла.

`cat /proc/cpuinfo` - выводит информацию о процесоре.  
`cat /proc/meminfo` - выводит информацию о памяти.

`du -sh <каталог>` - выводит размер директории.  
`du -sh *` - выводит размер файлов и директорий в текущем каталоге.

`df -h` - показывает общий и доступный объем системных разделов.

`wc <файл>` - выводящая число (количество) переводов строк, слов и байт для каждого указанного файла и итоговую строку, если было задано несколько файлов. Если входной файл не задан, или равен `-`, то данные считываются со стандартного ввода. Флаги:
- `-l` - только количество строк;
- `-c` - только количество байт;
- `-m` - только количество символов;
- `-L` - только длину самой длинной строки;
- `-w` - только количество слов.

> `ls | wc -l` - считает количество файлов.

`xxd -p <файл>` - выводит в hex-формате содержимое файла

> `xxd -p <файл> | tr -d '\n'` - то же самое, только в одну строку.

`date` - выводит текущую дату в консоль.

`cal` - выводит календарь для текущего месяца.

`uptime` - выводит время работы сервера.

`w` - выводит список подключенных пользователей и их терминалов.

`whoami` - выводит логин пользователя под которым произведен вход.

`whereis <приложение>` - выводит все возможные местоположения программы.

`which <приложение>` - выводит местоположение программы, которое вызовится по умолчанию.