Подключение
===========

## Использование в HTML

```html
<script>
    <JS_код>
</script>
```

```html
<script src="<путь_к_JS_коду.js>"></script>
```

Если указан атрибут `src`, то содержимое тега игнорируется.

Атрибут `async` - скрипт выполняется полностью асинхронно. То есть, при обнаружении браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен - он выполнится.

Атрибут `defer` - скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от `async`: первое - браузер гарантирует, что относительный порядок скриптов с `defer` будет сохранен; второе отличие - скрипт с `defer` сработает, когда весь HTML-документ будет обработан браузером.

При одновременном указании `async` и `defer` в современных браузерах будет использован только `async`.

Атрибуты `async`/`defer` работают только в том случае, если назначены на внешние скрипты, т.е. имеющие `src`.

Документ, события, интерфейсы
=============================

## Дерево DOM

Основным инструментом работы и динамических изменений на странице является **DOM** (*Document Object Model*) - объектная модель, используемая для XML/HTML-документов. Согласно DOM-модели, **документ** является иерархией, **деревом**. Каждый **HTML-тег** образует **узел** дерева с типом "**элемент**". Вложенные в него теги становятся **дочерними** узлами. Для представления текста создаются узлы с типом "**текст**". DOM - это представление документа в виде дерева объектов, доступное для изменения через JavaScript.

При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.

Все, что есть в HTML, находится и в DOM.

Всего различают 12 типов узлов, но на практике работают с четырьмя из них:
- **документ** - точка входа в DOM;
- **элементы** - основные строительные блоки;
- **текстовые узлы** - содержат текст;
- **комментарии** - иногда в них можно включить информацию, которая не будет показана, но доступна из JS.

DOM нужен для того, чтобы манипулировать страницей - читать информацию из HTML, создавать и изменять элементы.

## Навигация по DOM-элементам

Доступ к DOM начинается с объекта `document`. Из него можно добраться до любых узлов.
```
                          +----------+
                          | document |
                          +----------+
                                ^
                                |
                    +--------------------------+
                    | document.documentElement | <HTML>
                    +--------------------------+
                                ^
                                |
                        +---------------+
                        | document.body | (если внутри body)
                        +---------------+
    --------------------------------------------------------
                                ^
                                |
                            parentNode
                          (parentElement)
                                ^
                                |
        previousSibling      +--------+  nextSibling
    <----------------------  | <DIV>  |  ------------------->
    (previousElementSibling) +--------+  (nextElementSibling)
                            /childNodes\
                           / (children) \
                          /              \
                    firstChild         lastChild
           (firstElementChild)         (lastElementChild)
```

Самые верхние элементы дерева доступны напрямую из `document`:
- `document.documentElement` - это свойство ссылается на DOM-объект для тега `<html>`;
- `document.body` - соответствует тегу `<body>`;
- `document.head` - прямая ссылка на `<head>`.

В DOM в качестве значения, обозначающего "нет такого элемента" или "узел не найден", используется не `undefined`, а `null`.

**Дочерние элементы** (или дети) - элементы, которые лежат непосредственно внутри данного.

**Потомки** - все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, все поддерево DOM.

`<элемент>.childNodes` - псевдо-массив, который хранит все дочерние элементы, включая текстовые.  
`<элемент>.firstChild` и `<элемент>.lastChild` - обеспечивают быстрый доступ к первому и последнему элементу.

**DOM-коллекции** не являются JavaScript-массивами. В них нет методов массивов. Именно поэтому их и называют "**коллекция**" или "**псевдомассив**". Для перебора коллекции используется обычный цикл `for`.

`<элемент>.previousSibling` / `<элемент>.nextSibling` - элементы слева и справа от данного.  
`<элемент>.parentNode` - возвращает родитель.
`<элемент>.children` - только дочерние узлы-элементы, то есть соответствующие тегам.  
`<элемент>.firstElementChild`, `<элемент>.lastElementChild` - соответственно, первый и последний дети-элементы-узлы.  
`<элемент>.previousElementSibling`, `<элемент>.nextElementSibling` - соседи-элементы-узлы.  
`<элемент>.parentElement` - родитель-элемент-узел.

У конкретных элементов DOM могут быть свои дополнительные ссылки для большего удобства навигации.

## Поиск

Если элементу назначен специальный атрибут `id`, то можно получить его прямо по переменной с именем из значения `id` или через `window['<id>']`.

`document.getElementById("<идентификатор>")` - возвращает элемент по идентификатору.  
`<элемент>.getElementsByTagName("<тег>")` - ищет все элементы с заданным тегом внутри элемента и возвращает их в виде списка. Регистр тега не имеет значения. Можно получить всех потомков, передав звездочку `*` вместо тега.  
`document.getElementsByName("<name>")` - позволяет получить все элементы с данным атрибутом `name` в виде списка.  
`<элемент>.getElementsByClassName("<имя_класса>")` - возвращает коллекцию элементов с указанным классом. Находит элемент и в том случае, если у него несколько классов, а искомый - один из них.  
`<элемент>.querySelectorAll("<css_селектор>")` - возвращает все элементы внутри элемента, удовлетворяющие CSS-селектору. Псевдо-классы в CSS-селекторе также поддерживаются.  
`<элемент>.querySelector("<css_селектор>")` - возвращает не все, а только первый элемент, соответствующий CSS-селектору.  
`<элемент>.matches("<css_селектор>")` - ничего не ищет, а проверяет, удовлетворяет ли элемент селектору. Он возвращает `true` либо `false`.  
`<элемент>.closest("<css_селектор>")` - ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор. Сам элемент тоже включается в поиск.

Результаты поиска `getElementsBy*` - живые! При изменении документа - изменяется и результат запроса. Так как результат запросов `getElementsBy*` - это не массив, а специальный объект, имеющий тип `NodeList` или `HTMLCollection`. Он похож на массив, так как имеет нумерованные элементы и длину, но внутри это не готовая коллекция, а "живой поисковой запрос". Собственно поиск выполняется только при обращении к элементам коллекции или к ее длине.

`<NodeList>.item(<id>)` - возвращает элемент коллекции по `id`, аналогичен `<NodeList>[<id>]`.

`<NodeList>.forEach(function (elem, i, arr) {...})` - итеративно перебирает все элементы списка `<NodeList>`, по аналогии с циклом `forEach` у обычного массива.

## Свойства узлов

Самое главное различие между DOM-узлами - разные узлы являются объектами различных классов. Классы DOM образуют иерархию наследования. Основной объект в ней: **Node**, от которого наследуют остальные:
```
                             +-------------+
                             | EventTarget |
                             +-------------+
                                    |
                                    v
                                 +------+
        +----------------------- | Node | --------------------------+
        |                        +------+                           |
        |                           |                               |
        v                           v                               v
    +------+                    +---------+                     +---------+
    | Text |                    | Element | -------------+      | Comment |
    +------+                    +---------+              |      +---------+
                                    |                    |
                                    v                    v
                              +-------------+           +------------+
            +---------------- | HTMLElement | ------+   | SVGElement |
            |                 +-------------+       |   +------------+
            |                       |               |
            v                       v               v
    +------------------+    +-----------------+    +-------------------+
    | HTMLInputElement |    | HTMLBodyElement |    | HTMLAnchorElement |
    +------------------+    +-----------------+    +-------------------+
```

`<элемент>.nodeType` - возвращает тип узла элемента согласно таблице:
Константа                          | Значение | Описание
---------------------------------- | -------- | --------
`Node.ELEMENT_NODE`                | 1        | Узел элемента `<p>` или `<div>`
`Node.ATTRIBUTE_NODE`              | 2        | Атрибут элемента
`Node.TEXT_NODE`                   | 3        | Текст внутри элемента или атрибута
`Node.CDATA_SECTION_NODE`          | 4        | Секция `CDATASection` - `<!CDATA[[ ... ]]>`
`Node.PROCESSING_INSTRUCTION_NODE` | 7        | Процессорная инструкция XML документа - `<?xml-stylesheet ... ?>`.
`Node.COMMENT_NODE`                | 8        | Узел коментария - `<!-- ... -->`
`Node.DOCUMENT_NODE`               | 9        | Узел `Document`
`Node.DOCUMENT_TYPE_NODE`          | 10       | Узел `DocumentType` - `<!DOCTYPE html>`
`Node.DOCUMENT_FRAGMENT_NODE`      | 11       | Узел `DocumentFragment`

`<элемент>.nodeName`, `<элемент>.tagName` - содержат название (тег) элемента узла. Название HTML-тега всегда находится в **верхнем регистре**. Свойство `nodeName` определено для любых узлов Node, для элементов оно равно `tagName`, а для не-элементов обычно содержит строку с типом узла.  
`<элемент>.innerHTML` - позволяет получить HTML-содержимое элемента в виде строки. В `innerHTML` можно и читать и писать. Значение, возвращаемое `innerHTML` - всегда валидный HTML-код. Если в `innerHTML` есть тег `script` - он не будет выполнен.  
`<элемент>.outerHTML` - содержит HTML элемента целиком. Изменить `outerHTML` элемента невозможно.

Содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство `data`. Его тоже можно читать и обновлять.

`<элемент>.textContent` - содержит только текст внутри элемента, за вычетом всех `<тегов>`. Возвращает конкатенацию всех текстовых узлов внутри элемента. Есть возможность записать текст в элемент, причем именно как текст.

`<элемент>.hidden` - возвращает `true`, если узел не видим иначе `false`. Позволяет также устанавливать значение.

У DOM-узлов есть и другие свойства, зависящие от типа, например:
- `value` - значение для `INPUT`, `SELECT` или `TEXTAREA`;
- `id` - идентификатор;
- `href` - адрес ссылки;
- многие другие.

### Таблица

Для таблицы используются дополнительные методы, которые значительно упрощают процесс конструирования таблиц.

`<элемент_таблицы>.createTHead()` - создает заголовочную секцию и возвращает ее.  
`<элемент_таблицы>.insertRow()` - создает строку и возвращает ее.  
`<элемент_строки>.insertCell()` - создает ячейку и возвращает ее.  

## Полифиллы

"**Полифилл**" (англ. *polyfill*) - это библиотека, которая добавляет в старые браузеры поддержку возможностей, которые в современных браузерах являются встроенными.

Общий вид этого полифилла довольно типичен. Обычно полифилл состоит из двух частей:
1. Проверка, есть ли встроенная возможность. Важная тонкость - элемент, который тестируем, должен по стандарту поддерживать такое свойство.
2. Эмуляция, если ее нет. Для добавления нужной возможности берется правильный класс и модифицируется его prototype.

## Свои DOM-свойства

**Узел DOM** - это объект, поэтому, как и любой объект в JavaScript, он может содержать пользовательские свойства и методы.

Нестандартные свойства и методы видны только в JavaScript и никак не влияют на отображение соответствующего тега. Пользовательские DOM-свойства:
- могут иметь любое значение;
- названия свойств чувствительны к регистру;
- работают за счет того, что DOM-узлы являются объектами JavaScript.

## Атрибуты

Элементам DOM, с другой стороны, соответствуют HTML-теги, у которых есть текстовые атрибуты.

Доступ к атрибутам осуществляется при помощи стандартных методов:
- `<элемент>.hasAttribute(<имя>)` - проверяет наличие атрибута;
- `<элемент>.getAttribute(<имя>)` - возвращает значение атрибута;
- `<элемент>.setAttribute(<имя>, <значение>)` - устанавливает значение атрибута;
- `<элемент>.removeAttribute(<имя>)` - удаляет атрибут.

Эти методы работают со значением, которое находится в HTML.

`<элемент>.attributes` - возвращает все атрибуты элемента, которые содержится в псевдо-массиве объектов типа `Attr`.

В отличие от свойств, атрибуты:
- всегда являются строками;
- их имя нечувствительно к регистру (ведь это HTML);
- видны в `innerHTML` (за исключением старых IE).

Ссылка "как есть" из атрибута `href` - синхронизация не гарантирует одинакового значения в атрибуте и свойстве.

Изменение некоторых свойств обновляет атрибут. Чаще синхронизация - односторонняя: свойство зависит от атрибута, но не наоборот.

При изменении свойства `input.value` атрибут `input.getAttribute('value')` не меняется.

`<элемент>.className` - соответствует атрибуту `class`.

`<элемент>.classList` - это объект для работы с классами.

Методы `classList`:
- `<элемент>.classList.contains("<class>")` - возвращает `true`/`false`, в зависимости от того, есть ли у элемента класс;
- `<элемент>.classList.add("<class>")` - добавляет класс;
- `<элемент>.classList.remove("<class>")` - удаляет класс;
- `<элемент>.classList.toggle("<class>")` - если класса нет, добавляет его, если есть - удаляет.

Кроме того, можно перебрать классы через `for`, так как `classList` - это псевдо-массив.

Для нестандартных атрибутов DOM-свойство не создается. Стандартным свойство является, лишь если оно описано в стандарте именно для этого элемента.

С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript. Как правило, это делается при помощи атрибутов с названиями, начинающимися на `data-`. Стандарт HTML5 специально разрешает атрибуты `data-*` и резервирует их для пользовательских данных. К таким атрибутам можно обратиться не только как к атрибутам, но и как к свойствам, при помощи специального свойства `dataset`. Доступ к свойству: `<элемент>.dataset.<свойство>`.

## Относительное расположение узлов

`<родитель>.contains(<ребенок>)` - возвращает `true`, если родитель содержит ребенка или родитель == ребенку.
`<узелА>.compareDocumentPosition(<узелВ>)` - возвращаемое значение - битовая маска, биты в которой означают следующее:

Константа                                        | Биты   | Число | Значение
------------------------------------------------ | ------ | ----- | -------
.                                                | 000000 | 0     | `<узелА>` и `<узелВ>` - один и тот же узел
`Node.DOCUMENT_POSITION_DISCONNECTED`            | 000001 | 1     | Узлы в разных документах (или один из них не в документе)
`Node.DOCUMENT_POSITION_PRECEDING`               | 000010 | 2     | `<узелВ>` предшествует `<узелА>` (в порядке обхода документа)
`Node.DOCUMENT_POSITION_FOLLOWING`               | 000100 | 4     | `<узелА>` предшествует `<узелВ>`
`Node.DOCUMENT_POSITION_CONTAINS`                | 001000 | 8     | `<узелВ>` содержит `<узелА>`
`Node.DOCUMENT_POSITION_CONTAINED_BY`            | 010000 | 16    | `<узелА>` содержит `<узелВ>`
`Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC` | 100000 | 32    | Зарезервировано для браузера

Понятие "*предшествует*" - означает не только "*предыдущий сосед при общем родителе*", но и имеет более общий смысл: "раньше встречается в порядке прямого обхода дерева документа. Могут быть и сочетания битов.

## Добавление и удаление узлов

`document.createElement('<тег>')` - создает новый элемент с указанным тегом и возвращает его.  
`document.createTextNode('<текст>')` - создает новый *текстовый* узел с данным текстом возвращает его.  
`<родитель>.appendChild(<элемент>)` - добавляет элемент в конец дочерних элементов родителя и возвращает вставленный элемент.  
`<родитель>.insertBefore(<вставляемый_элемент>, {<элемент_перед> | null})` - вставляет элемент в коллекцию детей родителя, перед указанным элементом `<элемент_перед>` и возвращает вставленный элемент.  
`<элемент>.cloneNode({true | false})` - создаст "глубокую" копию элемента и возвратит его - вместе с атрибутами, включая подэлементы, если `true`. Если же вызвать с аргументом `false`, то копия будет сделана без дочерних элементов. Это нужно гораздо реже.  
`<родитель>.removeChild(<элемент>)` - удаляет элемент из списка детей родителя и возвращает его.  
`<родитель>.replaceChild(<новый_элемент>, <элемент>)` - среди детей родителя удаляет элемент и вставляет на его место новый элемент и возвращает удаленный элемент.

Все методы вставки автоматически удаляют вставляемый элемент со старого места.

`<элемент>.remove()` - удаляет элемент напрямую, не требуя ссылки на родителя.

### Мультивставка

`<элемент>.insertAdjacentHTML("<куда>", "<html>")` - позволяет вставлять произвольный HTML в любое место документа, в том числе и между узлами, указанные в `<куда>`, который принимает значения:
- `beforeBegin` - перед элементом;
- `afterBegin` - внутрь элемента, в самое начало;
- `beforeEnd` - внутрь элемента, в конец;
- `afterEnd` - после элемента.

`<элемент>.insertAdjacentElement("<куда>", <вставляемый_элемент>)` - вставляет в произвольное место элемент.  
`<элемент>.insertAdjacentText("<куда>", "<текст>")` - создает текстовый узел из строки и вставляет его в указанное место относительно элемента.  

### `DocumentFragment`

Это особенный кросс-браузерный DOM-объект, который похож на обычный DOM-узел, но им не является.

`document.createDocumentFragment()` - создает и возвращает объект.

В него можно добавлять другие узлы.

У `DocumentFragment` нет обычных свойств DOM-узлов, таких как `innerHTML`, `tagName` и т.п. Это не узел. Его главная цель заключается в том, что когда `DocumentFragment` вставляется в DOM - то он исчезает, а вместо него вставляются его дети. Это свойство является уникальной особенностью `DocumentFragment`.

### Новые методы

`<узел>.append(...<узлы>)` - вставляет узлы в конец узла.  
`<узел>.prepend(...<узлы>)` - вставляет узлы в начало узла.  
`<узел>.after(...<узлы>)` - вставляет узлы после узла узла.  
`<узел>.before(...<узлы>)` - вставляет узлы перед узлом узла.  
`<узел>.replaceWith(...<узлы>)` - вставляет узлы вместо узла.

Эти методы ничего не возвращают. Во всех этих методах узлы - DOM-узлы или строки, в любом сочетании и количестве. Причем строки вставляются именно как текстовые узлы.

## Метод `document.write`

`document.write("<текст>")` - работает только пока HTML-страница находится в процессе загрузки. Он дописывает текст в текущее место HTML еще до того, как браузер построит из него DOM.  
`document.writeln("<текст>") `- работает аналогично `document.write`, но который добавляет после текста символ перевода строки `\n`.

Методы `document.write` и `document.writeln` пишут напрямую в текст документа, до того как браузер построит из него DOM, поэтому они могут записать в документ все, что угодно, любые стили и незакрытые теги. Попытка дописать что-то в закрытый документ открывает его заново. При этом все текущее содержимое удаляется.

## Стили

`<элемент>.style` - возвращает объект, который дает доступ к стилю элемента на чтение и запись. Свойство `style` содержит лишь тот стиль, который указан в атрибуте элемента, без учета каскада CSS. С его помощью можно изменять большинство CSS-свойств:  
`<элемент>.style.<CSS_свойство> = <значение>` - при этом для свойств, названия которых состоят из нескольких слов: `часть1-часть2-часть3`, используется: `часть1Часть2Часть3`. Исключение: `style.cssFloat` вместо `style.float`. Если свойство с префиксами, то каждый дефис дает большую букву.

Чтобы сбросить поставленный стиль свойству, присваивают в `style` свойству пустую строку: `<элемент>.style.<CSS_свойство> = ""`. При сбросе свойства `style` стиль будет взят из CSS.

Стиль в `style` находится в формате браузера, а не в том, в котором его присвоили.

`<элемент>.style.cssText` - позволяет поставить стиль целиком в виде строки. При этом все предыдущие свойства `style` удаляются.

`<элемент>.style.getPropertyValue(<CSS_свойство>)` - возвращает значение указанного CSS свойства.

`<элемент>.style.setProperty(<CSS_свойство>, <значение>[, 'important'])` - устанавливает значение указанного CSS свойства[, и делает его с модификатором `!important`].

### Полный стиль

`getComputedStyle(<элемент>[, "<псевдо_элемент>"])` - возвращает объект с текущими используемыми значениями свойств элемента [или стиль псевдо-элемента], подобно `<элемент>.style`.

Для правильного получения значения нужно указать точное свойство.

### Медиа-запросы

`const mediaQueryList = window.matchMedia('<медиа_запрос>')` - возвращает объект типа `MediaQueryList`, который содержит:
- свойства:
    - `matches` со значением `true`, если документ соответствует мультимедийному запросу;
- методы:
    - `addEventListener('change', (mediaQueryList) => {/* ... */})` - добавляет обработчик для события `change` - который вызывается при изменении статуса медиа-запроса;
    - `removeEventListener('change', (mediaQueryList) => {/* ... */})` - удаляет обработчик для события `change`.

## Размеры и прокрутка элементов

`<элемент>.offsetParent` - находится ссылка на родительский элемент в смысле отображения на странице или `null`, если у элемента или родительского элемента установлено свойство `display` равное `none`, содержит первый элемент, у которого свойсво `position` не равен `static`.  
`<элемент>.offsetLeft`/`<элемент>.offsetTop` - задают смещение относительно `<элемент>.offsetParent`.
`<элемент>.offsetWidth`/`<элемент>.offsetHeight` - содержат "внешнюю" ширину/высоту элемента, то есть его полный размер, включая поля `padding` и рамки `border`.

Метрики для невидимых элементов равны нулю. Координаты и размеры в JavaScript устанавливаются только для видимых элементов.

`<элемент>.clientTop`/`<элемент>.clientLeft` - отступ внутренней части элемента от внешней, обычно толщина рамки `border`.  
`<элемент>.clientWidth`/`<элемент>.clientHeight` - размер элемента внутри рамок `border`. Они включают в себя ширину содержимого `width` вместе с полями `padding`, но без прокрутки. Если `padding` нет, то `<элемент>.clientWidth`/`<элемент>.clientHeight` в точности равны размеру области содержимого, внутри рамок и полосы прокрутки.

`<элемент>.scrollWidth`/`<элемент>.scrollHeight` - аналоги `<элемент>.clientWidth`/ `<элемент>.clientHeight`, но с учетом прокрутки. При этом если свойства `<элемент>.clientWidth`/`<элемент>.clientHeight` относятся только к видимой области элемента, а `<элемент>.scrollWidth`/`<элемент>.scrollHeight` добавляют к ней прокрученную (которую не видно) по горизонтали/вертикали.  
`<элемент>.scrollLeft`/`<элемент>.scrollTop` - ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху. Их можно изменять.

Не стоит брать `width`/`height` из CSS.

## Анимация

`<элемент>.animate(<массив_из_объектов_css-свойств>, <опции>)` - производит анимацию элемента по аналогии с `@keyframes`. Где `<массив_из_объектов_css-свойств>` выглядит в виде:
- массива из объектов со свойствами:
    - `<css-свойство1>` - css свойство и его значение (свойство `offset` должно быть `cssOffset`);
    - `offset` - необязательное число от 0.0 до 1.0 отвечающее за процент в анимации;
    - `easing` - необязательное строка с функцией смягчения: `'linear'`, `'ease'`, `'ease-in'`, `'ease-out'`, `'ease-in-out'`, `'cubic-bezier(x,x,x,x)'`.
- объект со свойствами и значениями в виде массивов для описания кадров:
    - `<css-свойство1>` - css свойство и его значение массив значений для анимации(свойство `offset` должно быть `cssOffset`);
    - `offset` - необязательное массив чисел от 0.0 до 1.0 отвечающее за процент в анимации;
    - `easing` - необязательное массив строк с функциями смягчения как в css.
`<опции>` - число - время анимации или объект с необязательными свойствами для анимации:
- `id` - идентификатор анимации;
- `delay` - задержка перед анимацией в мс;
- `direction` - направление: `'normal'`, `'reverse'`, `'alternate'`, `'alternate-reverse`;
- `duration ` - продолжительность;
- `easing` - функциея смягчения: `'linear'`, `'ease'`, `'ease-in'`, `'ease-out'`, `'ease-in-out'`, `'cubic-bezier(x,x,x,x)'`;
- `endDelay` - задержка после анимации в мс;
- `fill` - режим воздействия анимации: `'none'`, `'forwards'`, `'backwards'`, `'both'`;
- `iterationStart` - смещение первой итерации анимации от 0.0 до 1.0;
- `iterations` - количество повторений анимации.

## Размеры и прокрутка страницы

`document.documentElement.clientWidth` / `document.documentElement.clientHeight` - ширина / высота видимой области окна, то есть за вычетом полосы прокрутки.  
`document.documentElement.scrollWidth` / `document.documentElement.scrollHeight` - ширина / высота размера веб-страницы, включая в себя внутренние отступы страницы, но не включая границы, внешние отступы и полосы прокрутки.  
`window.pageXOffset`/`window.pageYOffset` - ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.  
`window.scrollBy(<x>, <y>)` - прокручивает страницу относительно текущих координат.  
`window.scrollTo(<pageX>, <pageY>)` - прокручивает страницу к указанным координатам относительно документа. Он эквивалентен установке свойств `scrollLeft`/`scrollTop`.  
`<элемент>.scrollIntoView({true | false})` - вызывается на элементе и прокручивает страницу так, чтобы элемент оказался вверху, если параметр равен `true`, и внизу, если равен `false`.  
`<элемент>.scrollIntoView({behavior: { 'auto' | 'smooth' }, block: { 'start' | 'center' | 'end' | 'nearest' } })` - вызывается на элементе и прокручивает страницу плавно при этом так, чтобы элемент оказался в начале, по центру, в конце или в ближайшей позиции.

Чтобы запретить прокрутку страницы, достаточно поставить `document.body.style.overflow = "hidden"`.

Размеры экрана хранятся в глобальной переменной `screen`:
- `window.screen.width` - содержит ширину экрана;
- `window.screen.height` - содержит высоту экрана;
- `window.screen.availWidth` - содержит доступную ширину экрана - без панели инструментов операционной системы;
- `window.screen.availHeight` - содержит доступную высоту экрана - без панели инструментов операционной системы.

Размеры окна:
- `window.outerWidth` - содержит ширину окна браузера, включая адресную строку, панель вкладок и другие панели браузера;
- `window.outerHeight` - содержит высоту окна браузера, включая адресную строку, панель вкладок и другие панели браузера;
- `window.innerWidth` - содержит ширину окна области просмотра (вьюпорта);
- `window.innerHeight` - содержит высоту окна области просмотра (вьюпорта).

### Видимость страницы

`document.hidden` - свойство для чтения, которое содержит `true`, если страница скрыта.  
`document.visibilityState` - свойство для чтения, которое возвращает состояние видимости страницы:
- `visible` - страница видима или страница не свернута и находится в текущей вкладке;
- `hidden` - страница скрыта;
- `prerender` - начальное состояние видимой страницы: предварительный рендеринг;
- `unloaded` - страница выгружена из памяти.

## Координаты в окне

`<элемент>.getBoundingClientRect()` - возвращает координаты элемента, под которыми понимаются размеры "воображаемого прямоугольника", который охватывает весь элемент. Координаты относительно окна не учитывают прокрутку, они высчитываются от границ текущей видимой области. Координаты возвращаются в виде объекта со свойствами:
- `top` - Y-координата верхней границы элемента;
- `left` - X-координата левой границы;
- `right` - X-координата правой границы;
- `bottom` - Y-координата нижней границы;
- `x` - X-координата правого угла;
- `y` - Y-координата правого угла;
- `width` - ширина элемента;
- `height` - высота элемента.

`document.elementFromPoint(<x>, <y>)` - возвращает элемент, который находится на координатах [`<x>`, `<y>`] относительно окна. А для координат вне окна возвращает `null`.

## Координаты в документе

Система координат относительно страницы или, иначе говоря, относительно документа, начинается в левом-верхнем углу, но не окна, а именно страницы. И координаты в ней означают позицию по отношению не к окну браузера, а к документу в целом.

Координаты относительно экрана `window.screenX` / `window.screenY` отсчитываются от его левого-верхнего угла. Имеется в виду именно весь экран, а не окно браузера.

## `MutationObserver`

`MutationObserver` предоставляет возможность получать уведомления об изменении определенных DOM-элементов.

`const <mutationObserver> = new MutationObserver(function (mutations, <mutationObserver>) {});` - создает новый `MutationObserver`, который принимает функцию, которая будет вызываться каждый раз, когда в DOM будут происходить изменения, где `mutations` - это коллекция всех произошедших мутаций в виде единого пакета. Где объект мутации содержит:
- `type` - возвращает `"attributes"` если это изменение атрибутов, `"characterData"` если это изменение узла `CharacterData`, и `"childList"` если это изменение дочернего дерева узлов;
- `target` - возвращает узел, который затронула мутация, в зависимости от типа `type`:
    - `attributes` - это элемент где произошли изменения;
    - `characterData` - это узел `CharacterData`;
    - `childList` - это узел где потомок был изменен;
- `addedNodes` - список добавленных узлов;
- `removedNodes` - список удаленных узлов;
- `previousSibling` - возвращает предыдущего соседа добавленных или удаленных узлов или `null`;
- `nextSibling` - возвращает следующего соседа добавленных или удаленных узлов или `null`;
- `attributeName` - возвращает имя измененного атрибута или `null`;
- `attributeNamespace` - возвращает пространство имен измененного атрибута или `null`;
- `oldValue` - возвращает значение, которое зависит от типа `type`:
    - `attributes` - это значение атрибута до изменений;
    - `characterData` - это данные `CharacterData` до изменений;
    - `childList` - это `null`.

`<mutationObserver>.observe(<элемент_наблюдения>, <объект_опций>)` - запускает процесс отслеживания изменений DOM за узлом DOM `<элемент_наблюдения>`, за которым нужно наблюдать, и объект с параметрами `<объект_опций>`:
- `childList` - `true`, если необходимо наблюдать за добавлением или удалением дочерних элементов (включая текстовые узлы (text nodes));
- `attributes` - `true`, если необходимо наблюдать за изменениями атрибутов целевого элемента;
- `characterData` - `true`, если необходимо наблюдать за изменениями значения текстового содержимого целевого узла (текстовых узлов дочернего элемента);
- `subtree` - `true`, если необходимо наблюдать за потомками целевого элемента;
- `attributeOldValue` - `true`, если необходимо возвращать предыдущее значение атрибута;
- `characterDataOldValue` - `true`, если необходимо возвращать предыдущее значение `Data` атрибута;
- `attributeFilter` - устанавливает массив названий атрибутов (без указания пространства имен), если требуется наблюдать за изменениями конкретных атрибутов.

Внутри себя содержит слабые ссылки на узлы за которыми смотрит, поэтому не перепятствуется их удалению сборщиком мусора.

Необходимо указать одно из cвойств: `childList`, `attributes`, `characterData`.

`<mutationObserver>.disconnect()` - останавливает наблюдение за изменениями.

`<mutationObserver>.takeRecords()` - возвращает текущую очередь экземпляра `MutationObserver`, после чего очищает ее.

## `ResizeObserver`

`ResizeObserver` предоставляет возможность получать уведомления об изменении размеров DOM-элементов.

`var <resizeObserver> = new ResizeObserver(function (entries, <resizeObserver>) {});` - создает новый `MutationObserver`, который принимает функцию, которая будет вызываться каждый раз, когда в DOM будут изменяться размеры, где `entries` - это массив всех объектов у которых изменился размер со свойствами:
- `borderBoxSize` - содержит размер;
- `contentBoxSize` - содержит размер;
- `contentRect` - содержит размер в виде `<элемент>.getBoundingClientRect()`;
- `target` - элемент у которого произошли изменения.

`<resizeObserver>.observe(<элемент_наблюдения>)` - запускает процесс отслеживания изменений DOM за узлом DOM `<элемент_наблюдения>`, за которым нужно наблюдать.

`<resizeObserver>.unobserve()` - останавливает процесс отслеживания.

`<resizeObserver>.disconnect()` - останавливает наблюдение за изменениями.

Основы работы с событиями
=========================

**Событие** - это сигнал от браузера о том, что что-то произошло. Существует много видов событий.

## События мыши

- `click` - возникает, когда кликнули на элемент левой кнопкой мыши;
- `dblclick` - возникает, когда дважды кликнули на элемент левой кнопкой мыши;
- `contextmenu` - возникает, когда кликнули на элемент правой кнопкой мыши;
- `mouseover` и `mouseout` - возникает, когда на элемент наводится мышь или на один из его детей, или покидает его или одного из его детей;
- `mousedown` и `mouseup` - возникает, когда кнопку мыши нажали или отжали над элементом;
- `mousemove` - возникает при движении мыши;
- `mouseenter` и `mouseleave` - возникает, когда на элемент наводится мышь или покидает его, при этом не учитываются переходы внутри элемента и они не всплывают.

Основные свойства событий:
- `which` - содержит нажатую кнопку мыши (`1` - левая кнопка, `2` - средняя кнопка, `3` - правая кнопка);
- `shiftKey` - содержит `true`, если нажат `shift`;
- `altKey` - содержит `true`, если нажат `alt`;
- `ctrlKey` - содержит `true`, если нажат `ctrl`;
- `metaKey` - (для Mac) содержит `true`, если нажат `meta`;
- `clientX`/`clientY` - содержит координаты курсора относительно текущего окна;
- `pageX`/`pageY` - содержит координаты курсора относительно документа;
- `target` - элемент, на который пришла мышь для события `mouseover` и элемент, с которого ушла мышь для события `mouseout`, то есть на котором возникло событие;
- `relatedTarget` - элемент, с которого пришла мышь для события `mouseover` и элемент, на который перешла мышь для события `mouseout`, может быть равно `null`, если мышь пришла не с другого элемента, а из-за пределов окна (или ушла за окно).

## События на элементах управления

- `submit` - возникает, когда пользователь отправляет форму `<form>`;
- `blur` - возникает, когда элемент теряет фокус;
- `change` - возникает, когда содержимое элемента изменяется (для `<input>`, `<keygen>`, `<select>`, и `<textarea>`);
- `focus` - возникает, когда элемент получает фокус;
- `input` - возникает, когда элемент получает ввод;
- `invalid` - возникает, когда элемент не валиден;
- `reset` - возникает, когда форма сбрасывается;
- `search` - возникает, когда печатается что-то в поле поиска (`<input="search">`);
- `select` - возникает, когда пользователь что-то выделяет в тексте (для `<input>` и `<textarea>`).

## Клавиатурные события

- `keydown` - возникает, когда пользователь нажимает клавишу;
- `keypress` - возникает, когда пользователь нажал клавишу;
- `keyup` - возникает, когда пользователь отпускает клавишу.

Основные свойства событий:
- `keyCode` - содержит скан-код клавиши;
- `which` - содержит код символа;
- `charCode` - содержит код символа;
- `shiftKey` - содержит `true`, если нажат `shift`;
- `altKey` - содержит `true`, если нажат `alt`;
- `ctrlKey` - содержит `true`, если нажат `ctrl`;
- `metaKey` - (для Mac) содержит `true`, если нажат `meta`;
- `repeat` - `true` при долгом нажатии клавиши, когда возникает автоповтор.

Управляющие клавиши, такие как `Ctrl`, `Shift`, `F1`, `F2`... - `keypress` не генерируют. Появление символа можно предотвратить, если отменить действие браузера на `keydown`/`keypress` по умолчанию. Отменять можно не только символ, а любое действие клавиш. На момент срабатывания `keydown`/`keypress` клавиша еще не обработана браузером, поэтому значение еще старое.

## События манипулирования текстом

- `copy` - возникает, когда пользователь копирует содержимое элемента;
- `cut` - возникает, когда пользователь вырезает содержимое элемента;
- `paste` - возникает, когда пользователь вставляет содержимое в элемент.

## События выделения текста

- `selectstart` - возникает, когда пользователь начинает выделение на элементе;
- `selectionchange` - возникает каждый раз, когда область выделения меняется.

`window.getSelection()` - возвращает объект с информацией о текущем выделении текста на странице, который содержит:
- `anchorNode` - узел на котором началось выделение;
- `anchorOffset` - отступ на узле на котором началось выделение;
- `focusNode` - узел на котором выделение закончилось;
- `focusOffset` - отступ на узле на котором выделение закончилось.

## События перетаскивания Drag'n'Drop

Запускаются только у тех элементов, у которых есть атрибут `draggable="true"`:
- `drag` - возникает, когда элемент начинается перетаскиваться;
- `dragenter` - возникает, когда элемент входит в зону опускания;
- `dragleave` - возникает, когда элемент выходит из зоны опускания;
- `dragover` - возникает, когда элемент находится над зоной опускания элемента, необходимо отменять стандартное действие `event.preventDefault()`, для указания возможности опускания;
- `dragstart` - возникает, когда пользователь начинает перетаскивать элемент, тут можно назначать полезные данные для передачи, с помощью: `event.dataTransfer` у которого есть специальные методы и свойства:
    - `setData('<ключ>', <значение>)` - устанавливает данные по ключу;
    - `getData('<ключ>')` - возвращает данные по ключу;
    - `setDragImage(<img_элемент>, <x>, <y>)` - устанавливает изображение перемещения;
    - `files` - массив с файлами, если пользователь перетягивал файл в указанную область.
- `dragend` - возникает, когда пользователь заканчивает перетаскивать элемент.

Возникает над элементом, в котором прекращается перетаскивание:
- `drop` - возникает, когда пользователь опускает перетаскиваемый элемент в зону опускания, необходимо отменять стандартное действие `event.preventDefault()`, для указания возможности опускания, можно использовать `event.dataTransfer`.

## События печати

- `beforeprint` - возникает, когда страница выводится на печать;
- `afterprint` - возникает, когда страница начинает печататься или диалог печати закрыт.

## События CSS transition

- `transitionend` - возникает, когда `CSS-transition` завершен.

Основные свойства событий:
- `propertyName` - свойство, анимация которого завершилась;
- `elapsedTime` - время (в секундах), которое заняла анимация, без учета `transition-delay`.

## События CSS анимации

- `animationend` - возникает, когда CSS-анимация завершена;
- `animationiteration` - возникает, когда CSS-анимация повторяется;
- `animationstart` - возникает, когда CSS-анимация начинается.

## События `Frame` и `Object`

- `abort` - возникает при отмене загрузки ресурса;
- `beforeunload` - возникает перед выгрузкой документа, если назначено на `window`, то можно показать уведомление об уходе, для этого нужно присвоить `''` свойству `returnValue`;
- `error` - возникает при ошибки загрузки существующего файла;
- `hashchange` - возникает при смене хеша (якоря) документа;
- `load` - возникает после загрузки объекта;
- `pageshow` - возникает, когда пользователь просматривает страницу;
- `pagehide` - возникает, когда у пользователя страница скрыта;
- `resize` - возникает при изменении области вывода вида документа;
- `scroll` - возникает, когда пользователь прокручивает документ - генерируется всегда, при любой прокрутке, не обязательно "мышиной". Некоторые области применения `onscroll`:
    - показ дополнительных элементов навигации при прокрутке;
    - подгрузка и инициализация элементов интерфейса, ставших видимыми после прокрутки.
- `unload` - возникает, когда страница выгружена.

## События касания

- `touchcancel` - возникает, когда касание прервано;
- `touchend` - возникает, когда касание окончено;
- `touchmove` - возникает, когда касание движется по экрану;
- `touchstart` - возникает, когда касание начато.

## Другие события

- `DOMContentLoaded` - возникает, когда HTML загружен и обработан, DOM документа полностью построен и доступен - браузер полностью загрузил HTML, и построил DOM-дерево, все DOM-элементы разметки уже созданы, можно их искать, вешать обработчики, создавать интерфейс, но при этом, возможно, еще не догрузились какие-то картинки или стили. Вешается на `document`;
- `message` - возникает, когда принимается сообщение из `WebSocket`, `Web Worker`, `Event Source` или из родительского окна или из дочернего фрейма;
- `online` и `offline` - возникает, когда браузер начинает работать онлайн или оффлайн;
- `popstate` - возникает, когда изменяется история браузера;
- `storage` - возникает, когда `Web Storage` обновляется;
- `wheel` - возникает, когда колесико мыши прокручивается над элементом. При этом не важно, прокручиваемый он или нет. В частности, `overflow: hidden` никак не препятствует обработке колеса мыши. Свойства:
    - `<event>.deltaX`/`<event>.deltaY`/`<event>.deltaZ` - количество прокрученных пикселей по горизонтали и вертикали и оси Z. Возникает до прокрутки, поэтому в нем можно отменить саму прокрутку (действие браузера).
- `visibilitychange` - возникает, когда изменяется свойство `visibilityState`.

## Обработка событий

Событию можно назначить **обработчик**, то есть функцию, которая сработает, как только событие произошло.

`<элемент>.on<событие> = function (event) {...}` - только один обработчик, кросс-браузерный.  
Его можно убрать назначением `<элемент>.on<событие> = null`. Где `event` - это событие типа `Event`.

Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором он сработал. Это можно использовать, чтобы получить свойства или изменить элемент.

`<элемент>.addEventListener("<событие>", function (event) {...}[, {<фаза> | <опции>}])` - назначение обработчика, позволяет добавлять несколько обработчиков на одно событие одного элемента, где `<фаза>` обозначает фазу погружения при значении `true` или всплытия при значении `false`, а `<опции>` представляет собой объект со свойствами:
- `capture` - обозначет фазу погружения при `true` или всплытия при `false`;
- `once` - при значении `true` указывает, что слушатель должен быть вызван не более одного раза после добавления, слушатель автоматически удаляется при вызове слушателя;
- `passive` - указывает, что слушатель никогда не вызовет `preventDefault()`, если все же вызов будет произведен, браузер должен игнорировать его и генерировать консольное предупреждение;
- `signal` - принимает `AbortSignal` для отмены запроса.

`<элемент>.removeEventListener("<событие>", <функция>[, <фаза>])` - удаление обработчика осуществляется вызовом, необходимо передать те же аргументы, что были у `addEventListener`, а именно одну и ту же функцию, т.е. ссылку на нее.ойства в колонках.

`<элемент>.addEventListener("<событие>", { handleEvent(event) {...} }[, {<фаза> | <опции>}])` - регистрирует объект для обработки события, у которого будет вызываться метод `handleEvent` при возникновении события в который будет передаваться событие.

`<элемент>.addEventListener("<событие>", <объект>[, {<фаза> | <опции>}])` - удаляет объект для обработки события.

### Специальные методы (Chrome)

`monitorEvents(<HTML_элемент>, { '<событие>' | ['<событие1>'[, ...]] });` - устанавливает мониторинг событий элемента, при каждом вызове события выводит в консоль сведения об этих событиях.  
`unmonitorEvents(<HTML_элемент>, { '<событие>' | ['<событие1>'[, ...]] });` - убирает мониторинг событий элемента.

`getEventListeners(<HTML_элемент>);` - возвращает объект, где ключи это имена событий, а его значения - это список слушателей события элемента.

### AbortController

Используется для отмены операций.

`const <abortController> = new AbortController();`  
`const <abortSignal> = <abortController>.signal` - возвращяет связанный объект `AbortSignal`.  
`<abortController>.abort()` - вызывает прерывание в сигнале и сигнал вызывает прерывание там где он передан.

### Очередь событий

Когда происходит событие, оно попадает в очередь. Внутри браузера непрерывно работает "**главный внутренний цикл**", который следит за состоянием очереди и обрабатывает события, запускает соответствующие обработчики и т.п. Иногда события добавляются в очередь сразу пачкой. Когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.

Отложенный вызов через `setTimeout(<функция>, 0)` используется не только в событиях, а вообще - всегда, когда необходимо, чтобы некая функция сработала после того, как текущий скрипт завершится.

#### Порядок обработки событий

**Стек вызовов** - это список, который отражает, какие функции сейчас вызываются и куда будет совершен переход, после окончания исполнения текущей функции.

1. Очередь **TaskQueue** - представляет собой очередь из **Task** - вызовов обработчиков событий, таймаутов, интервалов;
2. Очередь **MicroTaskQueue** - представляет собой очередь из **MicroTask** - обратных функций для `Promise` или для `MutationObserver`. Выполняется сразу же после освобождения очереди **TaskQueue**. Задачи в этой очереди могут порождать другие **MicroTask**, которые будут вызываться сразу же по освобождению стека вызовов;
3. Очередь **RenderQueue** - представляет собой очередь для отрисовки, состоит из этапов:
    1. **requestAnimationFrame** - вызываются все обратные функции переданые в `requestAnimationFrame`;
    2. **Style** - перерасчет всех стилей, которые должны примениться из-за изменений, запланированных JS (изменение свойств, классов, порядка элементов). Здесь же происходит вычисление активных media queries;
    3. **Layout** - происходит вычисление слоев, расчет положения элементов на странице, их размеров, взаимного влияния друг на друга. Чем больше DOM элементов на странице, тем тяжелее эта операция. Вычисляется каждый раз при чтении свойств влияющих на размер и положение элементов (`offsetWidth`, `offsetLeft`, `getBoundingClientRect`, и т.д.) и при записи свойств, влияющих на размер и положение элементов, за исключением некоторых свойств, вроде `transform` и `will-change`. Самая тяжелая операция;
    4. **Paint** - происходит отрисовка элементов;
    5. **Composition** - исполняются специфические CSS стили, например `transform`. Задача этой операции: совместить слои и получить готовый кадр. Анимация на `transform` позволяет нам не вызывать layout каждый кадр, и это экономит время.

При изменении размеров или получении размеров элемента из кода будет запущен процесс **force layout** в котором будут вызваны **requestAnimationFrame**, **Style**, **Layout** вне своей очереди событий и пока эти опрерации не завершаться, дальнейшее выполнение кода будет приостановлено. Для ускорения этих опраций лучше использовать групирование операций на изменение свойств и на чтение свойств.

### Основные свойства объекта события `Event`

- `type` - тип события;
- `currentTarget` - элемент, на котором сработал обработчик. Значение - в точности такое же, как и у `this`, но бывают ситуации, когда обработчик является методом объекта и его `this` при помощи `bind` привязан к этому объекту, тогда можно использовать `currentTarget`;
- `clientX`/`clientY` - координаты курсора в момент клика (относительно окна);
- `target` - это исходный элемент, на котором произошло событие, в процессе всплытия он неизменен;
- `eventPhase` - на какой фазе он сработал (**погружение** = `1`, **всплытие** = `3`).

Кросс-браузерное решение: `event = event || window.event`.

### Всплытие

Основной принцип всплытия: при наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.

Всплытие идет прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента `<html>`, а затем до `document`, а иногда даже до `window`, вызывая все обработчики на своем пути.

`<event>.stopPropagation()` - останавливает всплытие.  
`<event>.stopImmediatePropagation()` - останавливает всплытие, но и останавливает обработку событий на текущем элементе для всех последующих обработчиков.

### Погружение

Событие сначала идет сверху вниз по DOM. Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент `addEventListener` `<фаза>`:
- если аргумент `true`, то событие будет перехвачено по дороге вниз;
- если аргумент `false`, то событие будет поймано при всплытии.

### Делегирование событий

Всплытие событий позволяет реализовать один из самых важных приемов разработки - **делегирование**. Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому - мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент `<event>.target`, понять на каком именно потомке произошло событие и обработать его, иногда необходимо вверх по иерархии родителей от `<event>.target` и выше.

Делегирование позволяет использовать обработчик и для абсолютно разных действий, к примеру один обработчик на родителе вместо многих на детях.

### Прием проектирования "поведение"

Шаблон проектирования "**поведение**" (*behavior*) позволяет задавать хитрые обработчики на элементе декларативно, установкой специальных HTML-атрибутов и классов.

Прием проектирования "поведение" состоит из двух частей:
1. Элементу ставится атрибут, описывающий его поведение.
2. При помощи делегирования ставится обработчик на документ, который ловит все клики и, если элемент имеет нужный атрибут, производит нужное действие.

### Отмена действия браузера по умолчанию

Есть два способа отменить действие браузера:
- основной способ - это воспользоваться объектом события. Для отмены действия браузера существует стандартный метод `<event>.preventDefault()`:
- если же обработчик назначен через `on<событие>` (не через `addEventListener`), то можно просто вернуть `false` из обработчика.

Кросс-браузерное решение: `event.preventDefault ? event.preventDefault() : (event.returnValue = false);`

### Генерация событий на элементах

`var <событие> = new Event("<тип_события>"[, <флаги>])` - создание события, где `<флаги>` - объект вида `{ bubbles: {true | false}, cancelable: {true | false} }`, где свойство `bubbles` указывает, всплывает ли событие, а `cancelable` - можно ли отменить действие по умолчанию. Флаги по умолчанию: `{bubbles: false, cancelable: false}`.

`<элемент>.dispatchEvent(<событие>)` - инициирование события, возвращает `false` если было вызвано `<event>.preventDefault()`. При этом событие срабатывает наравне с браузерными, то есть обычные браузерные обработчики на него отреагируют. Если при создании указан флаг `bubbles`, то оно будет всплывать.

При создании события браузер автоматически ставит следующие свойства:
- `isTrusted: false` - означает, что событие сгенерировано скриптом, это свойство изменить невозможно;
- `target: null` - это свойство ставится автоматически позже при `dispatchEvent`;
- `type: <тип_события>` - первый аргумент `new Event`;
- `bubbles`, `cancelable` - по второму аргументу `new Event`.

Другие свойства события, если они нужны - можно присвоить в объект события позже:
`<событие>.<свойство> = <значение>`.

Для некоторых конкретных типов событий есть свои, специфические, конструкторы: `UIEvent`, `FocusEvent`, `MouseEvent`, `WheelEvent`, `KeyboardEvent`, `CompositionEvent`. Специфический конструктор позволяет указать стандартные свойства для данного типа события.

### Свои события

Для генерации своих, нестандартных, событий, можно использовать конструктор `Event`, но существует и специфический конструктор `CustomEvent`. Технически, он абсолютно идентичен `Event`, кроме небольшой детали: у второго аргумента-объекта есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.

### Старое API

`var <событие> = document.createEvent("<интерфейс_типа_события>")` - создание события, где интерфейс типа события может быть `Event` или `UIEvent`, `FocusEvent`, `MouseEvent`, `WheelEvent`, `KeyboardEvent`, `CompositionEvent`.  
`<событие>.initEvent("<тип_события>", <bubbles>, <cancelable>)` - инициализация события.

У конкретных типов событий, есть методы, которые позволяют указать стандартные свойства. Они называются по аналогии: `init<интерфейс_типа_события>`. Их можно использовать вместо базового `initEvent`, если нужно, чтобы свойства событий соответствовали встроенным браузерным.

### Мышь: Drag'n'Drop

**Drag'n'Drop** - это возможность захватить мышью элемент и перенести его. Перенос мышкой может заменить целую последовательность кликов. И, самое главное, он упрощает внешний вид интерфейса: функции, реализуемые через Drag'n'Drop, в ином случае потребовали бы дополнительных полей, виджетов и т.п.

Основной алгоритм Drag'n'Drop выглядит так:
1. Отслеживают нажатие кнопки мыши на переносимом элементе при помощи события `mousedown`;
2. При нажатии - подготавливают элемент к перемещению;
3. Далее отслеживают движение мыши через `mousemove` и передвигают переносимый элемент на новые координаты путем смены `left`/`top` и `position: absolute`;
4. При отпускании кнопки мыши, то есть наступлении события `mouseup` - останавливают перенос элемента и производят все действия, связанные с окончанием Drag'n'Drop.

Также нужно отключить собственный Drag'n'Drop у браузера, который автоматически запускается и вступает в конфликт с нашим. Это происходит именно для картинок и некоторых других элементов:` <элемент>.ondragstart = function () { return false;};`

Еще одна особенность правильного Drag'd'Drop - событие `mousemove` отслеживается на `document`, а не на элементе.

При Drag'n'Drop везде используется координаты относительно документа, так как они подходят в большем количестве ситуаций.

"**Аватар**" - это DOM-элемент, который перемещается по экрану.

При Drag'n'Drop элемент перекрывает остальные элементы. Поэтому функция `document.elementFromPoint()` увидит на текущих координатах именно его, поэтому необходимо: спрятать элемент, вызывать `elementFromPoint`, показать элемент.

Формы, элементы управления
==========================

## Навигация и свойства элементов формы

Элементы `FORM` можно получить по имени или номеру, используя свойство `document.forms[{<имя_формы> | <index>}]` или `document.forms.<имя_формы>`, где `<имя_формы>` - это `id` формы.

Любой элемент формы можно получить, используя свойство `<форма>.elements[{<имя_элемента> | <index>}]` или `<форма>.elements.<имя_элемента>`. Может быть несколько элементов с одинаковым именем. В таком случае вернет коллекцию элементов. Эти ссылки не зависят от окружающих тегов. Элемент может быть "зарыт" где-то глубоко в форме, но он все равно доступен через `<форма>.elements`. Свойство `elements` также есть у элементов `<fieldset>`.

По элементу можно получить его форму, используя свойство `<элемент>.form`.

Для большинства типов `input` значение ставится/читается через свойство `value`.

У большинства элементов формы может присутствовать атрибут `form="<имя_формы>"`, который связывает элемент с указанной формой.

Для элементов `textarea` доступно свойство `innerHTML`, но оно хранит только HTML, изначально присутствовавший в элементе, и не меняется при изменении значения.

Текущее "отмеченное" состояние для `checkbox` и `radio` находится в свойстве `checked` (`true`/`false`).

Выделение для `select` в JavaScript можно установить двумя путями: поставив значение свойства `value`, либо установив свойство `selectedIndex` в номер нужной опции. Установка `selectedIndex = -1` очистит выбор. Список элементов-опций (`option`) доступен через свойство `options`. Если `select` допускает множественный выбор (атрибут `multiple`), то значения можно получить/установить, сделав цикл по свойству `options`. При этом выбранные опции будут иметь свойство `selected = true`. Есть у `option` также свойства: `index` - номер опции в списке селекта и `text` - текстовое содержимое опции.

Для объектов у которых есть выделяемый текст доступны свойства: `selectionStart` - начало выделения, `selectionEnd` - конец выделения текста.

## Файлы

Для `input` с типом `file` файлы можно получить через свойство `files`, которое вернет коллекцию `FileList`, если есть атрибут `multiple`, то доступна множественная загрузка файлов, состоящую из элементов `File`, у которого имеются такие свойства:
- `name` - имя файла;
- `lastModified` - дата последней модификации;
- `size` - размер файла в байтах;
- `type` - MIME тип файла.

Для открытия окна выбора файла необходимо вызвать событие `click` на элементе `input`.

Для чтения содержимого файла используется `FileReader`.  
`var <fileReader> = new FileReader();`

`<fileReader>.error` - ошибка чтения.  
`<fileReader>.result` - содержимое файла.  
`<fileReader>.readyState` - состояние чтения:
- `EMPTY` = `0` - данные еще не загружены;
- `LOADING` = `1` - данные загружаются;
- `DONE` = `2` - данные загружены и обработаны.

`<fileReader>.onerror = function (event) {...}` - вызывается при ошибки чтения.  
`<fileReader>.onload = function (event) {...}` - вызывается при завершении чтения и обработки.

`<fileReader>.readAsArrayBuffer(<file>)` - читает содержимое файла как `ArrayBuffer` в `result` и будет доступно после события `onload`.  
`<fileReader>.readAsText(<file>[, "<кодировка>"])` - читает содержимое файла как текст [, в указаной кодировке] в `result` и будет доступно после события `onload`.  
`<fileReader>.readAsDataURL(<file>)` - читает содержимое файла как строку в виде `data:[<MIME_тип>][;charset=<кодировка>][;base64],<base64_содержимое_файла>` в `result` и будет доступно после события `onload`.

## Фокусировка

Событие `focus` вызывается тогда, когда пользователь фокусируется на элементе, а `blur` - когда фокус исчезает, например посетитель нажимает на другом месте экрана.

Методы `<элемент>.focus()`/`<элемент>.blur()` - переводят/уводят фокус с элемента.

Любой элемент поддерживает фокусировку, если у него есть атрибут `tabindex`. Его основной смысл - это указать номер по порядку элемента при переборе клавишей `Tab`. Исключением являются специальные значения: `tabindex="0"` делает элемент всегда последним; `tabindex="-1"` означает, что клавиша `Tab` будет элемент игнорировать.

События `focus` и `blur` не всплывают, но они могут быть пойманы на фазе перехвата.

Текущий элемент, на котором фокус, доступен как `document.activeElement`.

## Изменение

Событие `change` происходит по окончании изменении значения элемента формы, когда это изменение зафиксировано. Для текстовых элементов это означает, что событие произойдет не при каждом вводе, а при потере фокуса. Для остальных же элементов: `select`, `input` `type=checkbox`/`type=radio` оно срабатывает сразу при выборе значения.

Событие `input` срабатывает тут же при изменении значения текстового элемента.

События `cut`, `copy`, `paste` - происходят при вырезании/вставке/копировании значения. На момент срабатывания события в элементе все еще старое значение, а новое недоступно.

## Формы

Событие `submit` возникает при отправке формы.

Метод `<форма>.submit()` позволяет инициировать отправку формы из JavaScript, без участия пользователя. При этом само событие `submit` не генерируется.

Обработка ошибок
================

`window.onerror` - если в него записать функцию `function (message, url, lineNo, columnNo, error) {...}`, то она выполнится при возникновении неперехваченной ошибки, где `message` - сообщение ошибки , `url` - текущий URL, `lineNo` - номер строки, `columnNo` - номер столбца, где "возникла" ошибка и `error` - объект ошибки.

`window.addEventListener('unhandledrejection', (event) => {...});` - выполнит указанную функцию при возникновении не перехваченного исключения, где `event` - событие со свойством `reason` - причиной возникновения ошибки.

Взаимодействие с пользователем: `alert`, `prompt`, `confirm`
============================================================

`alert(<сообщение>);` - выводит на экран окно с сообщением и приостанавливает выполнение скрипта, пока пользователь не нажмет "ОК". Окно сообщения, которое выводится, является модальным окном. Слово "**модальное**" означает, что посетитель не может взаимодействовать со страницей, нажимать другие кнопки и т.п., пока не разберется с окном.

`prompt(<заголовок>, <значение_по_умолчанию>);` - выводит модальное окно с заголовком, полем для ввода текста, заполненным строкой по умолчанию и кнопками `OK`/`CANCEL`. Пользователь должен либо что-то ввести и нажать `OK`, либо отменить ввод кликом на `CANCEL` или нажатием `Esc` на клавиатуре. Вызов `prompt` возвращает то, что ввел посетитель - строку или специальное значение `null`, если ввод отменен (в Safari возвращает пустую строку).

`confirm(<вопрос>);` - `confirm` выводит модальное окно с вопросом с двумя кнопками: `OK` и `CANCEL`. Результатом будет `true` при нажатии `OK` и `false` - при `CANCEL`(`Esc`).

Создание графических компонентов
================================

**Виджет** - это объект, который либо контролирует готовое дерево DOM, либо создает свое.

## Основные принципы при создании виджета

- вся разметка заключена в корневой элемент. Внутри корневого элемента - только классы, не `id`;
- для работы с разметкой создается объект (`new`) и передается ему корневой элемент. Все методы и свойства добавляются к переданному корневому элементу. В конструкторе он ставит необходимые обработчики для событий. У конструктора только один аргумент (иногда два, первый аргумент - сам элемент `elem`) - объект `options`, так как у графических компонентов обычно много настроек, большинство из которых имеют разумные значения "**по умолчанию**";
- обработчики назначаются через **делегирование**. Обработчики отделяются от реальных действий;
- создаются публичные методы для изменения состояния компонента;
- в конструкторе происходит генерация DOM, которая по возможности, должна быть "**ленивой**". Фаза инициализации очень чувствительна к производительности, так как обычно в сложном интерфейсе создается много всего. При инициализации, если существенный участок работы можно отложить до реального задействования виджета - откладывают его.

## Верстка графических компонентов

При создании графических компонент ("**виджетов**") в первую очередь придумывается их **HTML/CSS-структура**. При семантической верстке классы описывают **смысл** ("*что это*?" - меню, кнопка...) и **состояние** (открыто, закрыто, отключено...) компонента.

Зачастую компонент может иметь несколько состояний. Состояние должно добавляться CSS-классом не на тот элемент, который нужно скрыть/показать/..., а на тот, к которому оно "*по смыслу*" относится, обычно - на корневой элемент.

Чтобы избежать возможных проблем, все классы внутри виджета начинают с его имени. Двойное подчеркивание `__` служит "*стандартным*" разделителем.

Стили должны вешаться на **класс**, а не на тег.

## Создание анимации с помощью `requestAnimationFrame`

`const <requestID> = requestAnimationFrame(<функция>)` - указывает браузеру выполнить указанную функцию, в которой будет происходить отрисовка анимации при первой возможности, а не с заданным интервалом, все это зависит от частоты кадров браузера и компьютера. Передает в вызываемую функцию первым параметром *timestamp*, который содержит миллисекунды до запятой, и микросекунды - после, который является некой временной меткой с момента открытия браузера. Возвращает идентификатор с помощью которого можно отменить вызов функции: `cancelAnimationFrame(<requestID>)`.

Также `requestAnimationFrame` - группирует все анимации в одном браузерном *repaint*.

## Работа во время простоя `requestIdleCallback`

`const <requestID> = requestIdleCallback(<функция>[, { timeout: <макс_ожидание_в_мс> }])` - указывает браузеру выполнить указанную функцию, во время периодов простоя браузера. Возвращает идентификатор с помощью которого можно отменить вызов функции: `cancelIdleCallback(<requestID>)`.

## Шаблонизация

**Шаблон** - это строка в специальном формате, которая путем подстановки значений (текст сообщения, цена и т.п.) и выполнения встроенных фрагментов кода превращается в DOM/HTML.

Для работы с таким шаблоном используется специальная функция, которая преобразует текст в функцию, а затем уже в DOM/HTML, т. е. функция запускает "**компиляцию**" шаблона и возвращает результат в виде функции, которую далее можно запустить с данными и получить строку-результат.

**Шаблон** - это многострочный HTML-текст. Записывать его прямо в скрипте - неудобно. Один из альтернативных способов объявления шаблона - записать его в HTML, в тег `<script>` с нестандартным `type`, например `"text/template"`:

```html
<script type="text/template" id="<tempalate-id>">
    ...
</script>
```

Если `type` не знаком браузеру, то содержимое такого скрипта игнорируется, однако оно доступно при помощи `innerHTML` - `document.getElementById('<tempalate-id>').innerHTML`.

## Колбэки

**Колбэк** (от англ. *callback*) - это функция, которую передают куда-либо и ожидают, что она будет вызвана при наступлении события.

В современных браузерах DOM-элементы могут генерировать произвольные события при помощи встроенных методов: `<элемент>.dispatchEvent(<событие>)`.

Очень важно, что внешний код ставит обработчик на корневой элемент, но не на внутренние элементы меню. Такое правило позволяет не опасаться проблем при оптимизации, расширении и даже полной переделке DOM-структуры меню. Коль скоро события и методы сохраняются, внешний код будет работать как прежде. Внешний код не имеет права залезать внутрь DOM-структуры меню, ставить там обработчики и так далее.

AJAX и COMET
============

**AJAX** (аббревиатура от "*Asynchronous Javascript And Xml*") - технология обращения к серверу без перезагрузки страницы. За счет этого уменьшается время отклика и веб-приложение по интерактивности больше напоминает десктоп. Под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.

**COMET** - общий термин, описывающий различные техники получения данных по инициативе сервера.

## `XMLHttpRequest`

Объект `XMLHttpRequest` (или, как его кратко называют, "**XHR**") дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы. `XMLHttpRequest` может работать с любыми данными, а не только с XML.

`var <xhr> = new XMLHttpRequest()` - создание.  
`<xhr>.open(<HTTP_метод>, <URL_адреса_запроса>, <async>[, <логин>, <пароль>])` - метод настройки открытия - как правило, вызывается первым после создания объекта `XMLHttpRequest`. Где `<async>`, если установлен в `false`, то запрос производится синхронно, если `true` - асинхронно [, а `<логин>` и `<пароль>` - логин и пароль для HTTP-авторизации, если нужен].

"**Синхронный запрос**" означает, что после вызова `<xhr>.send()` и до ответа сервера главный поток будет "заморожен". После получения ответа выполнение продолжится со следующей строки.

"**Асинхронный запрос**" означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики событий.

`<xhr>.send([<тело_запроса>])` - открывает соединение и отправляет запрос на сервер, так же можно отправить и содержимое файла.  
`<xhr>.abort()` - прерывает выполнение запроса.

Основные свойства, содержащие ответ сервера, которые содержатся в `<xhr>`:
- `status` - HTTP-код ответа: 200, 404, 403 и так далее. Может быть также равен 0, если сервер не ответил или при запросе на другой домен;
- `statusText` - текстовое описание статуса от сервера: `OK`, `Not Found`, `Forbidden` и так далее;
- `responseText` - текст ответа сервера;
- `responseXML` - если сервер вернул XML, снабдив его правильным заголовком `Content-type: text/xml`, то браузер создаст из него XML-документ.

### Событие `readystatechange`

Событие `readystatechange` происходит несколько раз в процессе отсылки и получения ответа. При этом можно посмотреть "*текущее состояние запроса*" в свойстве `<xhr>.readyState`:
- `UNSENT = 0` - начальное состояние;
- `OPENED = 1` - вызван `open`;
- `HEADERS_RECEIVED = 2` - получены заголовки;
- `LOADING = 3` - загружается тело (получен очередной пакет данных), повторяется при каждом получении очередного пакета данных по сети;
- `DONE = 4` - запрос завершен.

### HTTP-заголовки

Для работы с HTTP-заголовками есть 3 метода:
`<xhr>.setRequestHeader('<заголовок>', <значение>)` - устанавливает заголовок запроса с указанным значением. При этом поставленный заголовок нельзя снять.  
`<xhr>.getResponseHeader('<заголовок>')` - возвращает значение заголовка ответа, кроме `Set-Cookie` и `Set-Cookie2`.  
`<xhr>.getAllResponseHeaders()` - возвращает все заголовки ответа, кроме `Set-Cookie` и `Set-Cookie2`. Заголовки возвращаются в виде единой строки. Между заголовками стоит перевод строки в два символа `\r\n` (не зависит от ОС), значение заголовка отделено двоеточием с пробелом `: `. Этот формат задан стандартом.

Максимальную продолжительность асинхронного запроса можно задать свойством `<xhr>.timeout` в миллисекундах.

При превышении этого времени запрос будет оборван и сгенерировано событие `<xhr>.ontimeout`.

Полный список событий по ходу обработки запроса:
- `loadstart` - запрос начат;
- `progress` - браузер получил очередной пакет данных, можно прочитать текущие полученные данные в `<xhr>.responseText`. Объект типа `ProgressEvent` со свойствами:
    - `loaded` - сколько байт уже переслано, только тело запроса, заголовки не учитываются;
    - `lengthComputable` - если `true`, то известно полное количество байт для пересылки, и оно хранится в свойстве `total`;
    - `total` - общее количество байт для пересылки, если известно.
- `abort` - запрос был отменен вызовом `<xhr>.abort()`;
- `error` - произошла ошибка;
- `load` - запрос был успешно (без ошибок) завершен;
- `timeout` - запрос был прекращен по таймауту;
- `loadend` - запрос был завершен (успешно или неуспешно).

### POST

При POST обязателен заголовок `Content-Type`, содержащий кодировку:
`Content-Type: application/x-www-form-urlencoded`

Это указание для сервера - как обрабатывать (раскодировать) пришедший запрос.

#### POST-запрос в кодировке multipart/form-data

Достаточно указать в заголовке `Content-Type` кодировку и границу:  
`Content-Type: multipart/form-data; boundary=<разделитель>`  
и далее сформировать тело запроса, удовлетворяющее требованиям кодировки, каждую секцию для каждого элемента в теле запроса начинать с:
```
--<разделитель>
Content-Disposition: form-data; name="<имя_секции>"
<пустая_строка_или_\r\n>
<значения>
```

Для отправки каждого файла используется:
```
--<разделитель>
Content-Disposition: form-data; name="<имя_секции>"; filename="<имя_файла>"
Content-Type: <MIME_тип_файла>
<пустая_строка_или_\r\n>
<содержимое_файла>
```

В конце присутствует "эпилог" о завершении передачи:
```
--<разделитель>--
<пустая_строка_или_\r\n>
```

### `FormData`

Это объект, который кодирует формы для отправки на сервер.

`var <formData> = new FormData([<элемент_формы>]);` - создание [с определеннымы элементами по элементам формы, с `name` и `value`].  
`<formData>.append('<ключ>', <значение>[, '<имя_файла_для_отправки>']);` - добавление значение ключу, таким обазом можно добавлять и файлы.

Объект `<formData>` можно сразу отсылать, интеграция `FormData` с `XMLHttpRequest` встроена в браузер. Кодировка при этом будет `multipart/form-data`.

Для обмена данными JS <-> сервер можно использовать и просто `JSON`, желательно с указанием кодировки в заголовке `Content-Type`.

### `URLSearchParams`

Это объект, который кодирует или раскодирует параметры для отправки на сервер.

`var <urlSearchParams> = new URLSearchParams(['<параметры>']);` - создание [с определеннымы параметрами после `?` для запроса `GET` или тело запроса `POST`].  
`<formData>.set('<ключ>', <значение>);` - устанавливает значение по ключу.  
`<formData>.has('<ключ>');` - возвращает `true` если есть ключ со значением или `false` если его нет.  
`<formData>.append('<ключ>', <значение>);` - добавление значение ключу.
`<formData>.get('<ключ>');` - возвращает значение по ключу или `null` если его нет.  
`<formData>.getAll('<ключ>');` - возвращает массив значений ключа.  
`<formData>.delete('<ключ>');` - удаляет значение ключа и сам ключ.  
`<formData>.toString();` - возвращает строку запроса с правильно сформированным URL.  

## Кросс-доменные запросы

Спецификация **CORS** налагает специальные ограничения на кросс-доменные запросы. Их виды:
1. **Простые** - считаются запросы, если они удовлетворяют следующим двум условиям:
    - простой метод: `GET`, `POST` или `HEAD`;
    - простые заголовки - только из списка:
        - `Accept`;
        - `Accept-Language`;
        - `Content-Language`;
        - `Content-Type` со значением `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.
2. **Непростые** - т.е. все остальные.

В кросс-доменный запрос браузер автоматически добавляет заголовок `Origin`, содержащий домен, с которого осуществлен запрос.

Сервер должен, со своей стороны, ответить специальными заголовками, разрешает ли он такой запрос к себе. Если сервер разрешает кросс-доменный запрос с этого домена - он должен добавить к ответу заголовок `Access-Control-Allow-Origin`, содержащий домен запроса или звездочку `*`. Только при наличии такого заголовка в ответе - браузер сочтет запрос успешным, а иначе JavaScript получит ошибку. При таких запросах не передаются куки и заголовки HTTP-авторизации.

Чтобы JavaScript мог прочитать HTTP-заголовки ответа, сервер должен указать их имя в `Access-Control-Expose-Headers` через запятую.

Чтобы браузер передал вместе с запросом куки и HTTP-авторизацию, нужно поставить запросу `<xhr>.withCredentials = true`. При таком запросе сервер должен вернуть уже не один, а два заголовка:
- `Access-Control-Allow-Origin: <домен>`;
- `Access-Control-Allow-Credentials: true`.

Для запросов с "**непростым**" методом или особыми заголовками браузер делает предзапрос `OPTIONS`, указывая их в `Access-Control-Request-Method` и `Access-Control-Request-Headers`. Браузер ожидает ответ со статусом `200`, без тела, со списком разрешенных методов и заголовков в `Access-Control-Allow-Method` и `Access-Control-Allow-Headers`. Дополнительно можно указать `Access-Control-Max-Age` для кэширования предзапроса. Дополнительно: названия нестандартных заголовков ответа сервер должен указать в `Access-Control-Expose-Headers`, если хочет, чтобы клиент мог их прочитать.

### Стадия закачки

На стадии закачки для получения информации используем объект `<xhr>.upload`. У этого объекта нет методов, он только генерирует события в процессе закачки, их значение аналогично стадии загрузки: `loadstart`, `progress`, `abort`, `error`, `load`, `timeout`, `loadend`.

## COMET с XMLHttpRequest: длинные опросы

**Длинные опросы** - отличная альтернатива частым опросам, которые проводятся с некоторым интервалом. Они также удобны в реализации, и при этом сообщения доставляются без задержек. Схема:
1. Отправляется запрос на сервер;
2. Соединение не закрывается сервером, пока не появится сообщение;
3. Когда сообщение появилось - сервер отвечает на запрос, пересылая данные;
4. Браузер тут же делает новый запрос.

Ситуация, когда браузер отправил запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений. При этом если соединение рвется само, например, из-за ошибки в сети, то браузер тут же отсылает новый запрос.

## WebSocket

**Протокол WebSocket** предназначен для решения любых задач и снятия ограничений обмена данными между браузером и сервером. Он позволяет пересылать любые данные, на любой домен, безопасно и почти без лишнего сетевого трафика. Протокол WebSocket работает над HTTP.

`var <socket> = new WebSocket("ws[s]://<url>"[, "soap"][, "wamp"])` - создание соединения.

Основные события:
- `onopen` - при открытии;
- `onclose` - при закрытии; при чистом закрытии: `<event>.wasClean = true`;
- `onmessage` - при получении данных;
- `onerror` - при ошибки соединения.

`<socket>.send(<данные>)` - посылка данных на сервер.

## Протокол JSONP

Если создать тег `<script src>`, то при добавлении в документ запустится процесс загрузки `src`. В ответ сервер может прислать скрипт, содержащий нужные данные. Таким образом можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок.

**Протокол JSONP** - это "надстройка" над таким способом коммуникации.

```javascript
var elem = document.createElement("script");
elem.src = "<url>";
document.head.appendChild(elem);
```

Обработка ответа:
1. Вместе с запросом клиент в специальном, заранее оговоренном, параметре передает название функции, которая должна быть глобальной. Обычно такой параметр называется `callback`;
2. Сервер кодирует данные в JSON и оборачивает их в вызов функции, название которой получает из параметра `callback` запроса: `<url>?callback=<функция_колбэк>`.

Это и называется JSONP ("*JSON with Padding*").

### Реестр CallbackRegistry

Чтобы не загрязнять глобальное пространство имен, или по крайней мере свести загрязнение к минимуму, для этого создают один глобальный объект "**реестр**", который как правило называется `CallbackRegistry`. Далее для каждого запроса в нем генерируется временная функция.  
`<url>?callback= CallbackRegistry.<временная_функция_колбэк>`

### Обнаружение ошибок

При запросе данных при помощи SCRIPT возможны различные ошибки:
- скрипт может не загрузиться: отказ в соединении, разрыв связи...;
- ошибка HTTP, например 500;
- скрипт загрузился, но внутри некорректен и не вызывает функцию. Например, на сервере произошла ошибка и в ответе передан ее текст, а вовсе не данные.

Чтобы отловить их все "одним махом", используется следующий алгоритм:
1. Создается `<script>`.
2. На `<script>` ставятся обработчики `onreadystatechange` (для старых IE) и `onload`/`onerror` (для остальных браузеров).
3. При загрузке скрипт выполняет функцию-колбэк. Пусть она при запуске ставит флажок "все ок". А затем в обработчиках проверяют - если флага нет, то функция не вызывалась - стало быть, ошибка при загрузке или содержимое скрипта некорректно.

### COMET

COMET через SCRIPT реализуется при помощи длинных опросов. То есть, создается тег `<script>`, браузер запрашивает скрипт у сервера и... Сервер оставляет соединение висеть, пока не появится, что сказать. Когда сервер хочет отправить сообщение - он отвечает, используя формат JSONP. И после этого сразу, создается новый запрос.

## Server Side Events - события с сервера

Современный стандарт **Server-Sent Events** позволяет браузеру создавать специальный объект `EventSource`, который сам обеспечивает соединение с сервером, делает пересоединение в случае обрыва и генерирует события при поступлении данных.

При создании объекта `EventSource` браузер автоматически подключается к указанному адресу и начинает получать с него события:  
`var <eventSource> = new EventSource("<url>")` - создание объекта.

Чтобы соединение успешно открылось, сервер должен ответить с заголовком `Content-Type: text/event-stream`, а затем оставить соединение висящим и писать в него сообщения в специальном формате:
- каждое сообщение пишется после `data:`. Если после двоеточия есть пробел, то он игнорируется;
- сообщения разделяются двумя строками `\n\n`;
- если нужно переслать перевод строки, то сообщение разделяется. Каждая следующая строка пересылается отдельным `data:`.

При создании объекта браузер автоматически подключается к серверу, а при обрыве - пытается его возобновить.

Закрытие соединения на стороне браузера: ответ со статусом не 200 или ответ с `Content-Type`, не совпадающим с `text/event-stream`.

Между попытками возобновить соединение будет пауза, начальное значение которой зависит от браузера (1-3 секунды) и может быть изменено сервером через указание в ответе `retry: <задержка_в_мс>`.

`<eventSource>.close() `- закрытие соединения, при этом дальнейших попыток соединения не будет. Открыть обратно этот объект тоже нельзя, можно создать новый `EventSource`.

### Идентификатор id

Для того, чтобы продолжить получение событий с места разрыва, стандарт предусматривает идентификацию событий через `id: <номер>`. Сервер может указать его в ответе.

При получении `id:` браузер:
- устанавливает свойство `<eventSource>.lastEventId` в его значение;
- при пересоединении пошлет заголовок `Last-Event-ID` с этим `id`, так что сервер сможет переслать последующие, пропущенные, сообщения.

При этом: `id` шлется не перед сообщением, а после него, чтобы обновление `lastEventId` произошло, когда браузер все уже точно получил.

### Статус соединения `readyState`

У объекта `EventSource` есть свойство `readyState`, которое содержит одно из значений: `CONNECTING` = `0` - в процессе (пере-)соединения, `OPEN` = `1` - соединение установлено, `CLOSED` = `2` - соединение закрыто.

События:
- `onopen` - при успешном установлении соединения;
- `onerror` - при ошибке соединения;
- `onmessage` - пришло сообщение, доступно как `event.data`, по умолчанию на события срабатывает обработчик `onmessage`, но можно сделать и свои события. Для этого сервер должен указать перед событием его имя после `event: <событие>`. Сообщение по умолчанию имеет имя `message`. Для обработки своих имен событий необходимо ставить обработчик при помощи `addEventListener`.

```
data: Сообщение 1
id: 1

event: join
data: Сообщение 2
id: 2

event: leave
retry: 15000
data: Сообщение 3
data: из двух строк
id: 3
```

### Кросс-доменость

`EventSource` поддерживает кросс-доменные запросы, аналогично `XMLHttpRequest`. Для этого у конструктора есть второй аргумент - объект, который нужно передать так:  
`{withCredentials: true}`

Сервер при этом получит заголовок `Origin` с доменом запроса и должен ответить с заголовком `Access-Control-Allow-Origin` (и `Access-Control-Allow-Credentials`, если стоит `withCredentials`).

При кросс-доменных запросах у событий `event` также появится дополнительное свойство `origin`, содержащее адрес источника, откуда пришли данные. Его можно использовать для дополнительной проверки со стороны браузера.

## Атака CSRF

**CSRF** (*Cross-Site Request Forgery*, также **XSRF**) - опаснейшая атака, которая приводит к тому, что хакер может выполнить на неподготовленном сайте массу различных действий от имени других, зарегистрированных посетителей.

"**Классический**" сценарий атаки таков:
- пользователь является залогиненным на целевой сайт. У него есть сессия в куках;
- пользователь попадает на "злую страницу" на каком-то сайте;
- на злой странице находится форма такого вида:
    ```html
    <form action="<url_целевого_сайта>" method="<метод>">
        <input type="hidden" name="<имя>" value="<значение>">
        ...
    </form>
    ```
- при заходе на злую страницу JavaScript вызывает `form.submit`, отправляя таким образом форму на целевой сайт. Целевой сайт проверяет куки, видит, что посетитель авторизован и обрабатывает форму.

Итог атаки - пользователь, зайдя на злую страницу, ненароком совершил действия на сайте от своего имени. Содержимое действий сформировано хакером.

### Защита

Куки не гарантируют, что форму создал именно тот пользователь, который в куках. Они только удостоверяют личность, но не данные.

Типичный способ защиты сайтов - это "**секретный ключ**" (*secret*), специальное значение, которое генерируется случайным образом и сохраняется в сессии посетителя. Его знает только сервер, посетителю его даже не показывают.

Затем на основе ключа генерируется "**токен**" (*token*). Токен делается так, чтобы с одной стороны он был отличен от ключа, в частности, может быть много токенов для одного ключа, с другой - чтобы было легко проверить по токену, сгенерирован ли он на основе данного ключа или нет.

Для каждого токена нужно дополнительное случайное значение, которое называют "**соль**" *salt*. Формула вычисления токена:  
`token = salt + ":" + MD5(salt + ":" + secret)`

Далее, токен добавляется в качестве скрытого поля к каждой форме, генерируемой на сервере.

При ее отправке сервер проверит скрытое поле, удостоверится в правильности токена, и лишь после этого отошлет сообщение.

"Злая страница" при всем желании не сможет сгенерировать подобную форму, так как не владеет `secret`, и токен будет неверным.

Такой токен также называют "**подписью**" формы, которая удостоверяет, что форма сгенерирована именно на сервере.

Эта подпись говорит о том, что автор формы - сервер, но ничего не гарантирует относительно ее содержания. Есть ситуации, когда необходимо быть уверенным, что некоторые из полей формы посетитель не изменил самовольно. Тогда можно включить в MD5 для формулы токена эти поля, например:  
`token = salt + ":" + MD5(salt + ":" + secret + ":" + field)`

### Токен и AJAX

Как и в случае с формой, нужно "**подписать**" запрос токеном, чтобы гарантировать, что его содержимое прислано на сервер именно интерфейсом сайта, а не "злой страницей".

Здесь возможны варианты, самый простой - это дополнительная кука:
- при авторизации сервер устанавливает куку с именем `CSRF-TOKEN`, и пишет в нее токен;
- код, осуществляющий `XMLHttpRequest`, получает куку и ставит заголовок `X-CSRF-TOKEN` с ней;
- сервер проверяет, есть ли заголовок и содержит ли он правильный токен.

Защита действует потому, что прочитать куку может только JavaScript с того же домена. "Злая страница" не сможет "переложить" куку в заголовок.

Если нужно сделать не `XMLHttpRequest`, а, к примеру, динамически сгенерировать форму из JavaScript - она также подписывается аналогичным образом, скрытое поле или дополнительный URL-параметр генерируется по куке.

## Метод `fetch`: замена `XMLHttpRequest` (ES6)

Метод `fetch` - это `XMLHttpRequest` нового поколения. Он предоставляет улучшенный интерфейс для осуществления запросов к серверу: как по части возможностей и контроля над происходящим, так и по синтаксису, так как построен на промисах.

`let <promise> = fetch(<url>[, <options>]);` - где:
- `<url>` - URL, на который нужно сделать запрос;
- `<options>` - необязательный объект с настройками запроса. Свойства `<options>`:
    - `method` - метод запроса;
    - `headers` - заголовки запроса (объект);
    - `body` - тело запроса: `FormData`, `Blob`, строка и т.п.;
    - `mode` - одно из: `"same-origin"`, `"no-cors"`, `"cors"`, указывает, в каком режиме кросс-домености предполагается делать запрос;
    - `credentials` - одно из: `"omit"`, `"same-origin"`, `"include"`, указывает, пересылать ли куки и заголовки авторизации вместе с запросом;
    - `cache` - одно из `"default"`, `"no-store"`, `"reload"`, `"no-cache"`, `"force-cache"`, `"only-if-cached"`, указывает, как кэшировать запрос;
    - `redirect` - можно поставить `"follow"` для обычного поведения при коде 30x (следовать редиректу) или `"error"` для интерпретации редиректа как ошибки;
    - `signal` - принимает `AbortSignal` для отмены запроса.

При вызове `fetch` возвращает промис, который, когда получен ответ, выполняет колбэки с объектом `Response` или с ошибкой, если запрос не удался.

Объект `<response>` содержит свойства:
- `status` - код статуса;
- `statusText` - строка, которая соответствует HTTP коду статуса;
- `ok` - будет содержаться `true` при кодах статуса от 200 до 299;
- `headers` - объект заголовков.

Для прочитения тела ответа в желаемом формате используются метода, которые описаны в спецификации `Body`, они включают в себя:
- `<response>.arrayBuffer()`;
- `<response>.blob()`;
- `<response>.formData()`;
- `<response>.json()`;
- `<response>.text()`.

Соответствующие вызовы возвращают промис, который, когда ответ будет получен, промис разрешиться с результатом.

```javascript
// GET запрос
fetch('<url>')
    .then(response => response.json())
    .then(json => console.log(json));
// POST запрос
fetch('<url>', {
    method: 'POST',
    body: JSON.stringify({/*<data>*/})
})
    .then(response => response.json())
    .then(json => console.log(json));
```

Куки, `document.cookie`
=====================

`document.cookie` - возвращает все куки в виде строки, которая состоит из пар `<ключ>=<значение>`, которые перечисляются через точку с запятой с пробелом `; `.

В `document.cookie` можно писать, при этом запись не перезаписывает существующие cookie, а дополняет к ним:  
`<ключ>=<значение>[; path=/<путь_страниц_сайта>][; domain=<домен_действия>][; expires=<дата_истечения_куки_в_формате_GMT>][; secure]`

Если `secure` - то cookie можно передавать только по `HTTPS`.

Чтобы удалить cookie:  
`document.cookie = "<ключ>=; path=/; expires=" + (new Date(0)).toUTCString();`

Сервер может поставить cookie с дополнительным флагом `HttpOnly`. Cookie с таким параметром передается только в заголовках, оно никак не доступно из JavaScript.

Отловить то, что если отключены cookie можно проверкой свойства `navigator.cookieEnabled`.

Сессионная кука не имеет аттрибутов `Expires` или `Max-Age`.

Локальное хранилище
===================

HTML5-хранилище базируется на именах пар ключ/значение.

Для локального хранилища используется глобальный объект `localStorage`.

Основные методы:
`localStorage.setItem("<ключ>", <значение>) `- устанавливает значение ключа.  
`localStorage.getItem("<ключ>")` - возвращает значение ключа по его имени.  
`localStorage.removeItem("<ключ>")` - удаляет ключ из хранилища и его значение.  
`localStorage.length` - возвращает количество ключей в хранилище.  
`localStorage.key(<номер>)` - возвращает значение ключа по номеру.  
`localStorage.clear()` - очищает хранилище.

"5 мегабайт" - сколько места для хранения выдается по умолчанию. `"QUOTA_EXCEEDED_ERR"` это исключение, если будет превышена квота в 5 Мб.

Событие `storage` возникает в объекте `window`, когда `setItem()`, `removeItem()` или `clear()` вызываются и что-то изменяют. имеет указанные свойства:
- `key` - ключ может быть добавлен, удален или изменен;
- `oldValue` - предыдущее значение (если переписано) или `null`, если добавлено новое значение;
- `newValue` - новое значение или `null`, если удалено;
- `url` - страница, которая вызывает метод, приведший к изменению.

Также существует сессионное хранилище `sessionStorage`, которое полностью аналогично `localStorage`, только распространяется на одну вкладку или окно браузера и каждая вкладка имеет свой уникальный `sessionStorage`, который очищается при закрытии вкладки или браузера.

Управление историей браузера
============================

DOM `window` объект предоставляет доступ к истории браузера через объект `history`. Он расширяет полезные свойства и методы, которые позволяют двигаться вперед и назад по истории пользователя, а также манипулировать содержимым стека истории.

`window.history.back();` - перемещает назад по истории.  
`window.history.forward();` - перемещает вперед по истории.  
`window.history.go(<количество>);` - перемещает на указаное `<количество>` позиций относительно текущей, который равен 0, по истории вперед, если число положительное и назад, если отрицательное.  
`window.history.length;` - количество страниц в стеке истории.

`history.pushState(<объект_состояния>, "<заголовок>", "<URL>");` - помещает новую запись в историю, где `<объект_состояния>` - может быть всем, что может сериализироваться, `"<заголовок>"` - заголовок записи истории, `"<URL>"` - URL новой записи истории, при этом браузер не пытается загрузить этот URL после вызова `pushState()`. Новый URL может любым в пределах домена, порта и протокола.

`history.replaceState(<объект_состояния>, "<заголовок>", "<URL>");` - работает аналогично `history.pushState()`, но заменяет последнюю запись истории вместо создания новой.

При изменении истории вызывается событие `popstate` у `window`, у него есть свойство `state` которое содержит копию записи истории, если запись истории была создана с помощью вызова `pushState` или `replaceState`.

`history.state;` - содержит объект состояния текущей записи истории, если он есть.

`window.location` - возвращает объект `Location` с информацией о текущем расположении документа, представляет собой объект только для чтения, но ему можно присвоить значение, что будет аналогично присвоению `window.location.href = "<url>"`.

Свойства (как и у `URLUtils`):
- `href` - строка содержащая URL целиком. При изменении, соответствующий документ переходит на новую страницу;
- `protocol` - строка содержащая протокол текущего URL, включая `:`;
- `host` - строка содержащая хост, а именно имя хоста, `:` и порт;
- `hostname` - строка содержащая домен текущего URL;
- `port` - строка содержащая номер порта текущего URL;
- `pathname` - строка содержащая первый `/` после хоста с последующим текстом URL;
- `search` - строка содержащая `?` с последующими параметрами URL;
- `hash` - строка содержащая `#` с последующим идентификатором;
- `username` - строка содержащая имя пользователя, указанное перед именем домена;
- `password` - строка содержащая пароль, указанный перед именем домена;
- `origin` - строка содержащая протокол, хост и порт текущего URL.

Методы:
- `assign("<url>")` - загружает ресурс по URL, указанному URL;
- `reload([true])` - перезагружает ресурс по текущему URL[, страница будет заново загружена с сервера];
- `replace("<url>")` - заменяет текущий ресурс на новый по URL, указанному в качестве параметра, текущая страница не будет сохранена в `History`, и пользователь не сможет использовать кнопку назад, чтобы вернуться к ней.

`document.referrer` - возвращает URI страницы, с которой был совершен переход на текущую, пустую строку, если перешел напрямую.

`window.open(<url>[, "_black"])` - открывает указаную ссылку `<url>` [в новом окне].

Полноэкранный режим
===================

`<элемент>.requestFullscreen()` - возвращает промис, который разрешается успешно, если удалось установить `<элемент>` в полноэранный режим, при этом все что находилось выше него по иерархии и элементы браузера будут скрыты.

`document.exitFullscreen()` - возвращает промис, который разрешается успешно, если удалось выйти из полноэкранного режима.  
`document.fullscreenElement` - содержит элемент, который в полноэкранном режиме.

WebRTC
======

Это коллекция стандартов, протоколов и JavaScript API, которые все вместе обеспечивают peer-to-peer видео-аудио коммуникации в реальном времени, а также могут быть использованы для передачи любых бинарных данных.

## Потоки от пользователя

```javascript
navigator.mediaDevices.getUserMedia({
    video: true, // для захвата видео
    audio: true, // для захвата аудио
})
    .then(stream => {
        const tracks = stream.getTracks(); // содержит массив треков из потока от пользователя
    });
```

## `RTCPeerConnection`

Используется для установки соединения. С помощью ICE протокола узнается ip собеседника, если он находится за NAT.

```javascript
const peerConnection = new RTCPeerConnection({
    iceServers: [{
        urls: '<stun_сервер>' // 'stun:stun.l.google.com:19302'
    }]
});
```

`peerConnection.addTrack(<track>)` - присоединяет трек к соединению.

Событие `negotiationneeded` - срабатывает сразу при добавлении медиапотока в peerConnection.
```javascript
peerConnection.onnegotiationneeded = (event) => {
      peerConnection.createOffer() // Создает и назначает SDP (Session Description Protocol)) offer
        .then((offer) => peerConnection.setLocalDescription(offer))
    };
```

`peerConnection.iceConnectionState` - содержит строку состояния peerConnection. Состояния:
- `'connected'` - соединен.

Событие `iceconnectionstatechange` - срабатывает при изменении ICE состояния peerConnection.
```javascript
peerConnection.oniceconnectionstatechange = (event) => {
    // ...
}
```

Событие `icegatheringstatechange` - срабатывает каждый раз, как появляется ICE кандидат.
```javascript
peerConnection.onicegatheringstatechange = (event) => {
    const connection = event.target; // соединение с новым кандидатом
    connection.iceGatheringState; // содержит состояние соединения с кандидатом, 'complete' - соединен.
    // ...
}
```

Worker
======

**Веб-воркеры** - это потоки, принадлежащие браузеру, которые можно использовать для выполнения JS-кода без блокировки цикла событий. Виды:
- **Выделенные воркеры** - экземпляры выделенных веб-воркеров создаются главным процессом. Обмениваться данными с ними может только он;
- **Разделяемые воркеры** - доступ к разделяемому воркеру может получить любой процесс, имеющий тот же источник, что и воркер (например - разные вкладки браузера, iframe, и другие разделяемый воркеры);
- **Сервис-воркеры** - это воркеры, управляемые событиями, зарегистрированные с использованием источника их происхождения и пути. Они могут контролировать веб-страницу, с которой связаны, перехватывая и модифицируя команды навигации и запросы ресурсов, и выполняя кэширование данных, которым можно очень точно управлять.

Возможности, доступные веб-воркерам:
- объект `navigator`;
- объект `location` (только для чтения);
- `XMLHttpRequest`;
- `setTimeout()`/`clearTimeout()` и `setInterval()`/`clearInterval()`;
- кэш приложения;
- импорт внешних скриптов с использованием `importScripts()`;
- создание других веб-воркеров.

В контексте воркера и `self`, и `this`, указывают на глобальное пространство имен для воркера.

## Выделенные воркеры

`const <worker> = new Worker('<путь_к_js_файлу>');` - создает воркера с его кодом, если файл существует и к нему есть доступ, браузер создаст новый поток, который асинхронно загрузит этот файл. После того, как загрузка будет завершена, начнется выполнение кода воркера. Если при попытке загрузки файла браузер получит сообщение об ошибке `404`, файл загружен не будет, при этом сообщения об ошибках не выводятся.

`<worker>.postMessage(<данные> [, <массив_передаваемых_объектов>]);` - передает в воркер указанные данные `<данные>` [, а также передает во влвдение все объекты из массива `<массив_передаваемых_объектов>`, эти объекты становятся непригодные в текущем контексте и становятся доступны только в воркере, объекты могут быть экземплярами классов `ArrayBuffer`, `MessagePort` или `ImageBitmap`. Для удобства использования на них должна передаваться ссылка в объекте `<данные>`].

`<worker>.addEventListener('message', function (e) {...}, false);` - регистрирует функцию принимающую данные от воркера, где `e` - это событие, со свойствами:
- `data` - это переданные данные.

`<worker>.addEventListener('error', function (e) {...}, false);` - регистрирует функцию, которая вызовется при ошибке в воркере, где `e` - это событие, со свойствами:
- `filename` - имя файла, в котором содержится скрипт воркера, вызвавший ошибку;
- `lineno` - номер строки, в которой произошла ошибка;
- `message` - описание ошибки.

`<worker>.terminate();` - уничтожает воркера.

`const <worker> = new Worker(URL.createObjectURL(new Blob(['<js_код>'])));` - позволяет создать воркера с произвольным кодом.

### Строение воркера

Воркеры могут создавать новых воркеров, если нужно.

`this.postMessage(<данные> [, <массив_передаваемых_объектов>]);` - передает указанные данные `<данные>` тому, кто запустил воркера [, а также передает во влвдение все объекты из массива `<массив_передаваемых_объектов>`, эти объекты становятся непригодные в текущем контексте и становятся доступны только в том кто запустил воркера, объекты могут быть экземплярами классов `ArrayBuffer`, `MessagePort` или `ImageBitmap`. Для удобства использования на них должна передаваться ссылка в объекте `<данные>`].

`this.addEventListener('message', function (e) {...}, false);` - регистрирует функцию принимающую данные от того, кто запустил воркера, где `e` - это событие `MessageEvent`, со свойствами:
- `data` - это копия переданных данных.

`onmessage = function (e) {...}` - аналогично.

`this.close();` - уничтожает воркера, т.е. самого себя.

Внутри воркера можно подключать внешние скрипты с помощью:  
`importScripts([<url1>[, ...]]);`

## Сервис-воркеры

`navigator.serviceWorker.register('<путь_к_js_файлу>');` - регистрирует сервис воркера, если он не был уже зарегистрирован и возвращает `Promise` для сообщения о результате регистрации, который завершается успешно с объектом `registration` класса `ServiceWorkerRegistration`. Сервис воркер будет получать события `fetch` в рамках своего пути подключения, т.е. воркер по пути `<путь>/<js_файл>` будет получать только все события `<путь>/` и не выше.

После активации сервис-воркер сможет управлять всеми страницами, которые попадают в его область видимости. Он пока эта страница не будет перезагружена. Может находиться в состояниях:
- **Обработка событий** - ожидает поступления событий `fetch` и `message`;
- **Остановлен** - когда система останавливает сервис-воркер для экономии ресурсов.

### Кэш

Представляет собой глобальный объект: `caches`.

`caches.open('<имя_кэша>');` - возвращает `Promise`, который завершается успешно с объектом `cache` - который представляет кэш и имеет методы:
- `cache.add(<url>)` - возвращает `Promise`, который завершается успешно когда указанная ссылка будет добавлена в кэш;
- `cache.addAll([<url1>[, ...]])` - возвращает `Promise`, который завершается успешно когда все указанные ссылки из масссива будут добавлены в кэш;
- `cache.put(<request>, <response>)` - возвращает `Promise`, который завершается успешно когда запрос `<request>` и ответ `<response>` на него будут добавлены в кэш;
- `cache.match(<request>)` - возвращает `Promise`, который завершается успешно после после поиска запроса в этом кэше `<request>` с ответом или без него, если его нет.

`caches.keys();` - возвращает `Promise`, который завершается успешно с массивом имен кэшей.

`caches.delete('<имя_кэша>');` - возвращает `Promise`, который завершается успешно после удаления кэша с именем `<имя_кэша>`.

`caches.match(<request>);` - возвращает `Promise`, который завершается успешно после после поиска запроса в кэшах `<request>` с ответом или без него, если его нет.

### Строение воркера

`self.addEventListener('install', (event) => {...});` - регистрирует функцию, которая вызовется при установки сервис воркера, где `event` - это событие, со свойствами:
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
event.waitUntil(
    caches.open('<имя_кэша>') // открывает кэш
        .then((cache) => cache.addAll([ // загружает ресурсы по указаным url
                '<url>',
                '<another_url>'
            ])
        )
);
```

Это событие подходит для кэширования стилей, изображений, скриптов, и для любых статических файлов, используемых на странице.

После того, как сервис-воркер будет установлен и пользователь перейдет на другую страницу приложения или обновит страницу, на которой он находится, сервис-воркер начнет получать события `fetch`.

`self.addEventListener('fetch', (event) => {...});` - регистрирует функцию, которая вызовется при получении события `fetch`, где `event` - это событие, со свойствами:
- `respondWith` - принимает промис для того, чтобы определить то, как нужно отвечать на события `fetch` либо из кэша, либо запросом, либо ответом. Внутри можно выполнять работу с кэшем `caches`:
```javascript
event.respondWith(
    caches.match(event.request)// ищет кэшированные результаты в любом из созданных сервис-воркером кэшей
        .then((response) => {
            if (response) { // если в кэше данные найдены, то они возвращаются
                return response;
            }
            const fetchRequest = event.request.clone(); // клонируется запрос, так как он поток
            return fetch(fetchRequest) // загружаются данные напрямую
                .then((response) => {
                    if(!response || response.status !== 200 || response.type !== 'basic') {
                        return response; // если данные не правильные, то они возвращаются
                    }
                    var responseToCache = response.clone(); // клонируется ответ, так как он поток
                    caches.open('<имя_кэша>')
                        .then((cache) => {
                            cache.put(event.request, responseToCache); // добавляется ответ в кэш для последующего использования
                        });
                    return response;
                });
    })
);
```

Пример запросов через кэш:
```javascript
self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request)
            .then(response => response || fetch(event.request))
    );
});
```

`self.addEventListener('activate', (event) => {...});` - регистрирует функцию, которая вызовется при установки новой версии сервис воркера, где `event` - это событие, со свойствами:
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
event.waitUntil(
    caches.keys() // возвращает все ключи из кэша
        .then((cacheNames) => Promise.all(
            cacheNames.map((cacheName) => { // проходит по всем кэшированным файлам
                return caches.delete(cacheName); // удаляет файл из кэша
            })
        ))
);
```

`self.addEventListener('push', (event) => {...});` - регистрирует функцию, которая вызовется при приеме push-уведомления, где `event` - это событие, со свойствами:
- `data` - объект с данными, который может существовать и иметь методы:
    - `text()` - возвращает данные в текстовом формате;
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
self.addEventListener('push', (event) => {
    if (event.data.text() === 'new-email') {
        event.waitUntil(
            caches.open('<имя_кэша>')
                .then(cache => fetch('/inbox.json')
                    .then(response => {
                        cache.put('/inbox.json', response.clone());
                        return response.json();
                    })).then(emails => {
                        registration.showNotification('New email', {
                            body: `From ${emails[0].from.name}`,
                            tag: 'new-email'
                        });
                    });
        );
    }
});
```

`self.addEventListener('notificationclick', (event) => {...});` - регистрирует функцию, которая вызовется при нажатии на push-уведомления, где `event` - это событие, со свойствами:
- `notification` - объект с данными, который содержит:
    - `tag` - тег уведомления;
    - `close()` - закрывает уведомление;
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
self.addEventListener('notificationclick', (event) => {
    if (event.notification.tag === 'new-email') {
        new WindowClient('/inbox/');
    }
});
```

`self.addEventListener('sync', (event) => {...});` - регистрирует функцию, которая вызовется при синхронизации, где `event` - это событие, со свойствами:
- `id` - идентификатор;
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
self.addEventListener('sync', event => {
    if (event.id === 'update-leaderboard') {
        event.waitUntil(
            caches.open('mygame-dynamic')
                .then(cache => cache.add('/leaderboard.json'))
        );
    }
});
```

Воркер может показывать уведомления:
```javascript
registration.showNotification('<Заголовок>', {
    body: `<тело>`,
    tag: '<тег>'
})
```

## Широковещательный канал передачи данных `BroadcastChannel`

Объект `BroadcastChannel` представляет собой более универсальное API для передачи данных. Он позволяет передавать сообщения, которые можно принять во всех контекстах, имеющих один и тот же источник. Все вкладки браузера, `iframe` или воркеры, относящиеся к одному источнику, могут передавать и принимать широковещательные сообщения.

`var <broadcastChannel> = new BroadcastChannel('<имя_канала>');` - создает подключение к широковещательному каналу.

`<broadcastChannel>.postMessage(<данные>);` - отправляет сообщение (данные) всем подписавшимся.

`<broadcastChannel>.onmessage = function (e) {...}` - подписывает (регистрирует) функцию на прием сообщений, где `e` - это событие, со свойствами:
- `data` - это переданные данные.

`<broadcastChannel>.addEventListener('message', function (e) {...});` - аналогично предыдущему.

`<broadcastChannel>.close();` - отписывание (отключение) от канала.

Push API и Notifications API
============================

**Push API** - используется, когда сервер передает сообщение сервис-воркеру.  
**Notifications API** - применяется, когда сервис-воркер, или скрипт в самом веб-приложении, намеревается показать пользователю уведомление.

## Push API

Для использования необходимо зарегистрировать сервис-воркер.

`let <promise> = Notification.requestPermission();` - запускает процедуру для получения разрешения пользователя на отправку ему push-сообщений (приводит к показу окна) и возвращает промис, который выполняется успешно с результатом разрешения, если `'granted'`, то пользователь дал свое разрешение, `'denied'` - отказал (окно больше не покажется) или `'default'` - проигнорировал.

`registration.pushManager.subscribe({userVisibleOnly: true, applicationServerKey: '<key>'});` - оформляет подписку, где `'<key>'` это открытый ключ в кодировке Base64, или объект `ArrayBuffer`, который push-сервер будет использовать для аутентификации сервера приложения и возвращает промис, который завершается успешно с `pushSubscription`, который имеет свойства:
- `endpoint` - представляет собой URL сервиса push-уведомлений, точку входа в API, для того, чтобы отправить уведомление, надо выполнить POST-запрос по этому URL;
- `keys`: - содержит сведения, используемые для шифрования данных сообщения, отправляемых в push-уведомлении:
    - `p256dh`;
    - `auth`.

Браузер передает `applicationServerKey` (открытый ключ) push-сервису в ходе оформления подписки, что означает, что push-сервис сможет связать открытый ключ приложения с подпиской, `PushSubscription`.

## Notifications API

`const <notification> = new Notification("<заголовок>", <опции>);` - создает уведомление с указанным заголовком и отображает его, где `<опции>` - это объект со свойствами:
- `body` - текст тела уведомления;
- `icon` - ссылка на иконку;
- `tag` - тег, используемый для идентификации уведомления, что позволяет обновлять уведомления без их отображения, что может быть полезным при большом количестве уведомлений;
- `image` - ссылка на изображение;
- `data` - данные, ассоциированные с уведомлением и др.

`<notification>.close();` - закрывает уведомление.

Объект `Notification` создает события:
- `show` - отображение уведомления;
- `close` - закрытие уведомления;
- `click` - нажатие на уведомление;
- `error` - ошибка.

`window.navigator`
==================

## API разрешений

`let <promise> = window.navigator.permissions.query({ name: '<тип_разрешения>' });` - возвращает промис с запросом на разрешение указаного типа, который разрешиться с объектом со свойствами:
- `state` - при разрешении будет равно `'granted'` или `'prompt'`.

## Clipboard API

`let <promise> = window.navigator.clipboard.writeText('<текст>');` - копирует текст в буфер обмена и возвращает промис, которые может отклониться если нет разрешения копировать текст в буфер обмена.

`const <clipboardItem> = new ClipboardItem({ [<blob>.type]: <blob> });` - создает объект для буфера обмена из Blob объекта `<blob>`.

`let <promise> = window.navigator.clipboard.write([<clipboardItem>]);` - копирует Blob объект в буфер обмена и возвращает промис, которые может отклониться если нет разрешения копировать текст в буфер обмена.  
`let <promise> = window.navigator.clipboard.writeText("<текст>");` - копирует текст в буфер обмена и возвращает промис, которые может отклониться если нет разрешения копировать текст в буфер обмена.

`let <promise> = window.navigator.clipboard.readText();` - возвращает промис, который разрешится с текстовым содержимым, которое есть в буфере обмена.

`document.addEventListener('copy', function (e) {...}, false);` - добавляет обработчик, который сработает при копировании в буфер обмена, где `e` - это событие, со свойствами:
- `clipboardData` - это объект с буфером данных, с методами:
    - `setData('text', '<текст>')` - установка текста в буфер обмена;
    - `files` - массив файлов.

`let <promise> = window.navigator.permissions.query({ name: 'clipboard-read' });` - возвращает промис с запросом на разрешение чтения буфера обмена.  
`let <promise> = window.navigator.permissions.query({ name: 'clipboard-write' });` - возвращает промис с запросом на разрешение записи в буфер обмена.

## Web Share API

Позволяет делиться содержимым страницы или копировать его в буфер обмена пользователя.

`navigator.canShare(<data>)` - возвращает `true`, если данными можно поделиться.  
`navigator.share(<data>)` - возвращает промис, который разрешается в случае успешного шаринга (sharing) данных.

Где `<data>` - это объект с полями:
- `url` - ссылка для шаринга;
- `text` - текст;
- `title` - заголовок;
- `files` - массив объектов `File`.

## Beacon API

Позволяет отправлять на сервер асинхронные и неблокирующие запросы (методом POST), которые гарантированно завершаются до выгрузки страницы. Используется для логгирования активности пользователей или отправки аналитических данных на сервер.

`navigator.sendBeacon("<url>"[, <data>])` - отправляет на указанный url `<url>` данные [с указанным телом `<data>`] и возвращает `true` если данные были поставленны в очередь для передачи.

Performance API
===============

Используется для высокоточного вычисления производительности.

`const <time> = performance.now();` - возвращает отметку высокоточную отметку времени в виде числа.

jQuery
======

Добавление jQuery на страницы:

```html
<script type="text/javascript" src="jquery.min.js"></script>
```

## Команды jQuery

`$()` - это синоним для `jQuery()`.
`$('<селектор>')` - возвращает jQuery выборку элементов. Может принимать также стандартные элементы JS и `this`. Ее принято начинать именовать с `$`. Знак `$` сообщает, что символы идущие после него являются jQuery кодом;

Селектор позволяет выбрать элемент на странице, должен быть похожим на селектор CSS и позволяет указать дополнительные комманды:
- `:first` - первый элемент;
- `:last` - последний элемент;
- `:even` - все элементы списка с четными индексами;
- `:odd` - все элементы с нечетными индексами;
- `:eq(<номер>)` - элемент списка с указаным индексом, нумерация начинается с 0, если индекс меньше нуля, то с конца;
- `:gt(<номер>)` - все элементы списка, которые больше по индексу указанного, нумерация начинается с 0;
- `:lt(<номер>)` - все элементы списка, которые меньше по индексу указанного, нумерация начинается с 0;
- `:animated` - все анимированные элементы;
- `:contains('<строка>')` - все элементы содержащиеуказанную строку;
- `:empty` - все элементы не имеющие узлов потомков;
- `:hidden`- все скрытые элементы;
- `:visible` - все видимые элементы.

Стандартный синтаксис jQuery команд:  
`$('<селектор>').<метод>();`

Метод задает действие, которое необходимо совершить над выбранным элементом, подразделяются на следующие группы:
- методы для манипулирования DOM;
- методы для оформления элементов;
- методы для создания AJAX запросов;
- методы для создания эффектов;
- методы для привязки обработчиков событий.

### Загрузка кода после загрузки страницы

Для этого можно использовать один из вариантов:
- `$(document).ready(function () {<код>});`;
- `$().ready(function () {<код>});`;
- `$(function () {<код>});`.

### Цепочки команд

Можно соединять команды jQuery в цепочки, если они возвращают jQuery выборку элементов. Команды в цепочке будут выполняться поочередно слева направо.

`$('<селектор>').<метод1>()[.<метод2>()[....]];`

### Перебор выборки всех элементов

`<$_выборка>.each(function ([index[, element]]) {...})` - вызывает указанную функцию для каждого элемента в выборке, где `this` в контексте функции это элемент [`index` номер элемента в выборке [`element` сам элемент]], если функция возвратит `false`, то прервется цикл по элементам выборки.

## Методы навигации по DOM

`<$_выборка>.find('<селектор>')` - возвращает jQuery выборку элементов, которые выбраны по указанному селектору с указанной выборки.  
`<$_выборка>.closest('<селектор>')` - возвращает выборку из элементов для каждого текущего элемента обходя вверх по DOM дереву, до тех пор пок не найдет первое совпадение для заданного селектора.

`<$_выборка>.prev(['<селектор>'])` - возвращает выборку предыдущих элементов от текущих, [которые соответствуют указаному селектору].  
`<$_выборка>.next(['<селектор>'])` - возвращает выборку следующих элементов от текущих, [которые соответствуют указаному селектору].

`<$_выборка>.children(['<селектор>'])` - возвращает выборку всех детей текущих элементов, [которые соответствуют указаному селектору].  
`<$_выборка>.parent()` - возвращает выборку всех прямых родителей текущих элементов.  
`<$_выборка>.parents(['<селектор>']) `- возвращает выборку всех родителей текущих элементов, [которые соответствуют указаному селектору].

`<$_выборка>.filter('<селектор>')` - возвращает выборку из всех элементов, которые соответствуют указаному селектору.

`<$_выборка>.eq(<номер>)` - возвращает указанный `<номер>` элемента в выборке.  
`<$_выборка>.get(<номер>)` - возвращает указанный `<номер>` элемента в выборке в виде стандартного элемента.  
`<$_выборка>.get()` - возвращает все элементы выборки как массив в виде стандартных элементов.

`<$_выборка>.add({'<селектор>' | <$_выборка>})` - возвращает новую выборку с добавленными элементами.

`<$_выборка>.end()` - возвращает предыдущую выборку по стеку выборок.

## Атрибуты элементов и CSS

### CSS свойства

`<$_выборка>.css('<свойство>')` - получение значения CSS свойства, возвращает текущее значение, а не прописанное в CSS файле.  
`<$_выборка>.css('<свойство>', <значение>)` - установка значения CSS свойства.  
`<$_выборка>.css({'<свойство1>': <значение>[, ...]})` - установка нескольких значений CSS свойств через структуру.  
`<$_выборка>.css('<свойство>', function (index, value) {return <новое_значение>})` - для установки значения используется функция обратного вызова,где `index` это порядковый номер элемента в выборке, `value` - старое значение свойства. Должна возвращать новое значение.

### CSS классы

`<$_выборка>.addClass('<имя_класса>')` - добавление класса элементу.  
`<$_выборка>.addClass(function (index, classList) {return '<имя_класса>'})` - добавление класса используя функцию обратного вызова, `classList` - список классов у элемента.  
`<$_выборка>.hasClass('<имя_класса>')` - проверка на причастность к определенному классу.  
`<$_выборка>.removeClass('<имя_класса>')` - удаление класса.  
`<$_выборка>.removeClass(function (index, classList) {return '<имя_класса>'})` - удаление класса используя функцию обратного вызова.  
`<$_выборка>.toggleClass('<имя_класса>')` - переключение класса.  
`<$_выборка>.toggleClass('<имя_класса>', <switch>)` - переключение класса по флагу `<switch>`, если равно `true`, то он добавиться, при `false` - удалиться.  
`<$_выборка>.toggleClass(function (index, classList, switch) {return '<имя_класса>'}, <switch>)` - переключение класса используя функцию обратного вызова.

В приведенных функциях в качестве `<имя_класса>` может быть строка содержащая список классов через пробел.

### Атрибуты

Атрибуты - это все то, что находится внутри самого тега.

`<$_выборка>.attr('<имя_атрибута>')` - получение значения атрибута.  
`<$_выборка>.attr('<имя_атрибута>', <значение_атрибута>)` - установка значения атрибута (также можно использовать объект, либо функцию обратного вызова, как у CSS свойств).  
`<$_выборка>.removeAttr('<имя_атрибута>')` - удаление атрибута.

### data-атрибуты

`<$_выборка>.data()` - возвращает объект со всеми ключами и значениями из реестра данных.  
`<$_выборка>.data('<ключ>')` - получение значения ключа из реестра данных, если его там нет то возвращается из атрибута тега `data-<ключ>`.  
`<$_выборка>.data('<ключ>', <значение>)` - установка значения ключа.  
`<$_выборка>.data({'<ключ1>': <значение>[, ...]})` - установка нескольких значений ключей через структуру.  
`<$_выборка>.removeData('<ключ>')` - удаление ключа из реестра данных.

### Свойства элементов

К ним относится `selectedIndex`, `checked`, `selected`, `tagName`, `nodeName`, `nodeType`, `ownerDocument`, `defaultChecked` и `defaultSelected`.

`<$_выборка>.prop('<имя_свойства>')` - получение значения свойства.  
`<$_выборка>.prop('<имя_свойства>', <значение_свойства>)` - установка значения свойства (также можно использовать объект, либо функцию обратного вызова, как у CSS свойств).  
`<$_выборка>.removeProp('<имя_свойства>')` - удаление свойства.

## События

Основные события JavaScript:
- `change` - изменение значения элемента (значение, при потери фокуса, элемента отличается от изначального, при получении фокуса);
- `click` - клик по элементу (порядок событий: `mousedown`, `mouseup`, `click`);
- `dblclick` - двойной щелчок мышки;
- `resize` - изменение размеров элементов;
- `scroll` - скроллинг элемента;
- `select` - выбор текста (только для `input[type=text]` и `textarea`);
- `submit` - отправка формы;
- `focus` - фокус на элементе;
- `blur` - фокус ушел с элемента;
- `focusin` - фокус на элементе, данное событие срабатывает на предке элемента, для которого произошло событие `focus`;
- `focusout` - фокус ушел с элемента, данное событие срабатывает на предке элемента, для которого произошло событие `blur`;
- `keydown` - нажатие клавиши на клавиатуре;
- `keypress` - нажатие клавиши на клавиатуре (`keydown` -> `keypress` -> `keyup`);
- `keyup` - отжатие клавиши на клавиатуре;
- `load` - загрузка элемента;
- `unload` - выгрузка элемента;
- `mousedown` - нажатие клавиши мыши;
- `mouseup` - отжатие клавиши мыши;
- `mousemove` - движение курсора;
- `mouseenter` - наведение курсора на элемент, не срабатывает при переходе фокуса на дочерние элементы;
- `mouseleave` - вывод курсора из элемента, не срабатывает при переходе фокуса на дочерние элементы;
- `mouseover` - наведение курсора на элемент;
- `mouseout` - вывод курсора из элемента.

Методы для работы с событиями:  
`<$_выборка>.<событие>()` - вызов события на элементах выборки.

Установка обработчика события:

```javascript
<$_выборка>.<событие>(function (event) {
    ...
    event.stopImmediatePropagation() //останавливает цепочку вызова событий для последующих слушателей DOM элемента, то есть события оставшихся слушателей вызваны не будут

    event.preventDefault(); //отменяет стандартное действие
    event.stopPropagation(); //отменяет всплытие события
    return false; //совмещает две предыдущие инструкции
});
```

`<$_выборка>.on('<событие>'[, '<селектор>'][, <данные>], function (event) {...})` - установка обработчика события (`'<событие>'` - может быть списком событий разделенных пробелом: `'<событие1>[ <событие2>[ ...]]'`) для элементов (аналогично `addEventListener`) [динамически для указанных `<селектор>` внутри элементов выборки, при условии что к ним будет относиться событие] [где `<данные>` будут доступны в `event.data`, когда событие вызовется].  
`<$_выборка>.off('<событие>'[, '<селектор>'][, <функция_обработчика>])` - удаления обработчиков события на элементах.

`<$_выборка>.trigger('<событие>'[, <данные>])` - вызов указаного события [где `<данные>` должны быть массивом или объектом и они перададутся в функцию обработки как дополнительные параметры].

`<$_выборка>.bind('<событие>'[, <данные>], function (event) {...})` - привязывает функцию обработчик к событию.  
`<$_выборка>.unbind(['<событие>'])` - удаления обработчиков события на элементах.

Можно повесить обработчик событий практически на любой объект.

### Пространство имен

Задаются как дополнение к `'<событие>'` после точки `.`:  
`'<событие>.<пространство_имен>'`

Могут использоваться для вызова обработчиков:  
`'<событие>.<пространство_имен>[.<пространство_имен>[...]]'`

Можно удалить все обработчики с определенного пространства имен:  
`'.<пространство_имен>'`

## Анимация

`<$_выборка>.hide([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - скрывает элементы, оперирует лишь CSS атрибутом `display`, переключая его из текущего состояния в `none`[, оперирует `width`, `height`, `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`) [и вызывает указаную функцию после завершения анимации]].  
`<$_выборка>.show([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - показывает элементы.  
`<$_выборка>.toggle([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - работает как переключатель `hide` -> `show` или `show` -> `hide`.  
`<$_выборка>.toggle({true | false})` - отображает элемент при `true`, скрывает при `false`.

Функции анимации из семейства `slide` - оперирует `height`, `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`, по ум. = `200`):  
`<$_выборка>.slideUp([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - скрывает.  
`<$_выборка>.slideDown([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - показывает.  
`<$_выборка>.slideToggle([{'slow' | 'fast' | <количество_мс>}[, function () {..}]])` - скрывает или показывает в зависимости от состояния.

Функции анимации из семейства `fade` - оперирует `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`, по ум. = `200`):  
`<$_выборка>.fadeIn([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - изменяет `opacity` от `0` до предыдущего.  
`<$_выборка>.fadeOut([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - изменяет `opacity` от текущего до `0`.  
`<$_выборка>.fadeToggle([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - переключатель между `In` и `Out`.  
`<$_выборка>.fadeTo([{{'slow' | 'fast' | <количество_мс>}, <прозрачность>[, function () {...}]])` - изменяет значение `opacity` до требуемого значения.

### `animate`

Данная функция берет один или несколько CSS-свойств элемента и изменяет их от исходного до заданного за N-ое количество итераций (количество итераций зависит от указанного времени, но не реже одной итерации в 13мс).

```javascript
<$_выборка>.animate({
        '<свойство1>': <значение>, //изменяет текущее значение до указаного
        '<свойство2>': {'show' | 'hide' | 'toggle'}, //изменяет текущее значение по указаной схеме
        '<свойство3>': {+=<значение> | -=<значение>} //изменяет на указаное значение
        [, ...]
    },
    {'slow' | 'fast' | <количество_мс>} //скоростью изменения
    [, {'linear' | 'swing'} //функция для изменения значений процесса анимации
    [, function () {...}]] //функция обратного вызова после завершения анимации
)
```

Второй вариант:  
`<$_выборка>.animate(<CSS_свойства>, <опции>)`, где у опции может быть:
- `duration` - скоростью изменения - `'slow'` | `'fast'` | `<количество_мс>`;
- `easing` - функция для изменения значений процесса анимации: `'linear'` | `'swing'`;
- `complete` - функция обратного вызова после завершения анимации: `function () {...}`;
- `step` - функция, которая будет вызвана на каждом шаге анимации: `function (now, obj) {...}`. Где у `obj` имеются свойства:
    - `elem` - объект анимации;
    - `prop` - параметр, который анимируется;
    - `start` - начальное значение;
    - `end` - конечное значение;
    - `pos` - коэффициент, изменяется от 0 до 1;
    - `options` - опции настроек анимации.
    `now` - текущее значение анимированного параметра, вычисляется как: `now = (obj.end - obj.start) * obj.pos`;
- `queue` - флаг/параметр очереди, при значении строки равной `<имя_очереди_анимации>`, то укажет имя очереди анимации и автоматомически при это не стартует, при значении `false` анимации будут выполняться параллельно;
- `specialEasing` - объект в котором можно описать какую именно `easing` функцию следует использовать для изменения определенных параметров.

Если `animate` указывать за `animate`, то будет выполняться последовательный вызов анимаций, сразу после завершения предыдущей.

`$('html').animate({scrollTop: $('.class').offset().top})`

`<$_выборка>.dequeue(<имя_очереди_анимации>)` - запускает указаную очередь анимации.

#### Остановка анимации

`<$_выборка>.stop([<имя_очереди_анимации>, ][<очистка_очереди>[, <применение_результата>]])` - останавливает анимацию [указанной очереди, по ум `'fx'`] [с очищением очереди всех последующих анимаций, если `true` [и применением результата анимации, если `true`]].

`jQuery.fx.off = true;` - отключает всю анимацию

## Манипуляции с DOM

### Создания элементов

`$('<<имя_тега>>'[, <объект_атрибутов_элемента>])` - создает jQuery элемент.

### Перемещение элементов

`<$_выборка>.after('<контент>')` - вставляет контент после каждого элемента из выборки.  
`<$_выборка>.insertAfter({'<селектор>' | <элементы>})` - вставляет элементы из выборки после каждого элемента переданного в качестве аргумента.  
`<$_выборка>.before('<контент>')` - вставляет контент перед каждым выбранным элементом.  
`<$_выборка>.insertBefore({'<селектор>' | <элементы>})` - вставляет элементы из выборки перед каждым элементом переданным в качестве аргумента.

`<$_выборка>.append('<контент>')` - вставляет контент в конец каждого элемента из выборки.  
`<$_выборка>.appendTo({'<селектор>' | <элементы>}) `- вставляет выбранный контент в конец каждого элемента переданного в качестве аргумента.  
`<$_выборка>.prepend('<контент>')` - вставляет контент в начало каждого элемента из выборки.  
`<$_выборка>.prependTo({'<селектор>' | <элементы>})` - вставляет выбранный контент в начало каждого элемента переданного в качестве аргумента.

`<$_выборка>.replaceWith('<контент>')` - заменяет найденные элементы новым контентом.  
`<$_выборка>.replaceAll({'<селектор>' | <элементы>})` - вставляет элементы в замен найденному.

`<$_выборка>.wrap({'<селектор>' | <элементы>})` - оборачиваем каждый найденный элемент новым элементом.  
`<$_выборка>.wrapAll({'<селектор>' | <элементы>})` - оборачивает все найденные элементы новым элементом.  
`<$_выборка>.wrapInner({'<селектор>' | <элементы>})` - оборачивает контент каждого найденного элемента новым элементом, оставляя при этом элементы на своих местах.  
`<$_выборка>.unwrap()` - удаляет родительский элемент у найденных элементов.

`<$_выборка>.clone([true])` - клонирует выбранные элементы, для дальнейшей вставки копий назад в DOM, позволяет так же копировать и обработчики событий.

`<$_выборка>.detach()` - удаляет элемент из DOM, но при этом сохраняет все данные о нем в jQuery, используется, если надо удалить элемент, а потом вернуть его обратно.  
`<$_выборка>.empty()` - удаляет текст и дочерние DOM элементы.  
`<$_выборка>.remove()` - удаляет элемент из DOM, насовсем.

`<$_выборка>.html()` - возвращает HTML заданного элемента.  
`<$_выборка>.html(<html>)` - заменяет HTML в заданном элементе.  
`<$_выборка>.text()` - возвращает текст заданного элемента, если внутри элемента будут другие HTML тэги, то вернется текст всех элементов.  
`<$_выборка>.text(<text>)` - заменяет текст внутри выбранных элементов, при попытке вставить таким образом HTML, будет получен текст, где тэги будут приведены к `HTML entities`.

### Размеры элементов

`<$_выборка>.offset()` - возвращает позицию DOM элемента относительно `document`'а, данные будут получены в виде объекта: `{top: <поз_сверху>, left: <поз_слева>}`.  
`<$_выборка>.offset({top: <поз_сверху>, left: <поз_слева>})` - устанавливает расположение DOM элемента по указанным координатам.

`<$_выборка>.position()` - возвращает позицию DOM элемента относительно родительского элемента.

`<$_выборка>.height([<высота>])` - возвращает высоту элемента за вычетом отступов и границ; если у нас несколько элементов в выборке, возвратит первое; значение, в отличии от метода `css('height')`, возвращается без указания единиц измерения [, устанавливает высоту всех элементов в выборке, если значение высоты передано без указания единиц измерения, то это будут "px"].  
`$(window).height()` - высота окна.  
`$(document).height()` - высота HTML документа.  
`<$_выборка>.width([<ширина>])` - возвращает ширину элемента [, устанавливает ширину всех элементов в выборке].  
Методы `height()` и `width()` не изменяют своего поведения в зависимости от выбранной блочной модели, т.е. они всегда возвращают параметры области внутри `margin`, `padding` и `border`'а элемента.

`<$_выборка>.innerHeight()` и `<$_выборка>.innerWidth()` - возвращают высоту и ширину элемента, включая `padding`.  
`<$_выборка>.outerHeight([true])` и `<$_выборка>.outerWidth([true])` - возвращают высоту и ширину элемента, включая `padding`, `border` [и `margin`].

### Прокрутка

`<$_выборка>.scrollLeft([<значение>])` - возвращает значение "проскроленности" по горизонтали первого элемента из выборки [, устанавливает значение горизонтального скрола для каждого элемента из выборки].  
`<$_выборка>.scrollTop([<значение>])` - возвращает значение "проскроленности" по вертикали первого элемента из выборки [, устанавливает значение вертикального скрола для каждого элемента из выборки]

Значение `"scrollTop"` и `"scrollLeft"` поддаются анимации и не работают для спрятанных элементов DOM.

## Работа с формами

`<$_выборка>.serialize()` - возвращает данные с формы в виде строки: `<name>=<value>[&...]`.  
`<$_выборка>.serializeArray()` - возвращает данные с формы в виде массива объектов.

## AJAX

`<$_выборка>.load("<url>"[, <данные>][, function (<строка_ответа>, <текст_статуса>, <jqXHR>) {...}])` - загружает данные с указанного адреса [, передавая дополнительные данные] в элемент [и вызывая после этого функцию обратного вызова].

`$.ajax(<опции>)` - где `<опции>` - объект со свойствами:
- `url` - в виде `"<url>"` - адрес запроса;
- `method` - метод запроса, один из `"POST"` | `"GET"` | `"PUT"`;
- `dataType` - тип загружаемых данных, один из `"html"` | `"xml"` | `"text"` | `"json"` | `"script"` | `"jsonp"`;
- `success` - функция вызова при удачном запросе: `function (data) {...}`, где `data` - пришедшие данные в указаном формате;
- `data` - данные для передачи, должны быть в виде массива, объекта или строки;
- `error` - возникает в случае ошибки: `function (error) {...}`, где `error` - ошибка.

События AJAX для элементов, для которых можно установить обработчики в объекте `<опции>`:
- `ajaxStart` - данное событие возникает в случае когда начался первый AJAX запрос, и при этом других активных AJAX запросов в данный момент нет;
- `beforeSend` - возникает до отправки запроса, позволяет редактировать `XMLHttpRequest`, локальное событие;
- `ajaxSend` - возникает до отправки запроса, аналогично `beforeSend`;
- `success` - возникает по возвращению ответа, когда нет ошибок ни сервера, ни вернувшихся данных, локальное событие;
- `ajaxSuccess` - возникает по возвращению ответа, аналогично `success`;
- `error` - возникает в случае ошибки, локальное событие;
- `ajaxError` - возникает в случае ошибки;
- `complete` - возникает по завершению текущего AJAX запроса (с ошибкой или без - срабатывает всегда), локальное событие;
- `ajaxComplete` - глобальное событие, аналогичное `complete`;
- `ajaxStop` - данное событие возникает в случае, когда больше нету активных запросов.

Эти имена событий могут использоваться в `$.ajax`, тогда они будут глобальными.

### Префильтры

**Префильтр** - это функция, которая будет вызвана до `ajaxStart`, в можно изменить как объект `jqXHR`, так и любые сопутствующие настройки.

`$.ajaxPrefilter(['<типы_возвращаемых_ajax_данных>',] function (options, originalOptions, jqXHR) {...});`. Где:
- `options` - настройки запроса (то что указывается при вызове "$.ajax()");
- `originalOptions` - "чистые" настройки, даже без учета изменений "по умолчанию";
- `jqXHR` - объект "jQuery XMLHttpRequest".

Их можно использовать для кэшрования результата или перенаправлении запросов на другой адрес.

### Конвертеры

**Конвертор** - функция обратного вызова, которая вызывается в том случае, когда полученный типа данных не совпадает с ожидаемым.

`$.ajaxSetup({converters: <конвертеры>})` - где `<конвертеры>` - объект, который должен содержать свойства в указаном формате:  
`"{<входящий_тип> | *} <тип_преобразования>": function (textValue) {... return <newValue>}` - должна возвращать значение в типе преобразования или бросать исключение.

### Транспорт

**Транспорт** - это объект, который предоставляет два метода - `send()` при отправке и `abort()` при отмене - они будут использоваться внутри метода `$.ajax()`.

`$.ajaxTransport(['<типы_возвращаемых_ajax_данных>',] function (options, originalOptions, jqXHR) {...})`, где тело функции может быть:

```javascript
if (<необходим_транспорт>) {
    return {
        send: function (headers //заголовки запроса в виде связки ключ-значение
            , function (status //HTTP статус ответа
                , statusText //текстовая интерпретация ответа
                , responses //объект содержащий ответы сервера во всех форматах, которые поддерживает транспорт
                , headers //строка содержащие заголовки ответа сервера, если конечно транспорт может их получить
            ) {...} /// функция обратного вызова, используется для оповещения о завершении запроса
        ) {...},
        abort: function () {...}
    };
}
```

## Объект `Deferred` и подобные

`Deferred` используется чтобы заставлять асинхронный JavaScript работать синхронно.

`var <Deferred> = $.Deferred()` - инициализация `Deferred` объекта со статусом "ожидает выполнение".

`<Deferred>.done(function (data) {...}[, ...])` - добавление одного обработчика для успеха, где `data` - данные, которые были переданы с помощью метода `<Deferred>.resolve(<данные>)`, возвращает самого себя - `<Deferred>`.  
`<Deferred>.fail(function (error) {...}[, ...])` - добавление одного обработчика для ошибки, где `error` - данные, которые были переданы с помощью метода `<Deferred>.reject(<данные>)`, возвращает самого себя - `<Deferred>`.  
`<Deferred>.always(function (data) {...}[, ...])` - добавление одного обработчика для любого исхода, возвращает самого себя - `<Deferred>`.  
`<Deferred>.then(function (data) {...}, function (error) {...})` - добавление одного обработчика для успеха и для ошибки, возвращает самого себя - `<Deferred>`.

`<Deferred>.resolve([<данные>])` - изменения статуса на "выполнен успешно" и вызов всех обработчиков для успеха в порядки очереди, но они будут выполняться параллелено.  
`<Deferred>.reject([<ошибка>])` - изменения статуса на "выполнен с ошибкой" и вызов всех обработчиков для ошибки.

Если будут подключены обработчики после вызова метода который меняет статус, то он сразу выполнится.

`<Deferred>.promise()` - возвращает искомый объект в режиме "read only".

`$.when(<Deferred>[, ...])` - реализует интерфейс `Deferred`, возвращает проекцию `Deferred` объекта, принимает в качестве параметров произвольное множество `Deferred` объектов, когда все из них отработают, объект `when` изменит свое состояние в "выполнено", с последующим вызовом всех подписавшихся.

Также методы `ajax()` и `animate()` реализуют интерфейс `Deferred`.

### Методы уведомлений

`<Deferred>.progress(function (data) {...}[, ...])` - регистрирует функцию для получения уведомлений.  
`<Deferred>.notify([<данные>])` - посылает уведомления во все зарегистрированные функции, т.е вызывает их [и передает в них указанные данные].

## `Callbacks`

`Callbacks` - позволяет составлять списки функций обратного вызова и вызывать их всех по надобности.

`var <Callbacks> = $.Callbacks([<флаги>])` - где `<флаги>` могут быть:
- `'once'` - все функции будут вызваны единожды (аналогично как в Deferred);
- `'memory'` - сохранять значение с последнего вызова `fire()`, и передача его в ново-зарегистрированные функции обратного вызова, и лишь потом обрабатывает новое значение (как в `Deferred`);
- `'unique'` - список функций обратного вызова фильтруется по уникальности;
- `'stopOnFalse'` - как только какая-нить функция вернет `false`, процесс запуска остановится.

`<Callbacks>.add(function (data) {...}[, ...])` - регистрирует функцию обратного вызова.  
`<Callbacks>.fire([<данные_для_функций>])` - вызывает все зарегистрированные функции обратного вызова в порядке их добавления.

## Дополнительные методы

`$.extend([true, ]{{} | <object1>}[, <object2>[, ...]])` - сливает содержимое двух и более объектов в первый и возвращает его [и включая вложенные объекты].

## jQuery плагин

`$.fn.<имя_плагина> = function (params) {...}` - объявление плагина, при этом `this` содержит jQuery объект с коллекцией всех элементов, а `params` - объект параметров инициализации, используется такая схема объявления плагина:

```javascript
(function ($) {
    var defaults = {'<параметр1>': <значение>[, ...]}; //параметры по умолчанию
    var options; //актуальные настройки, глобальные
    $.fn.<имя_плагина> = function (params) {
        options = $.extend({}, defaults, options, params); //при многократном вызове настройки будут сохранятся и замещаться при необходимости
        ...
        return this;
    };
})(jQuery);
```

`<$_выборка>.<имя_плагина>([<объект_параметров_инициализации>])` - создание плагина.

### Публичные методы

Методы объявляются в отдельном объекте, где **ключ** - это названия метода, а его **значение** - это реализация метода.

Для использования метода необходимо изменить функцию инициализатор плагина, при таком подходе будет происходить вызов метода, если он есть, со всем списком аргументов, иначе будет выполняться инициализация:

```javascript
    var methods = {...}; //описание методов.
    $.fn.<имя_плагина> = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else {
            ...//метод инициализации
        }
        ...
    }
```

`<$_выборка>.<имя_плагина>([<имя_метода>][, <аргум1>[, ...]])` - вызов метода.

Если плагин вешает какой-либо обработчик, то лучше всего всегда данный обработчик повесить в своем собственном пространстве имен `namespace`.

Webpack
=======

`npm i -g webpack` - инсталляция.  
`npm i webpack` - инсталляция локальная, для установки всех дополнительных модулей.

## Включение зависимостей

Базовая конфигурация представляет собой импорт и экспорт как в NodeJs. Для включения файла в файл необходимо написать:  
`var <модуль> = require('<имя_файла>');`

### Сборка

`webpack <имя_входного_файла> <имя_выходного_файла>` - запуск, - эта команда скомпилирует модуль `<имя_входного_файла>` и соберет все необходимые зависимости в один файл `<имя_выходного_файла>`, готовый к использованию в браузере.

Параметр `--watch` позволяет Webpack наблюдать за файлами от которых зависит модуль и пересобирать модуль по мере изменения файлов.

## Конфигурация

В файле `webpack.config.js` помещается код, внутри можно использовать любой код из NodeJs или Js. Это - модуль, экспортирующий объект конфигурации, который читает Webpack при вызове его из командной строки без аргументов. Сам конфигурационный модуль должен экспортировать объект опций:  
`module.exports = <объект_опций>;`

`const NODE_ENV = process.env.NODE_ENV || 'developer';` - позволяет взять переменную окружения, для дальнейшего использования в конфигурирование.

`const webpack = require('webpack');` - используется для установки плагинов

`webpack` - запуск, с использованием файла `webpack.config.js`.

Пример использования библиотек:  
`npm install jquery` - установка.  
`const $ = require('jquery');` - подключение и использование.

## Свойства

Пример конфигурации:

```javascript
const path = require('path');

module.exports = {
    entry: path.join(__dirname, "src", "main.js"),
    output: {
        path: path.join(__dirname, "dist"),
        filename: "bundle.js"
    },
    module: {
        loaders: [
            {
                test: path.join(__dirname, "src"),
                loader: 'babel-loader',
                query: {
                    presets: ['es2015']
                }
            }
        ]
    },
    plugins: [definePlugin, uglifyJsPlugin]
};
```

Основные свойства:
- `entry` - отвечает за входной файл, точку входа, задается в виде `"<путь_к_модулю>"`;
- `context` - означает базовое нахождение модулей (для точки входа, `entry`), задается в виде `"<путь_к_модулям>"`;
- `output` - отвечает за выходной файл, задается в виде объекта со свойствами:
    - `filename` - имя выходного файла, задается в виде `"<имя_конечного_файла>"`;
    - `path` - путь к каталогу выходного файла, задается в виде `"<путь>"`;
    - `library` - в этот объект поместится все то что экспортируется из входного файла (для точки входа, `entry`): `exports.<имя> = <значение>`, и тогда онобудет доступно как `<имя_библиотеки>.<имя>`, задается в виде `"<имя_библиотеки>"`;
- `module` - отвечает за утилиты для сборки, задается в виде объекта со свойствами:
    - `loaders` - массив загрузчиков, каждый из которых выполняет конкретное преобразование, задается в виде массива, который содержит объекты определенной структуры:
        - `test` - маска соответствия загрузчику, задается в виде строки или регулярного выражения;
        - `include` - включает только файлы, которые соответствуют указанному пути, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
        - `exclude` - исключает файлы, которые соответствуют указанному пути, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
        - `loader` - имя загрузчика, задается в виде `"<имя_модуля>"`;
    - `noParse` - используется для исключения файлов из обработки, которые соответствуют указаным маскам, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
- `plugins` - отвечает за плагины, задается в виде массива, который содержит объекты плагинов;
- `watch` - указывает при значении `true` что нужно наблюдать за файлами и пересобирать их по их изменению (сохранению), после этого `webpack` будет запущен и наблюдать за файлами;
- `watchOptions` - отвечает за опции наблюдения, задается в виде объекта со свойствами:
    - `aggregateTimeout` - указывает время ожидания для пересборки в мс (по ум. 300), задается в виде числа `<время_мс>`;
- `devtool` - отвечает за "карту модулей" в файле `<имя_конечного_файла>.map` для удобной отладки по модулям, задается в виде одного из значений: `"source-map"`, `"cheap-source-map"`, `"cheap-module-eval-source-map"`;
- `resolve` - используется для поиска входных модулей, задается в виде объекта со свойствами:
    - `modules` - отвечает за каталоги поиска, задается в виде массива, должен включать `"node_modules"`;
    - `extensions` - отвечает за расширения файлов, задается в виде массива, должен включать `""`;
    - `root` - отвечает за дополнительный, корневой каталог поиска модулей;
    - `alias` - используется для указания алиасов путям подключения файлов, задается в виде объекта, где ключ - это алиас, а значение - это путь к модулю.

### Плагины

Плагины можно повторять.

#### Плагин `webpack.EnviromentPlugin`

Позволяет в скрипты передавать значения переменных окружения, и тогда их можно использовать как: `process.env.<имя_переменной_окружения>`.

`const EnviromentPlugin = new webpack.EnviromentPlugin('<имя_переменной_окружения>'[, ...]);`.

#### Плагин `webpack.DefinePlugin`

Позволяет заменить отдельные фрагменты исходного кода динамическим кодом или постоянными значениями.

`const definePlugin = new webpack.DefinePlugin(<объект_замен>);` - где `<объект_замен>` - представляет собой объект, где ключи - это то что нужно заменить, а значение - это то на что нужно заменить.

#### Плагин ` webpack.optimize.UglifyJsPlugin`

Применяется для обфускации и минификации JavaScript-кода в файле пакета с помощью `UglifyJs`.

`const uglifyJsPlugin = new webpack.optimize.UglifyJsPlugin(<объект_опций>);` - где `<объект_опций>` - представляет собой объект с опциями и свойствами:
- `beautify` - при значении `true` помогает избежать удаления всех отступов и пробельных символов, чтобы проще было читать получившийся файл пакета, по умолчанию `false`;
- `dead_code` - при значении `true`, удаляет все, что сочтет "мертвым кодом", поэтому текущий код чистится, по умолчанию `false`;
- `compress` - отвечает за сжатие, представляет собой объект с опциями и свойствами:
    - `warnings` - при значении `true` убирает предупреждения, по умолчанию `false`;
    - `drop_console` - при значении `true` убирает вывод в консоль, по умолчанию `false`;
    - `unsafe` - при значении `true` позволяет использовать не безопасные возможности во время сжатия, по умолчанию `false`.

#### Плагин `webpack.NormalModuleReplacementPlugin`

Позволяет заменять ресурсы, которые соответствуют регулярному выражению другим ресурсом.

`const NormalModuleReplacementPlugin = new webpack.NormalModuleReplacementPlugin(/<рег_выражение_поиска>/, "<путь_к_ресурсу>");` - если ресурс соответствует регулярному выражению `/<рег_выражение_поиска>/`, он заменяется ресурсом, указанным в `"<путь_к_ресурсу>"`.

#### Плагин `webpack.NoErrorsPlugin`

Позволяет не собирать сборку, если есть какая-то ошибка в сборке.

`const NoErrorsPlugin = new webpack.NoErrorsPlugin();`.

#### Плагин `webpack.CommonsChunkPlugin`

Позволяет вынести общую часть из всех модулей в один файл. Также можно объявить в `entry`: `"common": "<путь_к_общему_модулю>"`. Тогда в файл внесется и еще указанный модуль.

`const CommonsChunkPlugin = new webpack.CommonsChunkPlugin(<объект_опций>);` - где `<объект_опций>` - представляет собой объект с опциями и свойствами:
- `name` - имя общего файла;
- `minChunks` - минимальное количество файлов использования общей части, по умолчанию все, задается в виде числа.

Пример тестирования
===================

```html
Пример HTML-страницы для тестов:
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- подключаем стили Mocha, для отображения результатов -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">
    <!-- подключаем библиотеку Mocha -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"></script>
    <!-- настраиваем Mocha: предстоит BDD-тестирование -->
    <script>
        mocha.setup('bdd');
    </script>
    <!-- подключаем chai -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"></script>
    <!-- в chai есть много всего, выносим assert в глобальную область -->
    <script>
        var assert = chai.assert;
    </script>
</head>

<body>
    <script>
    function <тестируемая_функция>(...) {
        /* код функции, пока что пусто */
    }
    </script>

    <!-- в этом скрипте находятся специализации -->
    <script src="test.js"></script>

    <!-- в элементе с id="mocha" будут результаты тестов -->
    <div id="mocha"></div>

    <!-- запустить тесты! -->
    <script>
        mocha.run();
    </script>
</body>
</html>
```

Страницу можно условно разделить на четыре части:
- **блок `<head>`** - в нем подключаются библиотеки и стили для тестирования, кода там нет;
- **блок `<script>`** с реализацией спецификации, с кодом тестируемых функций;
- далее подключаются тесты, файл `test.js` содержит `describe("<имя_тестируемой_функции>", ...)`, для тестирования функций. Методы `describe` и `it` принадлежат библиотеке Mocha;
- элемент `<div id="mocha">` будет использоваться библиотекой Mocha для вывода результатов. Запуск тестов инициируется командой `mocha.run()`.
