Node.JS
=======

Представляет собой язык JS на сервере.

## Запуск

`node <файл входа>.js`

## Модули

### Базовая настройка

`var <модуль> = require("<имя_модуля>");` - происходит подключения файла с модулем `<имя_модуля>` (можно указывать или не указывать расширение файла), которое сначала ищет в текущей директории с расширением `js`, `json`, а затем если не находит, то в папке с именем модуля в файле `index`, которая будет главной точной входа в модуль, то есть объект `exports` модуля станет равен `<модуль>`.

### Экспорт функций модуля

`exports.<имя_экспорта> = <экспортируемый_объект>;`

Объект `exports` доступен в любом модуле и возвращается при каждом вызове функции `require` при подключении модуля.

`global.<имя_экспорта> = <экспортируемый_объект>;` - подключение объекта в глобальную область видимости, то есть теперь не нужно использовать объект модуля.

`module` - главный объект модуля, который доступен в модуле.  
`module.parent` - информация о том, кто подключает текущий модуль.  
`module.exports` - ссылка на `exports`.  
`module.exports = <функция>;` - экспорт только единственной функции, подходит для конструктора.

`node_modules` - используется как базовая директория для модулей, для текущего проекта, там будут искаться подключаемые модули по базовому названию.

Модуль кэшируется, то есть инициализируется один раз, при множественном подключении.

## Функции обратного вызова (callback)

Если функция должна принимать **callback** функцию, то она должна принимать ее **последним параметром**.

Если *callback** функция должна принимать ошибку, то она должна принимать ее в качестве **первого параметра**.

Для того чтобы избежать двойного вызова функции обратного вызова, используется такая конструкция: `return callback(...)`.

Если функция принимает коллбек, то она не должна его вызывать сразу, а использовать для его вызова (в качестве обвертки): `setImmediate()` или `process.nextTick()`.

## Использование `EventEmitters`

Node.js реализует шаблон проектирования наблюдатель, используя класс `EventEmitter`. Всегда, когда есть объект, который является источником событий, Node.js наследует класс этого объекта от класса `EventEmitter`.

`const EventEmitter = require('events');`  
`const <eventEmitter> = new EventEmitter;`

`<eventEmitter>.on("<событие>", <функция_обработки>)` - связывает событие объекта с функцией обработки, которая будет вызвана при событии, добавляет в конец очереди обработчиков события, возвращает ссылку на объект `<eventEmitter>`, которому она принадлежит, что позволяет связывать в цепочки вызовов несколько прослушивателей событий.  
`<eventEmitter>.addListener("<событие>", <функция_обработки>)` - синоним `on`.  
`<eventEmitter>.once("<событие>", <функция_обработки>)` - аналогично предыдущей, только реагирует на первое возникновение события.  
`<eventEmitter>.prependListener("<событие>", <функция_обработки>)` - аналогично `on` только добавляет в начало очереди обработчиков события.  
`<eventEmitter>.prependOnceListener("<событие>", <функция_обработки>)` - аналогично `once` только добавляет в начало очереди обработчиков события.  

`<eventEmitter>.removeListener("<событие>", <функция_обработки>)` - удаляет функцию прослушивания с определенного события.
`<eventEmitter>.removeAllListeners("<событие>")` - удаляет всех обработчиков с определенного события.

`<eventEmitter>.emit("<событие>"[, <аргумент1>[, ...]])` - вызывает всех слушателей события по порядку подписки, с указанными аргументами.

`<eventEmitter>.listeners("<событие>")` - возвращает массив слушателей события данного типа.  
`<eventEmitter>.listenerCount("<событие>")` - возвращает количество слушателей события данного типа.  
`<eventEmitter>.setMaxListeners(<количество>)` - устанавливает количество разрешенных слушателей.

При создании генераторов событий применяется соглашение, что вместо непосредственного вызова ошибки можно генерировать событие `error`. Если не задан ни один слушатель для события этого типа, то в результате генерирования события типа `error` генератор событий выведет на экран трассировку стека и остановит выполнение программы. Трасса стека будет указывать на ошибку, тип которой определяется с помощью второго аргумента вызова `emit`. Подобное поведение присуще только событиям типа `error`.

`EventEmitter` должен использоваться вместо колбека, когда есть больше чем одно событие или событие вызывается множественное количество раз или когда необходимо подписавать множественное количество объектов.

### Комбинирование колбеков и `EventEmitter`

Иногда удобно комбинировать колбеки и `EventEmitter`. Для этого функция возвращает `EventEmitter` и принимает коллбек последним аргументом для основного события, если он есть, то использует его иначе `EventEmitter`.

## Ошибки

Реализуются и наследуются от стандартного класса `Error`. Необходимо переопределить свойства `name` и `message`.

`Error.captureStackTrace(this)`- производит захват стека, пишется внутри конструктора класса ошибки.

## Таймеры

Аналогично встроенным в браузер.

`var <timer> = setTimeout(<функция>, <задержка_мс>[, <аргумент1_для_функции>[, ...]])` - исполнение `<функция>` произойдёт спустя время, указанное в `<задержка_мс>`, возвращает таймер `<timer>`, который можно использовать для отмены действия.

`clearTimeout(<timer>)` - отменяет исполнение таймера.

`var <timer> = setInterval(<функция>, <задержка_мс>[, <аргумент1_для_функции>[, ...]])` - исполнение `<функция>` произойдёт спустя время, указанное в `<задержка_мс>`, а затем будет повторятся через каждые `<задержка_мс>`, возвращает таймер <`timer>`, который можно использовать для отмены действия.

`clearInterval(<timer>)` - отменяет исполнение интервала.

`<timer>.unref()` - означает что таймер служебный, то есть его можно завершить и он не будет препятствовать завершению процесса.  
`<timer>.ref()` - отменяет `unref`.

`process.nextTick(function () {...})` - запускает следующую функцию асинхронно, после завершения текущей итерации цикла событий, до начала следующей, до следующей операции ввода/вывода.

`setImmediate(function () {...})` - запускает следующую функцию асинхронно, на следующей итерации цикла событий, после операции ввода/вывода.

## Потоки

`var stream = require('stream');`

### `stream.Readable`

Может работать в двух режимах: в поточном режиме и в нее его (по умолчанию).

Необходимо придерживаться единого метода получения данных и не переключаться между ними.

`var <stream> = new stream.Readable([<опции>]);` - универсальный поток для чтения. Где опции - объект со свойствами:
- `encoding` - кодировка, по умолчанию `null`, задается в виде `"<кодировка>"`;
- `objectMode` - объектный режим если `true`, по умолчанию `false`;
- `highWaterMark` - максимальный размер буфера задается в виде `<размер_в_байтах>` или `<количество_объектов>`, по ум. 16KB или 16 объектов;
- `read` - представление внутреннего метода `_read`, в виде функции `<функция>`.

`var <stream> = <поток>;` - поток для чтения.

`<stream>.on('readable', function () {...});` - (не поточный режим) вызывается при считывании данных из потока.

`<stream>.read([<размер>])`; - возвращает часть считанных данных [указанного размера] из потока в виде строки, `Buffer`, а также `null`, если данных уже в буфере нет. Используется внутри функции события `'readable'`. Для считывания всего буфера используются такая конструкция:

```javascript
var chunk;
while((chunk = <stream>.read()) !== null) {
    ...
}
```

`<stream>.on('data', function (chunk) {...});` - (поточный режим) вызывается при считывании данных из потока, где `chunk` - это часть данных в виде строки, `Buffer` или другого типа, включает поточный режим.  
`<stream>.on('end', function () {...});` - вызывается при завершении считывания данных из потока.  
`<stream>.on('error', function (err) {...});` - вызывается при ошибке считывания данных из потока.  

`<stream>.pipe(<writable_stream>[, <опции>]);` - считывает часть данных из потока чтения в поток записи, возвращает переданный поток `<writable_stream>`, можно присоединять множественное число потоков записи [, где опции могут быть: `{end: false}` - тогда поток чтения, не вызывает автоматически событие `'end'` после завершения всего чтения].  
`<stream>.unpipe(<writable_stream>);` - отсоединяет поток записи, от потока чтения.

`<stream>.destroy();` - закрывает поток и вызывается событие `'error'`.

`<stream>.isPaused();` - возвращает `true`, если поток приостановлен.  
`<stream>.pause();` - приостанавливает поток, в это время он перестает генерировать события `'data'`.  
`<stream>.resume();` - возобновляет поток, включает поточный режим.

`<stream>.setEncoding("<кодировка>");` - устанавливает кодировку, возвращает `<stream>`.

`<stream>.unshift(<chunk>);` - записывает данные обратно в буфер потока, нельзя вызывать после события `'end'`.

#### Произвольный поток чтения

```javascript
function <Stream>() {
    stream.Readable.call(this, options);
}
util.inherits(<Stream>, stream.Readable);

<Stream>.prototype._read = function (size) {
    ...
    this.push(<chunk>[, "<кодировка>"]);
}
```

Создает новый класс, который наследуется от `stream.Readable`, `options` представляет собой объект конфигурации.

`_read` - переопределяет внутренюю функцию заполнения буфера потока, где `size` - предпочитаемый размер, будет вызываться при попытке чтения из потока, внутри этой функции нужно вызывать функцию для заполнения буфера данными:  
    `this.push(<chunk>[, "<кодировка>"]);` - записывает данные в буфер потока и если есть еще место в буфере (ограничено `highWaterMark`), то возвращает `true`, иначе `false`, для окончания передачи нужно передать `null`.

### `stream.Writable`

`var <stream> = new stream.Writable([<опции>]);` - универсальный поток для записи. Где `<опции>` - объект со свойствами:
- `decodeStrings` - автоматическая конвертация строк в буфер перед передачей их в метод `_write()` при значении `true`, по умолчанию `true`;
- `objectMode` - объектный режим при значении `true`, по умолчанию `false`;
- `highWaterMark` - максимальный размер буфера задается в виде `<размер_в_байтах>` или `<количество_объектов>`, по ум. 16KB или 16 объектов;
- `write` - представление внутреннего метода `_write`, в виде функции `<функция>`;
- `writev` - представление внутреннего метода `_writev`, в виде функции `<функция>`.

`var <stream> = <поток>;` - поток для записи.

`<stream>.setDefaultEncoding("<кодировка>");` - устанавливает кодировку по умолчанию, возвращает `<stream>`.

`<stream>.write(<data>[, "<кодировка>"][, function () {...}]);` - записывает данные в поток и если есть еще место в буфере, то возвращает `true`, иначе `false` [, вызывает коллбек, когда данные будут записаны]. Для записи большого куска данных в поток, которые больше размера буфера `highWaterMark`, используется такая конструкция:

```javascript
function generateMore() {
    var shouldContinue = <stream>.write(<data>);
    if (!shouldContinue) {
        return <stream>.once('drain', generateMore);
    }
    <stream>.end(<end_data>, function () {...});
}
generateMore();
```

`<stream>.cork();` - включает запись данных в память, а не в буфер, используется для избежания генерации событий вставки в буфер для множества маленьких данных.  
`<stream>.uncork();` - записывает все данные из памяти в буфер.

`<stream>.on('drain', function () {...});` - вызывается при завершении считывания данных из буфера потока.  
`<stream>.end([<data>][, "<кодировка>"][, function () {...}]);` - [записывает данные в поток и] финализирует поток.  
`<stream>.on('finish', function (err) {...});` - вызывается при завершении считывания данных из буфера потока и финализации потока, после вызова `<stream>.end([<data>])` у потока.  
`<stream>.on('error', function (err) {...});` - вызывается при ошибке считывания данных из потока.

`<stream>.destroy();` - закрывает поток и вызывается событие `'error'`.

`<stream>.on('pipe', function (<readable_stream>) {...});` - вызывается, когда метод `<stream>.pipe(<writable_stream>)` вызывается в универсальном потоке для чтения для добавления в набор назначения.

`<stream>.on('unpipe', function (<readable_stream>) {...});` - вызывается, когда метод `<stream>.unpipe(<writable_stream>)` вызывается в универсальном потоке для чтения для удаления из набора назначения.

#### Произвольный поток записи

```javascript
function <Stream>() {
    stream.Writable.call(this, options);
}
util.inherits(<Stream>, stream.Writable);

<Stream>.prototype._write = function (chunk, encoding, callback) {
    ...
}

<Stream>.prototype._writev = function (chunks, callback) {
    ...
}
```

Создает новый класс, который наследуется от `stream.Writable`, `options` представляет собой объект конфигурации.

`_write` - переопределяет внутренюю функцию записи, где `chunk` - данные, `encoding` - кодировка, а `callback` - колбек завершения записи, который необходимо вызвать.

`_writev` - переопределяет внутренюю функцию записи для обработки множественных кусков данных, где `chunk` - массив данных с элементами в виде: `{chunk: <данные>, encoding: <кодировка>}`, а `callback` - колбек завершения записи, который необходимо вызвать.

### `stream.Duplex`

Это потоки, которые реализуют и `stream.Readable` и `stream.Writable`.

`var <stream> = new stream.Duplex([<опции>]);` - создает поток, дополнительные опции создания, к опциям `stream.Readable` и `stream.Writable`:
- `allowHalfOpen` - автоматическое закрытие потока чтения при закрытии потока записи при значении `true`, по умолчанию `true`;
- `readableObjectMode` - объектный режим для чтения при значении `true`, по умолчанию `false`;
- `writableObjectMode` - объектный режим записи при значении `true`, по умолчанию `false`;
- `readableHighWaterMark` максимальный размер буфера для чтения задается в виде `<размер_в_байтах>` или `<количество_объектов>`, по ум. 16KB или 16 объектов;
- `writableHighWaterMark` максимальный размер буфера для записи задается в виде `<размер_в_байтах>` или `<количество_объектов>`, по ум. 16KB или 16 объектов.

### `stream.Transform`

Это потоки, которые реализуют `Duplex`, и преобразовывают данных на этапе получения из потока записи в поток чтения.

`var <stream> = new stream.Transform([<опции>]);` - создает поток, дополнительные создания:
- `decodeStrings` - автоматическая конвертация строк в буфер перед передачей их в метод `_transform()` при значении `true`, по умолчанию `true`;
- `objectMode` - объектный режим при значении `true`, по умолчанию `false`;
- `transform` - представление внутреннего метода `_transform`, в виде функции `<функция>`;
- `flush` - представление внутреннего метода `_flush`, в виде функции `<функция>`.

#### Произвольный поток преобразования

```javascript
function <Stream>() {
    stream.Transform.call(this, options);
}
util.inherits(<Stream>, stream.Transform);

<Stream>.prototype._transform = function (chunk, encoding, callback) {
    ...
    this.push(<chunk>[, "<кодировка>"]);
    [callback([<err>[, <chunk>]]);]
}

<Stream>.prototype._flush = function (callback) {
    ...
    this.push(<chunk>[, "<кодировка>"]);
    [callback([<err>[, <chunk>]]);]
}
```

Создает новый класс, который наследуется от stream.Transform, options представляет собой объект конфигурации.

`_transform` - переопределяет внутренюю функцию преобразования, где `chunk` - данные, `encoding` - кодировка, а `callback` - колбек завершения записи, который необходимо вызвать. Внутри нужно вызвать указаную функцию:  
    `this.push(<chunk>[, "<кодировка>"]);` - записывает данные в буфер потока и если есть еще место в буфере (ограничено `highWaterMark`), то возвращает `true`, иначе `false`, для окончания передачи нужно передать `null`.  
    `callback([<err>[, <chunk>]]);` - альтернативный вызов предыдущего варианта.

`_flush` - переопределяет внутренюю функцию, которая вызывается перед тем как входящий поток завершится, и используется для вставки оставшихся данных в исходящий поток, `callback` - колбек завершения записи, который необходимо вызвать.

## `Process`

Глобальный объект, который доступен как `process` и содержит информацию о текущем процессе Node. Имеет свойства:  
- `process.argv` - возвращает все переменные переданные во время запуска;
- `process.env.<имя_окружения>` - возвращает значение окружения;
- `process.execPath` - возвращает путь выполнения Node;
- `process.version` - возвращает версию Node;
- `process.platform` - возвращает платформу сервера;
- `process.pid` - возвращает `pid` процесса;
- `process.memoryUsage()` - возвращает объект в котором содержится информация о потребляемой памяти, с указаными свойствами:
    - `rss` - содержит в виде числа размер всей памяти в байтах;
    - `heapTotal` - содержит в виде числа размер кучи в байтах;
    - `heapUsed` - содержит в виде числа сколько использовано кучи в байтах;
    - `external` - содержит в виде числа размер памяти занимаемой C++ объектами в байтах.

`process.exit(<код>);` - завершает процесс с указанным кодом ошибки.

`process.on('exit', function (err) {...});` - вызовется непосредственно перед завершением процесса, уже после остановки цикла событий.  
`process.on('SIGINT', function () {...});` - вызовется непосредственно после нажатия клавиш `Ctrl-C` для уничтожении процесса или приема сигнала `SIGINT`.  
`process.on('<сигнал>', function () {...});` - вызовется непосредственно после приема сигнала `POSIX`.  
`process.on('uncaughtException', function (err) {...});` - вызовется при перехвате не переваченного исключения.

`process.kill(<pid_процесса>[, '<сигнал>']);` - убивает процесс [посылая ему указанный сигнал].

### Потоки ввода-вывода

Потоки `process.stdout`, `process.stdin` являются асинхронными, а `process.stderr` синхронным.
`process.stdin.resume();` - возобновляет поток для ввода, так как по ум. приостановлен.  
`process.stdin.on('data', function (data) {...});` - вызывается каждый раз при получении данных.

`process.stdout.write(<data>);` - записывает данные в поток вывода.

## `Buffer`

Специальный тип данных `Buffer` действует как фрагмент необработанных данных фиксированной длины. Буферы подобны массивам, отличия заключаются в том, что размеры буфера неизменны, причем буфер может содержать только значения в диапазоне от 0 до 255. Буфер можно рассматривать как эквивалент функции `malloc()` языка C или оператора `new` языка C++.

`var <buffer> = new Buffer(<данные>);` - считается устаревшим.

`Buffer.alloc(<размер>[, <значение_заполнитель>[, <кодировка>]])` - создает `Buffer` указаного размера [, во значениями `<значение_заполнитель>` [, в указаной кодировке `<кодировка>`]].

`<buffer>.length;` - содержит длину буфера.  
`<buffer>.toString([<кодировка>]);` - возвращает содержимое буфера в виде строки, виды кодировок:
- `'ascii'` - только для 7-bit ASCII данных;
- `'utf8'`;
- `'utf16le'`;
- `'ucs2'` - синоним `'utf16le'`;
- `'base64'`;
- `'latin1'`;
- `'binary'` - синоним `'latin1'`;
- `'hex'` - каждый байт представляет собой вид двух hex-символов.

`Buffer.from(<массив>)` - возвращает буфер из массива.  
`Buffer.from('<строка>')` - возвращает буфер из строки.  
`Buffer.from(<буфер>)` - возвращает точную копию буфера из буфера.  
`Buffer.byteLength('<строка>')` - возвращает длину строки в байтах.  

`<buffer>.write<Тип>(<данные>[, <позиция>]);` - записывает в буфер данные [, начиная с указанной позиции].

### `btoa` / `atob`

Их реализаций не имеется, есть альтернативы:
- `btoa('<строка>')` - `Buffer.from('<строка>').toString('base64')`
- `atob('<строка_в_формате_Base64>')` - `Buffer.from('<строка_в_формате_Base64>', 'base64').toString()`

### Порядок байтов

Он относится к порядку следования байтов в многобайтовой последовательности. Если байты расположены в последовательности от младшего к старшему, младший значащий бит (*Least Significant Byte*, *LSB*) хранится первым, а последовательность байтов считывается в направлении справа налево. В случае расположения байтов от старшего к младшему сначала сохраняется старший байт (*Most Significant Byte*, *MSB*), а последовательность байтов считывается в направлении слева направо.

## Глобальные объекты

`__dirname` - возвращает полный путь к каталогу текущего модуля.  
`__filename` - возвращает полный путь к файлу текущего модуля.

## NPM

`npm {i | install} [--production] [-g | --global] [<имя_модуля>[@<номер_версии>]]` - производит установку всех модулей из файла `package.json` из `dependencies` и `devDependencies`[указанного модуля `<имя_модуля>` [указанной версии `<номер_версии>`]] в самую ближайшую папку `node_modules`. Ключи:
- `--production` - `devDependencies` игнорируется при установке;
- `-g` | `--global` - означает использование как глобального модуля;
- `--save-prod` | `-P` - добавит указанный пакет в список зависимостей проекта для разработки в `dependencies`;
- `--save-dev` | `-D` - добавит указанный пакет в список зависимостей проекта в `devDependencies`.

`npm update [-g | --global] [<имя_модуля>]` - производит обновление всех модулей [только указаного `<имя_модуля>`] до актуальной версии.

`npm outdated [<имя_модуля>] `- производит проверку всех модулей [только указаного] на наличее новой версии.

`npm search <ключевое_слово>[ ...]` - производит поиск всех модулей по указанным ключевым словам и выводит их.

`npm {uninstall | remove| rm | r | un | unlink} [-g | --global] <имя_модуля>[@<номер_версии>] [-S | --save]` - удаляет указанный пакет. Ключи:
- `-S` | `--save` - удаляет пакет также из `dependencies`.

`npm {ls | list | la | ll} [-g | --global] [--depth=0] [<имя_модуля>]` - отображает список установленных локальных [глобальных] пакетов [только указаного `<имя_модуля>`] [только пакеты верхнего уровня, которые перечислены в `package.json`].

`npm init` - создает пакет и файл информации о нем: `package.json`.

`npm view <имя_модуля> version` - возвращает самый последний номер версии пакета.  
`npm view <имя_модуля> versions` - возвращает все номера версии пакета.

Строение `package.json`:

```json
{
    "name": "<имя_пакета>",
    "private": true,
    "main": "<путь_к_файлу-точки_входа_в_пакет>",
    "description": "<описание_пакета>",
    "version": "<номер_текущей_версии_пакета>",
    "keywords": "<список_ключевых_слов_о_пакете>",
    "bugs": {
        "url": "<url_куда_можно_отправлять_сообщения_об_ошибках>",
        "email": "<email_куда_можно_отправлять_сообщения_об_ошибках>"
    },
    "licenses": "<тип_лицензии_пакета>",
    "files": [
        "<файл_или_каталог_включения_к_пакету1>"
        ],
    "repositories": {
        "type": "<тип_репозитория_пакета>",
        "url": "<url_репозитория_пакета>"
  	},
    "dependencies": {
        "<имя_пакета1>": "[<|>][=]<номер_версии>[ [<|>][=]<номер_версии>]|*"
    },
    "devDependencies": {
        "<имя_пакета1>": "[<|>][=]<номер_версии>[ [<|>][=]<номер_версии>]|*"
    },
    "scripts": {
        "start": "<команды_запуска>",
        "install": "<команды_установки>",
        "<команда>": "<команды>",
    }
}
```

Где в секции `"scripts"`:
- `"start"` - обозначает что выполнит указанные команды при запуске пакета `npm start`;
- `"install"` - обозначает что выполнит указанные команды при установке пакета;
- `"<команда>"` - обозначает что указанные команды при вызове `npm run <команда>`.

### NPX

`npx` - утилита, которая позволяет производить запуск исполняемых файлов, входящих в состав npm-пакетов.

`npx [node@<номер_версии>] <имя_модуля>[@<номер_версии>][ <аргумент1>[ ...]]` - запускает [используя указанную версию node] модуль как комманду, что приводит к автоматическому поиску нужного файла запуска в папке проекта `node_modules`.

## Стандартные модули

### Модуль `fs`

Модуль `fs` реализует файловую систему.

`var fs = require('fs');`

`fs.readFile("<путь_к_файлу>"[, {"binary" | "utf8" | <опции>}], function (err, file) {...});` - читает файл и записывает в переменную `file` все его содержимое (по ум. используется тип `Buffer`), а затем вызывает функцию обратного вызова.  
`fs.readFileSync("<путь_к_файлу>"[, {"binary" | "utf8" | <опции>}]);` - синхронно читает файл и возвращает все его содержимое (по ум. используется тип `Buffer`), в случае ошибки выбрасывает исключение.

`fs.writeFile("<путь_к_файлу>", <содержимое>[, {"binary" | "utf8" | <опции>}], function (err) {...});` - записывает в файл содержимое, а затем вызывает функцию обратного вызова.  
`fs.writeFileSync("<путь_к_файлу>", <содержимое>[, {"binary" | "utf8" | <опции>}]);` - синхронно записывает в файл содержимое, в случае ошибки выбрасывает исключение.

`fs.appendFile("<путь_к_файлу>", <содержимое>[, {"binary" | "utf8" | <опции>}], function (err) {...});` - дописывает в файл содержимое, а затем вызывает функцию обратного вызова.  
`fs.appendFileSync("<путь_к_файлу>", <содержимое>[, {"binary" | "utf8" | <опции>}]);` - синхронно дописывает в файл содержимое, в случае ошибки выбрасывает исключение.

`fs.rename("<путь_к_файлу>", "<новый_путь_к_файлу>", function (err) {...});` - переименовывает файл (или его перемещает по новому пути), а затем вызывает функцию обратного вызова.  
`fs.unlink("<путь_к_файлу>", function (err) {...});` - удаляет файл, а затем вызывает функцию обратного вызова.

`fs.stat("<путь_к_файлу>", function (err, stats) {...});` - возвращает информацию о файле в виде объекта `stats` типа `fs.Stats` с такими методами:
- `stats.isFile()`;
- `stats.isDirectory()`;
- `stats.isBlockDevice()`;
- `stats.isCharacterDevice()`;
- `stats.isSymbolicLink()`;
- `stats.isFIFO()`;
- `stats.isSocket()`.

если `error.code = 'ENOENT'`, то это значит что файл не найден.

`fs.statSync("<путь_к_файлу>");` - синхронно возвращает информацию о файле в виде объекта: `fs.Stats`, в случае ошибки выбрасывает исключение.

`fs.existsSync("<путь_к_файлу>");` - синхронно возвращает `true` если файл существует, иначе `false`, в случае его отсутсвия.

`fs.readdir("<путь_к_файлу>", function (err, files) {...});` - читает содержимое каталога, а затем вызывает функцию обратного вызова где `files` - массив файлов каталога.  
`fs.readdirSync("<путь_к_файлу>");` - синхронно читает содержимое каталога, а затем возвращает массив файлов каталога, в случае ошибки выбрасывает исключение.  
`fs.mkdir("<путь_к_каталогу>", function (err) {...});` - создает каталог , а затем вызывает функцию обратного вызова.

`fs.watchFile("<путь_к_файлу>", function (curr, prev) {...});` - отслеживает изменение файла, где `curr` и `prev` представляют текущий и предыдущий объекты `fs.Stat`, которые должны иметь различные временные метки, соответствующие времени изменения файла, функция передаваемая этому методу, будет вызываться при каждом изменении файла.

`fs.unwatchFile("<путь_к_файлу>"[, <слушатель>]);` - убирает всех наблюдателей с файла [, или определенного `<слушатель>`].

`fs.watch("<путь>"[, {recursive: true}], function (eventType, filename) {...});` - отслеживает изменение за файлом или директорией, где `eventType` - это тип события: `'rename'` - при появлении или исчезании файла в директории [и во всех поддиректориях] или `'change'` - при изменении его содержимого; и `filename` - имя измененного файла. Возвращает `fs.FSWatcher`, у которого есть метод: `close()` для остановки наблюдения.

`var <stream> = new fs.ReadStream("<путь_к_файлу>");` - возвращает поток для чтения.  
`var <stream> = fs.createReadStream("<путь_к_файлу>"[, <объект_опций>]);` - возвращает поток для чтения.

`var <stream> = new fs.WriteStream("<путь_к_файлу>");` - возвращает поток для записи.  
`var <stream> = fs.createWriteStream("<путь_к_файлу>"[, <объект_опций>]);` - возвращает поток для записи. Где `<опции>` - объект со свойствами:
- `flags` - режим записи:
    - `w` - перезапись файла;
    - `a` - дополнение к текущему файлу.

### Модуль `util`

Модуль `util` реализует утилиты.

`var util = require('util');`

`util.inspect(<объект>)` - выводит информацию о объекте.  
`util.format("<строка>"[, <аргумент_строки_1>[, ...]])` - выводит форматированную строку.  
`util.inherits(<объект1>, <объект2>)` - производит наследование `<объект1>` от `<объект2>`, эквивалентно записи `<объект1>.prototype = new <объект2>();`.

`var <промис_функция> = util.promisify(<исходная_функция>)` - (node 8) - оборачивает функцию в промис, исходная функция должна соответствовать:
- колбек в параметрах исходной функции всегда идет последним;
- первым параметром колбека приходит объект ошибки, если она есть.

```javascript
<промис_функция>([<аргумент_1>[, ...]])
    .then(value => {...}[, err => {...}])
    .catch(err => {...});
```

### Модуль `child_process`

Модуль `child_process` позволяет запускать дочерние процессы.

`var child_process = require('child_process');`

`child_process.exec("<shell_комманда>"[, <объект_опций>], function (err, stdout, stderr) {...});` - выполняет shell-команду внутри Node.js а затем вызывает callback-функцию.

`child_process.execFile("<путь_к_файлу>"[, <объект_опций>], function (err, stdout, stderr) {...});` - выполняет файл внутри Node.js а затем вызывает callback-функцию.

`var <process> = child_process.spawn("<shell_комманда>"[, <массив_аргументов>][, <объект_опций>]);` - запускает команду в новом процессе [, с указанным числом аргументов][ где `<объект_опций>` - это объект со свойствами:
- `detached` - разрешает процессу работать после прекращения работы главного процесса при значении `true`, по умолчанию `false`.]

`<process>.stdout.on('data', function (data) {...});` - вызывается при получении данных в поток вывода процесса, где `data` - данные.  
`<process>.stderr.on('data', function (data) {...});` - вызывается при получении данных в поток ошибок процесса, где `data` - данные.  
`<process>.on('exit', function (code, signal) {...});` - вызывается при завершении процесса, где `code` - код завершения процесса, `signal` - сигнал, которым был процесс завершен.  
`<process>.on('close', function (code, signal) {...});` - вызывается когда `stdin` процесса закрывается, где `code` - код завершения процесса, `signal` - сигнал, которым был процесс завершен.  
`<process>.stdin.write(<data>);` - записывает данные в поток ввода процесса.  
`<process>.stdin.end();` - закрывает поток ввода процесса.

`var <process> = child_process.fork("<путь_к_файлу_js>"[, <массив_аргументов>[, <объект_опций>]]);` - запускает файл js в новом процессе [с указанным числом аргументов], со специальным встроенным IPC-каналом.

`<process>.on('message', function (message) {...});` - вызывается при получении сообщения от порожденного процесса.  
`process.send(<сообщение>);` - отправляет сообщение (может быть любым типом данных, включая объект) используется в порожденном процессе.

### Модуль `cluster`

Кластер это система приложений которые где есть две роли: Главная роль (master) и рабочая роль (worker). Есть один мастер на который приходят все запросы, и n-ое количество рабочих.

`var cluster = require('cluster');`

`var numCPUs = require('os').cpus().length;` - возвращает количество ядер процессора.

`cluster.isMaster` - возвращает `true`, если `cluster` вызывается в главном процессе, в главном процессе необходимо создавать рабочих.

`var <worker> = cluster.fork([<объект_новых_переменных_окружения>]);` - запускает новый процесс идентичный текущему.

`<worker>.send('<сообщение>');` - посылает сообщение в воркер.  
`<worker>.process;` - возвращает `ChildProcess`.  
`<worker>.disconnect();` - отключает воркер.  
`<worker>.kill();` - убивает воркер.  
`<worker>.isDead();` - возвращает `true`, если воркер убит или завершил свою работу, иначе false.

`cluster.workers;` - объект запущенных воркеров, в виде: `{<idWorker>: <worker>}`.
`cluster.on('message', function (worker, message, handle) {...});` - принимает сообщение от воркеров.  
`cluster.on('exit', function (deadWorker, code, signal) {...});` - вызовется если воркер умер, позволяет перезапустить воркера с помощью `var <worker> = cluster.fork();`.

`cluster.isWorker` - возвращает `true`, если `cluster` является рабочим `worker`, в рабочем процессе необходимо выполнять все остальные функции.

`process.on('message', function (msg) {...});` - принимает сообщение.  
`process.send('<сообщение>');` - посылает сообщение в мастер.  
`process.exit([<код_возврата>]);` - завершает воркера.  
`cluster.worker;` - ссылка на текущий воркер.

### Модуль `dns`

Модуль `dns` обеспечивает разрешение имен доменов.

`var dns = require('dns');`

`dns.lookup('<доменное_имя>', function (err, addresses, family) {...});` - находит первый ip-адрес указанного доменного имени и вызывает функцию, где `addresses` - его ip-адрес, `family` - тип ip-адреса: 4 или 6.

`dns.resolve('<доменное_имя>', '<тип>', function (err, addresses) {...});` - находит ip-адреса для указанного доменного имени по указанному типу `'<тип>'` (`'A'` - `IPV4`, `'AAAA'` - `IPV6`) и вызывает функцию, где `addresses` - массив его ip-адресов.

`dns.reverse('<ip-адрес>', function (err, hostnames) {...});` - находит список доменов указанного ip-адрес и вызывает функцию, где `hostnames` - список доменных адресов.

### Модуль `url`

Модуль `url` поддерживает методы, которые позволяют извлекать различные части URL (такие как запрошенный путь (URL path) и строка параметров запроса (query string)).

`var url = require('url');`

`url.parse("<url>"[, true])` - возвращает объект разбора URL [строку параметров `query` преобразует ее в объект] со свойствами:
- `pathname` - содержит путь;
- `query` - содержит строку параметров запроса [объект].

### Модуль `querystring`

Модуль `querystring` поддерживает методы, которые используется для парсинга строки параметров запроса (query string).

`var querystring = require('querystring');`

`querystring("<url>")["<параметр>"]` - возвращает значение указанного параметра запроса.

`querystring.parse("<данные>"[, <разделитель_пар_ключей_значений>[, <разделитель_ключей_и_значений>]]);` - распарсивает строку с данными и возвращает ассоциативный массив.

`querystring.stringify(<объект>[, <разделитель_пар_ключей_значений>[, <разделитель_ключей_и_значений>]]);` - формирует строку с данными и возвращает ее из ассоциативного массива.

### Модуль `http`

Модуль `http` содержит сервер.

`var http = require('http');`

`var <server> = new http.Server([function (request, response) {...}]);` - создает сервер.  
`var <server> = http.createServer([function (request, response) {...}]);` - создает сервер.

`<server>.listen(<порт>[, '<ip>']);` - устанавливает сервер на прослушку указанного порта.

`<server>.on("request", function (request, response) {...})` - установка обработчика события на новой запрос. Основные переменные:
- `request` - объект запроса:
    - `request.url` - возвращает `url`;
    - `request.method` - возвращает `method`;
    - `request.headers` - возвращает заголовки в виде объекта.

    `request.on("data", function (chunk) {...});` - подписывание на событие получения порции - `chunk` данных из запроса в виде `Buffer` и вызовом функции при получении (используется для сбора всех данных из POST).

    `request.on("end", function () {...});` - подписывание на событие получения всех порций - `chunk` данных из запроса и вызовом функции при получении всех (используется для сбора всех данных из POST).

    `request.setEncoding("<кодировка>");` - указывает какая кодировка ожидается для обработки запроса, при `"utf8"` - будут возвращаться строки вместо `Buffer`.
    Для форм значение заголовка `content-type` может быть:
    - `application/x-www-form-urlencoded` - значение (по ум.) для HTML-форм;
    - `multipart/form-data` - используется когда форма содержит файлы, двоичные данные или текст, кодировка которого отличается от ASCII (задается на форме как `enctype="multipart/form-data"`).

- `response` - объект ответа:
    `response.getHeader("<заголовок>");` - возвращает заголовок ответа.  
    `response.setHeader("<заголовок>", "<значение>");` - устанавливает заголовок ответа. Значение заголовка `Content-Length` должно представлять длину строки, выраженную в байтах, а не в символах.
    `response.removeHeader("<заголовок>");` - удаляет заголовок ответа.  
    `response.writeHead(<код_статуса_возврата>, {"<заголовок>": "<значение>"[, ...]});` - устанавливает код возврата и заголовки через объект.

    Добавлять и удалять заголовки можно в произвольном порядке, но только до первого вызова метода `response.write()` или `response.end()`.

    `response.write("<текст_ответа>");` - записывает текст в ответ [в бинарном виде].  
    `response.write(<данные> , "binary");` - записывает данные в ответ в бинарном виде.  
    `response.end(["<текст_ответа>"]);` - завершает ответ.  
    `response.statusCode` - код статуса возврата.

    `response.on('close', function () {...});` - вызывается при завершении соединения.

`var <request> = http.request(<опции>, function (response) {...});` - посылает запрос с указанными опциями и в конце вызывает указанную функцию, где `response` - объект ответа, а `<опции> `- объект со свойствами:
- `hostname` - `'<доменное_имя_или_ip_сайта>'`;
- `port` - `<номер_порта>`;
- `path` - `'<путь_запроса_с_/>'`;
- `method` - `'<МЕТОД_запроса>'`;
- `headers` - `<объект_заголовков>`;
- `auth` - `'<пользователь>:<пароль>'`;
- `timeout` - `<кол_мс_таймаута>`.

`<request>.write(<данные>);` - записывает данные в тело запроса (для POST).  
`<request>.end();` - отправляет запрос.  
`<request>.on('error', function (err) {...});` - запускает функцию в случае возникновения ошибки связанную с запросом.

### Модуль `https`

Аналогичен модулю `http`, используется для шифрования, различается только метод создания сервера:  
`var https = require('https');`

`var <server> = https.createServer({key: <key.pem>, cert: <key-cert.pem>}[, function (request, response) {...}]);`

### Модуль `net`

Используется для TCP передачи данных.

`var net = require('net');`

`var <server> = net.createServer([{allowHalfOpen: true},] function (socket) {` - создает сервер [, без отправки FIN пакета после получения FIN пакета], и вызывает функцию при каждом подключении, где `socket` является типом `net.Socket`.

`<server>.listen(<порт>[, '<ip>']);` - устанавливает сервер на прослушку указанного порта.

Тип `net.Socket` предстовляет собой сокет.

`socket.remoteAddress` - содержит удаленный ip-адрес.  
`socket.address()` - возвращает объект с информацией о удаленном ip-адресе.  
`socket.setEncoding("<кодировка>")` - указывает какая кодировка ожидается для обработки запроса, `"utf8"` - будут возвращаться строки вместо `Buffer`.

`socket.on("data", function (data) {...})` - вызывается при получении данных, где `data` данные из запроса в виде `Buffer`.  
`socket.on("end", function () {...})` - вызывается при получении FIN пакета.  
`socket.on("close", function () {...})` - вызывается при полном закрытии сокета.  
`socket.on("error", function (err) {...})` - вызывается при ошибке сокета.  
`socket.on("drain", function () {...})` - вызывается при завершении считывания данных из буфера ввода, когда буфер очищен.

`socket.write(<data>[, "<кодировка>"][, function () {...}])` - отправляет данные на запись в сокет, возвращает `true` если все данные удачно были помещены в буфер ядра или `false` если все или часть данных поместились в пользовательскую память, вызовет событие `"drain"`, когда буфер освободится[, вызовет функцию, когда данные полностью запишутся].

`var <socket> = new net.Socket(); `- создает сокет для подключения к серверу.

`<socket>.connect(<порт>[, "<ip_адрес>"][, function () {...}]);` - подключается к серверу по указанному порту [, и затем вызовет функцию, после удачного соединения].

### Модуль `dgram`

Используется для UDP передачи данных.

`var dgram = require('dgram');`

`var <socket> = dgram.createSocket({'udp4' | 'udp6'});` - создает сокет с указанным типом.

`<socket>.send(<сообщение>[, <отступ>, <длина>], <порт>, "<ip_адрес>"[, function (err) {...}])` - отправляет сообщение, которое содержит данные, которые должны быть `Buffer`, `String`, `Array` [с указанным отступом и длиной] на указанный порт и адрес [, и затем вызовет функцию].

`<socket>.on('error', function (err) {...});` - вызывается при ошибке сокета.

`<socket>.on('message', function (msg, rinfo) {...});` - вызывается по приходу сообщения на сокет, где `msg` в виде `Buffer`, а `rinfo` содержит объект с информацией о удаленном ip-адресе:
- `address` - `'<ip-адрес>'`;
- `family` - `'<тип_ip-адреса>'`;
- `port` - `<номер_порта>`;
- `size` - `<размер_пакета_в_байтах>`.

`<socket>.on('listening', function (error) {...});` - вызывается при начале прослушивания датаграммы из сокета.

`<socket>.bind(<порт>);` - привязывает сокет к прослушке указанного порта.

### Модуль `path`

Модуль `path` - используется для работы с путями.

`var path = require('path');`

`path.normalize('<путь>')` - нормализирует путь (`..` и `.`), и заменяет множественные `/` на один и возвращает его.  
`path.join('<путь1>'[, ...])` - соединяет пути и нормализирует и возвращает его.  
`path.parse('<путь>')` - возвращает объект пути строки с `root`, `dir`, `base`, `ext`, `name`.  
`path.resolve(['<путь1>'[, ...])` - разрешает последовательность путей или части путей в абсолютный путь, если много путей с асолютным путем, то выберется последний и возвращает его.  
`path.dirname('<путь>')` - возвращает родительскую директорию файла.  
`path.extname('<путь>')` - возвращает расширение файла.  
`path.basename('<путь>'[, '<расширение>'])` - возвращает имя файла [без расширения].  

### Модуль domain (устаревший)

Модуль domain - используется для перехвата всех асинхронный исключений и ошибок.

`var domain = require('domain');`

`var <domain> = domain.create();` - создает домен.

`<domain>.run(<функция>);` - запускает функцию для которой необходимо обработать ошибку.  
`<domain>.on('error', function (err) {...});` - запускает функцию в случае возникновения ошибки в запускаемой функции.  
`<domain>.add(<объект>)` - добавляет объект в домен для слежения за ним и перехватки всех ошибок.  
`<domain>.remove(<объект>) `- удаляет объект из домена для слежения за ним.

### Модуль `readline`

Модуль `readline` - представляет интерфейс для чтения данных из `Readable` потока (по умолчанию из `process.stdin`) строка за строкой.

`var readline = require('readline');`

`var <readline> = readline.createInterface(<опции>);` - создает интерфейс, где `<опции>` - это объект со свойствами:
- `input` - используется для чтения данных;
- `output` - для вывода сообщений.

`<readline>.on("close", function () {...});` - вызывается при закрытии потока `input`, через метод `end` или принятии сигналов: `end-of-transmission` (`EOT`) (`<ctrl>-D`), `SIGINT` (`<ctrl>-C`).  
`<readline>.on("line", function (line) {...});` - вызывается при получении строки `line` из `input` потока, котора оканчивается концом строки (`\n`, `\r`, или `\r\n`), обычно при нажатии клавиш `<Enter>` или `<Return>`.  
`<readline>.on("pause", function () {...});` - вызывается при приостановке (получении паузы) потока `input` или принятии сигнала: `SIGCONT`.  
`<readline>.on("resume", function () {...});` - вызывается при возобновлении потока `input`.

`<readline>.close();` - закрывает интерфейс и вызывает событие `"close"`.
`<readline>.pause();` - приостанавливает поток `input`.
`<readline>.resume(); `- возобновляет поток `input`.

`<readline>.setPrompt('<сообщение>');` - устанавливает сообщение `prompt` для вывода.  
`<readline>.prompt([true]); `- выводит сообщение `prompt` в `output` с новой строки и переводит курсор на следующую строку [не переводит].  
`<readline>.question('<сообщение>', function (input) {...});` - выводит сообщение и дожидается ввода пользователя на сообщение, а затем вызывает функцию, где `input` - ввод пользователя.

`<readline>.write('<сообщение>');` - записывает сообщение в поток `output` вывода.
`<readline>.write(null, {[ctrl: {true | false}], [meta: {true | false}], [shift: {true | false}], name: '<имя_клавиши>'});` - записывает нажатие клавиши в поток `output` вывода.

### Модуль `crypto`

Модуль `crypto` - предостовляет криптографический функционал.

`const crypto = require('crypto');`

`const <hash> = crypto.createHash({'sha256' | 'md5'});` - создает экземпляр класса `Hash` для подсчитывания хеша данных.  
`<hash>.update(<данные>);` - обновляет (добавляет) содержимое хеша данными.  
`<hash>.createHash({'hex' | 'latin1' | 'base64'});` - возвращает хеш содержимого в указаном формате.  

### Модуль `os`

Модуль `os` - предостовляет доступ ко многим функциям, которые можно использовать для получения информации об операционной системе и об аппаратном обеспечении компьютера, на котором работает NodeJS.

`const os = require('os');`

`os.EOL;` - содержит используемый в системе разделитель строк (признак конца строки). В Linux и macOS это `\n`, в Windows - `\r\n`.  
`os.constants;` - содержит константы системы.  
`os.arch();` - возвращает строку, идентифицирующую архитектуру системы (`arm`, `x64`, `arm64`).  
`os.cpus();` - возвращает массив процессоров, доступных в системе в виде объектов.  
`os.endianness();` - возвращает `'BE'` или `'LE'` в зависимости от того, какой порядок байтов (Big Engian или Little Endian) был использован для компиляции бинарного файла NodeJS.  
`os.freemem();` - возвращает количество свободной системной памяти в байтах.  
`os.totalmem();` - возвращает количество общей системной памяти в байтах.  
`os.homedir();` - возвращает путь к домашней директории текущего пользователя.  
`os.tmpdir();` - возвращает путь к заданной в системе директории для хранения временных файлов.  
`os.hostname();` - возвращает имя хоста.  
`os.networkInterfaces();` - возвращает объект со сведениями о сетевых интерфейсах, доступных в системе.  
`os.platform();` - возвращает сведения о платформе (`darwin`, `win32`), для которой был скомпилирован NodeJS.  
`os.release();` - возвращает строку, идентифицирующую номер релиза операционной системы.  
`os.uptime();` - возвращает время работы системы в секундах с последней перезагрузки.  

## Дополнительные модули

### Модуль `debug`

Модуль `debug` - используется для отладки.

`var debug = require('debug')('<имя>[:<подимя>]');` - устанавливает `debug` для указанного имени.

`debug('<сообщение>');` - запись сообщения.

Для вывода необходимо запустить сервер с параметрами:  
`SET DEBUG=<имя>[:<подимя> | *][, ...]`

### Модуль `mime`

Модуль `mime` - используется для получения типа mime файла.

`var mime = require('mime');`

`mime.lookup("<путь_к_файлу>")` - возвращает тип mime файла.

### Модуль `optimist`

Модуль `optimist` - возвращает переменные, которые были переданы скрипту.

`var optimist = require('optimist');`

`optimist.argv` - возвращает переменные, которые были переданы скрипту в виде объекта ключ-значение.

### Модуль `nconf`

Модуль `nconf` - используется для конфигурирования приложения.

`var nconf = require('nconf');`

`nconf.argv()` - подключает аргументы командной строки.  
`nconf.env()` - подключает параметры окружения.  
`nconf.file({file: '<путь_к_файлу_настроек_json>'})` - подключает настройки.  
`nconf.set('<свойство>[:<под_свойство>]', <значение>)` - устанавливает значение свойства.  
`nconf.get('<свойство>[:<под_свойство>]')` - получает значение свойства.

### Модуль `async`

Модуль as`ync - используется для управлениями цепочками асинхронных вызовов.

`var async = require(async);`

```javascript
async.parallel([
        function (callback) {...}
        [, ...]
    ]
    [, function (err[, results]) {...}]
    )
```
Вызывает функции для параллельного асинхронного выполнения, где каждая функция в конце своего выполнения должна вызвать `callback(err, result)` - и передав вместо `err` - ошибку и вместо `result` - результат работы [в конце всех функций вызовется главный колбек всего или если где-то вызвался колбек с ошибкой, где `err` - любая первая ошибка любого колбека [ и `results` - результат работы всех функций в виде массива]]

```javascript
async.series([
        function (callback) {...}
        [, ...]
    ]
    [, function (err[, results]) {...}]
    )
```
Вызывает функции для последовательного выполнения, где каждая функция в конце своего выполнения должна вызвать `callback(err, result)` - и передав вместо `err` - ошибку и вместо `result` - результат работы [в конце всех функций вызовется главный колбек всего или если где-то вызвался колбек с ошибкой, где `err` - любая первая ошибка любого колбека [ и `results` - результат работы всех функций в виде массива]]

```javascript
async.waterfall([
        function (callback) {...}
        [, function ([<аргумент>[, ...], ]callback) {...}
        [ ...]]
    ]
    [, function (err[, result[, ...]]) {...}]
    )
```
Вызывает функции для последовательного выполнения, где каждая функция в конце своего выполнения должна вызвать `callback(err[, <аргумент>[, ...]])` - и передав вместо `err` - ошибку [и аргументы для следующей функции] [в конце всех функций вызовется главный колбек всего или если где-то вызвался колбек с ошибкой, где `err` - любая первая ошибка любого колбека [ и `result[, ...]` - результат работы последней функции]]

```javascript
async.each(<массив>,
    function (item, callback) {...},
    function (err) {...}
    )
```
Используется для асинхронной обработки массива, где для каждого элемента массива применяется функция паралельно, где `item` - элемент массива и должна вызвать `callback(err)` - и передав вместо `err` - ошибку; по завершению обработки массива функциями вызовется главный колбек всего или он вызовется если где-то вызвался колбек с ошибкой, где `err` - любая первая ошибка любого колбека.

```javascript
async.eachSeries(<массив>,
    function (item, callback) {...},
    function (err) {...}
    )
```
Аналогично `each`, только последовательно, одна асинхронная операция.

```javascript
async.eachLimit(<массив>,
    <лимит>,
    function (item, callback) {...},
    function (err) {...}
    )
```
Аналогично `each`, только выполняется максимум `<лимит>` асинхронных операций.

```javascript
async.eachOf(<объект>,
    function (value, key, callback) {...},
    function (err) {...}
    )
```
Аналогично `each`, только используется для асинхронной обработки объекта, где `value` - значение ключа, `key` - ключ.

```javascript
async.eachOfSeries(<объект>,
    function (value, key, callback) {...},
    function (err) {...}
    )
```
Аналогично `eachOf`, только последовательно, одна асинхронная операция.

```javascript
async.eachOfLimit(<объект>,
    <лимит>,
    function (value, key, callback) {...},
    function (err) {...}
    )
```
Аналогично `eachOf`, только выполняется максимум <лимит> асинхронных операций.

```javascript
async.map(<массив>,
    function (item, callback) {...},
    function (err, results) {...}
    )
```
Используется для асинхронной обработки массива, где для каждого элемента массива применяется функция паралельно, где `item` - элемент массива и должна вызвать `callback(err, result)` - и передав вместо `err` - ошибку и вместо `result` - результат работы; по завершению обработки массива функциями вызовется главный колбек всего или он вызовется если где-то вызвался колбек с ошибкой, где `err` - любая первая ошибка любого колбека и `results` - результат работы функции над элементами масива в виде массива.

```javascript
async.mapSeries(<массив>,
    function (item, callback) {...},
    function (err, results) {...}
    )
```
Аналогично `map`, только последовательно, одна асинхронная операция.

```javascript
async.mapLimit(<массив>,
    <лимит>,
    function (item, callback) {...},
    function (err, results) {...}
    )
```
Аналогично `map`, только выполняется максимум <лимит> асинхронных операций.

```javascript
async.filter(<массив>,
    function (item, callback) {...},
    function (err, results) {...}
    )
```
Используется для асинхронного фильтрования массива, где для каждого элемента массива применяется функция, где `item` - элемент массива и должна вызвать `callback(err, truthValue)` - и передав вместо `err` - ошибку, а `truthValue` - `true` если элемент должен присутствовать в результирующем массиве; по завершению обработки массива функциями вызовется главный колбек всего или он вызовется если где-то вызвался колбек с ошибкой, где `err` - любая первая ошибка любого колбека, а `results` - отфильтрованный массив.

```javascript
async.reduce(<массив>,
    <начальное_значение>,
    function (accumulator, item, callback) {...},
    function (err, result) {...}
    )
```
Используется для свертки массива, с начальным значением свертки равным `<начальное_значение>`, где для каждого элемента массива последовательно применяется функция, где `accumulator` - результат свертки на предыдущем этапе, `item` - элемент массива и должна вызвать `callback(err, accumulator)` - и передав вместо `err` - ошибку, а `accumulator` - новое значение свертки; по завершению обработки массива функциями вызовется главный колбек всего или он вызовется если где-то вызвался колбек с ошибкой, где `err` - любая первая ошибка любого колбека, а `result` - результат свертки массива.

```javascript
async.reduceRight(<массив>,
    <начальное_значение>,
    function (accumulator, item, callback) {...},
    function (err, result) {...}
    )
```
Аналогично `reduce`, только справо.

`var <очередь> = async.queue(function (task, callback) {...}, <лимит>)` - возвращает очередь, которая использует указанную функцию для обработки задач, с ограниченным количеством `<лимит>` задач одновременно, где `task` - задача, ей может быть что угодно и должна вызвать `callback(err)` - и передав вместо err - ошибку, по завершению обработки задачи.

`<очередь>.push(<задача>, function (err) {...});` - добавляет задачу в конец очереди, по окончании выполнения задачи вызовется указаная функция, где `err` - ошибка.  
`<очередь>.unshift(<задача>, function (err) {...});` - добавляет задачу в начало очереди, по окончании выполнения задачи вызовется указаная функция, где `err` - ошибка.

### Модуль `ws`

Модуль `ws` - используется для работы с `WebSocket`.

`var WebSocketServer = require('ws').Server;`

`var <webSocketServer> = new WebSocketServer({[server: <http_сервер>][, port: <порт>]});` - создает сервер на основе готового сервера.

`<webSocketServer>.on('connection', function (ws) {...});` - вызывается при новом соединении.  
`ws.send(<данные>, function (err) {...});` - отправляет данные.  
`ws.on('message', function (message) {...});` - вызывается при приеме сообщения.  
`ws.on('close', function () {...});` - вызывается при закрытии соединения.

### Модуль `formidable`

Модуль `formidable` - делает форму, отправленную через HTTP POST, доступной для парсинга в Node.js. Для этого нужно создать новый экземпляр объекта `IncomingForm`, который является абстракцией отправленной формы и может быть использован для парсинга объекта `request` HTTP-сервера, для полей и файлов, отправленных через эту форму.

Используется для форм с заголовком `content-type=multipart/form-data`.

`var formidable = require('formidable');`

`var <form> = new formidable.IncomingForm();`

`<form>.uploadDir` - путь к папке размещения файлов (по умолчанию - `/tmp`).  
`<form>.parse(request[, function (err, fields, files) {...}]);` - производит разбор пришедшей формы [и вызывает функцию, где `err` - ошибка, `fields` - переданные поля с значениями и `files` - загруженные файлы].  
`<form>.on('field', function (field, value) {...});` - событие происходит после завершения получения данных поля, где `field` - имя поля, `value` - значение поля.  
`<form>.on('file', function (name, file) {...});` - событие генерируется после получения и обработки файла, где `name` - имя файла, `file` - объект файла, который поддерживает размер файла, путь к файлу, исходное базовое имя и MIME-тип.  
`<form>.on('end', function () {...});` - событие генерируется после окончания разбора формы.

### Модуль `redis` для работы с Redis

`var redis = require("redis");`

`var <client> = redis.createClient(<порт>, '<ip_адрес>');` - создает клиента соединенного с Redis-сервером.

`<client>.on('error', function (err) {...});` - генерирует событие если возникают проблемы при попытке установки соединения с Redis-сервером.

`redis.print` - функция вывода информации, может передаваться как обратная.

`<client>.quit()` - закрывает соединение клиента, после всех команд.  
`<client>.end()` - немедленно закрывает соединение клиента.

#### Пары ключ/значение

`<client>.set('<ключ>', '<значение>'[, function (err, res) {...}]);` - устанавливает значение ключа [и после этого вызывает функцию].  
`<client>.get('<ключ>', function (err, value) {...});` - возвращает значение ключа через функцию, где `value` - значение ключа или `null` если ключа нет.  
`<client>.del('<ключ>'[, function (err, res) {...}]);` - удаляет ключ [и после этого вызывает функцию].

#### Хеш-таблицы

`<client>.hset('<ключ>', '<поле>', '<зачение>'[, function (err, res) {...}]);` - устанавливает значение поля ключа [и после этого вызывает функцию].  
`<client>.hmset('<ключ>', <объект_полей_значений>[, function (err, res) {...}]);` - устанавливает значение полей ключа по полям и значениям объекта.  
`<client>.hget('<ключ>', '<поле>', function (err, value) {...});` - возвращает значение поля ключа через функцию, где `value` - значение поля ключа или `null` если ключа нет.  
`<client>.hgetall('<ключ>', function (err, values) {...});` - возвращает значения ключей через функцию, где `values` - объект вида пол-значение или `null` если ключа нет.  
`<client>.hkeys('<ключ>', function (err, value) {...});` - возвращает значение ключа через функцию, где `value` - значение ключа в виде объекта или `null` если ключа нет.  
`<client>.hdel('<ключ>', '<поле>'[, function (err, res) {...}]);` - удаляет поле ключа [и после этого вызывает функцию].

#### Список

`<client>.lpush('<список>', '<зачение>'[, function (err, res) {...}]);` - добавляет в список значение [и после этого вызывает функцию].  
`<client>.lrange('<список>', <начальный_индекс>, <конечный_индекс>, function (err, items) {...});` - возвращает значения списка через функцию, где `items` - массив значений списка или `null` если значений нет.  
`<client>.lpop('<список>', function (err, item) {...});` - возвращает первое значение списка через функцию, где `item` - значение списка или `null` если списка нет.  
`<client>.lrem('<список>', <количество>, '<зачение>'[, function (err, res) {...}]);` - удаляет заданое количество (`0 `- все, `< 0` - с хвоста, `> 0` с головы) значений из списка, если они равны указаному значению [и после этого вызывает функцию].

#### Множества

`<client>.sadd('<множество>', '<зачение>'[, function (err, res) {...}]);` - добавляет в множество значение [и после этого вызывает функцию].  
`<client>.smembers('<множество>', function (err, members) {...});` - возвращает значения множества через функцию, где `members` - массив значений или `null` если множества нет.  
`<client>.srem('<список>', '<зачение>'[, function (err, res) {...}]);` - удаляет значение из множества, если оно равно указаному значению [и после этого вызывает функцию].

#### Подписки

После перевода соединения в режим подписки к нему можно применять только команды, от­носящиеся к подписке.

`<client>.subscribe('<канал>');` - подписка на канал.  
`<client>.on('message', function (channel, message) {...});` - вызывает функцию при получении сообщения из канала, где `channel` - канал, `message` - сообщение.  
`<client>.publish('<канал>', <сообщение>);` - посылает сообщение в заданный канал.  
`<client>.unsubscribe('<канал>');` - производит отписку от канала.

### Модуль `mysql` для работы с MySql

`var mysql = require('mysql');`
`var <db> = mysql.createConnection(<опции>);` - создает соединение с БД, где <опции> это объект со свойствами:
- `host` - `'<ip_адрес>'`;
- `user` - `'<имя_пользователя>'`;
- `password` - `'<пароль>'`;
- `database` - `'<имя_БД>'`.

`<db>.query('<sql_запрос>'[, <массив_значений_для_подстановки>], function (err, rows) {...});` - выполняет запрос к БД [, в который подставляет вместо знака `?` значение в массиве в указанном порядке] где в `rows` - передается результат скрипта в виде массива, где элемент массива - это строка результата в виде объекта - `{<имя_колонки>: <значение>[, ...]}`.

### Модуль `mongodb` для работы с MongoDB

`var mongodb = require('mongodb');`

`var <server> = new mongodb.Server('<ip_адрес>', <порт>, <объект_опций>);` - подключение к серверу.

`var <client> = new mongodb.Db('<имя_БД>', <server>, {w: 1});` - создает клиента сервера.

`<client>.open(function (err) {...});` - открывает соединение с БД.  
`<client>.close();` - закрывает соединение с БД.  
`<client>.collection('<имя_коллекции>', function (err, collection) {...});` - представляет доступ к коллекции БД.

## Фреймворк `Connect`

В основе лежит использование **middleware** (связующего программного обеспечения).

`var connect = require("connect");`
`var <connect> = connect();` - является подклассом `http.Server`.

`http.createServer(<connect>).listen(<порт>);` - переопределяет все запросы на `<connect>`.

### Связующие программы

Все связующие программы вызываются в порядке задания.

`<connect>.use(['<префикс_пути>', ]function (request, response, next) {...});` - установка функции обработки запроса [если `url` запроса совпадает по указанному префиксу пути, перед вызовом связующей программы Connect удаляется префикс из свойства `url` объекта запроса], если функция обрабатывает запрос не до конца, то она должна вызывать `next()`.

Для большей гибкости можно использовать вложенность связующих программ, для этого передается собственная связующая программа, которая в зависимости от условий будет вызывать соответствующие связующие программы, которые ей могут быть переданы в качестве аргументов или `next()`.

#### Собственные связующие программы

Для создания собственной связующей программы необходимо определить функцию которая после вызова возвратит функцию с указанной сигнатурой: `function (request, response, next) {...}`, и передать (вызвать) ее в: `<connect>.use(<связующая_программа>(...));`

#### Собственная обработка ошибок приложения

Аналогично собственной связующей программе, только должна возвращать функцию с указанной сигнатурой `function (err, request, response, next) {...}`, где `err` - ошибка и передать (вызвать) ее в `<connect>.use(<связующая_программа>(...));`. Будет вызвана при вызове `next(<Error>)` или исключению в какой-то связующей программе.

### Связующие программы `Connect`

`<connect>.use(connect.directory('<путь_к_каталогу>')[, <опции>]);` - регистрирует связующую программу для отдачи списка файлов в указанном каталоге и перемещения по ним, где `<опции>` это объект со свойствами:
- `hidden` - при `true` позволяет перемещаться по скрытым файлам;
- `icons` - при `true` позволяет отображать иконки файлов.

`<connect>.use(connect.static('<путь_к_каталогу>')[, <опции>]);` - регистрирует связующую программу для отдачи статики в указанном каталоге. Если запрашивается папка, в которой находится файл index.html, будет отдан этот файл, где `<опции>` это объект со свойствами:
- `maxAge` - `<время_кэша_в_мс>`;
- `hidden` - при `true` позволяет перемещаться по скрытым файлам;
- `redirect` - при `true` устанавливает перенаправление по замыкающему слешу `/`.

`<connect>.use(connect.favicon("<путь_к_иконке>"));` - регистрирует связующую программу для отдачи иконки сайта.

`<connect>.use(connect.logger({<опции>));` - регистрирует связующую программу для логирования, по умолчанию в `stdout`, где `<опции>` это объект со свойствами:
- `format` - формат вывода, один из `"default"` | `"short"` | `"tiny"` | `"dev"`;
- `stream` - ссылка на поток вывода `<stream>`;
- `immediate` - если `true` то пишет только в том случае, если запрос получен в первый раз;
- `buffer` - содержит количество мс `<кол_мс>` в виде числа, на основе их пишет в поток не чаще чем раз в заданное значение.

`var cookieParser = require('cookie-parser');`  
`<connect>.use(cookieParser(["<ключ_шифрования>"]));` - регистрирует связующую программу для извлечения данных `cookie` из заголовка запроса и сохранения данных в объекте запроса по ключу `cookie`, в виде объекта, где ключ - имя куки, значение - полное значение куки [, а в объекте запроса по ключу `signedCookies` будут находиться куки, которые подписаны SHA-1 HMAC (в виде `<значение>.<подпись>`), в виде объекта, где ключ - имя куки, значение - полное значение куки без `.<подпись>`, и назначает в объекте запроса по ключу `secret` ключ шифрования, если же значение подписанной cookie-файла изменится, то она поместится в `cookie`] JSON куки будут иметь префикс `j:` в значении куки.

`response.setHeader('Set-Cookie', "<имя>=<полное_значение>");` - задание куки. Среда `Connect` исправляет заданную по умолчанию Node-функцию `response.setHeader()` таким образом, чтобы использовать заголовки `Set-Cookie` специального вида.

`var cookieSession = require('cookie-session');`
`<connect>.use(cookieSession(<опции>));` - регистрирует связующую программу для работы с сессиями, данные сессии добавляются в объект запроса по ключу `session`, в виде объекта, в который можно записывать произвольные данные сессии. Для обнуления необходимо ключ `session` задать равным `null`. Куки сессии доступны по ключу `session.cookie`, где `<опции>` это объект со свойствами:
- `name` - имя куки хранения сессии в виде `"<имя_куки_хранения>"`, по ум. `"express:sess"`;
- `keys` - список ключей для подписывания и верефикации кук, задается в виде массива `["<ключ>"[, ...]]`;
- `cookie` - содержит объект для хранения информации о куке хранения сессии, со свойствами:
    - `maxAge` - максимальное время хранения в виде числа `<время_хранения>`;
    - `httpOnly` - при `true` использовать только с `http`;
    - `secure` - при `true` использовать только с `https`.
- `store` - содержит объект для хранения сессии, в виде `<объект_для_хранения_сессии>`.

Для хранения сессии в `redis`, необходимо использовать модуль connect-redis.

```javascript
var RedisStore = require('connect-redis')(connect);

<connect>.use(connect.session({
    store: new RedisStore({prefix: '<префикс_для_ключа_редиса>'})
}));
request.session.destroy(function (err) {...});
```
Обнуления сессии, если сессия хранится в хранилище;

`<connect>.use(connect.limit('<размер_в_байтах>'));` - регистрирует связующую программу для ограничения размера тела запроса.

`var bodyParser = require('body-parser');`

`<connect>.use(bodyParser());` - регистрирует связующую программу для разбора `POST`, и помещает в объект запроса по ключу `body` объект, где ключ - имя поля, значение - значение, разбирает данные на основании значения `Content-Type`. Если задано `multipart/form-data` то помещает файлы в объект запроса по ключу `files` объект, где ключ - имя поля, значение - объект информации о файле со свойствами:
- `size` - `<размер>`;
- `path` - '`<путь_к_заруженному_файлу>'`;
- `name` - '`<оригинальное_имя>'`;
- `type` - '`<тип>'`;
- `lastModifiedDate` - `<время>`;
- `length` - длина файла;
- `filename` - имя файла;
- `mime` - `mime` тип фала.

`<connect>.use(connect.query());` - регистрирует связующую программу для разбора `GET`, и помещает в объект запроса по ключу `query` объект, где ключ - имя поля, значение - значение.

`<connect>.use(connect.vhost('<имя_хоста>', <объект_http_Server>));` - регистрирует связующую программу для перенаправления всего запроса на другой сервер.

`<connect>.use(connect.basicAuth('<имя_пользователя>', '<пароль>'));` - регистрирует связующую программу для HTTP аунтефикации, если пользователь введет правильные данные, то его пустит дальше.

`<connect>.use(connect.basicAuth(function (user, pass) {...});` - функция должна возвращать `true` если имя пользователя `user` и пароль `pass` верны, иначе `false`.

`<connect>.use(connect.csrf());` - регистрирует связующую программу для предотвращения кросс-фаер атаки, должен помещаться после сессии и записует 24 значный токен в объект запроса по ключу `session._csrf`. Нужно помещать его после `connect.bodyParser`. После этого его можно получить для сверки в объекте запроса по ключу `body._csrf`.

`<connect>.use(connect.errorHandler());` - регистрирует связующую программу для вывода ошибки при вызове `next(<Error>)` с ошибкой, используется во время разработки.

`<connect>.use(connect.compress([]));` - регистрирует связующую программу для сжатия и разжатия данных с помощью `gzip` и `deflate` которые могут быть указаны в заголовке `AcceptEncoding` [будет использоваться только для тех запросов, на которые функция фильтр вернет `true`], его необходимо помещать как можно выше, так как он переопределяет методы `write()` и `end()` объекта запроса, где `<опции>` это объект со свойствами:
- `filter` - функция вида: `function (req, res) {...}`, которая должна возвращать `true` для применения фильтра, в противном случа `false`;
- `level` - `<уровень_сжатия>`;
- `memLevel` - `<уровень_потребления_памяти>`.

## Фреймворк Express

Фреймворк `Express` представляет собой надстройку над `Connect`.

### Установка

`nmp I -g express`  
`express -e -s` - флаг `-e` включает поддержку EJS в файле `app.js`, а флаг `-s` - поддержку сеансов  
`nmp i`

### Структура каталогов проекта

- `controllers/` - определяются роуты и их логика, должны обрабатывать запросы обслуживать шаблоны для пользователя, взаимодействовать с моделями для получения и извлечения данных, в нем может содержаться главный файл `index.js`, в котором будут склеиваться все контролеры (роуты);
- `helpers/` - код и функциональность, которая должна быть доступна для разных частей проекта;  
- `middlewares/` - `Express` мидверы, которые обрабатывают входящие запросы перед передачей их в контролеры (роуты), например авторизация;
- `models/` - представляет данные, реализует бизнес логику и обработку их хранения в БД, так и в других источниках, она не должна напрямую работать с объектами запросов и ответов и должна по минимуму зависить от окружающего мира, должно существовать по минимуму одному файлу на каждую сущность в БД;
- `public/` - содержит все статичные файлы - изображения, `css`, `js`, `html`;
- `views/` - предоставляет шаблоны, которые отображаются и обслуживаются контролерами;(роутами), содержит как минимум по каталогу для каждого контролера (роута), в самом шаблоне должно содержаться по минимуму логики;
- `tests/` - содержит тесты для приложения;
- `app.js` - инициализирует приложение и склеивает все вместе.

### Базовая настройка

`var express = require("express.js");`

`var <app> = express();` - создает функцию для обработки запросов, является подклассом `http.Server`.

`http.createServer(<app>).listen(<порт>, function () {...})` - переопределяет все запросы на `<app>` на указанный `<порт>`.

### Кофигурирование

Переменная окружения `NODE_ENV` (`NODE_ENV=production`) используется в качестве средства извещения Node-приложения о текущем окружении, в котором по умолчанию происходит разработка. Ее можно получить через `process.env.NODE_ENV`.

`app.configure(['<имя_кофигурации>' [, ...],] function () {...});` - вызывает указанную функцию для всех [только для указанных] конфигураций.

`<app>.set('<свойство>', <значение>);` - устанавливает значение свойства.  
`<app>.get('<свойство>');` - получает значение свойства.  
`<app>.enable('<свойство>');` - аналогично `<app>.set('<свойство>', true)`.  
`<app>.enabled('<свойство>');` - возвращает `true`, если свойство установлено, иначе `false`.  
`<app>.disable('<свойство>');` - аналогично `<app>.set('<свойство>', false)`.  
`<app>.disabled('<свойство>');` - возвращает `true`, если свойство не установлено, иначе `false`.

### Middleware

Используются аналогичные как из `connect`.

`express.errorHandler(err, request, response, next);` - производит форматированный вывод ошибки.

Express также расширяет `request`, `response` дополнительными методами и свойствами.

`request.param('<имя_параметра>');` - возвращает значение параметра по имени из таких источников в указанном порядке:
- `request.params` - из роутинга;
- `request.body` - из тела POST-запроса;
- `request.query`;
- `request.accepted` - возвращает массив поддерживаемых медиа типов заданых в поле `Accept` заголовка от наивысшего значения `quality` - качества, в таком формате:
    - `value` - `'<медиа_тип>'`;
    - `quality` - `<качество>`;
    - `type` - `'<медиа_тип_главный>'`;
    - `subtype` - `'<медиа_подтип>'`.

`response.format(<объект>);` - вызывает указаную функцию в зависимости от принятого медиа типа в поле `Accept` заголовка, в виде объекта, где ключ - это медиа тип в виде: `'<медиа_тип>'` | `'html'` | `'xml'` | `'json'`, а значение функция `function (){...}`.

`response.status(<код_ответа>)` - устанавливает код ответа, а также возвращает response.  
`response.send([<код_ответа>, ]<текст_JSON>)` - отсылает сразу данные.

`response.redirect('<url>')` - перенаправляет на другую страницу.  

`response.sendfile('<путь_к_файлу>'[, <опции>][, function (err) {...}]);` - отправляет файл на выгрузку автоматически устанавливая заголовок `Content-Type` в зависимости от типа файла, используется код, аналогичный отдачи статики [с указанными опциями] [и вызывает указанную функцию после выгрузки файла, где `err` - ошибка передачи], где `<опции>` это объект со свойствами:
- `maxAge` - время кэширования `<время_кэширования_в_мс>`, по ум. `0`;
- `root` - путь к корневой директории файла `'<путь_к_корневой_директории>'`.

`response.download('<путь_к_файлу>'[, '<имя_файла>'][, function (err) {...}]);` - отправляет пользователю приглашение на загрузку файла, полю `Content-Disposition` заголовка присваивается имя файла [указанное имя] использую при выгрузке метод `sendfile` [и вызывает указанную функцию после выгрузки файла, где `err` - ошибка передачи].

### Роутинг

`<app>.use(express.router);`

Тогда можно исользовать следующие методы, для разных методов запросов:
- `<app>.use(['<путь_маршрута>', ]function (request, response, next) {...}[, ...]);` - для любого;
- `<app>.all('<путь_маршрута>', function (request, response, next) {...}[, ...]);` - для всех;
- `<app>.<имя_метода>('<путь_маршрута>', function (request, response, next) {...}[, ...]);`  
`<app>['<имя_метода>']('<путь_маршрута>', function (request, response, next) {...}[, ...]);` - используется для маршрутизации методов, где `<имя_метода>` может быть указано именем метода HTTP: `get`, `post`, `put`, `head`, `delete`, `options`, `trace`, `copy`, `lock`, `mkcol`, `move`, `purge`, `propfind`, `proppatch`, `unlock`, `report`, `mkactivity`, `checkout`, `merge`, `m-search`, `notify`, `subscribe`, `unsubscribe`, `patch`, `search` и `connect`.

Пути маршрутов могут представлять собой строки, шаблоны строк или регулярные выражения. Символы `?`, `+`, `*` и `()` представляют собой подмножества соответствующих им регулярных выражений. Дефис `-` и точка `.` интерпретируются буквально в путях на основе строк.

Маски пути маршрутов для задания:
`'<url>/:<переменная>'` - то тогда переменная будет доступна как request.params.<переменная>, знак ? после переменной указывает на ее необязательность.

`<app>.route('<путь_маршрута>').<имя_метода>(function (request, response, next) {...})[. ...]` - позволяет создавать обработчики маршрутов, образующие цепочки, для пути маршрута.

`var <router> = express.Router();` - маршрутизатор, позволяет создавать модульные, монтируемые обработчики маршрутов. Представляет собой комплексную систему промежуточных обработчиков и маршрутизации; по этой причине часто называется "мини-приложением".

`<router>.use(['<путь_маршрута>', ]function (request, response, next) {...}[, ...]);` - указание обработчика специфичного для данного маршрутизатора.  
`<router>.<имя_метода>('<путь_маршрута>', function (request, response, next) {...}[, ...]);` - используется для маршрутизации методов, которые специфичны для данного маршрутизатора.  
`<app>.use(['<путь_маршрута>', ]<router>);` - загрузка маршрутизатора в приложение.

### Хранение транзитных сообщений в сеансах

Обычным паттерном проектирования веб-приложений является паттерн **PRG** (*Post/Redirect/Get* - *отправить/перенаправить/получить*).

Объект `express.response` представляет собой прототип, который в Express используется для объектов ответа. Добавление свойств к объекту означает, что они будут доступны всему программному обеспечению промежуточного уровня и соответствующим маршрутам.

### Шаблонизация ejs

`<app>.set('views', '<путь_к_каталогу_с_шаблонами>');`  
`<app>.set('views engine', 'ejs');` - установка движка шаблонов.  
`<app>.engine('ejs', require('ejs-locals'));` - установка расширенного движка шаблонов.

`<app>.locals` - содержит объект с переменными для шаблонов, в котором можно присваивать ключей значениями переменных, которые будут доступны в шаблоне по имени ключа, как `<переменная>` так и `locals.<переменная>`.  
`response.locals` - аналогично `<app>.locals`, только имеет область видимости текущего запроса и имеет выше приоритет.

`response.render('<имя_шаблона>', {'<переменная>': <значение>[, ...]}[, {delimiter: '<значек_разделителя>'}]);` - производит рендер шаблона в ответ, все переменные которые переданы, будут доступны в шаблоне по их имени.

Виды комманд ejs в html шаблоне:
- разделители команд (обвертки) `<? ?>` и `<% %>`;
- `<%-<переменная>%>` - выводит значение переменной как html, без экранирования;
- `<%=<переменная>%>` - выводит значение переменной как текст с экранированием переменной;
- `-%>` - обрезает появление новой строки после команды;
- `<%_` - обрезает пробелы до начала команды;
- `_%>` - обрезает пробелы после конца команды;
- `<%#<текст>%>` - комментарий;
- `<%%` - вывод `<%`;
- `%%>` - вывод `%>`.

По умолчанию Express экспонирует представлениям только одну переменную уровня приложения, переменную `settings`. Эта переменная представляет собой объект, включающий все значения, установленные методом `<app>.set()`.

`<%- include('<путь_к_под_шаблону>', {'<переменная>': <значение>[, ...]}) %>` - включает указаный шаблон, в который передаются указаные переменные и переменные доступные для текущего шаблона в текущий шаблон.

`<% layout('<путь_к_главному_шаблону>')-%> ` - поместит все тело шаблона в главный шаблон в `<%- body -%>`.  
`<%- block('<переменная>', '<значение>'); -%>` - добавляет значение к переменной, которая будет доступна, через `blocks.<переменная>` в главном шаблоне.  
`<%- partial('<путь_к_под_шаблону>')%>` - загружает подшаблон в текущий шаблон.

## Тестирование

Основные виды тестирования:
- **Модульное тестирование** - разновидность автоматического тестирования, в ходе которого проверяются отдельные части приложения, непосредственная проверка логики приложения, обычно на уровне функции или метода; модульное тестирование применимо ко всем типам приложений. Подразделяется на:
    - **разработка на основе тестирования** (*Test-Driven Development*, *TDD*);
    - **разработка на основе функционирования** (*Behavior-Driven Development*, *BDD*).
- **Приемочное тестирование** - дополнительный уровень тестирования, применяется преимущественно при отладке веб-приложений, подразумевает контроль сценариев из браузера и проверку функциональности веб-приложений с его помощью.

### Модуль `assert`

Встроенный модуль. В нем выполняется проверка некоего условия, к примеру сравнивается вычисленное значение и ожидаемое значение, и если условие не выполняется, генерируется ошибка и результатом утверждения становится вывод на консоль трассы стека с сообщением об ошибке.

`var assert = require('assert');`

`assert.equal(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - проверяется, действительно ли значение переменной равно значению второго аргумента.  
`assert.notEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - проверяется на не равенство.  
`assert.strictEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - проверяется на строгое равенство.  
`assert.notStrictEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - проверяется на не строгое равенство.  
`assert.deepEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - выполняется рекурсивное сравнение двух объектов на равенство, то есть сравниваются свойства двух объектов, а если свойства сами являются объектами, они тоже сравниваются.  
`assert.notDeepEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - выполняется рекурсивное сравнение двух объектов на не равенство, то есть сравниваются свойства двух объектов, а если свойства сами являются объектами, они тоже сравниваются.  
`assert.ok(<выч_значение>,'<сообщение_ошибки>');` - проверяет асинхронное значение на истинность, если значение не равно true, то это ошибка.  
`assert.throws(<функция>[, <регулярное_выражение>], '<сообщение_ошибки>');` - проверяет функцию на генерацию исключений (ошибки)[, сообщение которой совпадает с регулярным выражением].

## Шаблонизатор EJS

`var ejs = require('ejs');`

`ejs.render('<содержимое_шаблона>', <опции>)` - возвращает сгенерированный результат шаблона, на основе указанного шаблона с заданными переменными, где `<опции>` это объект со свойствами:
- `locals` - объект в виде: `{'<переменная>': <значение>[, ...]}`, гарантирует, что отдельные биты контекстных данных не будут интерпретироваться как EJS-параметры;
- `cache` - при `true` кэширует шаблон;
- `filename` - в виде `'<уникальное_значение_шаблона>'`.

### Фильтры

`<%=: <переменная>| <фильтр>[:<параметр>[: ...]][| ...] %>` - вывод переменной с помощью фильтра, фильтры могут выстраиваться в цепочки. Виды фильтров:
- `first` - возвращает первый элемент из массива;
- `last` - возвращает последний элемент из массива;
- `get:'<свойство_индекс>'` - возвращает указанное свойство из объекта или массива;
- `capitalize` - возвращает строку, где первая буква прописная;
- `downcase` - возвращает строку, где только символы нижнего регистра;
- `upcase` - возвращает строку, где только символы верхнего регистра;
- `truncate`: <количество> - возвращает усеченную строку до указанного количества символов;
- `truncate_words: <количество>` - возвращает усеченную строку до указанного количества слов;
- `replace:'<искомая_строка_или_RegExp>','<строка_для_замены>'` - возвращает строку с замененными подстроками;
- `prepend: '<текст>'` - возвращает строку с текстом до;
- `append: '<текст>'` - возвращает строку с текстом после;
- `sort` - возвращает отсортированный массив;
- `sort_by:'<свойство>'` - возвращает отсортир;ованный массив объектов по указанному свойству
- `map:'<свойство>'` - возвращает массив из массива, в котором содержится указанное свойство из объектов.

```javascript
ejs.filters.<имя_фильтра>= function (<вводимое_значение>[, <параметр>[, ...]) {
    ...
    return <новое_значение>;
}
```
Создает собственный фильтр.

## Шаблонизатор Hogan (Mustache)

`var hogan = require('hogan.js');`

`var <шаблон> = hogan.compile('<содержимое_шаблона>');` - компилирует шаблон на основе текста и возвращает его.

`<шаблон>.render({'<переменная>': <значение>[, ...]}));` - возвращает результат шаблона на основе указанного шаблона с заданными переменными.

### Mustache-теги

`{{<переменная>}}` - выводит экранированное значение переменной.  
`{{{<переменная>}}}` или `{{&<переменная>}}` - выводит значение переменной.  
`{{!<комментарий>}}` - комментарий.  
`{{#<переменная>}} <текст> {{/<переменная>}}` - если переменная `<переменная>` не равна `false` или массив на который указывает переменная не пуст или, то отобразится секция.  
`{{#<переменная_массив>}} <текст>{{<ключ_текущего_элемента_из_массива>}}... {{/<переменная_массив>}}` - перебирает массив объектов из переменной, где в тело секции помещается по очереди элемент.  
`{{^<переменная>}} <текст> {{/<переменная>}}` - выполнится, если переменная указывает на массив, который пуст или переменная равна `false`, или если она не существует.

#### Лямбда-секции

`{{#<секция>}} <текст> {{/<секция>}}` - объявление произвольной секции.

`<шаблон>.render({'<переменная>': <значение>[, ...], <объект_секций>);` - возвращает результат шаблона с произвольными секциями, где `<объект_секций>` - это объект, где в виде ключей - имя секции `'<секция>'`, а значение - функция вида:  
`function () {... return function (text, render) {...return <новый_текст>;};}`, которая должна возвращать функцию для рендера секции, где в `text` помещается текст секции, а `render` - функция для стандартного рендеринга.

### Компоненты

`{{> <имя_подшаблона>}}` - передает текущий объект в указанный подшаблон.

```javascript
var <шаблон> = hogan.compile('<содержимое_шаблона>');
var <подшаблон> = hogan.compile('<содержимое_подшаблона>');

<шаблон>.render({'<переменная>': <значение>[, ...]},
    {<имя_подшаблона>: <подшаблон>[, ...]}
);
```
Возвращает результат шаблона на основе указанного шаблона с заданными переменными и подшаблонами.

## Шаблонизатор Jade

В Jade используются те же названия тегов, что и в HTML, но в Jade можно не применять открывающие и закрывающие символы (`<` и `>`), а уровень вложенности тегов разрешается выражать отступами.

`<тег>[.<CSSкласс>[....]][#<идентификатор>][(<атрибут>[=<значение>][, ...])]`

Если тег это `div`, то его можно не писать. После запятой можно ставить перенос строки.

`<тег>[...] [<содержимое тега>]`

Символ `|` перед содержимым позволяет разбивать содержимое построчно для удобства. Если HTML-тег, такой как `style` или `script`, принимает только текст (то есть вложенные HTML-элементы не допускаются) то символы `|` можно не писать. Добавление точки `.` после тега без пробела перед ней даёт понять компилятору Jade, что всё внутри данного тега является текстом.

Текстовые блоки должны быть дважды заэкранированы.

В случае блочного расширения после тега указывается двоеточие `:` что позволяет писать сразу новый тег на текущей строке.

```jade
div.movie-card#oceans-11
    h1(class="movie-title")
        | Ocean's
        | 11
    img(src="/img/oceans-11.png", class="movie-poster")
    ul.genre-list.genre-list-blue
        li Comedy
        li.
            Thriller
```

### Данные в Jade-шаблоне

`var jade = require('jade');`

`var <функция_шаблона> = jade.compile('<содержимое_шаблона>');` - компилирует шаблон на основе текста и возвращает его функцию.

`<функция_шаблона>({'<переменная>': <значение>[, ...]}));` - возвращает результат шаблона на основе указанного шаблона с заданными переменными.

### Jade-теги

`#{<переменная>}` - выводит значение переменной в содержимом тега.  
`<переменная>` - выводит значение переменной в теге.

### Программная логика в Jade-шаблонах

В Jade можно непосредственно внедрять в шаблоны строки JavaScript-кода.

Если предварить строку JavaScript-кода символом `-`, это приведет к выполнению JavaScript-кода без возвращения какого-либо значения в выводимых шаблоном данных.

Если же строку JavaScript-кода предварить символом `=`, возвращаемое этим кодом значение попадет в выводимые данные, причем оно будет экранировано для предотвращения XSS-атак.

Если же генерируемое JavaScript-кодом значение экранировать не нужно, можно предварить код символами `!=`.

`<переменная> = <значение>` - объявляет переменную.

Для вывода переменных необходимо использовать символы `= <переменная>` - экранировать или `!= <переменная>` для не экранирования, сразу после тега без пробела.

### Условные и итеративные инструкции

Их можно писать без префиксов. На них действует вложенность как в html для тегов.

`each <элемент> in <массив>` - используется для перебора массива, где в `<элемент>` помещается элемент массива.  
`each <значение>, <ключ> in <объект>` - используется для перебора объекта, где в `<значение>` помещается значение объекта, а в `<ключ>` его ключ.

`if <условие>` - дальнейший код выполниться если условие вернет `true`.

`unless <условие>` - дальнейший код выполниться если условие вернет `false`.

Конструкция выбора:

```jade
case <переменная>
    when <значение>
        <код_при_совпадении>
    ...
    default
        <код_по_ум>
```

### Наследование шаблонов

С помощью блоков при наследовании шаблонов задается место, в котором будет находиться контент, предоставляемый производным шаблоном.

`block <имя>` - объявление блока в родительском шаблоне.

`extends <имя_шаблона>` - экспортирует блоки в указанный шаблон, заменяя приэтом их.

Объявление блока с кодом:

```jade
block [append|]<имя>
    <код>
```

Если же блок в унаследованном шаблоне содержит контент, этот контент может не заменяться производными шаблонами, а наращиваться путем добавления блоков в начало и в конец шаблона.

`var <функция_шаблона> = jade.compile('<содержимое_шаблона>' {filename: '<имя_файла_шаблона>'});` - компилирует шаблон на основе текста и возвращает его функцию.

### Включение шаблонов

`include <имя_шаблона>` - включает шаблон в текущий шаблон, также можно включить имя файла.

### Примеси

Jade-команда `mixin` является аналогом JavaScript-функции. Как и функция, команда mixin может принимать аргументы, на основе которых генерируется Jade-код.

Объявление примеси:

```jade
mixin <имя_примеси>(<переменная>[, ...])
    <код_примеси>
```

`<имя_примеси>(<переменная>[, ...])` - вызывает примесь и помещает ее результат в текущее место.

## Построение собственных модулей

Главные свойства компонентов и подсистем программного обеспечения, в которые входит и модуль:
- **сцепленность** (*cohesion*): мера корреляции функций компонента между собой. Например, модуль, предназначенный для выполнения только одного действия, когда все его элементы подчинены решению одной задачи, обладает высокой сцепленностью.
    > Модуль, содержащий функции для сохранения объектов любого типа в базу данных, такие как saveProduct(), saveInvoice(), saveUser() и т. д., имеет низкую сцепленность;
- **связанность** (*coupling*): мера зависимости от других компонентов системы. Кроме того, два модуля, взаимодействующих через глобальное или общее состояние, также тесно связаны. С другой стороны, два модуля, взаимодействующих только через передачу параметров, слабо связаны.
    > Например, модуль тесно связан с другим модулем, если непосредственно читает или изменяет данные другого модуля.

Наиболее желательна высокая сцепленность при слабой связанности, что обеспечивает наглядность, возможность повторного использования и расширяемость модулей.

### Внедрение зависимостей Dependency Injection

Шаблон "**Внедрение зависимостей**" (**Dependency Injection** , **DI**) - основная идея шаблона внедрения зависимостей заключается в предоставлении компонента зависимости в качестве входных данных с помощью внешней сущности. Такой сущностью может быть клиентский компонент или глобальный контейнер, централизованно связывающий все модули системы. Основным преимуществом такого подхода является устранение тесных связей, особенно между модулями и экземплярами с состоянием. При использовании DI все зависимости не создаются внутри модуля, а передаются извне. Это означает, что модуль можно настроить на использование любых зависимостей и, следовательно, повторно использовать в различных контекстах.

Реорганизация модулей для использования DI заключается в следовании простому рецепту: заменить жесткие зависимости от экземпляров с состоянием фабрикой, получающей набор зависимостей в качестве аргументов.

Алгоритм использования:
1. Сначала загружаются фабрики служб; на данный момент они являются объектами без состояния;
2. Затем создается по экземпляру каждой из служб с передачей необходимых зависимостей. Это тот этап, где создаются и соединяются вместе все модули.

Дополнительные виды DI:
- **внедрение через параметры конструктора** - зависимости передаются в конструктор в момент создания объекта;
- **внедрение через свойства** - зависимости внедряются в объект после его создания.

### Локатор служб

Шаблон "**Локатор служб**" - основная идея заключается в наличии центрального реестра для управления компонентами системы, который выступает в качестве посредника при загрузке зависимости любым модулем. Суть в том, что вместо жесткого связывания зависимости запрашиваются у локатора служб.

Важно понимать, что при использовании локатора служб возникает зависимость от него самого, что определяет уровень сцепления модулей и, следовательно, возможность их повторного использования. В Node.js можно определять три вида локаторов служб, в зависимости от порядка подключения к компонентам системы:
- **жесткая зависимость от локатора служб** - подразумевает создание непосредственной ссылки на экземпляр локатора служб с помощью `require()`, это считается антишаблоном, так как приводит к образованию тесной связи с компонентом, предназначенным для ослабления связей;
- **внедрение локатора служб** - с использованием механизма DI;
- **глобальный локатор служб** - ссылка на локатор служб в глобальной области видимости. Имеет те же недостатки, что и жесткое связывание локатора служб, но, поскольку в этом случае локатор носит глобальный характер, то является настоящим объектом одиночкой и, следовательно, может совместно использоваться разными пакетами как общий экземпляр.

Пример локатора служб:

```javascript
module.exports = function () {
    const dependencies = {};
    const factories = {};
    const serviceLocator = {};

    serviceLocator.factory = (name, factory) => {
        factories[name] = factory;
    };
    serviceLocator.register = (name, instance) => {
        dependencies[name] = instance;
    };
    serviceLocator.get = (name) => {
            if(!dependencies[name]) {
                const factory = factories[name];
                dependencies[name] = factory && factory(serviceLocator);
                if(!dependencies[name]) {
                    throw new Error('Cannot find module: ' + name);
                }
            }
            return dependencies[name];
    };

    return serviceLocator;
};
```

Модуль `serviceLocator` является фабрикой, возвращающей объект с тремя методами:
- метод `factory()` используется для связывания имени компонента с фабрикой;
- метод `register()` используется для связывания имени компонента непосредственно с экземпляром;
- метод `get()` извлекает компонент по его имени. Если экземпляр уже доступен, метод просто возвращает его, в противном случае он пытается вызвать зарегистрированную фабрику для получения нового экземпляра.

Важно, что фабрики модулей вызываются путем внедрения текущего экземпляра локатора служб `serviceLocator`, который передается в каждый модуль в качестве параметра. Это основной механизм шаблона, который обеспечивает построение графа зависимостей автоматически или по требованию. Модули-фабрики должны быть вида:

```javascript
module.exports = function (serviceLocator) {
    const <модуль> = serviceLocator.get('<имя_зависимости>');
    ...
};
```

Локатор служб может использоваться для извлечения не только экземпляров компонентов, но и параметров конфигурации, определяющих поведение всего создаваемого графа зависимостей.

Использование в главном модуле:

```javascript
const <serviceLocator> = require('...serviceLocator')();
<serviceLocator>.register('<имя_зависимости>', <экземпляр>);
<serviceLocator>.factory('<имя_зависимости>', require('<путь_к_модулю>'));
```

Минусы:
- затрудняет определение взаимосвязей между компонентами, поскольку они разрешаются во время выполнения;
- компоненты, полагающиеся на локатор служб, хуже подходят для повторного использования, поскольку требуют доступности в системе локатора служб;
- усложняет понимание, какую именно зависимость конкретный компонент собирается затребовать.

### Контейнер внедрения зависимостей, DI-контейнер

DI-контейнер, по сути, представляет собой локатор служб с одной дополнительной функцией, определяющей зависимости модуля до создания его экземпляра. Для этого модуль должен объявить свои зависимости одним из способов:
- внедрить набор зависимостей, опираясь на имена аргументов фабрики или конструктора:  
`module.exports = (<имя1>[, <имя2>[, ...]]) => {...}`, чтобы получить возможность прочитать имена аргументов функции необходимо сериализовать функцию и получить ее исходный код. Для этого достаточно вызвать метод `toString()` ссылки на функцию и получить список аргументов с помощью регулярных выражений, имя должно полностью соответсвовать зависимости;
- В фабричную функцию можно добавить специальное свойство, например массив, явно перечисляющий все зависимости для внедрения:  
`module.exports = (<имя1>[, <имя2>[, ...]]) => {...};`  
`module.exports._inject = ['<зависимость1>'[, '<зависимость2>' [, ...]]];`
- Модуль можно описать как массив имен зависимостей, за которыми следует фабричная функция:  
`module.exports = ['<зависимость1>'[, '<зависимость2>'[, ...]], (<имя1> [, <имя2> [, ...]]) => {...}];`
- Можно использовать аннотацию в виде комментария, добавляемую к каждому аргументу функции:  
`module.exports = (<имя1> /*<зависимость1>*/[, <имя2> /*<зависимость2>*/[, ...]]) => {...};`

Пример DI-контейнера:

```javascript
module.exports = function () {
    const dependencies = {};
    const factories = {};
    const serviceLocator = {};

    diContainer.factory = (name, factory) => {
        factories[name] = factory;
    };
    diContainer.register = (name, instance) => {
        dependencies[name] = instance;
    };
    diContainer.get = (name) => {
        if(!dependencies[name]) {
            const factory = factories[name];
            dependencies[name] = factory && diContainer.inject(factory);
            if(!dependencies[name]) {
                throw new Error('Cannot find module: ' + name);
            }
        }
        return dependencies[name];
    };
    diContainer.inject = (factory) => {
        const args = <функция_вычленения_зависимостей>(factory)
        .map(dependency => diContainer.get(dependency));
            return factory.apply(null, args);
        };
        return diContainer;
    };
```

Модуль `diContainer` является фабрикой, похожим по строению на `serviceLocator`, возвращающей объект с дополнительными методами:
- метод `inject()` используется для определения зависимостей модуля и использующий их для вызова фабрики.

Логика его работы:
1. С помощью функции `<функция_вычленения_зависимостей>` извлекается список аргументов указанной фабричной функции;
2. Затем имя каждого аргумента отображается в экземпляр зависимости, полученный с помощью метода `get()`;
3. В завершение полученный список зависимостей просто передается в вызов фабрики.

Использование в главном модуле:

```javascript
const <diContainer> = require('...diContainer')();
<diContainer>.register('<имя_зависимости>', <экземпляр>);
<diContainer>.factory('<имя_зависимости>', require('<путь_к_модулю>'));
```

### Плагины

Часто в Node.js плагины приложения устанавливаются как пакеты в каталог `node_modules` проекта. Этот способ имеет два преимущества:
- появляется возможность использовать npm для распространения плагинов и управления их зависимостями;
- пакет может иметь собственный граф зависимостей, что снижает вероятность конфликтов и несовместимостей между зависимостями, поскольку плагин не использует зависимости родительского проекта.

Вот как выглядит структура каталогов приложения с плагинами-пакетами:
```
application
'-- node_modules
 |-- plugin1
 |-- ...
 '-- pluginN
```

Расширение, управляемое плагинами и приложением:
- **расширение, управляемое плагином**, является более мощным и гибким, так как часто открывает доступ к внутренним компонентам приложения и дает больше свободы, как если бы плагин был частью самого приложения. Но иногда это может приводить к увеличению ответственности, не давая никаких преимуществ. В самом деле, любое изменение в приложении может влиять на плагин, что требует постоянного его обновления по мере развития основного приложения. В плагин передается само приложение;
- **расширение, управляемое приложением**, требует организации инфраструктуры управления плагинами в самом приложении. Когда расширение управляется плагинами, единственным требованием является поддержка определенного способа расширения компонентами приложения. Из плагина берутся методы и значения и подключаются в определенных местах приложения.

## Подключение модулей, инициализируемых асинхронно

Используется для модулей у которых длительная инициализация.

Для этого используется шаблон "Прокси", в который оборачивается оригинальный модуль и в нем используется шаблон "Состояние", которое состоит из двух частей:
- для постановки в очередь всех операций, пока модуль не ини­циализирован, которые используют шаблон "Комманда";
- для передачи операций оригинальному модулю после завершения его инициализации.

Вся работа с оригинальным модулем происходит через прокси объект. Прокси-объект изначально имеет состояние, которое помещает все все вызовы методов как команды в очередь, пока инициализация не завершится.

Вызов инициализуруешего метода запускает инициализацию оригинального модуля, передавая метод прокси-объекта как функцию обратного вызова. Это позволяет обертке узнать, когда завершится инициализация оригинального модуля, и выполнить следующие операции:
1. Присвоить переменной, которая отвечает за состояние объект следующего состояния, который работает напрямую с оригинальным модулем или есть сам оригинальный модуль;
2. Выполнить все команды, хранящиеся в очереди;
3. Вызвать оригинальную функцию обратного вызова.

## Группировка асинхронных операций

Сама идея очень проста и заключается в том, чтобы при вызове асинхронной функ­ции в момент, когда аналогичный вызов уже находится в режиме ожидания, присо­единить обратный вызов к уже выполняемой операции, а не создавать новый запрос.

Преобразовать от:

    +----------+  +----------+  +----------------------+  +----------------------+
    | Клиент A |  | Клиент Б |  | Асинхронная операция |  | Асинхронная операция |
    +----------+  +----------+  +----------------------+  +----------------------+
          | запрос с данными                |                         |
          |================================>|                         |
          |             | запрос с теми же данными                    |
          |             |============================================>|
          | ответ       |                   |                         |
          |<--------------------------------|                         |
          |             | ответ             |                         |
          |             |<--------------------------------------------|
    +----------+  +----------+  +----------------------+  +----------------------+
    | Клиент A |  | Клиент Б |  | Асинхронная операция |  | Асинхронная операция |
    +----------+  +----------+  +----------------------+  +----------------------+

К:

    +----------+  +----------+         +----------------------+
    | Клиент A |  | Клиент Б |         | Асинхронная операция |
    +----------+  +----------+         +----------------------+
          | запрос с данными                       |
          |=======================================>|
          |             | запрос с теми же данными |
          |             |=========================>|
          |             |                #---------------------#
          |             |                # Присоединения к     #
          |             |                # запущенной операции #
          |             |                #---------------------#
          | ответ       |                          |
          |<---------------------------------------|
          |             | ответ                    |
          |             |<-------------------------|
    +----------+  +----------+         +----------------------+
    | Клиент A |  | Клиент Б |         | Асинхронная операция |
    +----------+  +----------+         +----------------------+

Для этого используется шаблон "Прокси", который реализует проксирование оригинального программно­го интерфейса для каждой функции и действует следующим образом:
1. Если очередь для заданной функции с конкретными параметрами уже существует, значит, в настоя­щее время обрабатывается запрос для заданной функции с конкретными параметрами. В таком случае достаточно добавить обратный вызов в существующую очередь и немед­ленно вернуть управление. Ничего больше не потребуется;
2. Если очередь для заданной функции с конкретными параметрами отсутствует, необходимо создать новый за­прос. Для этого создается новая очередь для заданной функции с конкретными параметрами, куда помещается текущая функция обратного вызова. Затем вызывается оригиналь­ный программный интерфейс, его функция;
3. После, когда оригинальная функция вернет управление, выпол­няются обход и вызов всех функций в очереди с передачей им результата опе­рации.

Шаблон группировки запросов наиболее эффективен в высоконагруженных приложениях с медленным программным интерфейсом, поскольку именно в этих обстоятельствах имеется возможность группировать наибольшее число запросов.

Можно использовать объект `Promise`, так как к нему можно подключить несколько обработчиков `then()` и он уже кэширует вычисленное значение, что обеспечивает естественный механизм возврата кэшированного значения асин­хронным образом. В него оборачивается заданая функция.

Одна из проблем шаблона группировки запросов заключается в том, что чем быстрее работает программный интерфейс, тем меньше запросов можно сгруппировать. То нет никакого смысла пытаться его оптимизировать, но он по-прежнему расходует ресурсы прило­жения, что в конечном итоге может иметь существенное значение.

## Кэширование асинхронных запросов

Его идея проста и заключается в том, чтобы сохранить результат запроса в кэше, который может быть переменной, записью в базе данных или записью в специализи­рованном сервере кэширования. Тогда при следующем обращении результат можно извлечь непосредственно из кэша, не инициируя нового запроса.

В асинхронном про­граммировании этот шаблон отличается дополнительной поддержкой группиров­ки запросов, что делает его более эффективным. Причина включения такой под­держки - в том, что одновременно может обрабатываться несколько запросов, пока кэш еще не создан, и по завершении этих запросов кэш будет сохранен несколь­ко раз.

Два этапа работы алгоритма оптимального асинхронного кэ­ширования:
- первый этап полностью идентичен шаблону группировки. Любые запросы, по­лученные в моменты времени, пока кэш еще не создан, объединяются в группу. После обработки запроса кэш сохраняется только один раз;
- если кэш уже создан, все последующие запросы будет обслуживаться непо­средственно из него.

Кеш должен очищаться через время или при изменении данных на которые он ссылается.

Основные механизмы по использованию кэша:
- большое количество кэшированных значений может потреблять слишком мно­го памяти. В этом случае избежать чрезмерных затрат памяти поможет при­менение алгоритма **вытеснения давно неиспользуемых**;
- когда приложение выполняется как группа процессов, использование обычных переменных для хранения кэша может привести к возврату разных результа­тов разными экземплярами сервера. Если это нежелательно, решить данную проблему можно, использовав для кэша общее хранилище;
- очистка кэша вручную, в отличие от использования механизма истечения сро­ка действия, продлевает существование кэша и при этом позволяет возвращать более актуальные данные, но таким кэшем сложнее управлять.

**Мемоизация** - один из способов кэширования, когда в кэше сохраняются результаты выполнения функции.

Можно использовать объект `Promise`, также как и в группировке асинхронных операций, так как он кэширует результат.

## Использование нескольких процессов

Основные шаги по реализации делегирования задач:
1. Создать новый модуль, создающий пул процессов. Запуск ново­го процесса является достаточно затратным в отношении ресурсов и времени, поэтому наличие пула работающих процессов, готовых к обработке запросов, позволит сэкономить время и ресурсы центрального процессора. Кроме того, пул поможет ограничить число одновременно выполняющихся процессов, что позволит исключить риск атак отказ в обслуживании (*denial-of-service*, *DoS*);
2. Создать модуль, отвечающий за абстрагирование задач, выполняемого в дочернем процессе. Его задача - взаимодействие с дочерним процессом и вывод результатов в той форме, как если бы они посту­пали из текущего приложения;
3. Создать рабочий (дочерний) процесс - программу Node.js, предна­значенную только для выполнения алгоритма извлечения подмножеств с задан­ной суммой элементов и передачи результатов родительскому процессу.

Реализация пула процессов:

```javascript
const child_process = require('child_process');

class ProcessPool {
    constructor(file, poolMax) {
        this.file = file;
        this.poolMax = poolMax;
        this.pool = [];
        this.active = [];
        this.waiting = [];
    }

    acquire(callback) {
        let worker;
        if(this.pool.length > 0) {
            worker = this.pool.pop();
            this.active.push(worker);
            return process.nextTick(callback.bind(null, null, worker));
        }

        if(this.active.length >= this.poolMax) {
            return this.waiting.push(callback);
        }

        worker = child_process.fork(this.file);
        this.active.push(worker);
        process.nextTick(callback.bind(null, null, worker));
    }

    release(worker) {
        if(this.waiting.length > 0) {
            const waitingCallback = this.waiting.shift();
            waitingCallback(null, worker);
        }
        this.active = this.active.filter(w => worker !== w);
        this.pool.push(worker);
    }
}
```

Где:
- `file` - файл с программой для запуска;
- `poolMax` - макси­мальное количество запущенных экземпляров в пуле;
- `pool` - список готовых к использованию запущенных процессов;
- `active` - список используемых в настоящее время процессов;
- `waiting` - очередь функций обратного вызова для всех запросов, которые не могут быть выполнены немедленно из-за отсутствия доступных процессов;
- `acquire` - возвращающий го­товый к использованию процесс, алгоритм его работы:
    - если в пуле имеется готовый к использованию процесс, он просто перемещается в список `active`, а затем возвращается вызовом функции `callback`;
    - если в пуле нет доступных процессов и достигнуто максимальное число запу­щенных процессов, нужно пождать, пока один из них освободится. Для этого текущий обратный вызов помещается в список `waiting`;
    - если еще не достигнуто максимальное число запущенных процессов, вызовом функции `child_process.fork()` создается новый процесс и добавляется в список `active` с последующим возвратом этого процесса с помощью функции `callback`;
- `release` - возвращает процесс обратно в пул, алгоритм его работы:
    - если в списке `waiting` имеется запрос, выполняется переназначение освобо­дившегося рабочего процесса путем передачи ему обратного вызова из начала очереди `waiting`;
    - в противном случае рабочий процесс исключается из списка `active` и помеща­ется обратно в пул.

Чтобы уменьшить объем памяти, не используемой долгое время, и повысить надежность пула, можно:
- уничтожать процессы, простаивающие определенное время, для высвобожде­ния памяти;
- добавить механизм уничтожения зависших процессов или перезапуска тех из них, в работе которых возник сбой.

Взаимодействие сдочерним процессом:

```javascript
const ProcessPool = require('./processPool');
const workers = new ProcessPool(__dirname + '<файл_с_программой>', <макс_кол_экземпляров>);

workers.acquire((err, worker) => {
    worker.send(<объект_с_данными_для_задачи>);//отправка сообщения с исходными данными дочернему процессу

    const onMessage = msg => {//рабочий процесс генерирует сообщения в формате {event, data}
        if (msg.event === 'end') {//обработка завершения операции по событию end
            worker.removeListener('message', onMessage);
            workers.release(worker);
        }
        //дальнейшая обработка данных из процесса
    };
    worker.on('message', onMessage);//подключение функции для приема сообщений, возвращаемых рабочим процессом
});
```

Взаимодействие с родительским процессом:

```javascript
process.on('message', msg => {
    //обработка сообщения, поступающие от родительско­го процесса
    process.send({event: 'end', data: <данные>});//отправка родительскому процессу данных в формате {event, data}
});
```

> **DoS-атака** - это попытка сделать машину или сетевой ресурс недоступным для предполагаемых пользователей, чтобы временно или постоянно отключить или приостановить службу, действующую на подключенном к Интернету узле.

## Масштабирование приложений

**Распределение нагрузки** - технология распределения нагрузки приложе­ния между несколькими процессами и машинами.

Модель **куб масштабирования** описывает мас­штабируемость с точки зрения трех размерностей:
- *ось x* - клонирование - заключается в клонировании одного и того же приложения n раз, что позволяет каждому экземпляру обрабатывать 1/n-часть ра­бочей нагрузки;
- *ось y* - разделение на службы/функциональные особенности - обозначает декомпозицию приложений по функ­циональным особенностям, службам или вариантам использования. Предполагает создание разных автономных приложений, каждое из которых обладает собственной базой кода, а иногда и выделенной базой данных и даже отдельным пользовательским интерфейсом, чаще всего ассоциируется с термином "**микрослужбы**";
- *ось z* - разбиение на разделы данных - определяет такое разбиение приложения, что каждый из его экземпляров отвечает только за часть все­го массива данных. Этот метод используется в основном для баз данных и по-другому называется **горизонтальным разделением**, или **шардингом** (*sharding*). Каждый из разделов соотносит­ся с конкретным экземпляром приложения. Использование разделов данных требует перед каждой операцией определять, какой именно экземпляр приложения отвечает за нужный раздел данных. Виды разбиения на разделы данных:
    - **списочное разделение**;
    - **диапазонное раз­деление**;
    - **хешевое разделение**.

Нижний левый угол куба представляет приложения, все функциональные воз­можности и службы которых сосредоточены в единой (монолитной) базе кода, выполняющейся в одном экземпляре.

### Клонирование и распределение нагрузки

Приложению Node.js досту­пен один поток и ему по умолчанию доступен ограниченный объем памяти 1,7 ГБ на 64-битных машинах (этот предел можно увеличить с помощью специального пара­метра командной строки `--max_old_space_size=<размер_в_МБ>`).

Виды масштабирования:
- **вертикальное масштабирование** - наращивание ресурсов одной машины;
- **горизонтальное масштабирование** - добавление в инфраструктуру дополнительных машин.

С помощью модуля `cluster` можно обеспечить **отказоустойчивость и высокую доступность**. Главная точка входа оборачивается в модуль, который подключается с помощью: `cluster.fork(<путь_к_модулю>);` и проверяется в главном кластере событие и если подтверждается что процесс завершился из-за ошибки, запускается новый рабочий процесс:

```javascript
cluster.on('exit', (worker, code) => {
    if(code != 0 && !worker.suicide) {
        cluster.fork();
    }
});
```

**Перезапуск без простоя** можно организовать с помощью модуля `cluster`. Суть решения за­ключается в том, чтобы перезапускать рабочие процессы по одному. В этом случае остальные рабочие процессы продолжат выполняться и обслуживать приложение. Основной алгорит работы:
1. Перезапуск рабочих процессов начинается после получения сигнала, указывающего на перезапуск;
2. Создается функция `restartWorker()`, которая реализует шаблон асинхронных последователь­ных итераций по элементам объекта `cluster.workers` и замыкается на нем;
3. Первая задача функции `restartWorker()` - безопасно остановить рабочий про­цесс вызовом метода `worker.disconnect()`;
4. После завершения процесса запускается новый рабочий процесс:
    ```javascript
    worker.on('exit', () => {
        if (!worker.suicide) return;
        const newWorker = cluster.fork();
        newWorker.on('listening', () => {
            restartWorker(i + 1);
        });
    });
    ```
5. Только когда новый рабочий процесс будет готов к приему новых соединений, по событию `'listening'`, можно перейти к следующей итерации и приступить к перезапуску очередного рабочего процесса.

**Взаимодействия с сохранением состояния** можно организовать с помощью:
- **совместного использования состояния всеми экземплярами** - для этого потребуется общее хранилище данных;
- **распределением нагрузки с привязкой** - когда балансировщик нагрузки получает запрос на соз­дание нового сеанса, он связывает этот сеанс с одним конкретным экземпляром, вы­бранным алгоритмом распределения нагрузки. В следующий раз, получив запрос в рамках того же сеанса, балансировщик минует алгоритм распределения нагрузки и выберет тот экземпляр приложения, который был ранее связан с сеансом. Главная проблема заключается в том, что оно сводит на нет преимущества избыточной системы, где все экземпляры при­ложения равноценные и где любой из экземпляров может заменить тот, что перестал работать.

**Масштабирование с помощью обратного проксирования** является запуск нескольких авто­номных экземпляров одного и того же приложения, прослушивающих разные порты или выполняющихся на разных машинах, и использование **обратного прокси-сер­вера** (или шлюза) для доступа к этим экземплярам и распределения трафика между ними. В такой конфигурации отсутствует главный процесс, распределяющий запро­сы между рабочими процессами, вместо этого имеется множество автономных про­цессов, запущенных на одном компьютере (и прослушивающих разные порты) или разбросанных по нескольким компьютерам в сети. Роль единой точки доступа к при­ложению играет **обратный прокси-сервер** - специальное устройство или служба, - находящийся между клиентами и экземплярами приложения, который принимает все запросы, передает их конечному серверу и возвращает результат клиенту, как будто он сам его создал. В этом случае обратный прокси-сервер используется так­же в качестве балансировщика нагрузки, распределяя запросы между экземплярами приложения.

**Динамическое масштабирование** - если приложение снижает производительность из-за роста нагрузки, автоматически подключаются серверы, помогающие справиться с этой повышенной нагрузкой. Поддерживается также возможность остановки не­которых серверов в определенные часы, например ночью, когда трафик существенно меньше, и запуска их снова по утрам. Этот механизм требует распределения нагрузки в зависимости от актуальной топологии сети, чтобы знать, когда следует запускать серверы.

**Реестром служб** - хранит информацию о действующих серверах и предоставляемых ими услугах, т.е. используется как центральное хранилище актуальных данных о доступных в системе серверах и службах. Для работы в автоматическом режиме все экземпляры приложения должны ре­гистрироваться в реестре после перехода в состояние готовности принимать запросы и отменять регистрацию перед завершением работы. Благодаря этому балансировщик нагрузки всегда обладает актуальными сведениями о доступных серверах и службах.

### Динамическое распределение нагрузки с помощью http-proxy и Consul

Основные пакеты:
- `http-proxy` - библиотека, упрощающая создание прокси-серверов и средства распределения нагрузки на платформе Node.js;
- `portfinder` - библиотека, помогающая об­наруживать свободные порты в системе;
- `consul` - библиотека, обеспечивающая регист­рацию служб в реестре Consul.

Файл `app.js`:

```javascript
const http = require('http');
const pid = process.pid;
const consul = require('consul')();
const portfinder = require('portfinder');
const serviceType = process.argv[2];

portfinder.getPort((err, port) => {
    const serviceId = serviceType + port;
    consul.agent.service.register({
        id: serviceId,
        name: serviceType,
        address: 'localhost',
        port: port,
        tags: [serviceType]
    }, () => {
        const unregisterService = (err) => {
            consul.agent.service.deregister(serviceId, () => {
                process.exit(err ? 1 : 0);
            });
        };
        process.on('exit', unregisterService);
        process.on('SIGINT', unregisterService);
        process.on('uncaughtException', unregisterService);

        http.createServer((req, res) => {
            for (let i = 1e7; i> 0; i--) {}
            console.log(`Handling request from ${pid}`);
            res.end(`${serviceType} response from ${pid}\n`);
        }).listen(port, () => {
            console.log(`Started ${serviceType} (${pid}) on port ${port}`);
        });
    });
});
```

Отвечает за отдельный сервер, где:
- `portfinder.getPort` - вызывается чтобы получить свободный порт (по умолчанию `portfinder` начинает поиск с порта 8000);
- `consul.agent.service.register` - выполняется регистрация новой службы в реестре. Где:
    - `id` - уникальное имя службы;
    - `name` - общее имя, идентифицирующее службу;
    - `address` и `port` - адрес и порт для доступа к службе;
    - `tags` - необязательный массив тегов, используемый для фильтрации и группировки служб.
- `unregisterService` - функция, которая позволит удалить службу, зарегистрированнyю в реестре Consul, которая вызывается в момент завершения программы (на­меренного или случайного), для отмены регистрации в реестре служб Consul;
- в конце выполняется запуск HTTP-сервера, прослушивающего порт, обна­руженный с помощью `portfinder`.

Файл `loadBalancer.js`:

```javascript
const routing = [
    {
        path: '/api',
        service: 'api-service',
        index: 0
    },
    {
        path: '/',
        service: 'webapp-service',
        index: 0
    }
];

const http = require('http');
const httpProxy = require('http-proxy');
const consul = require('consul')();

const proxy = httpProxy.createProxyServer({});
http.createServer((req, res) => {
    let route;
    routing.some(entry => { // [2]
        route = entry;
        return req.url.indexOf(route.path) === 0;
    });

    consul.agent.service.list((err, services) => { // [3]
        const servers = [];
        Object.keys(services).filter(id => { //
            if (services[id].Tags.indexOf(route.service) > -1) {
                servers.push(`http://${services[id].Address}:${services[id].Port}`)
            }
        });

        if (!servers.length) {
            res.writeHead(502);
            return res.end('Bad gateway');
        }

        route.index = (route.index + 1) % servers.length; // [4]
        proxy.web(req, res, {target: servers[route.index]});
    });
}).listen(8080, () => console.log('Load balancer started on port 8080'));
```

Отвечает за сервер отвечающий за распределение нагрузки, это главный сервер, который контролирует все службы, где:
- `routing` - содержит таблицу соответствия URL-путей и служб, где:
    - `path` - путь (адрес);
    - `service` - имя службы;
    - `index` - указывает на следующий сервер в списке, в соответствии с циклическим алгоритмом;
- `routing.some` - выполняется поиск URL-адреса в таблице маршрутизации. В результате извлекается дескриптор, содержащий имя службы;
- `consul.agent.service.list` - извлекается список серверов, реализующих требуе­мые службы. Если этот список пуст, клиенту возвращается ошибка. Атрибут Tag используется для фильтрации всех доступных служб и поиска адресов серверов, реализующих данный вид службы;
- `route.index` - изменяется так чтобы он указывал на следующий сервер в списке;
- `proxy.web` - обеспечивает отправку запроса выбранному серверу вместе с объектами запроса (`req`) и ответа (`res`).

Запуск:

```bash
# запуск реестра служб
consul agent -dev
# запуск балансировщика нагрузки
node loadBalancer
# запуск нескольких экземпляров служб
forever start app.js api-service
forever start app.js api-service
forever start app.js webapp-service
```

Таким образом можно масштабировать инфра­структуру динамически, по требованию или по расписанию, и балансировщик на­грузки будет автоматически корректировать свою работу в соответствии с новой конфигурацией.

### Одноранговое распределение нагрузки

Оно состоит в том что распределять запросы будет клиент, который будет отвечать за распределение нагрузки между различными экземплярами служб. Тогда клиент будет знать подробности реализации серверов, предоставляющих службы, что во внутренней сети является обычной практикой. Обеспечивает следующие преимущества:
- снижение сложности инфраструктуры путем удаления сетевого узла;
- ускорение взаимодействий, поскольку маршрут передачи сообщений сокраща­ется на один узел;
- улучшение масштабирования, так как производительность не ограничиваетсявозможностями балансировщика нагрузки.

Недостатки:
- исключение обратного прокси-сервера приводит к раскрытию всей сложной внутренней инфраструктуры;
- возлага­ется реализация алгоритма распределения нагрузки;
- возлага­ется хранение ак­туальных сведений об инфраструктуре.

Файл `balancedRequest.js`:

```javascript
const http = require('http');
const servers = [
    {host: 'localhost', port: '8081'},
    {host: 'localhost', port: '8082'}
];
let i = 0;
module.exports = (options, callback) => {
    i = (i + 1) % servers.length;
    options.hostname = servers[i].host;
    options.port = servers[i].port;
    return http.request(options, callback);
};
```

Обертывает ори­гинальный программный интерфейс `http.request` и подменяет значения `hostname` и `port` в запросе значениями, выбранными из списка доступных серверов `servers` с помощью циклического алгоритма.

Файл `client.js`:

```javascript
const request = require('./balancedRequest');

for(let i = 10; i>= 0; i--) {
    request({method: 'GET', path: '/'}, res => {
        let str = '';
        res.on('data', chunk => {
            str += chunk;
        }).on('end', () => {
            console.log(str);
        });
    }).end();
}
```

Использование однорангово распределения нагрузки.

Запуск:

```bash
# запуск нескольких экземпляров служб
node app 8081
node app 8082
# запуск клиента
node client
```

### Декомпозиция сложных приложений

Основные минусы **монолитной архитектуры**:
- все модули, по сути, являются частью одной и той же базы кода и запускаются как часть
единого приложения;
- сбой в любом из компонентов, например неперехваченное ис­ключение, может привести к краху всего приложения;
- модули находятся в тесной взаимосвязи, потому что границы между ними не всегда явно очерчены и часто игно­рируются;
- сложный граф зависимостей означает, что каждый компонент системы является критически важным; он должен поддерживаться на протяжении всего срока существования приложения, и внесение в него любых из­менений необходимо тщательно продумывать.

**Архитектура на микрослужбах** - основная идея заключается в том, чтобы разделить приложение на основные компонен­ты, поместив их в отдельные, независимые приложения - *любая программа должна делать что-то одно, но делать это хорошо*.

Основные факторы при проектировании архитектуры на микрослужбах:
- слабая связанность;
- высокая сцепленность;
- сложность интеграции.

Плюсы микрослужб:
- **снижение важности служб** - изоляция системы в целом от сбоев и ошибок и возможность внесения важных изменений, создании полностью независимых небольших служб, которые легко изменять и можно даже создавать заново на другом языке и при этом остальные службы и приложение от этого не пострадает;
- **повторное использование на разных платформах и языках** - позволяет создавать независимые единицы, которые без особых усилий могут повторно использоваться;
- **уровень сокрытия информации обычно намного выше** - благодаря тому, что вза­имодействие обычно происходит через удаленный интерфейс, например через вебслужбу или брокера сообщений, что значительно упрощает сокрытие деталей реали­зации и ограждает клиента от влияния изменений в реализации или развертывании службы.
- **легкость масштабирования**.

Минусы микрослужб:
- высокая сложность интеграции, развертывания и совместного использования кода;
- взаимодействие служб.

### Шаблоны интеграции в архитектуре на микрослужбах

#### Прокси-сервер для служб

**Прокси-сервер для служб** (**шлюз доступа к службам**) - это сервер, который управляет взаимодей­ствиями между клиентом и рядом удаленных служб. Основным назначением является обеспечение единой точкой до­ступа для нескольких служб, но также может поддерживать распределение нагрузки, кэширование, аутентификацию и ограничение трафика, что иногда очень полезно для реализации полноценного решения. Это, по сути, обратный прокси-сервер. Не вникает в детали служб. Применение прокси-сервера помогает скрыть сложность базовой инфраструктуры.

```
                        |   |   |   |   |           <- запросы
                    +-------------------------+
                    | Прокси-сервер для служб |
                    +-------------------------+
                        |           |   ...     
        +---------------+           |
        |                 +---------+-----+
        |                 |               |
    +---------+     +-----------+   +-----------+
    | Служба1 |     | Служба2.1 |   | Служба2.1 |
    +---------+     +-----------+   +-----------+
```

#### Координация служб

**Координация служб** - идея заключается в том, чтобы создать абст­ракции для объединения обобщенных элементов данных и функций в реализации конкретных служб. Т.е. берутся операции из различных служб и собирается новый программный интерфейс, координирующий работу служб для поддержания всей си­стемы в согласованном состоянии. Координатор занимается семантической интеграцией служб и час­то поддерживает программный интерфейс, отличающийся от интерфейсов базовых служб. Основной минус его в том, что слишком много знает и за слишком многое отвечает, что обычно приводит к образованию жестких связей, слабой сцепленности и, самое главное, к большой сложности.

```
    +----------------------------------------+
    | Внешний интерфейс                      |  <- Приложение
    +----------------------------------------+
                        |
                        v
    +----------------------------------------+
    | Программный интерфейс слоя координации |  <- Координатор служб
    | Методы:                                |
    | +----------+  +----------+  +--------+ |
    | | Метод1() |  | Метод2() |  |   ...  | |
    | +-|-|-|----+  +----------+  +--------+ |
    +---|-|-|--------------------------------+
        | | |                                   <- Запросы операций служб
        | | +---------------------------+       
        | +-------------+               |       
        v               v               v
    +---------+    +---------+    +---------+
    | Служба1 |    | Служба2 |    | Служба3 |
    +---------+    +---------+    +---------+
```

#### Интеграция с помощью брокера сообщений

**Брокер сообщений** - система, отделяющая от­правителей сообщений от получателей, - позволяющего реализовать шаблон центра­лизованной публикации/подписки, практически шаблон наблюдателя для распреде­ленных систем. Распределяет между службами ответственность за синхронизацию информации во всей системе. Цель прежде всего заключается в том, чтобы каждая служба была изолированной, имела возможность работать отдельно от остальных служб или в сочетании с новыми службами и узлами.

Ответственность за распространение информации для со­гласования данных распределена между службами. Здесь нет вездесущей службы, обязанной знать механизм всей системы, и каждая служба отвечает за свой участок интеграции. Является основополагающим элементом для отделения служб и снижения сложности их взаимодействий.

```
    +----------------------------------------+
    | Внешний интерфейс                      |  <- Приложение
    +----------------------------------------+
            |                                   <- Запросы операций служб
            v
    +-----------------------+   +---------+
    | Служба1               |   | Служба2 |
    | Методы:               |   | Методы: |
    | +----------+  +-----+ |   | ...     |
    | | Метод1() |  | ... | |   |         |
    | +-|--------+  +-----+ |   |         |
    +---|-------------------+   +---------+
        |                            ^       
        | <- Публикация события      | <- Оповещение о событии
        |                            |
        v                            |
    +----------------------------------------+
    | Брокер сообщений                       |  
    +----------------------------------------+
```

## Шаблоны обмена сообщениями и интеграции

### Шаблоны однонаправленного обмена и вида "Запрос/ответ"

Основополагающим свойством системы обмена сообщениями является направлен­ность связи, которая обычно определяется ее семантикой.

```
    +-----------+    запрос  +------+
    | Инициатор | ---------> | Узел |
    |           |    ответ   |      |
    |           | <--------- |      |
    +-----------+            +------+
```

**Сообщения** - являются средством связи между различными программ­ными компонентами. Содержимое сообщения также может меняться в зависимости от его на­значения.

Типы сообщений:
- **сообщение-команда** - является сериализованным объ­ектом команды. Цель - инициировать выполнение действия или задания в приемнике. Для этого сообщение должно содержать информацию, необходимую для выполнения задания, которая, как правило, состоит из имени операции и списка аргументов. Со­общения-команды можно использовать при реализации системы **вызова удаленных процедур** (*Remote Procedure Call*, *RPC*), распределенных вычислений или просто для запроса данных;
- **сообщение-событие** - используется для уведомления другого компонента о происхо­дящем. Обычно такие сообщения содержат тип события и иногда некоторые подроб­ности, такие как контекст, тема или вовлеченный участник. Использование событий является очень важным ме­ханизмом интеграции в распределенных приложениях, поскольку позволяет сохра­нить все узлы системы в согласованном состоянии;
- **сообщения-документы** - главным образом предназначены для передачи данных меж­ду компонентами и компьютерами. Основным отличием сообщений-документов от сообщений-команд (которые тоже могут содержать данные) является отсутствие ка­кой-либо информации, указывающей получателю, что делать с данными. С другой стороны, главное отличие сообщений-документов от сообщений-событий заключает­ся в отсутствии в документах привязки к конкретному происшедшему событию. За­частую ответами на команды являются документы, поскольку они обычно содержат только запрашиваемые данные или результаты операции.

#### Очереди сообщений

**Очереди сообщений** - компоненты, которые являются посредниками между отправителем и получателем, хранящими сообщения, пока они не будут до­ставлены до места назначения.

Если по какой-либо причине получатель завершит работу, отключится от сети или окажется под высокой нагрузкой, сообщения будут накапливаться в очереди и пере­даны получателю, когда он вернется в сеть и восстановит свою работоспособность.

Очередь может находиться внутри отправителя, охватывать отправителя и получате­ля или быть помещена в выделенную внешнюю систему, действующую независимо, как промежуточное программное обеспечение для организации связи.

#### Обмен сообщениями через брокера

Брокер избавляет узлы за доставку со­общения получателю и о том что узлы должны знать адрес и порт приемника, а также согласовать форматы протоколов и сообщений, делая их независимыми и способными общаться с произволь­ным количеством других узлов, о которых им ничего не известно. Кроме того, брокер может служить мостом при использовании разных протоколов.

Протоколы прикладного уровня и основаны на протоколе TCP/IP:
- **MQTT** (*Message Queue Telemetry Transport*) - легковесный протокол обмена сообщениями, специально разработанный для связи между компьютерами;
- **AMQP** (*Advanced Message Queuing Protocol*) - более сложный протокол, который проектировался как открытая альтернатива проприетарной реализации обмена сообщениями;
- **STOMP** (*Simple/Streaming Text Orientated Messaging Protocol*) - легковесный текстовый протокол в стиле HTTP.

Уровни качества обслуживания:
- **QoS0, не более одного раза** - по-другому называется "послать и забыть", то есть сообщение не сохраняется и доставка не подтверждается. Это означает, что сообщение может быть потеряно в случае сбоя или отключения получателя;
- **QoS1, не менее одного раза** - сообщение гарантированно будет получено хотя бы один раз, но может быть продублировано, например если получатель завершит работу из-за ошибки до того, как уведомит отправителя. Это означает, что сообщения сохраняются, только если возникает необходимость повторной отправки;
- **QoS2, строго один раз** - это самый надежный из уровней QoS, поскольку он гарантирует, что сообщение будет получено один и только один раз. Это достигается за счет использования более медленного и громоздкого механизма подтверждения доставки сообщений;

Кроме организации взаимодействий, брокер может предлагать дополнительные возможности, такие как хранимые очереди, маршрутизация, преобразования сообще­ний и мониторинг.

Причины избегания брокеров:
- исключение элемента, отказ которого приведет к сбою всей системы;
- брокер должен масштабироваться, в то время как при использовании прямой передачи сообщений требуется масштабировать только отдельные узлы;
- переход на непосредственный обмен сообщениями может значительно уско­рить их передачу.

Реализация прямого обмена сообщениями дает больше гибкости и воз­можностей, поскольку отсутствует привязка к конкретной технологии, протоколу или архитектуре.

### Шаблон "Публикация/подписка"

Это всего лишь вариант шаблона «Наблюдатель» для распределенной архитектуры. Имеется ряд подписчиков, регистрирующихся для получения сообщений конкретного вида, а издатель генерирует со­общения, распределяемые по соответствующим подписчикам.

Главная особенность в том, что издатель не знает заранее, кто подпишется на получение сообщений. Подписчики являются абонентами, зарегистрировавшимися на получение конк­ретного сообщения, что позволяет издателю работать с произвольным количе­ством получателей. Другими словами, обе стороны слабо связаны друг с другом, что делает этот шаблон идеальным для интеграции узлов эволюционирующей рас­пределенной системы.

Присутствие брокера еще больше ослабляет связанность узлов системы, посколь­ку абоненты взаимодействуют только с брокером и им не нужно знать, какой из узлов является отправителем.

Подписка, гарантирующая доставку всех сообщений, даже тех, что были отправле­ны, когда подписчик был отключен, называется **надежной подпиской**. Система надежной доставки сообщений должна использо­вать очередь сообщений для их хранения в то время, когда подписчики отключены.

#### Протокол AMQP

**Протокол AMQP** - открытый стандартный протокол, поддерживаемый многими системами сообщений с очередями. Помимо общего коммуникационного протокола, он также определяет модель для описания маршрутизации, фильтрации, организации очередей, надежности и безопасности. В AMQP имеются три основных компонента.

**Очередь** - структура данных, отвечающая за хранение сообщений, извлекаемых получателями. Сообщения из очереди передаются одному или нескольким по­лучателям, которыми, по сути, являются наши приложения. Если к одной оче­реди подключится несколько получателей, сообщения будут распределяться между ними. Очереди могут быть следующих видов:
- **надежные** - очередь автоматически восстанавливается при перезапуске брокера. Надежность не означает, что будет сохранено все содержимое оче­реди; на диск будут сохранены только сообщения, отмеченные как храни­мые, и они же будут восстановлены в случае перезагрузки;
- **эксклюзивные** - к очереди может быть подключен только один конкретный подписчик. После закрытия соединения очередь уничтожается;
- **автоматически удаляемые** - очередь удаляется после отключения послед­него подписчика.

**Коммутатор** - место публикации сообщений. Коммутатор направляет сообще­ния в одну или несколько очередей в зависимости от реализуемого алгоритма:
- **прямое коммутирование** - выбор маршрута определяется путем сопостав­ления полного ключа маршрутизации (например, chat.msg);
- **тематическое коммутирование** - выбор маршрута определяется путем со­поставления ключа с шаблоном (например, chat.# соответствует всем клю­чам маршрутизации, начинающимся с chat);
- **разветвляющее коммутирование** - сообщения рассылаются во все подклю­ченные очереди, независимо от ключа маршрутизации.

**Связь** - между коммутаторами и очередями. Также определяет ключ маршрути­зации или шаблон для фильтрации сообщений, поступающих от коммутатора.

Эти компоненты управляются брокером, предоставляющим программный интер­фейс для создания и управления ими. Подключаясь к брокеру, клиент создает канал - абстракцию соединения, - который отвечает за поддержание связи с брокером.

```
          Брокер -> +-----------------------------------------------+
                    |                       Связи        Очереди    |
    +----------+    |   +------------+  +-> [===] --> [-][-][+][+] ---+-> [Подписчик]
    | Издатель | -----> | Коммутатор | -+                           | v
    +----------+    |   +------------+  +-> [***] --> [-][-][-][+] -----> [Подписчик]
                    |                                               |
                    +-----------------------------------------------+
```

### Шаблоны "Запрос/ответ"

Идея шаблона заключается в маркировке каждого запроса идентификатором, ко­торый затем получатель прикрепляет к ответу. Таким образом, отправитель запроса может сопоставить два сообщения и вернуть ответ соответствующему обработчику. Это решает проблему использования только однонаправленного асин­хронного канала, позволяя передавать сообщения в любом направлении.

**Идентификатор корреляции** - уникальный идентификатором (маркер) запроса.

**Тип точка-точка** - прямое соединение двух узлов системы.

```
    +---------------+                                     +------------+
    | Запрашивающий | ----------[ID: 1][Запрос]---------> | Отвечающий |
    |               |                                     |            |
    |               | ----------[ID: 2][Запрос]---------> |            |
    |               |                                     |            |
    |               | <---------[Ответ][ID: 2 ]---------- |            |
    |               |                                     |            |
    |               | ----------[ID: 3][Запрос]---------> |            |
    |               |                                     |            |
    |               | <---------[Ответ][ID: 1 ]---------- |            |
    |               |                                     |            |
    |               | <---------[Ответ][ID: 3 ]---------- |            |
    +---------------+                                     +------------+
```

**Обратный адрес** - это сведения, которые позволят отвечающей стороне вернуть ответ исходному от­ правителю запроса.

Основы проектирования Node-приложений
=====================================

## Структура проекта

### Структурирование решений на основе компонентов

Структура проекта должна основываться на особеностях проекта, а не на его ролях. Она должна выглядеть как решения на самодостаточных компонентах, в файле компонента `index.js` должна описываться только развязка подключения всех других фалов компонента, но не логика:
```
application
|-- components
|   |-- orders
|   |-- users
|   |   |-- index.js
|   |   |-- user.js
|   |   |-- userApi.js
|   |   |-- userController.js
|   |   '-- userTesting.js
|   |-- ...
|   '-- other
'-- libraries
```

А не групировать файлы, основываясь на их технической роли:
```
application
|-- controllers
|-- models
|-- test
|-- utils
'-- views
```

### Слои компонентов

Каждый компонент должен содержать "слои" - определенные объекты, которые должны исполнять только одну роль для веба, логики и доступа к данным и как минимум пересекаться, а должны обмениваться только данными (контекстом), которые нужны для конкретной цели, так они будут менее связаны.

### Общие утилиты

Общие утилиты, которые нужны для каждого компонента должны помещаться в приватный npm-пакет. Также так могут оборачиваться 3-ии библиотека для уменшения зависимостей от их реализации. Структура проекта:
```
locale_modules
|-- module1
|   |-- package.json
|   '-- index.js
|-- module2
|-- ...
'-- moduleN
package.json
```

Для их подключения используется объявление зависимости в файле `package.json` приложения:

```json
{
    "dependencies": {
        "module1": "file:local_modules/module1",
        "module2": "file:local_modules/module2",
        "...": "file:local_modules/...",
        "moduleN": "file:local_modules/moduleN"
    }
}
```

Тогда их подключение будет как: `require('module1').User`, а не: `require('../../../../module1/User')`.

### Разделение Express "приложения" и "сервера"

Express приложение должно разделяться как минимум на два файла:
- **приложение** - где описываются API, а для лучшей структуры необходимо локализировать описание API внутри компонентов;
- **сервер** - где подключается сетевое взаимодействие с самим приложением.

Это позволит тестировать API без применения сетевых вызовов. А также лучше разделяет бизнес логику API.

### Параметры приложения

Все параметры, которые нужны для работы приложения должны храниться в отдельных файлах, в отдельной директории от всего остального кода, к примеру: `config` и должны быть в виде JSON файла или должны передаваться в приложение, как параметры окружения. Так будет проще конфигурировать и тестировать приложение.

Основы развертывания Node-приложений
====================================

## Инструмент Nodejitsu Forever

Он позволяет сохранить Node-приложение работающим даже после разрыва SSH-соединения и дополнительно обеспечивает его перезапуск после сбоя.

`sudo npm install -g forever` - установка.

`forever [-w] start <приложение>` - запускает приложение и поддерживает его работоспособность. [И автоматически перезагружает приложение в случае изменения какого-либо исходного файла.]  
`forever stop <приложение>` - останавливает приложение.  
`forever list` - отображает список приложений, которыми можно управлять с помощью Forever.

## Поддержание доступности приложения, Upstart

Проект Upstart предлагает элегантный способ управления запуском и остановкой любого Linux-приложения, включая Node-приложение.

`sudo apt-get install upstart` - установка на Ubuntu.  
`sudo yum install upstart` - установка на CentOS.

После установки Upstart для каждого из приложений нужно добавить конфигурационный файл программы Upstart.  
`sudo touch /etc/init/<имя_приложения>.conf`

Его строение:

```ini
author "<имя_автора>"
description "<описание_приложения>"
setuid "<имя_пользователя>"
start on (local-filesystems and net-device-up IFACE=eth0) #запуск при
stop on shutdown #остановка при
respawn [<количество> <интервал>] #попытки перезапуска в случае сбоя
console log #логирования потоков вывода
env <переменная_окружения>=<значение>
...
exec <комманда> #запуск приложения
```

Запуск приложения:  
`sudo service <приложение>`

## Распределение нагрузки с помощью Nginx

`sudo apt-get install nginx` - установка.

Файл `nginx.conf`:

```nginx
http {
    # ...
    upstream nodejs_design_patterns_app {
        server 127.0.0.1:8081;
        server 127.0.0.1:8082;
        server 127.0.0.1:8083;
        server 127.0.0.1:8084;
    }
    # ...
    server {
        listen 80;

        location / {
            proxy_pass http://nodejs_design_patterns_app;
        }
    }
    # ...
}
```

Где:
- в разделе `nodejs_design_patterns_app` определяется список внутренних серверов для обработки се­тевых запросов;
- директива `proxy_pass`, в разделе `server`, требует от сервера Nginx перенаправлять любые запросы в группу серверов в разделе `nodejs_design_patterns_app`.