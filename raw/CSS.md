CSS. Правила построения
=======================

**Таблица стилей** документа представляет собой набор правил, ассоциированных с документом HTML и определяющих его отображение. Каждое правило в таблице стилей состоит из **селектора** и **блока объявлений**. **Блок объявлений** всегда отделяется от селектора пробелом и заключается в фигурные скобки. **Селектор** определяет область применения стилевого правила, а блок объявлений содержит одно или несколько объявлений, которые отделяются друг от друга точкой с запятой.

Каждое **объявление** включает в себя свойство и соответствующее этому свойству значение. Любое свойство является обобщенным параметром оформления и должно отделяться от значения двоеточием. **Свойства** могут быть достаточно разнообразны: они могут определять цвет элемента и фона, поля, заполнение, тип и размер шрифта и т.п. Набор допустимых значений для каждого конкретного свойства должен быть определен индивидуально.

```css
<селектор> {
    <свойство>: <значение>;
    ...
}
```

**Универсальные селекторы** - позволяют применить стилевое оформление сразу ко всем элементам на странице:  
`* {...}`

**Селекторы элементов** - для определения информации о представлении элементов HTML используют в качестве селекторов имена этих элементов:  
`<имя_тега> {...}`

**Селекторы классов** - для всех элементов со специальным атрибутом `class`, который позволяет особым образом отметить некоторые структурные элементы в документе. Подобные стилевые правила будут применяться ко всем элементам, которые имеют атрибут `class` с указанным значением:  
`.<имя_класса> {...}`

**Селекторы идентификаторов** - для всех элементов со специальным атрибутом `id`, с помощью которого любому элементу можно назначить уникальный идентификатор, значение атрибута `id` должно быть уникальным:  
`#<имяИдентификатора> {...}`

Можно соединять несколько селекторов, чтобы определить еще более конкретные правила:  
`[<имя_тега>][#<имя_идентификатора>][.<имя_класса>] {...}`

**Селекторы атрибутов** - позволяют выбирать элементы на основе содержащихся в них атрибутов:  
`<селектор>[<имя_атрибута>[[^$*~|]=<значение>]] {...}`
> `div[data-role*="submit"] {...}`

Виды соответствий селекторов атрибутов:
- `=` - точное полное соответствие значению;
- `~=` - одно из слов заданных в атрибуте разделенных через пробел соответствует значению;
- `|=` - соответствует точному полному совпадению со значением или может начинаться с `<значение>-`;
- `^=` - начинается со значения;
- `$=` - заканчивается со значения;
- `*=` - содержит как минимум одно вхождение значения как подстроки.

`i` - через пробел после значения обозначает регистронезависимость значения.

**Селекторы потомков** - используются для выбора только определенных элементов, которые являются потомками других определенных элементов, только для потомка родителя, а не для потомка потомков.  
`<селектор1> > <селектор2> {...}`

**Селекторы нижележащих элементов** - выбирают все подходящие элементы в любом месте иерархии элементов.  
`<селектор1> <селектор2> {...}`

**Селекторы смежных одноуровневых элементов** - позволяют выбирать определенный элемент, который следует непосредственно после другого определенного элемента на том же уровне в иерархии элементов.  
`<селектор1> + <селектор2> {...}`

**Селекторы одноуровневых элементов** - позволяют выбирать определенный элемент, который следует после другого определенного элемента на том же уровне в иерархии элементов.  
`<селектор1> ~ <селектор2> {...}`

## Группировка селекторов

Если нескольким разным селекторам необходимо сопоставить одинаковые объявления, такие селекторы можно сгруппировать в список. Имена селекторов в данном случае должны разделяться запятыми:  
`<селектор1>[, <селектор2>[, ...]]] {...}`

## Псевдоклассы

Псевдоклассы используются для обеспечения стилевого оформления различных состояний элементов.  
`<селектор><псевдокласс> {...}`

Псевдокласс                    | Описание
 ----------------------------- | -------
`:invalid`                     | применяется к полям формы, содержимое которых не соответствует указанному типу.
`:read-only`                   | применяется к полям формы, у которых задан атрибут `readonly`.
`:active`                      | определяет стиль активной ссылки.
`:checked`                     | применяется к элементам интерфейса, таким как переключатели (`checkbox`) и флажки (`radio`), когда они находятся в положение "включено"
`:default`                     | применяет стиль к элементам форм, которые установлены по умолчанию в группе похожих элементов.
`:disabled`                    | применяет стиль к заблокированным элементам форм.
`:empty`                       | представляет пустые элементы, т.е. те, которые не содержат дочерних элементов, текста или пробелов.
`:enabled`                     | используется для применения стиля к доступным (не заблокированным) элементам форм.
`:first-child`                 | применяет стилевое оформление к первому дочернему элементу своего родителя.
`:first-of-type`               | задает правила стилей для первого элемента в списке дочерних элементов своего родителя.
`:focus`                       | определяет стиль для элемента получающего фокус.
`:focus-within`                | определяет стиль для элемента в котором дочений элемент получил фокус.
`:hover`                       | определяет стиль элемента при наведении на него курсора мыши, но при этом элемент еще не активирован.
`:indeterminate`               | задает стиль для элементов форм, таким как флажки и переключатели, когда они находятся в неопределенном состоянии.
`:lang`                        | определяет язык, который используется в документе или фрагменте.
`:last-child`                  | задает стилевое оформление последнего элемента своего родителя.
`:last-of-type`                | задает правила стилей для последнего элемента в списке дочерних элементов своего родителя.
`:link`                        | применяется к ссылкам, которые еще не посещались пользователем.
`:not(<селектор>)`             | задает правила стилей для элементов, которые не содержат указанный селектор.
`:nth-child(<соответствие>)`   | используется для добавления стиля к элементам на основе нумерации в дереве элементов, без исключения по типу.
`:nth-last-child`              | используется для добавления стиля к элементам на основе нумерации в дереве элементов.
`:nth-last-of-type`            | используется для добавления стиля к элементам указанного типа на основе нумерации в дереве элементов.
`:nth-of-type(<соответствие>)` | используется для добавления стиля к элементам указанного типа на основе нумерации в дереве элементов.
`:only-child`                  | применяется к дочерним элементам, только если он единственный у родителя.
`:only-of-type`                | применяется к дочерним элементам указанного типа, только если он единственный у родителя.
`:optional`                    | применяет стилевые правила к полю формы, у которого не задан атрибут `required`.
`:placeholder-shown`            | применяется когда отображается `placeholder` у элементов `<input>` `<textarea>`.
`:read-write `                 | применяется к полям формы, доступных для изменения.
`:required`                    | применяет стилевые правила к тегу `<input>`, у которого установлен атрибут `required`.
`:root`                        | определяет корневой элемент документа. В HTML этот селектор всегда соответствует элементу `<html>`.
`:target`                      | применяется к целевому элементу, иными словами, к идентификатору, который указан в адресной строке браузера.
`:valid`                       | применяется к полям формы, содержимое которых проходит проверку в браузере на соответствие указанному типу.
`:visited`                     | применяется к ссылкам, уже посещённым пользователем, и задает для них стилевое оформление.

Где `<соответствие>` может быть одним из:
- `odd` - все нечетные номера элементов;
- `even` - все четные номера элементов;
- `<число>` - конкретный номер;
- `<выражение>` - задается в виде `an+b`, где `a` и `b` целые числа, а `n` - счетчик, который автоматически принимает значение 0, 1, 2...

## Псевдоэлементы

Псевдоэлементы добавляются к селекторам, но вместо описания специального состояния, они позволяют стилизовать некоторые части документа.  
`<селектор><псевдоэлемент> {...}`

Псевдоэлемент    | Описание
 --------------- | -------
`::after`        | после селектора
`::before`       | перед селектором
`::first-letter` | для первого символа
`::first-line`   | для первой строки блочного текста
`::selection`    | для выделеного участка текста, поддерживает только свойства `color`, `background` и `text-shadow`.

## Комментарии

Комментарии в CSS начинаются с `/*` и заканчиваются `*/`.

Специфичность
=============

Если к одному элементу одновременно применяются противоречивые стилевые правила, то более высокий приоритет имеет правило, у которого значение специфичности селектора больше. Специфичность это некоторая условная величина, вычисляемая следующим образом:
- за каждый идентификатор (a) начисляется 100;
- за каждый класс и псевдокласс (b), а также атрибут начисляется 10;
- за каждый селектор тега и псевдоэлемент (c) начисляется 1.

Складывая указанные значения в определённом порядке, получим значение специфичности для данного селектора.

Пример           | Описание    | Результат
 --------------- | ----------- | --------
`*`              | a=0 b=0 c=0 | специфичность = 0
`li`             | a=0 b=0 c=1 | специфичность = 1
`li:first-line`  | a=0 b=0 c=2 | специфичность = 2
`ul li`          | a=0 b=0 c=2 | специфичность = 2
`ul ol+li`       | a=0 b=0 c=3 | специфичность = 3
`ul li.red`      | a=0 b=1 c=2 | специфичность = 12
`li.red.level`   | a=0 b=2 c=1 | специфичность = 21
`#t34`           | a=1 b=0 c=0 | специфичность = 100
`#content #wrap` | a=2 b=0 c=0 | специфичность = 200

Встроенный стиль, добавляемый к тегу через атрибут `style`, имеет специфичность 1000, поэтому всегда перекрывает связанные и глобальные стили. Однако добавление `!important` перекрывает в том числе и встроенные стили.

Если два селектора имеют одинаковую специфичность, то применяться будет тот стиль, что указан в коде ниже.

Правила форматирования CSS
==========================

Каждое свойство - на отдельной строке.

Каждый селектор - на отдельной строке.

Свойства, сильнее влияющие на документ, идут первыми. Рекомендуется располагать свойства в следующем порядке:
1. Сначала положение элемента относительно других: `position`, `left/right/top/bottom`, `float`, `clear`, `z-index`;
2. Затем размеры и отступы: `width`, `height`, `margin`, `padding`...;
3. Рамка `border`, она частично относится к размерам;
4. Общее оформление содержимого: `list-style-type`, `overflow`...;
5. Цветовое и стилевое оформление: `background`, `color`, `font`...

Общая логика сортировки: "*от общего - к локальному и менее важному*". При таком порядке свойства, определяющие структуру документа, будут видны наиболее отчётливо, в начале, а самые незначительно влияющие (например цвет) - в конце.

Свойство без префикса пишется последним.

Организация CSS-файлов проекта:
- блоки-компоненты имеют свой CSS. Такой CSS идёт "в комплекте" с модулем, его удобно выделять в отдельные файлы и подключать через `@import`;
- страничный и интегрирующий CSS. Этот CSS описывает общий вид страницы, расположение компонент и их дополнительную стилизацию, зависящую от места на странице и т.п.

Включение таблиц стилей в HTML-документ
=======================================

**Внешние таблицы стилей** - через отдельный файл:
```html
<HEAD>
    <LINK rel="stylesheet" href="style.css" type="text/css">
</HEAD>
```

**Внутренние таблицы стилей** - через описание в теге:
```html
<HEAD>
    <STYLE type="text/css">
        H1 {text-align: center}
    </STYLE>
</HEAD>
```

**Таблицы стилей элементов** - через описание в элементе:
```html
<H1 style="text-align: center">
```

Правила задания свойств
=======================

## Значения стилевых свойств

**Строки** - любые строки необходимо брать в двойные `"` или одинарные кавычки `'`. Если внутри строки требуется оставить одну или несколько кавычек, то можно комбинировать типы кавычек или добавить перед кавычкой обратный слэш `\`.

**Числа** - значением может выступать целое число, содержащее цифры от 0 до 9 и десятичная дробь, в которой целая и десятичная часть разделяются точкой. Если в десятичной дроби целая часть равна нулю, то её разрешается не писать.

**Проценты** - процентная запись обычно применяется в тех случаях, когда надо изменить значение относительно родительского элемента или когда размеры зависят от внешних условий.

## Размеры

Абсолютные единицы не зависят от устройства вывода, а относительные единицы определяют размер элемента относительно значения другого размера.

**Относительные единицы** обычно используют для работы с текстом, либо когда надо вычислить процентное соотношение между элементами:
- `em` - размер шрифта текущего элемента;
- `ex` - высота символа **x**;
- `px` - пиксел;
- `%` - процент;
- `rem` - root em (CSS3);
- `vw` - 1% от ширины **viewport** (CSS3);
- `vh` - 1% от высоты **viewport** (CSS3);
- `vmin` - 1% от меньшей стороны (ширины или высоты) **viewport** (CSS3);
- `vmax` - 1% от большей стороны (ширины или высоты) **viewport** (CSS3);
- `fr` - обозначает дробную часть свободного пространства (в свободное пространство не входят отсупы) (`2fr` из `2fr 300px 3fr` это будет `2/(2+3)` от всего свободного пространства который будет равен `5fr - 300px`).

Единица `em` это изменяемое значение, которое зависит от размера шрифта текущего элемента (размер устанавливается через стилевое свойство `font-size`). В каждом браузере заложен размер текста, применяемый в том случае, когда этот размер явно не задан. Поэтому изначально `1em` равен размеру шрифта, заданного в браузере по умолчанию или размеру шрифта родительского элемента. Процентная запись идентична `em`, в том смысле, что значения `1em` и `100%` равны.

Единица `ex` определяется как высота символа `x` в нижнем регистре. На `ex` распространяются те же правила, что и для `em`, а именно, он привязан к размеру шрифта, заданного в браузере по умолчанию, или к размеру шрифта родительского элемента.

Пиксел это элементарная точка, отображаемая монитором или другим подобным устройством, например, смартфоном. Размер пиксела зависит от разрешения устройства и его технических характеристик.

Единица размера `rem` (root em), которая похожа на `em`, но вместо сложной цепочки зависимостей по родительским элементам, она вычисляется только на основе размера шрифта элемента `<html>`.

**Абсолютные единицы** применяются реже, чем относительные и обычно при работе с текстом:
- `in` - дюйм (1 дюйм равен 2,54 см);
- `cm` - сантиметр;
- `mm` - миллиметр;
- `pt` - пункт (1 пункт равен 1/72 дюйма);
- `pc` - пика (1 пика равна 12 пунктам).

### Вычисления значений

#### `calc`

`calc(<выражение>)` - это функция CSS, которая может быть использована для вычисления значений для длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`.

Где `<выражение>` - математическое выражение, результат вычисления которого можно использовать как значение CSS свойства, может использовать операторы `+`, `-`, `*`, `/` с использованием стандартных правил приоритета операторов, которые должны быть окружены пробелами. При этом операнды могут быть различными выражениями длины.

#### `min`

`min(<выражение1>, <выражение2>)` - это функция CSS, которая может быть использована для вычисления минимального из двух значений для выражений длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`.

#### `max`

`max(<выражение1>, <выражение2>)` - это функция CSS, которая может быть использована для вычисления максимального из двух значений для выражений длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`.

#### `minmax`

`minmax(<мин_выражение>, <макс_выражение>)` - это функция CSS, которая может быть использована для вычисления значения больше или равно минимальному и меньше или равно максимальному для выражений длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`. По смыслу напоминает использование `auto` только с минимальным и максимальным ограничением.

#### `clamp`

`clamp(<мин_выражение>, <предпочитаемое_выражение>, <макс_выражение>)` - это функция CSS, которая может быть использована для вычисления значения ограниченого максимум и минимум (аналогично `max(<мин_выражение>, min(<предпочитаемое_выражение>, <макс_выражение>))`) для выражений длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`.

#### `repeat`

`repeat(<количество>, <значение>)` - повторяет переданое значение `<значение>` (может быть множеством значений указанных через пробел) указаное количество `<количество>` раз через пробел.

##### Особые случаи

`repeat(auto-fill, <значение>)` - для `grid` свойств: `grid-template-rows` `grid-template-columns` обозначает уместить как можно больше значений `<значение>`.
> `grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));`

`repeat(auto-fit, <значение>)` - аналогично `auto-fill`, только старается уместить элементы на весь размер.
> `grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));`

#### `auto`

`auto` - автоматически вычисляемое значение:
- для `width` будет равно размеру содержимого за вычетом ширины его частей, задаваемых свойствами `margin` (поле, внешний отступ), `padding` (внутренний отступ) и `border` (граница) и при этом, не будет больше своего родительского элемента;
- для `height` будет равно высоте содержимого элемента;
- для `margin-left` и `margin-right` ширина полей оказывается одинаковой, то это приводит к горизонтальной центровке элемента относительно краёв включающего его в себя блока;
- для `margin` ширина и высота полей оказывается одинаковой, то это приводит к центровке элемента относительно краёв включающего его в себя блока;
- для `top`, `right`, `bottom` и `left` сбрасывает значение свойства, и приводит к такому значению как он должен был бы быть позиционирован в том случае, если бы был статическим элементом.

### Изначальное значение `initial`

Ключевое слово `initial` в качестве значения позволяет использовать начальное значение свойства, которое есть у каждого свойства изначально.

### Наследование `inherit`

Наследование в CSS является механизмом, с помощью которого определенные свойства передаются от элемента предка его элементам потомкам. Наследуются не все свойства CSS, значения, заданные в виде процентных величин, не наследуются никогда. Для свойств, которые не наследуются по умолчанию, можно определить принудительное наследование, используя ключевое слово `inherit` в качестве значения.

Для того, чтобы правила пользовательской таблицы стилей могли перекрывать авторскую, CSS содержит атрибут `!important`, ставится после значения свойства. Правило пользовательской таблицы стилей, имеющее такой атрибут, имеет больший вес, чем соответствующее правило авторской таблицы стилей.

### Сброс `unset`

Ключевое слово `unset` в качестве значения позволяет сбросить значение свойства до унаследованного значения в том случае, если свойство естественным образом наследует это значение от родительского элемента. В противном случае значение сбрасывается до его исходного значения `initial`.

### Сброс `revert`

Ключевое слово `revert` работает как `unset`, только сбрасывается до заданого браузером значения.

## Цвет

Цвет в стилях можно задавать тремя способами:
- **по шестнадцатеричному значению** - используются числа в шестнадцатеричном коде. Шестнадцатеричная система, в отличие от десятичной системы, базируется, как следует из ее названия, на числе 16. Цифры будут следующие: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Цифры от 10 до 15 заменены латинскими буквами. Числа больше 15 в шестнадцатеричной системе образуются объединением двух чисел в одно. Каждый из трех цветов - красный, зеленый и синий - может принимать значения от 00 до FF. Таким образом, обозначение цвета разбивается на три составляющие `#rrggbb`, где первые два символа отмечают красную компоненту цвета, два средних - зелёную, а два последних - синюю. Допускается использовать сокращенную форму вида `#rgb`, где каждый символ следует удваивать (`#rrggbb`);
- **по названию** - браузеры поддерживают некоторые цвета по их названию;
- **с помощью RGB** - можно определить цвет, используя значения красной, зелёной и синей составляющей в десятичном исчислении. Значение каждого из трех цветов может принимать значения от 0 до 255. Также можно задавать цвет в процентном отношении. Вначале указывается ключевое слово `rgb`, а затем в скобках, через запятую указываются компоненты цвета - `rgb(<красный>, <зеленый>, <синий>)`, например `rgb(255, 0, 0)` или `rgb(100%, 20%, 20%)`.

### Задание цвета с помощью HSL (CSS3)

В CSS3 цвет может задаваться с помощью HSL, то есть оттенка, насыщенности и яркости.
Для того, чтобы задать цвет этим способом необходимо указать:
- **оттенок** цвета указывается в градусах поворота цветового круга (0 градусов - красный, 120 градусов - зеленый, 240 градусов - голубой и т.д.);
- **насыщенность** цвета указывается в процентах (по мере понижения процентов цвет будет блекнуть);
- **яркость** цвета также указывается в процентах (0% - темный, 100% - светлый).

`hsl(<оттенок>, <насыщенность>, <яркость>);`

### Задание цвета с помощью RGBA, HSLA (CSS3)

Данный способ позволяет определять цвет и прозрачность одновременно. Вначале необходимо указать значения RGB, а затем значение прозрачности (0 - максимальная прозрачность, 1 - минимальная прозрачность). Подобно RGBA цвет сразу вместе с прозрачностью можно задавать используя HSLA.

## Адреса

Адреса (*URI*, *Uniform Resource Identifiers*, *унифицированный идентификатор ресурсов*) применяются для указания пути к файлу, например, для установки фоновой картинки на странице. Для этого применяется ключевое слово `url()`, внутри скобок пишется относительный или абсолютный адрес файла. При этом адрес можно задавать в необязательных одинарных или двойных кавычках.

## Ключевые слова

В качестве значений активно применяются ключевые слова, которые определяют желаемый результат действия стилевых свойств. Ключевые слова пишутся без кавычек.

Основные свойства
=================

## Свойства для работы с текстом

### Семейство шрифтов: свойство `font-family`

Свойство `font-family` используется для задания списка имен семейств шрифтов для отображения содержимого элемента. Список шрифтов может включать одно или несколько названий, разделенных запятыми. Если в имени шрифта содержатся пробелы, например, Times New Roman, оно должно заключаться в двойные или одинарные кавычки. Гарнитуры должны указываться в порядке возрастающей вероятности доступности или предпочтения. В качестве защиты от отказа значение свойства `font-family` всегда должно заканчиваться ключевым словом, ссылающимся на родовое имя шрифта. Таким образом, последовательность шрифтов лучше начинать с экзотических типов и заканчивать обобщенным именем, которое задает вид начертания.

Имя семейства шрифтов может быть задано как название семейства шрифтов (например, Times New Roman, Arial и т.д.) или как родовое имя. Родовые имена шрифтов были разработаны на тот случай, если на компьютере пользователя не установлен ни один из шрифтов, заданных разработчиком. В этом случае браузер использует родовой шрифт, начертание которого напоминает шрифт, который планировал использовать разработчик.

Спецификацией определено пять родовых имен:
- `sans-serif` - шрифт без засечек;
- `serif` - шрифт с засечками;
- `cursive` - каллиграфический шрифт;
- `fantasy` - декоративный шрифт;
- `monospace` - телетайпный.

### Размер шрифтов: свойство `font-size`

Набор констант `хх-small`, `x-small`, `small`, `medium`, `large`, `x-large`, `xx-large` задает размер, который называется абсолютным. Другой набор констант `larger`, `smaller` устанавливает относительные размеры шрифта, относительно родителя. Также разрешается использовать любые допустимые единицы CSS: `em` (высота шрифта элемента), `ех` (высота символа х), пункты (`pt`), пиксели (`рх`), проценты (`%`) и др. При использовании процентной записи за 100% принимается размер шрифта родительского элемента.

### Насыщенность шрифтов: свойство `font-weight`

Значениями этого свойства могут быть ключевые слова `bold`, `bolder`, `lighter` и `normal`, которые устанавливают полужирное, жирное, светлое и нормальное начертание шрифта. Также можно использовать условные единицы от `100` до `900` с шагом `100`, причем чем больше значение, тем выше жирность. Установленное по умолчанию нормальное начертание шрифта эквивалентно значению `400`, а стандартный полужирный текст - `700`.

### Стиль шрифта: свойство `font-style`

Определяет начертание шрифта как обычное, курсивное или наклонное. Данным начертаниям соответствуют значения свойства `normal`, `italic` и `oblique`.

### Капитель: свойство `font-variant`

Капителью называется текст, набранный прописными буквами уменьшенного размера. Для создания такого эффекта используется свойство `font-variant` со значением `small-caps`. Особенность капители заключается в том, что заглавные и строчные буквы при ее использовании сохраняются.

### Свойство `font`

`font: [<font-style>||<font-variant>||<font-weight>] <font-size> [/<line-height>] <font-family> | inherit`

### Свойство `@font-face` (CSS3)

В CSS3 можно использовать любые шрифты. Необходимый шрифт просто нужно разместить на веб-сервере и подключить с помощью нового CSS3 свойства @font-face. Подключенный шрифт будет загружен и отображен автоматически при посещении страницы пользователем.

```css
@font-face {
    font-family: <имя_шрифта_для_использования>;
    src: url(<путь_к_шрифту>);
}
```

### Преобразование текста: свойство `text-transform`

Данное свойство может принимать четыре значения:
- `none` - текст пишется без изменений;
- `capitalize` - каждое слово будет начинаться с заглавного символа;
- `lowercase` - все символы становятся строчными (нижний регистр);
- `uppercase` - все символы становятся прописными (верхний регистр).

### Украшение текста: свойство `text-decoration`

Позволяет задать тексту дополнительное оформление. Значениями данного свойства являются константы none, `underline`, `overline`, `line-through` и `blink`, позволяющие отобразить обычный текст, провести линию над, под или через текст, а также сделать текст мигающим.

### Добавление теней к тексту: свойство `text-shadow` (CSS3)

`text-shadow: none / <тень>[,<тень>]*`

Где `<тень>`: `<сдвигПоX> <сдвигПоY> [<радиусРазмытия>] [<цвет>]`

### Свойство `text-overflow` (CSS3)

Позволяет указать, что должно случиться с текстом вышедшем за пределы границ элемента. Принимает значения `clip` текст обрезается по размеру области, `ellipsis` текст обрезается и к концу строки добавляется многоточие (также нужно свойство: `overflow: hidden;`).

#### Свойство `line-clamp`

Позволяет указать сколько строк текста оставить при обрезании.

### Интервал между словами: свойство `word-spacing`

Значения данного свойства можно задать с помощью ключевого слова `normal`, которое используется по умолчанию и задает стандартный интервал для текущего шрифта. Для задания интервала в дополнение к стандартному можно указать значение в любых доступных единицах CSS, причем значение может быть и отрицательным.

### Свойство `word-wrap` (CSS3)

Указывает, переносить или нет длинные слова, которые не помещаются по ширине в заданную область.

`word-wrap: normal | break-word | inherit`

### Пробелы между словами: свойство `white-space`

Устанавливает, как отображать пробелы между словами. Возможные значения:
- `normal` - текст в окне браузера выводится как обычно, переносы строк устанавливаются автоматически.
- `nowrap` - пробелы не учитываются, переносы строк в коде HTML игнорируются, весь текст отображается одной строкой; вместе с тем, добавление тега `<br>` переносит текст на новую строку.
- `pre` - текст показывается с учетом всех пробелов и переносов, как они были добавлены разработчиком в коде HTML. Если строка получается слишком длинной и не помещается в окне браузера, то будет добавлена горизонтальная полоса прокрутки.
- `pre-line` - в тексте пробелы не учитываются, текст автоматически переносится на следующую строку, если он не помещается в заданную область.
- `pre-wrap` - в тексте сохраняются все пробелы и переносы, однако если строка по ширине не помещается в заданную область, то текст автоматически будет перенесен на следующую строку.

### Выравнивание текста: свойство `text-align`

Допустимыми значениями данного свойства являются `left`, `right`, `center` и `justify`, задающие выравнивание по левому краю, по правому краю, по центру и по ширине соответственно.

### Интерлиньяж: свойство `line-height`

Интерлиньяжем называется расстояние между базовыми линиями близких друг к другу строк. При обычных обстоятельствах расстояние между строками зависит от вида и размера шрифта и автоматически определяется браузером. Заданное по умолчанию значение `normal` заставляет браузер вычислять расстояние между строками автоматически. Любое число больше нуля воспринимается как множитель от размера шрифта текущего текста. В качестве значений данного свойства допустимо также использовать любые единицы длины, принятые в CSS. Разрешается также использовать процентную запись, причем в этом случае за 100% принимается высота шрифта. Отрицательное значение межстрочного расстояния не допускается.

### Интервал между буквами: свойство `letter-spacing`

Браузер автоматически подбирает интервалы между символами, исходя из размера и типа шрифта. В качестве значений данного свойства могут использоваться любые единицы длины, принятые в CSS, однако рекомендуется использовать относительные единицы, основанные на размере шрифта (`em` и `ех`), допускает использование отрицательного значения.

### Управление цветом переднего плана: свойство `color`

Цвет текста задается свойством `color`. Значения данного свойства можно задавать несколькими способами. Можно задать явное название цвета (`red`, `yellow` и др.), указать шестнадцатеричное значение или значение RGB. Шестнадцатеричное значение состоит из символа `#`, за которым следует шесть символов. Первая пара указывает уровень красного цвета, а вторая и третья - уровни зеленого и синего цветов соответственно, например, `#FF0000`. Можно определить цвет, используя значения уровня красной, зеленой и синей составляющей в десятичном исчислении, например, `RGB(49, 151, 116)`. Также можно задавать цвет в процентном отношении.

`currentColor` - переменная которая берет свое значение цвета из свойства `color`.

> `color: red; text-shadow: 0 0 5px currentColor;`

## Свойства для работы с фоном

### Управление цветом фона: свойство `background-color`

Это свойство можно применять и к другим элементам, в том числе к заголовкам и тексту.

### Повторение фонового изображения: свойство `background-repeat`

Если фоновое изображение меньше области элемента, то по умолчанию оно будет повторяться по горизонтали и по вертикали, стремясь заполнить всю выделенную область. Может принимать значения `repeat-x`, `repeat-y` и `repeat`, которое соответствуют повторению изображения по горизонтали, по вертикали и в обоих направлениях соответственно. Еще одно значение `no-repeat` является значением, которое требуется использовать, чтобы изображение не повторялось.

### Присоединение: свойство `background-attachment`

Данное свойство имеет два значения `scroll` и `fixed`. Значением по умолчанию является `scroll`, которое заставляет фоновое изображение прокручиваться вместе с содержимым элемента. Значение `fixed` фиксирует изображение, а содержимое страницы прокручивается.

### Положение фонового изображения: свойство `background-position`

По умолчанию, фоновый рисунок располагается в левом верхнем углу экрана. Это свойство позволяет располагать фоновое изображение в любом месте. Набор координат (по горизонтали по вертикали) можно указывать в процентах от ширины экрана, в фиксированных единицах (пиксели, сантиметры, и т. п.), либо использовать символьные константы `top`, `bottom`, `center`, `left` и `right`.  
`background-position: <отступ_по_x>, <отступ_по_y>`

### Свойство `background`

С помощью свойства `background` можно объединить несколько свойств и записывать стили в сокращённом виде, что облегчает чтение таблиц. Для обеспечения межбраузерной совместимости и для организации и обслуживания таблицы стилей при объединении отдельных свойств фона в группу рекомендуется размещать свойства в следующем порядке:  
`background: <background-color>, <background-image>, <background-repeat>, <background-attachment>, <background-position>`.  
Если какое-либо свойство отсутствует, то оно автоматически получает значение по умолчанию.

Порядок наложения изображений друг на друга обратный порядку написания.

Для того чтобы использовать много цветных фонов - используется сплошной градиент: `linear-gradient(<background-color>, <background-color>)`, тогда появится возможность смешивать фоныю

### Размер фонового изображения: свойство `background-size` (CSS3)

`background-size: [ <значение> | <проценты> | auto ]{1,2} | cover | contain`

Где:
- `<значение>` - задает размер в любых доступных для CSS единицах;
- `<проценты>` - задает размер фоновой картинки в процентах от ширины или высоты элемента;
- `cover` - масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока;
- `contain` - масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь блока.

### Несколько фоновых изображений (CSS3)

CSS3 расширяет возможности свойства `background-image` теперь один элемент может иметь несколько фоновых изображений одновременно. Все новые изображения перечисляются через запятую в связанных с ними свойствами.

### Свойство `background-origin` (CSS3)

С помощью нового CSS3 свойства `background-origin` можно установить как должно вычисляться положение элемента относительно границ его родительского элемента. Данное свойство может иметь 3 различных значения:
- `border-box` - положение элемента вычисляется относительно верхнего левого угла границы элемента;
- `padding-box` - положение элемента вычисляется относительно верхнего левого угла блока `padding`;
- `content-box` - положение элемента вычисляется относительно верхнего левого угла содержимого.

## Свойства для компоновки CSS

Документ HTML состоит из множества перемешанных элементов. Когда такой документ изображается на экране компьютера или печатается на бумаге, эти элементы генерируют прямоугольные боксы. По умолчанию, встроенная таблица стилей в браузере заставляет элементы HTML блочного уровня генерировать блочные боксы, в то время как строковые элементы генерируют строковые боксы.
```
                      top
         +---------------------------+          
         |                           |           - margin
         |   +===================+   |           - border
         |   |                   |   |           - padding
         |   |   +----------+    |   |          
    left |   |   | Content  |    |   | right     - inner content in element
         |   |   +----------+    |   |          
         |   |                   |   |           - padding
         |   +===================+   |           - border
         |                           |           - margin
         +---------------------------+          
                      bottom
```

### Поля элемента: свойство `margin`

Это универсальный параметр, в зависимости от числа значений, он устанавливает поля со всех сторон элемента или для каждой его стороны отдельно. Например, указание одного значения задаст равные поля вокруг элемента. Допустимые значения обычно определяют в единицах измерения `px` или `em`. Для задания полей с разных сторон элемента предназначены производные от свойства `margin-margin-left`, `margin-right`, `margin-top` и `margin-bottom`, задающие значения левого, правого, верхнего и нижнего поля соответственно.

Отступ `margin` для двух соседних элементов будет равен максимальному отступу из двух элементов, т.е. он схлопнется. Исключения:
- плавающие элементы;
- абсолютно позиционированные элементы;
- строчно-блочные (`inline-block`) элементы;
- элементы с параметром `overflow`, установленным в любое значение кроме `visible` (они не схлопываются отступы со своими элементами-потомками);
- элементы, к которым применено правило `clear` (их верхние отступы не схлопываются с нижними отступами их родительских блоков);
- корневой элемент дерева документа.

### Добавление границы: свойство `border`

Для задания границ применяется несколько способов, один из которых основан на использовании свойства `border` и его производных. Это свойство позволяет одновременно установить толщину, стиль и цвет границы вокруг элемента. Значения разделяются пробелами и могут идти в любом порядке. Можно задать толщину, стиль и цвет любой из четырех сторон элемента, используя свойства `border-top`, `border-bottom`, `border-left` и `border-right`.  
`border: <border-width> <border-style> <border-color>`

### Толщина границы: свойство `border-width`

Это свойство задает толщину одной или нескольких сторон границы. Принимает значения в той же нотации, что и сокращенное свойство `margin`, за исключением того, что процентные значения не поддерживаются.

### Стиль границы: свойство `border-style`

Задает стиль линии и может принимать одно из восьми значений:
- `dotted` - в точку;
- `dashed` - в черточку;
- `solid` - сплошная;
- `double` - двойная линия;
- `groove` - от темного к светлому внутрь;
- `ridge` - от светлого к темному внутрь;
- `inset` - свет с правого нижнего угла;
- `outset` - свет с левого верхнего угла.

### Цвет границы: свойства `border-color`

Для каждой границы можно задать любой цвет с помощью сокращенного свойства `border-color` или его уточнения.

### Создание элементов со сглаженными углами: свойство `border-radius` (CSS3)

С помощью свойства border-radius можно делать углы элементов сглаженными.

`border-radius: <радиус>{1,4} [ / <радиусПоВертикали>{1,4}]`

Данное свойство может применяться не ко всем углам элемента, а только к определенным:
- `border-top-right-radius` - делает сглаженным только верхний правый угол элемента;
- `border-bottom-left-radius` - делает сглаженным только нижний левый угол элемента;
- `border-bottom-right-radius` - делает сглаженным только нижний правый угол элемента;
- `border-top-left-radius` - делает сглаженным только верхний левый угол элемента.

### Заполнение элемента: свойство `padding`

Заполнение определяет внутреннее расстояние между границей и содержимым элемента. Для изменения этой характеристики предназначено свойство `padding`. Оно позволяет задать расстояние между границей и содержанием для всех или определенных сторон элемента. Это свойство действует аналогично `margin`, поэтому итоговый результат зависит от числа аргументов. Для указания расстояний от разных сторон элемента можно воспользоваться свойствами `padding-left`, `padding-right`, `padding-top` и `padding-bottom`, которые управляют величиной расстояния слева, справа, сверху и снизу соответственно.

### Установка высоты и ширины элемента

Установить высоту и ширину элемента можно с помощью свойств `height` и `width` соответственно. Однако при применении данных свойств существуют некоторые особенности. Например, данные свойства не могут применяться к строковым элементам.

### Область вырезки: свойство `clip`

Свойство `clip` определяет область позиционированного элемента, в которой будет показано его содержимое. Все, что не помещается в эту область, будет обрезано и становится невидимым.

`clip: rect(<top_y1>, <left_x1>, <top_y2>, <left_x2>)` - вырезает прямоугольную область, в качестве параметров принимает расстояние от края элемента до области вырезки. Если край области нужно оставить без изменений, следует установить `auto`.

### Свойство `clip-path`

Свойство `clip-path` позволяет задать область вырезки как:
- **полигон точек** - `polygon(<x1> <y1>, ...)`;
- **прямоугольник** - `inset(<top_y1> <left_x1> <top_y2> <left_x2> [round <border-radius>])`;
- **круг** - `circle(<r>? [at <position>])`, где `<position>` - как у `background-position`;
- **эллипс** - `ellipse(<rx> <ry> [at <position>])`, где `<position>` - как у `background-position`.

### Свойство `box-sizing` (CSS3)

Применяется для изменения алгоритма расчета ширины и высоты элемента. Имеет значения:
- `content-box` основывается на стандартах CSS, при этом свойства `width` и `height` задают ширину и высоту контента и не включают в себя значения отступов, полей и границ;
- `border-box` свойства `width` и `height` включают в себя значения полей и границ, но не отступов (`margin`);
- `padding-box` свойства `width` и `height` включают в себя значения полей, но не отступов (`margin`) и границ (`border`).

### Добавление к элементам тени: свойство `box-shadow` (CSS3)

С помощью свойства `box-shadow` можно добавить к элементам страницы тени.

`box-shadow: none | <тень>[,<тень>]*`

Где `<тень>`: `[inset] <сдвигПоX> <сдвигПоY> [<нулевое_размытие>] [<радиус_распространения>] [<цвет>]`

### Создание прозрачных элементов и картинок: свойство `opacity` (CSS3)

Для создания прозрачных элементов используется это свойство, где принимает значение которое может изменяться от 0.0 (полностью прозрачный элемент) до 1.0 (полностью непрозрачный элемент).

### Свойство `object-fit`

Свойство `object-fit` в значении `contain` позволяет задать размер изображения так чтобы оно попадало точно в указаные размеры.

## Работа с потоком элементов

### Типы блоков: свойство `display`

Каждый элемент имеет соответствующий строковый или блочный тип. Каждый тип определяет поведение компоновки по умолчанию различным образом: последовательно идущие строковые элементы изображаются на общей базовой линии, в то время как блочные элементы всегда отделяются друг от друга и выводятся с предшествующим и последующим разрывом строки.

Свойство `display` имеет три наиболее часто используемых значения - `block`, `inline` и `none` - два из которых имеют прямое отношение к соответствующим типам элементов. Данное свойство позволяет изменить поведение элементов (например, строковый элемент будет вести себя как блочный или наоборот).

Свойство `display` со значением `none` может изменять представление данного элемента в документе не отображая его.

#### `display: contents`

Приводит к тому что блок, которому назначено это свойство становится элементом-"оберткой" и все его дочерние элементы становятся дочерними элементами его родителей.

### "Всплывающие" элементы: свойства `float` и `clear`

Элемент может "всплывать" вправо или влево с помощью свойства `float`. То есть бокс с его содержимым может смещаться к правому или левому краю в окне документа (или содержащего бокса) с помощью значений свойства `right`, `left` или `none`.

Свойство `clear` управляет поведением последовательности всплывающих элементов документа. По умолчанию, последовательные элементы смещаются вверх, заполняя доступное пространство, которое освобождается, если бокс смещается в сторону. Свойство `clear` может иметь значения `left`, `right`, `both` или `none`, которые обозначают с какой стороны элемента запрещено его обтекание другими элементами.

Каждый элемент HTML представляет собой прямоугольник (*бокс*), для которого можно задать такие параметры как поля, границы и заполнения. Позиционирование определяет, где должен располагаться этот прямоугольник, а также как он должен влиять на элементы вокруг себя. При помощи позиционирования можно разместить любой элемент точно в нужном месте страницы. В основе позиционирования лежит представление окна браузера как системы координат. Любой бокс возможно расположить в этой системе координат где угодно.

### Свойство `position`

Имеет четыре значения `static`, `relative`, `absolute` и `fixed`, которые определяют тип позиционирования и влияют на расположение элемента.

Значение `static` свойства `position` используется по умолчанию. Любой элемент со статическим позиционированием находится в общем потоке документа. Правила для его размещения определяются боксовой моделью. Блочные и строковые элементы размещаются по разным правилам. По умолчанию, **блочные боксы** выкладываются вертикально сверху вниз в порядке появления их в разметке. Каждый бокс обычно занимает всю ширину документа и имеет разрыв строки перед и после себя.

**Строковые боксы** выстраиваются по горизонтали в том порядке, в котором они появляются в разметке, переходя на новую строку, только если исчерпано доступное горизонтальное пространство. В зависимости от свойства `direction`, строковые боксы будут располагаться либо слева направо (`direction: ltr`), либо справа налево (`direction: rtl`). Множество строковых боксов, которые составляют строку на экране, заключаются еще в один прямоугольник, называемый линейным боксом. Линейные боксы выкладываются вертикально в своих предках блочного уровня без дополнительного пробела между ними. Высотой линейных боксов можно управлять с помощью свойства `line-height`. Для строковых боксов нельзя определить размеры и вертикальные поля.

Элемент со значением свойства `position`, равным `relative`, сначала размещается по правилам статического позиционирования. Но затем сгенерированный бокс смещается относительно своего положения в потоке, согласно значениям свойств `top`, `bottom`, `left` и `right`. Но при этом из потока он не исключается, а продолжает занимать там свое место. То есть сдвигается со своего места он только визуально, а положение всех боксов вокруг него никак не меняется. Это означает, что смещенный бокс может перекрывать боксы других элементов, так как они по-прежнему действуют, как если бы относительно позиционированный элемент остался там, где он должен был быть перед применением позиционирования.

Бокс с абсолютным позиционированием располагается по заданным координатам, а из того места, где он должен был бы быть, он удаляется, и в этом месте сразу начинают размещаться следующие боксы. Считается, что бокс исключается из потока. Для абсолютного позиционирования элемента свойство `position` должно принимать значение `absolute`. А для задания положения размещения блока используются значения `left`, `right`, `top` и `bottom`. Все четыре свойства можно использовать одновременно для определения расстояния от каждого края позиционируемого элемента до соответствующего края браузера или родительского блока. Можно определить также позицию одного из углов абсолютно позиционируемого (например, используя `top` и `left`), а затем определить размеры бокса, используя `width` и `height`.  
Влияет на свойство `display` и представляет элемент блочным, вне зависимости от того что он указан строчным.

Фиксированное позиционирование со значением свойства `position`, равным `fixed`, действует подобно абсолютному, однако элемент с фиксированным позиционированием всегда располагается только относительно окна браузера и никогда не смещается при прокручивании веб-страницы.

Приклееное позиционирование со значением свойства `position`, равным `sticky`, действует подобно фиксируемому, однако элемент с приклееным позиционированием не смещается при прокручивании элемента. Он будет остоваться при прокрутке на своем месте, пока прокрутка не достигнет конца родительского блока, а затем прокрутиться вместе с родителем.

### Третье измерение веб-страницы: свойство `z-index`

Страница сайта двухмерная: для нее заданы ширина и высота. CSS позволяет добавить к веб-станице глубину (третье измерение) с помощью свойства `z-index`. Данное свойство позволяет создавать слои и располагать одни элементы поверх других. Для создания слоев необходимо для каждого элемента задать значение свойства `z-index`, которое является своеобразным порядковым номером слоя, в котором находится данный элемент. Это значение может быть целым числом (которое может быть отрицательным) или одним из ключевых слов `auto` или `inherit`. Значением по умолчанию является `auto` или `0`. Элемент с большим значением свойства `z-index` перекрывает элемент с меньшим значением данного свойства.

### Переполнение контейнеров: свойство `overflow`

Для управления отображением содержимого контейнера когда размер контента превышает границы размеров контейнера используется атрибут стиля `overflow`, принимающий следующие значения:
- `visible` - отображается весь контент даже за пределами контейнера;
- `hidden` - отображается только область внутри контейнера, оставшаяся часть контента скрывается;
- `scroll` - добавление полос прокрутки контейнеру, полосы будут отображаться даже если в них нет необходимости;
- `auto` - полосы прокрутки появятся только в случае необходимости.

Существует возможность управления отображением содержания контейнера отдельно по горизонтали и вертикали, соответственно при помощи атрибутов `overflow-x` (для работы для блоков, необходимо чтобы было установленно свойство `white-space: nowrap;`) и `overflow-y`, значения которых аналогичны значениям `overflow`.

### Прокрутка

#### Свойство `scroll-behavior`

Свойство `scroll-behavior` в значении `smooth` добавляет плавную прокрутку элементу.

### Видимость элемента: свойство `visibility`

Предназначен для отображения или скрытия элемента, включая рамку вокруг него и фон. При скрытии элемента, хотя он и становится не виден, место, которое элемент занимает, остается за ним. Доступные значения:
- `visible` - отображает элемент как видимый;
- `hidden` - элемент становится невидимым или правильней сказать, полностью прозрачным, поскольку он продолжает участвовать в форматировании страницы.
- `collapse` - если это значение применяется не к строкам или колонкам таблицы, то результат его использования будет таким же, как `hidden`. В случае использования `collapse` для содержимого ячеек таблиц, то они реагируют, словно к ним было добавлено `display: none`. Иными словами, заданные строки и колонки убираются, а таблица перестраивается по новой;
- `inherit` - наследует значение родителя.

## Курсор

### Свойство `pointer-events` (CSS3)

Отвечает за реагирование элемента на события мыши. Принимает значения:
- `none` - элемент перестанет реагировать на `hover`, `click` и другие события мыши. Он станет "прозрачным" для взаимодействия, а `hover` и `click` будут передаваться элементу, лежащему под ним;
- `auto` - (значение по-умолчанию) включает стандартное поведение элемента.

### Свойство `user-select` (CSS3)

Отвечает за возможность выделения текста. Принимает значения:
- `none` - запрещает возможность выделения;
- `auto` - (значение по-умолчанию) включает стандартное поведение элемента;
- `text` - можно выделять текст;
- `contain` - позволяет выделять только то что находится в элементе;
- `all` - выделяет все содержимое элемента.

## Трансформирование элементов: свойство `transform` (CSS3)

С помощью свойства `transform` можно трансформировать элементы. В качестве значения данного свойства должна указываться одна из функций трансформирования:
- `translate(<x>, <y>)` - смещает элемент от изначальной позиции по горизонтали и вертикали;
- `translateX(<x>)` - смещает элемент по горизонтали;
- `translateY(<y>)` - смещает элемент по вертикали;
- `scale(<kx>, <ky>)` - растягивает элемент по вертикали и горизонтали;
- `scaleX(<kx>)` - растягивает элемент по горизонтали;
- `scaleY(<ky>)` - растягивает элемент по вертикали;
- `rotate(<градусы>)` - поворачивает элемент по часовой стрелке;
- `skew(<градусы_по_x>, <градусы_по_y>)` - скашивает элемент по горизонтали и вертикали;
- `skewX(<градусы_по_x>)` - скашивает элемент по горизонтали;
- `skewY(<градусы_по_y>)` - скашивает элемент по вертикали;
- `matrix(<a>, <b>, <c>, <d>, <e>, <f>)` - матрица для изменения в 2d. Представляет из себя матрицу вида:
```
| a c e |
| b d f |
| 0 0 1 |
```
- `matrix3d(<a1>, <b1>, <c1>, <d1>, <a2>, <b2>, <c2>, <d2>, <a3>, <b3>, <c3>, <d3>, <a4>, <b4>, <c4>, <d4>)` - матрица для изменения в 3d.

## Градиенты (CSS3)

### Линейные градиенты

Линейные градиенты создаются с помощью CSS3 метода `linear-gradient()`, который должен указываться в значение свойства `background`. Для того, чтобы создать линейный градиент необходимо указать его направление (может задаваться с помощью ключевых слов или градусов) и цвета перехода.

`background: linear-gradient(<направВУглах>, <цветПерехода1>[ <%PxГрадиента>][, ...]);`

`0` вместо процентной величины обозначает оставшееся расстояние, последнее значение.

### Сферические градиенты

С помощью метода `radial-gradient()` можно создавать сферические градиенты. Синтаксис определения сферических градиентов похож на синтаксис линейных, но требует также задания формы градиента (может быть сферической или эллипсоидной).

`background: radial-gradient([circle, ]<цветПерехода1>[ <%PxГрадиента>][, ...]);`

### Повторяющиеся градиенты

Повторяющиеся градиенты задаются с помощью CSS3 методов `repeating-linear-gradient` (создает повторяющийся линейный градиент) и `repeating-radial-gradient` (создает повторяющийся сферический градиент), и дальнейшее определение как у `linear-gradient` и `radial-gradient` соответственно.

## Анимация

### Переходы: свойство `transition` (CSS3)

С помощью свойства `transition` можно создавать эффекты перехода. Для создания переходов необходимо указать какое CSS свойство будет изменятся и скорость выполнения этих изменений в секундах.

`transition: [<имя_свойства1> | all] <время_в_сек> [<функ_смягчения>] [<задержка_в_сек>] [<шаги>][, ...];`

#### Шаги: steps

Позволяют указать на сколько шагов разбивать анимацию. На то же количество частей делится и временной интервал.

`steps(<количество_шагов_анимации>[, start | end]) | step-start | step-end`

Где:
- `start` - означает, что при начале анимации нужно сразу применить первое изменение;
- `end` - означает, что изменения нужно применять не в начале, а в конце каждого шага;
- `step-start` - то же, что `steps(1, start)`, то есть завершить анимацию в 1 шаг сразу;
- `step-end` - то же, что `steps(1, end)`, то есть завершить анимацию в 1 шаг по истечении `transition-duration`.

### Функции смягчения

Плавность выполнения переходов контролируется с помощью функций смягчения. Существуют несколько видов таких функций:
- `linear` - перемещение происходит постоянной скоростью от начала и до конца.
- `ease` - перемещение начинается медленно и затем набирает скорость (функция смягчения по умолчанию).
- `ease-in` - перемещение начинается медленно.
- `ease-out` - перемещение заканчивается медленно.
- `ease-in-out` - перемещение начинается и заканчивается медленно.
- `cubic-bezier(x,x,x,x)` - ручное определение значения перемещения.

#### Свойство `will-change`

Свойство` will-change` предоставляет автору возможность уведомить браузер об ожидаемом изменении элемента, таким образом браузер может настроить соответствующую оптимизацию до того как элемент действительно изменится.

Основные рекомендации по применению:
- `will-change` не должно применяться к большому числу элементов;
- рекомендуется включать и отключать `will-change` используя скрипт до и после того как произошли изменения;
- `will-change` не применяется к элементам для выполнения преждевременной оптимизации;
- `will-change` необходимо достаточно времени, чтобы работать.

`will-change: auto | scroll-position | contents | <CSS_свойство>[, ...]`

Значения:
- `auto` - это ключевое слово не выражает конкретной цели;
- `scroll-position` - указывает, что автор ожидает анимацию или изменение положения скролла элемента в ближайшем будущем;
- `contents` - указывает, что автор ожидает анимацию или изменение чего то в контенте элемента в ближайшем будущем;
- `<CSS_свойство>` - CSS свойство, которое должно измениться.

### Анимация: свойство `@keyframes`, свойство `animation` (CSS3)

Для создания анимации в CSS3 используется свойство `@keyframes`. Данное свойство представляет собой контейнер, в который должны помещаться различные свойства оформления.

```css
@keyframes <имя_анимации> {
    from {<CSS_свойства_элемента_перед_началом_анимации>}
    to {<CSS_свойства_элемента_после_началом_анимации>}
    [<процент_времени>% {<CSS_свойства_элемента_после_началом_анимации>}]
    [...]
}
```

После того, как анимация была создана необходимо добавить к элементу, который нужно анимировать с помощью свойства `animation` и указать в нем имя анимации и время, в течении которого она будет выполняться. Также можно устанавливать количество повторов анимации.

`animation: <имя_анимации> [<время_в_сек>] [<функ_смягчения>] [<задержка_в_сек>] [<шаги>] [<кол_повторов> | infinite] [normal | reverse | alternate | alternate-reverse] [<режим_воздействия>];`

При значении `alternate` в нечетные разы (1,3,5 ...) анимация будет проигрываться в нормальном, а в четные (2,4,6 ...) в обратном порядке.

Режимы воздействия:
- `none` - анимация воздействует на элемент только во время воспроизведения, по окончании элемент возвращается в исходное состояние.
- `forwards` - анимация воздействует на элемент по окончании воспроизведения.
- `backwards` - анимация воздействует на элемент до начала воспроизведения.
- `both` - анимация воздействует на элемент и до начала, и после окончания воспроизведения.

#### Ход выполнения анимации

Можно определять ход выполнения анимации не только с помощью ключевых слов `from` и `to` (которые использовались в предыдущем примере), но и с помощью %(от 0% до 100%).

### Правила анимациии

Для плавной анимации используются свойства, которые расчитываются на GPU, которые очень дешевые с точки зрения расчетов:
- **позиция** - `transform: translate(<n>px, <n>px)`;
- **масштаб** - `transform: scale(<n>)`;
- **поворот** - `transform: rotate(<n>deg)`;
- **прозрачность** - `opacity: <n>`.

Следующие по стоимости при изменении производят перерасчет стилей:
- `color`;
- `border-style`;
- `visibility`;
- `background`;
- `text-decoration`;
- `background-image`;
- `background-position`;
- `background-repeat`;
- `outline-color`;
- `outline`;
- `outline-style`;
- `border-radius`;
- `outline-width`;
- `box-shadow`;
- `background-size`.

Самые дорогии операции вызывают изменение расположения (layout):
- `width`;
- `height`;
- `padding`;
- `margin`;
- `display`;
- `border-width`;
- `border`;
- `top`;
- `position`;
- `font-size`;
- `float`;
- `text-align`;
- `overflow-y`;
- `font-weight`;
- `overflow`;
- `left`;
- `font-family`;
- `line-height`;
- `vertical-align`;
- `right`;
- `clear`;
- `white-space`;
- `bottom`;
- `min-height`.

### Разбиение текста на столбцы (CSS3)

С помощью свойства `column-count` можно указать количество столбцов, на которые необходимо разбить текст выбранного элемента.

С помощью свойство `column-gap` можно установить величину отступа между столбцами текста.

С помощью свойства `column-rule` можно задать ширину, цвет и стиль оформления пространства между столбцами.

Свойство `column-width` позволяет указывать ширину столбцов текста.

Свойство `column-rule` позволяет указывать границу между колонками в синтаксисе `border`.

## Произвольные свойства и переменные CSS

Переменные объявляются в селекторе как свойство: `--<имя_переменной>: <значение>;`
```css
header {
    --primary-color: 'red';
    --background-color: linear-gradient(#000, #000) center/50px;
    --offset: 10px;
}
```

`<значение>` - может хранить несколько значений независимо от значения переменной.

Для их использования необходимо написать: `var(--<имя_переменной>[, <значение_по_умолчанию>])` - заменит на указаное значение переменной `<значение>`.
```css
h1 {
    color: var(--primary-color, 'white');
    background-color: var(--background-color, 'black');
    padding: var(--offset, 10px) min(calc(var(--offset, 10px) * 2), 15px);
}
```

Если переназначить переменную ниже по дереву, то это подействует на все элементы-потомки.

Когда переменная CSS внутри функции `var()` невалидна, браузер заменяет ее начальным или унаследованным значением в зависимости от свойства.

Эти переменные могут меняются и назначаться в JS:
```javascript
element.style.getPropertyValue("--my-var");
element.style.setProperty("--my-var", jsVar + 4);
```

### Свойства (property)

Используются для описания типа переменных:
```css
@property --<имя_переменной> {
    syntax: '<<тип>>';
    initial-value: <начальное_значение>;
    inherits: <наследование>;
}
```
Где:
- свойство `syntax` - обозначает тип переменной, и `<тип>` может быть одним из:
    - `length`;
    - `number`;
    - `percentage`;
    - `length-percentage`;
    - `color`;
    - `image`;
    - `url`;
    - `integer`;
    - `angle`;
    - `time`;
    - `resolution`;
    - `transform-list`;
    - `transform-function`;
    - `custom-ident` - произвольная строка.
- свойство `initial-value` - обозначает начальное значение переменной, и `<начальное_значение>` может быть только типа переменной;
- свойство `inherits` - обозначает наследование значение переменной от родителя, и `<наследование>` может быть `true` - наследуется или `false`.

Таким образом переменная типизируется указаным типом и не может принимать значения другого, типа, если так будет то будет использовано значение по умолчанию.

Описаная переменная будет доступна в коде как обычная переменная: `var(--<имя_переменной>[, <значение_по_умолчанию>])` и ей также можно произвольно назначать значения.

```css
@property --colorPrimary {
    syntax: '<color>';
    initial-value: magenta;
    inherits: false;
}
```

## Атрибуты данных

Атрибуты данных можно использовать для динамического CSS-содержимого, они доступны внутри селектора: `content: attr(<имя_атрибута>);`.
> `content: attr(data-text);`

Flexbox (CSS3)
==============

**Flexbox** позволяет контролировать размер, порядок и выравнивание элементов по нескольким осям, распределение свободного места между элементами и многое другое.

Flexbox состоит из двух основных элементов, для которых определены наборы CSS свойств:
- **контейнер** (flex-контейнер) - задается как `display: flex` или `display: inline-flex`;
- **дочерние элементы** (flex-блоков).

Внутри флекс-контейнера элементы становятся блочными.

## Основные свойства flex-контейнера

### Главная и поперечная ось: свойство `flex-direction`

**Главной осью** flex-контейнера является направление, в соответствии с которым располагаются все его дочерние элементы.

**Поперечной осью** называется направление, перпендикулярное главной оси.

Главная ось в `ltr` локали по умолчанию располагается слева направо. Поперечная - сверху вниз. Направление главной оси flex-контейнера можно задавать, используя базовое свойство `flex-direction`, принимает значения:
- `row` - (значение по умолчанию) элементы следуют слева направо (в `rtl` справа налево);
- `row-reverse` - справа налево (в `rtl` слева направо);
- `column` - сверху вниз;
- `column-reverse` - снизу вверх.

### Выравнивание по главной оси: свойство `justify-content`

Свойство `justify-content` определяет то, как будут выровнены элементы вдоль главной оси, принимает значения:
- `flex-start` - (значение по умолчанию) блоки прижаты к началу главной оси;
- `start` - аналогично предыдущему;
- `flex-end` - блоки прижаты к концу главной оси;
- `end` - аналогично предыдущему;
- `center` - блоки располагаются в центре главной оси;
- `space-between` - первый блок располагается в начале главной оси, последний блок - в конце, все остальные блоки равномерно распределены в оставшемся пространстве;
- `space-around` - все блоки равномерно распределены вдоль главной оси, разделяя все свободное пространство поровну.

### Выравнивание по поперечной оси: свойство `align-items`

Свойство `align-items` определяет то, как будут выровнены элементы вдоль поперечной оси, принимает значения:
- `flex-start` - блоки прижаты к началу поперечной оси;
- `flex-end` - блоки прижаты к концу поперечной оси;
- `center` - блоки располагаются в центре поперечной оси;
- `baseline` - блоки выровнены по их *baseline*;
- `stretch` - (значение по умолчанию) блоки растянуты, занимая все доступное место по поперечной оси, при этом все же учитываются `min-width`/`max-width`, если таковые заданы.

### Многострочная организация блоков

За многострочность внутри flex-контейнера отвечает свойство `flex-wrap`, принимает значения:
- `nowrap` - (значение по умолчанию) блоки расположены в одну линию слева направо (в `rtl` справа налево);
- `wrap` - блоки расположены в несколько горизонтальных рядов (если не помещаются в один ряд). Они следуют друг за другом слева направо (в `rtl` справа налево);
- `wrap-reverse` - то-же что и `wrap`, но блоки располагаются в обратном порядке.

Свойство `flex-flow` предоставляет возможность в одном свойстве описать направление главной и многострочность поперечной оси. По умолчанию `flex-flow: row nowrap`.

`flex-flow: <flex-direction> || <flex-wrap>`

### Свойство `align-content`

Свойство `align-content` определяет то, каким образом образовавшиеся ряды блоков будут выровнены по линии контейнера flex в контейнере flex при наличии дополнительного пространства на перекрестной оси, работает только в многострочном режиме (т.е. в случае `flex-wrap: wrap;` или `flex-wrap: wrap-reverse;`), принимает значения:
- `flex-start` - ряды блоков прижаты к началу flex-контейнера;
- `start` - аналогично предыдущему;
- `flex-end` - ряды блоков прижаты к концу flex-контейнера;
- `end` - аналогично предыдущему;
- `center` - ряды блоков находятся в центре flex-контейнера;
- `space-between` - первый ряд блоков располагается в начале flex-контейнера, последний ряд блоков блок - в конце, все остальные ряды равномерно распределены в оставшемся пространстве;
- `space-around` - ряды блоков равномерно распределены в от начала до конца flex-контейнера, разделяя все свободное пространство поровну;
- `stretch` - (значение по умолчанию) ряды блоков растянуты, дабы занять все имеющееся пространство.

### Свойство `place-content`

Свойство `place-content` предоставляет возможность в одном свойстве описать выравнивание по линии контейнера и выровнивание элементы вдоль главной оси. При наличии только одного значения свойства, оно будет использовано для двух свойств.

`place-content: <align-content> || <justify-content>`

## CSS правила для дочерних элементов (flex-блоков)

### Базовый размер отдельно взятого flex-блока: свойство `flex-basis`

Свойство `flex-basis` - задает изначальный размер по главной оси для flex-блока до того, как к нему будут применены преобразования, основанные на других flex-факторах. Может быть задан в любых единицах измерения длинны (px, em, %, ...) или `auto`(по умолчанию). Если задан как `auto` - за основу берутся размеры блока (`width`, `height`), которые, в свою очередь, могут зависеть от размера контента, если не указаны явно.

### "Жадность" отдельно взятого flex-блока: свойство `flex-grow`

Свойство `flex-grow` - определяет как много свободного пространства (разница между размером flex-контейнера и размером всех его flex-элементов вместе) во flex-контейнере должно быть назначено текущему элементу, и следовательно в сколько раз отдельный flex-блок может быть больше соседних элементов в качестве пропорции с другими `flex-grow`, если это необходимо. `flex-grow` принимает безразмерное значение (по умолчанию 0).

`<итоговый_размер> = <размер> + <свободное_пространство> * <flex-grow> / <сумма_всех_flex-grow>`

элемент                       | элемент1 | элемент2 | элемент3 | свободное пространство
----------------------------- | -------- | -------- | -------- | -----------------------
размер                        | 40px     | 60px     | 100px    | 320px                  
flex-grow                     | 2        | 1        | 1        |                        
часть свободного пространства | 160px    | 80px     | 80px     |                        
итоговый размер               | 200px    | 140px    | 180px    |                        

### Фактор "сжимаемости" отдельно взятого flex-блока: свойство `flex-shrink`

Свойство `flex-shrink` - определяет, насколько flex-блок будет уменьшаться относительно соседних элементов внутри flex-контейнера в случае недостатка свободного места (по умолчанию 1). Если размер всех flex-элементов больше, чем размер их контейнера, размер элементов будет уменьшен в соответствии с назначенными им значениями свойства `flex-shrink`.

`<итоговый_размер> = <размер> - (<сумма_всех_размеров> - <контейнер>) * <flex-shrink> / <сумма_всех_flex-shrink>`

элемент                | элемент1 | элемент2 | элемент3 | элемент4 | контейнер
---------------------- | -------- | -------- | -------- | -------- | ------------
размер                 | 100px    | 200px    | 100px    | 100px    | 400px       
flex-shrink            | 1        | 0        | 1        | 2        |             
часть отнятого размера | 25px     | 0px      | 25px     | 50px     |             
итоговый размер        | 75px     | 200px    | 75px     | 50px     |             

### Свойство `flex`

Свойство `flex` - короткая запись для свойств `flex-grow`, `flex-shrink` и `flex-basis`

`flex: none | [<flex-grow> <flex-shrink>? || <flex-basis>]`

### Выравнивание отдельно взятого flex-блока по поперечной оси: свойство `align-self`

Делает возможным переопределять свойство flex-контейнера `align-items` для отдельного flex-блока с помощью свойства `align-self`:
- `flex-start` - flex-блок прижат к началу поперечной оси;
- `flex-end` - flex-блок прижат к концу поперечной оси;
- `center` - flex-блок располагаются в центре поперечной оси;
- `baseline` - flex-блок выравнен по baseline;
- `stretch` - (значение по умолчанию) flex-блок растянут, чтобы занять все доступное место по поперечной оси, при этом учитываются `min-width`/`max-width`, если таковые заданы.

### Порядок следования отдельно взятого flex-блока внутри flex-контейнера: свойство `order`

По умолчанию все блоки будут следовать друг за другом в порядке, заданном в html. Однако этот порядок можно изменить с помощью свойства `order`. Оно задается целым числом и по умолчанию равно 0. Значение `order` не задает абсолютную позицию элемента в последовательности. Оно определяет вес позиции элемента.

Выравнивание по горизонтали через `margin: auto` здесь работает и для вертикали.

`margin`-ы в flexbox не "коллапсятся", т.е. не сливаются, как это происходит в обычном потоке.

Значение `float` у flex-блоков не учитывается и не имеет значения.

Grid
====

**CSS Grid layout** приносит инструмент двумерного макета в Веб, с возможностью размещения элементов в строках и столбцах. CSS сетка может использоваться для достижения многих различных макетов. Он разделяет страницу на крупные регионы, или определяет отношения с точки зрения размера, положения и слоя, между частями элемента управления, построенных из HTML примитивов.

## Главный контейнер

`display: grid;` - определяет то, что это контейнер для двумерного макета.  
`grid-template-columns: <размер_колонки1> [<размер_колонки2> [...]];` - определяет ширину колонок (столбцов), можно использовать вместе с `fr` или `auto`.  
`grid-template-rows: <размер_строки1> [<размер_строки2> [...]];` - определяет ширину строк, можно использовать вместе с `fr` или `auto`.

`grid-gap: <размер_промежутка> [<размер_промежутка_колонок>];` - определяет размер промежутка между ячейками сетки как по вертикали так и по горизонтали [по горизонтали переопределяется отдельно].  
`grid-column-gap: <размер_промежутка>;` - определяет размер промежутка между ячейками сетки по горизонтали.  
`grid-row-gap: <размер_промежутка>;` - определяет размер промежутка между ячейками сетки по вертикали.

`grid-auto-columns: <размер_строки1> [<размер_строки2> [...]];` - определяет высоту строк, для элементов которые выходят за пределы сетки.  
`grid-auto-rows: <размер_строки1> [<размер_строки2> [...]];` - определяет ширину строк, для элементов которые выходят за пределы сетки.  
`grid-auto-flow` - управляет поведением автоматически размещаемых элементов, точно указывая, как они попадают в сетку, принимает значения:
- `row` - указывает размещать элементы, заполняя поочередно каждую строку и добавляя новые строки по мере необходимости, по умолчанию;
- `column` - указывает размещать элементы, заполняя поочередно каждый столбец и добавляя новые столбцы по мере необходимости;
- `dense` - указывает заполнять элементами свободное пространство сетки. Это может привести к нарушению порядка, т.к. элементы будут выстраиваться не в соответствии со своим расположением, а в соответсвии с размером;
- `row dense`;
- `column dense`.

Ключевое слово `subgrid` для `grid-template-columns` и `grid-template-rows` - указывает что, будет использоваться сеточное размещения родителя для внутренней сетки.

### Шаблон сетки

Задается с помощью матрицы, где каждая строка кода представляет строку в макете, и каждый из символов `<сим>` представляет ячейку сетки. Одинаковые символы образуют одинаковую область. "." - обозначает пустую ячейку сетки. Одинаковые символы должны образовывать **прямоугольник**.

```css
{
    grid-template-areas:
        "<сим11> ... <симN1>"
        ...
        "<сим1M> ... <симNM>";
}
```

### Названия линий

В свойствах `grid-template-columns` и `grid-template-rows` можно указывать названия линий, для этого они указываются в квадратных скобках перед размерами и это будет означать что название линии будет алиасом номеру при дальнейшем использовании: `[<имя_линии1>] <размер1>[ ...] [ [<имя_линии2>] <размер1>[ ...] ] [ ...]`
>   ```css
>   {
>       grid-template-columns: [left] 100px 200px [center] 300px [right];
>       /* left = 1, center = 3, right = 4 (такой колонки нет, но ее можно использовать для указания до)*/
>       grid-template-rows: [top] 100px [center] 20px 40px [bottom];
>       /* top = 1, center = 2, bottom = 4 (такой строки нет, но ее можно использовать для указания до)*/
>   }
>   ```

## Дочерние контейнеры

Задание горизонтального положения (по умолчанию 1), т.е. элемент начнется на `<номер_колонки_начала>` линии сетки и закончится на `<номер_колонки_окончания>` линии сетки по горизонтали.
```
      1   2   .   N
    1 +---+---.---+
      |   |   .   |
    2 +---+---.---+
      |   |   .   |
    . .............
      |   |   .   |
    M +---+---.---+
```

`grid-column-start: <номер_колонки_начала>;`  
`grid-column-end: <номер_колонки_окончания>;`  
`grid-column: <номер_строки_начала> / <номер_строки_окончания>;` - сокращение

Задание вертикального положения (по умолчанию 1), т.е. элемент начнется на `<номер_строки_начала>` линии сетки и закончится на `<номер_строки_окончания>` линии сетки по вертикали (но не включит ее).

`grid-row-start: <номер_строки_начала>;`  
`grid-row-end: <номер_строки_окончания>;`  
`grid-row: <номер_строки_начала> / <номер_строки_окончания>;` - сокращение

Вместо номера строки / колонки можно использовать названия линий.

> `grid-column: left / center;` что аналогично `grid-column: 1 / 3;`

`grid-area: <grid-row-start>, <grid-column-start>, <grid-row-end>, <grid-column-end>;` - общая запись.

Можно передавать отрицательные индексы и тогда отсчет будет идти в обратную сторону.
> `grid-column: 1 / -1;`

Ключевое слово `auto` - указывает что это будет колонка или строка, на которую элемент будет помещён в результате автоматического размещения.

`span <длина>` - обозначает протяженность элемента.
> `grid-column: auto / span 3;`

### Расположение на шаблоне сетки

Указанный элемент должен располагаться на месте `<сим>` - символа зоны, в макете шаблона сетки.

`grid-area: <сим>;`

### Выравнивание

Свойство `align-self` используется для выравнивания по вертикали и принимает значения:
- `start` - по верхнему краю ячейки;
- `center` - по центру краю ячейки;
- `end` - по нижнему краю ячейки.

Свойство `justify-self` используется для выравнивания по горизонтали и принимает значения:
- `start` - по левому краю ячейки;
- `center` - по центру краю ячейки;
- `end` - по правому краю ячейки.

### Свойство `justify-items`

Свойство `justify-items` определяет атрибут по умолчанию `justify-self` для всех элементов блока, предоставляя всем им способ выравнивания по умолчанию каждого блока вдоль соответствующей оси.:
- `flex-start` - блоки прижаты к началу поперечной оси;
- `flex-end` - блоки прижаты к концу поперечной оси;
- `center` - блоки располагаются в центре поперечной оси;
- `baseline` - блоки выровнены по их *baseline*;
- `stretch` - (значение по умолчанию) блоки растянуты, занимая все доступное место по поперечной оси, при этом все же учитываются `min-width`/`max-width`, если таковые заданы.

### Свойство `place-items`

Свойство `place-items` предоставляет возможность в одном свойстве описать выравнивание по линии контейнера и выровнивание элементы вдоль главной оси. При наличии только одного значения свойства, оно будет использовано для двух свойств.

`place-items: <align-items> || <justify-items>`

## Отличие Grid от Flexbox

Grid для макетов, Flexbox для компонентов.

Если у компонента все дочерние элементы отображаются встроенными (inline) в ряд, то лучше использовать Flexbox. Если присутствуют столбцы и строки, то лучше Grid.

Адаптивность
============

## CSS viewport в HTML

`<meta name="viewport" content="<свойство>=<значение>[, ...]" />` - используется для задания видимой области страницы.

Основные свойства мета-тега `viewport`:
- `width` - ширина видимой области. Рекомендуемое значение: `device-width`. Принимает натуральное число или ключевое слово `device-width`, устанавливающее оптимальную ширину `viewport` для устройства;
- `height` - высота видимой области. Работает аналогично `width`, только используется ключевое слово `device-height`;
- `initial-scale` - первоначальный масштаб страницы. Рекомендуемое значение: 1. Принимает число от 1 до 5;
- `minimum-scale` - минимальный масштаб страницы. Принимает натуральное число, которое идеологически должно быть меньше или равным `initial-scale`. Значение 1 запретит уменьшение масштаба страницы;
- `maximum-scale` - максимальный масштаб страницы. Принимает натуральное число, которое идеологически должно быть больше или равным `initial-scale`. Значение 1 запретит увеличение масштаба страницы;
- `user-scalable` - отключает или включает возможность масштабирования страницы. Принимает значение `no` или `yes`. Масштабирование отключается также при указании одинаковых значений `minimum-scale` и `maximum-scale`.

## Media Queries в CSS

```css
@media [not | only] <тип_носителя> and (<медиа-функция>: <значение>) {
    <описание_CSS_селекторов_для_этого_media>
}
```

Основные типы носителей:
- `all` - все типы, значение по умолчанию;
- `screen` - экраны настольных компьютеров, планшетов и современных мобильных телефонов;
- `print` - принтеры;
- `speech` - речевые браузеры, которыми пользуются люди с ограниченными возможностями.

Наиболее часто используемые медиа-функции:
- **width** (`min-width`, `max-width`) - ширина окна браузера;
    - `min-width` означает, что стили будут применены при ширине, равной или большей указанной;
    - `max-width` означает, что стили будут применены при ширине не больше указанной.
- **height** (`min-height`, `max-height`) - высота окна браузера;
- **device-width** (`min-device-width`, `max-device-width`) - ширина экрана устройства (может быть больше ширины браузера);
- **device-height** (`min-device-height`, `max-device-height`) - высота экрана устройства;
- **orientation** - принимает значения `landscape` или `portrait` для определения альбомной и портретной ориентации соответственно;
- **aspect-ratio** (`min-aspect-ratio`, `max-aspect-ratio`) - принимает значения `<ширина>/<высота>` (`16/9`) для определения соотношения сторон: ширине к высоте;
- **hover** (`any-hover`) - принимает значения `hover` или `none` для определения возможности наводиться на элементы или нет соответственно;
- **pointer** (`any-pointer`) - принимает значения `coarse`, `fine` или `none` для определения основного механизма ввода: включает в себя указатель неточного ввода, точного ввода или нет указателя ввода соответственно;
- **color-scheme** (`prefers-color-scheme`) - принимает значения `light` или `dark` для определения предпочитаемой пользователем цветовой темы.

## Директива `@supports`

Используется для определения поддерживаемости свойства и его значения в текущем браузере:
```css
@supports (<свойство>: <значение>) {
    <описание_CSS_селекторов_в_случае_поддержки>
}
```

Могут применяться условные операторы `and`, `or` или `not`, тогда каждое свойство со значением должно быть обернуто в скобки.
> `(display: flexbox) and ( not (display: inline-grid) ) or (transform-style: preserve)`


Приемы
======

## Эффект длинных теней для текста

```css
* {
    color: #444444;
    background: #ffffff;
    text-shadow: 1px 0px 1px #cccccc, 0px 1px 1px #eeeeee, 2px 1px 1px #cccccc, 1px 2px 1px #eeeeee, 3px 2px 1px #cccccc, 2px 3px 1px #eeeeee, 4px 3px 1px #cccccc, 3px 4px 1px #eeeeee, 5px 4px 1px #cccccc, 4px 5px 1px #eeeeee, 6px 5px 1px #cccccc, 5px 6px 1px #eeeeee, 7px 6px 1px #cccccc;
}
```

## Эффект контурного текста

```css
* {
    color: #fff;
    text-shadow: 
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
}
```

## Размытие текста

```css
* {
    color: transparent;
    text-shadow: 0 0 3px #fff;
}
```

БЭМ
===

**БЭМ** (*Блок*, *Элемент*, *Модификатор*) - компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки.

## Блок

Функционально независимый компонент страницы, который может быть повторно использован. В HTML блоки представлены атрибутом `class`. Особенности:
- **название блока** характеризует смысл (*"что это?" - "меню": menu, "кнопка": button*), а не состояние (*"какой, как выглядит?" - "красный": red, "большой": big*);
- **имя блока** формируется по схеме `<имя-блока>`, каждое слово в имени идет через тире `-` и задает пространство имен для элементов и модификаторов;
- блок не должен влиять на свое окружение, т. е. блоку не следует задавать внешнюю геометрию (в виде отступов, границ, влияющих на размеры) и позиционирование;
- в CSS по БЭМ также не рекомендуется использовать селекторы по тегам или id.

Таким образом обеспечивается независимость, при которой возможно повторное использование или перенос блоков с места на место.

Вложенность блоков:
- блоки можно вкладывать друг в друга;
- допустима любая вложенность блоков.

## Элемент

Составная часть блока, которая не может использоваться в отрыве от него. Особенности:
- **название элемента** характеризует смысл (*"что это?" - "пункт": item, "текст": text*), а не состояние (*"какой, как выглядит?" - "красный": red, "большой": big*);
- **структура полного имени элемента** соответствует схеме:  
    `<имя-блока>__<имя-элемента>`  
    Имя элемента отделяется от имени блока двумя подчеркиваниями `__`, каждое слово в имени идет через тире `-` и задает пространство имен, которое гарантирует зависимость элементов от блока (`block__elem`).

Вложенность элементов:
- элементы можно вкладывать друг в друга;
- допустима любая вложенность элементов;
- элемент - всегда часть блока, а не другого элемента. Это означает, что в названии элементов нельзя прописывать иерархию вида `block__elem1__elem2`.

Блок может иметь вложенную структуру элементов в DOM-дереве. Однако эта же структура блока в методологии БЭМ всегда будет представлена плоским списком элементов. Это позволяет изменять DOM-структуру блока без внесения правок в коде каждого отдельного элемента. Структура блока меняется, а правила для элементов и их названия остаются прежними.

**Элемент** - всегда часть блока и не должен использоваться отдельно от него.  
**Элемент** - необязательный компонент блока. Не у всех блоков должны быть элементы.  
**Элемент** создается, если фрагмент кода не может использоваться самостоятельно, без родительской сущности (блока).

## Модификатор

Сущность, определяющая внешний вид, состояние или поведение блока либо элемента. Особенности:
- **название модификатора** характеризует внешний вид (*"какой размер?", "какая тема?" и т. п. - "размер": size_s, "тема": theme_islands*), состояние (*"чем отличается от прочих?" - "отключен": disabled, "фокусированный": focused*) и поведение (*"как ведет себя?", "как взаимодействует с пользователем?" - "направление": directions_left-top*);
- **имя модификатора** отделяется от имени блока или элемента одним подчеркиванием `_`, каждое слово в имени идет через тире `-` или `_`.

### Типы модификаторов

**Булевый**:
- используют, когда важно только наличие или отсутствие модификатора, а его значение несущественно. Например, `"отключен": disabled`. Считается, что при наличии булевого модификатора у сущности его значение равно `true`;
- структура полного имени модификатора соответствует схеме:  
    `<имя-блока>_<имя_модификатора>`;  
    `<имя-блока>__<имя-элемента>_<имя_модификатора>`.

**Ключ-значение**:
- используют, когда важно значение модификатора. Например, "меню с темой оформления islands": menu_theme_islands;
- структура полного имени модификатора соответствует схеме:  
    `<имя-блока>_<имя_модификатора>_<значение_модификатора>`;  
    `<имя-блока>__<имя-элемента>_<имя_модификатора>_<значение_модификатора>`.

### Принципы работы с модификаторами

С точки зрения БЭМ-методологии модификатор не может использоваться в отрыве от модифицируемого блока или элемента. Модификатор должен изменять вид, поведение или состояние сущности, а не заменять ее.

## Микс

Прием, позволяющий использовать разные БЭМ-сущности на одном DOM-узле. Миксы позволяют:
- совмещать поведение и стили нескольких сущностей без дублирования кода;
- создавать семантически новые компоненты интерфейса на основе имеющихся.

Микс содержит одновременно и блок и элемент.