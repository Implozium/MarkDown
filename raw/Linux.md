Основы скриптов bash
====================

## Основные файлы для запуска

При сеансе командной оболочки входа (login shell session) выполняются файлы:
- `/etc/profile` - обшесистемный файл для всех пользователей;
- `~/.bash_profile` - личный файл для пользователя для расширения обшесистемного файла;
- `~/.bash_login` - личный файл, когда файл `~/.bash_profile` отсутствует;
- `~/.profile` - личный файл, когда файлы `~/.bash_profile` и `~/.bash_login` отсутствуют.

При сеансе простой командной оболочки (non-login shell session) выполняются файлы:
- `/etc/bash.bashrc` - обшесистемный файл для всех пользователей;
- `~/.bashrc` - личный файл для пользователя для расширения обшесистемного файла.

## Перехват ошибок

`set -euo pipefail` - обозначает установку строгого режима, обычно пишется в первых строках скрипта, где:
- `e` - останавливает выполнение команды в случае ошибки в скрипте;
- `u` - вызывает ошибку при доступе к несуществующим переменным;
- `o` и `pipefail` - вызывает ошибку в случае ошибки в пайплайне.

## Основные понятия

**Сценарии командной строки** - это наборы команд, которые можно вводить с клавиатуры, собранные в файлы и объединенные некоей общей целью. При этом результаты работы команд могут представлять либо самостоятельную ценность, либо служить входными данными для других команд.

## Специальные символы

Символ  | Название             | Применение
------- | -------------------- | ---------
`*`     | Звездочка            | Регулярные выражения, джокерные символы
`.`     | Точка                | Текущий каталог, разделитель имени файла и хоста
`!`     | Восклицательный знак | Отрицание, история команд
`|`     | Вертикальная черта   | Командный конвейер
`/`     | Прямой слеш          | Разделитель каталогов, команда поиска
`\`     | Обратный слеш        | Литералы, макросы (но не каталоги)
`$`     | Доллар               | Обозначение переменной, конец строки
`'`     | Одиночная кавычка    | Буквенные строки
`` ` `` | "Обратная галочка"   | Замена команды
`"`     | Двойная кавычка      | Частично буквенные строки
`^`     | Знак вставки         | Отрицание, начало строки
`~`     | Тильда               | Отрицание, ярлык каталога
`#`     | Диез, знак фунта     | Комментарии, препроцессор, подстановки
`[ ]`   | Квадратные скобки    | Массивы
`{ }`   | Фигурные скобки      | Блоки инструкций, массивы
`_`     | Подчеркивание        | Просто замена символа пробела

`^<клавиша>` = `Ctrl + <клавиша>`

## Сочетания клавиш для командной строки

Сочетание клавиш | Действие
---------------- | --------
`Ctrl + B`       | Перемещение курсора влево
`Ctrl + F`       | Перемещение курсора вправо
`Ctrl + P`       | Просмотр предыдущей команды (или перемещение курсора вверх)
`Ctrl + N`       | Просмотр следующей команды (или перемещение курсора вниз)
`Ctrl + A`       | Перемещение курсора в начало строки
`Ctrl + E`       | Перемещение курсора в конец строки
`Ctrl + W`       | Удаление предыдущего слова
`Ctrl + U`       | Удаление текста от курсора до начала строки
`Ctrl + K`       | Удаление текста от курсора до конца строки
`Ctrl + Y`       | Вставка удаленного текста (например, после команды `CTRL+U`)

### Запуск

Для того чтобы сценарий запускался ему необходимо установить разрешение, сделать его выполняемым:  
`chmod +x ./<имя_файла>`  
`./<имя_файла>` - запускает скрипт

### Строение файла скрипта

Первая строка должна быть такого вида:  
`#!/bin/bash`

Команды оболочки отделяются знаком перевода строки или знаком точки с запятой `;`, комментарии выделяют знаком решетки `#`.

`<команда1> && <команда2>` - выполняет команду `<команда2>` только если команда `<команда1>` выполнилась успешно.  
`!!` - алиас предыдущей команды.

#### Строки

`"<текст>"` - при объявлении строки в таком формате будут работать только символы `$`, `\`, `` ` ``. Для их экранирования нужно использовать символ `\`.

`'<текст>'` - при объявлении строки в таком формате подавлены все символы подстановки.

Для вывода кавычек в строках используется экранировани с помощью символа `\` перед кавычкой.

#### Вывод `echo`

`echo [-n] [-e] "<текст>"` - выводит текст (список своих аргументов после флага в консоль) в консоль, для вывода знака `$` нужно писать `\$` [, `-n` - без перехода на новую строку] [, `-e` - расширенный режим для возможности интерпритации управляющи последовательностей].

> `echo "Home for the current user is: $HOME"`

##### Изменение цвета текста и фона в расширенном режиме `-e`

`\033[<атрибут_1>[;<атрибут_2>[;...]]m` - выводит последующие символы, с указанными характеристиками.  
`\u001b[<атрибут_1>[;<атрибут_2>[;...]]m` - аналогично.

Значения общих атрибутов:
- `0` - сбросить все атрибуты;
- `1` - bright (повышенная яркость);
- `2` - dim (затемнение);
- `4` - underscore (нижнее подчеркивание);
- `5` - blink (мигание);
- `7` - reverse (инверсия);
- `8` - hidden (скрыть текст).

Значения атрибутов цвета шрифта:
- `30` - black (черный);
- `31` - red (красный);
- `32` - green (зеленый);
- `33` - yellow (желтый);
- `34` - blue (синий);
- `35` - magenta (пурпурный);
- `36` - cyan (голубой);
- `37` - white (белый).

Значения атрибутов цвета фона:
- `40` - black (черный);
- `41` - red (красный);
- `42` - green (зеленый);
- `43` - yellow (желтый);
- `44` - blue (синий);
- `45` - magenta (пурпурный);
- `46` - cyan (голубой);
- `47` - white (белый).

> `\033[33msome text\033[0m`

##### Перемещение курсора

Производится с помощью управляющих последовательностей:
- `\033[<номер_строки>;<номер_колонки>H` - перемещает курсор в строку `<номер_строки>` и позицию `номер_колонки>`;
- `\033[<количество>A` - перемещает курсор в вверх на `<количество>` строк;
- `\033[<количество>B` - перемещает курсор в вниз на `<количество>` строк;
- `\033[<количество>C` - перемещает курсор в вперед (вправо) на `<количество>` символов;
- `\033[<количество>D` - перемещает курсор в назад (влево) на `<количество>` символов;
- `\033[2J` - очищает экран и помещает курсор в левый верхний угол (строка 0, позиция 0);
- `\033[K` - очищает экран от позиции курсора до конца текущей строки;
- `\033[s` - сохраняет текущую позицию курсора;
- `\033[u` - восстанавливает сохраненную позицию курсора.

## Переменные

`<имя_переменной>=<значение>` - установка значения переменной.
> `person="Adam"`

`$<имя_переменной>` - возвращает значение переменной, это можно использовать также в строке.  
`${<имя_переменной>}` - аналогично.
> `echo "Current script is ${srcipt}";`

``<имя_переменной>=`<команда>` `` - записывает результат вывода команды в переменную.  
`<имя_переменной>=$(<команда>)` - аналогично.
```
mydir=`pwd`
mydir2=$(pwd)
```

`<имя_переменной>=$((<математические_операции>))` - выполняет математические операции и записывает результат в переменную.
`<имя_переменной>=$[<математические_операции>]` - аналогично.
> `var2=$(( $var1 * 2 ))`

`expr "<выражение>"` - вычисляет математическое выражение и возвращает его результат.
> `a=$( expr 10 - 3 )`

Для записи многострочного текста в переменную или поток используется конструкция с использованием `cat <<EOF` и `EOF`
```bash
<имя_переменной>=$(cat <<EOF
<текст>
EOF
)
```

### Переменные окружения

`export <имя_переменной>` - экспортирует переменную как переменную окружения с указанным значением, которая будет доступна дочерним процессам этой оболочки.
> `export STUFF`

`printenv [<имя>]` - выводит список всех [только значние указанной с именем `<имя>`] переменных окружения с их значениями.

`set` - выводит список всех переменных окружения и оболочки с их значениями.

#### Специальные переменные окружения

`PATH` - содержит командный путь для поиска команд, пути разделяются знаком `:`.

`PS1` - содержит приглашение ко вводу в терминале, состоит из специальных символов.

## Конструкция if-then-else

```bash
if [!] <команда>
then
    <комманды>
[elif <команда>
then
    <комманды>]
[else
    <комманды>]
fi
```

> `if ps aux | grep some_proces[s] > /tmp/test.txt; then echo 1; else echo 0; fi`

Если выполнение команды `<команда>` завершится успешно, а именно будет возвращено нуль, то выполнятся комманды от `then` и до `elif` / `else` / `fi` [, иначе выполнятся комманды от `else` и до `fi`].

Знак `!` обозначает отрицание.

Команда в условии может быть не одной, а содержать конструкции `&&` и `||`.

### Сравнения и проверки

`[` - является синонимом команды `test`, и является встроенной командой, `[<выражение>]`. Условие, находящееся внутри квадратных скобок может быть проверено без использования оператора `if`.  
`if [ <выражение> ]`

`[[<выражение>]]` - расширенный вариант команды `test`, которая выполняет сравнение более стандартным способом, пишущим на других языках программирования.

Круглые скобки `((<выражение>))` и предложение `let <выражение>` возвращают код 0, если результатом арифметического выражения является ненулевое значение.

`let <выражение>` - позволяет вычислить выражение и записать его в переменную.
> `let a=5+4`  
> `let "a = $1 + 30"`

Выражение должно быть заключено в квадратные скобки `[<выражение>]` и использоваться вместо команды `<команда>`.
Операторы `&&`, `||`, `<` и `>` внутри `[[ ]]` вполне допустимы, в то время как внутри `[ ]` порождают сообщения об ошибках.

#### Сравнение чисел

- `<число1> -eq <число2>` - возвращает истинное значение, если `<число1>` равно `<число2>`;
- `<число1> -ge <число2>` - возвращает истинное значение, если `<число1>` больше или равно `<число2>`;
- `<число1> -gt <число2>` - возвращает истинное значение, если `<число1>` больше `<число2>`;
- `<число1> -le <число2>` - возвращает истинное значение, если `<число1>` меньше или равно `<число2>`;
- `<число1> -lt <число2>` - возвращает истинное значение, если `<число1>` меньше `<число2>`;
- `<число1> -ne <число2>` - возвращает истинное значение, если `<число1>` не равно `<число2>`.
> `[ $val1 -gt 5 ]`

Вместо чисел можно использовать переменные.

#### Сравнение строк

- `"<строка1>" = "<строка2>"` - проверяет строки на равенство, возвращает истину, если строки идентичны;
- `"<строка1>" != "<строка2>"` - возвращает истину, если строки не идентичны. ;
- `"<строка1>" \< "<строка2>"` - возвращает истину, если `<строка1>` меньше, чем `<строка2>`;
- `"<строка1>" \> "<строка2>"` - возвращает истину, если `<строка1>` больше, чем `<строка2>`;
- `-n "<строка>"` - возвращает истину, если длина `<строка>` больше нуля;
- `-z "<строка>"` - возвращает истину, если длина `<строка>` равна нулю.
> `[ $val = "user" ]`

Вместо строк можно использовать переменные, но их нужно заключать в кавычки `"`.
> `[ $val1 \> "$val2" ]`

#### Проверки файлов

- `-d <файл>` - проверяет, существует ли файл, и является ли он директорией;
- `-e <файл>` - проверяет, существует ли файл;
- `-f <файл>` - проверяет, существует ли файл, и является ли он файлом;
- `-r <файл>` - проверяет, существует ли файл, и доступен ли он для чтения;
- `-s <файл>` - проверяет, существует ли файл, и не является ли он пустым;
- `-w <файл>` - проверяет, существует ли файл, и доступен ли он для записи;
- `-x <файл>` - проверяет, существует ли файл, и является ли он исполняемым;
- `<файл1> -nt <файл2>` - проверяет, новее ли `<файл1>`, чем `<файл2>`;
- `<файл1> -ot <файл2>` - проверяет, старше ли `<файл1>`, чем `<файл2>`;
- `-O <файл>` - проверяет, существует ли файл, и является ли его владельцем текущий пользователь;
- `-G <файл>` - проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя;
- `<файл>` - должен выглядеть как путь к файлу, если в нем есть пробелы, то он должен быть заключен в кавычки.
> `[ -d /home/likegeeks ]`

Вместо файл можно использовать переменные.
> `[ -d $mydir ]`

## Циклы

Циклы можно вкладывать друг в друга.

### Цикл `for`

```bash
for <имя_переменной> in <список>
do
    <комманды>
done
```

В каждой итерации цикла в переменную `<имя_переменной>` будет записываться следующее значение из списка `<список>`.

Список может быть набором значений разделенных разделителем полей (**пробел**, **знак табуляции**, **знак перевода строки**) или результатом вывода команды.

```bash
for var in first "the second" "the third" fourth fifth
do
    echo The $var item
done
```

> `file="myfile"; for var in $(cat $file); do echo " $var"; done`

### Установка разделителей полей

Для этого нужно изменить переменную среды `IFS`:  
`IFS=$'\n'` - устанавливает в качестве разделителя - символ новой строки.  
`IFS=<символ>` - установка произвольного символа.  
`IFS="<символ>[...]"` - установка произвольных символов

### Обход директорий

В качестве списка может быть указано путь к директории, подстановочный знак `*` - обозначает все.

> `for file in /home/likegeeks/*`

### Цикл `for` в стиле C

```bash
for ((<начальное_значение_переменной>; <условие_окончания_цикла>; <изменение переменной>))
do
    <комманды>
done
```

```bash
for (( i = 1; i <= 10; i++ ))
do
    echo "number is $i"
done
```

```bash
for (( i = 0; i < ${#scripts[@]}; i++ ))
do
    script=${scripts[$i]};
    (( i++ ));
    log=${scripts[$i]};
    > ${log};
    echo "Run script '${script}' to log '${log}'";
    ${script} &> ${log} &
done

```

### Цикл `while`

```bash
while <команда>
do
    <комманды>
done
```

Будет выполнять тело цикла до тех пор, пока проверяемое условие возвращает ноль, или сигнал успешного завершения некоей операции.

Вместо команды `<команда>`, можно использовать выражение.

### Команда `break`

Эта команда позволяет прервать выполнение цикла.

### Команда `continue`

Эта команда завершает текущую итерацию досрочно и начинает следующую, при этом выхода из цикла не происходит.

### Перенаправление вывода цикла

После слова `done`, на той же сточке можно указать перенаправление в файл: `done > <файл>`.
> `done > myfile.txt`

## Параметры командной строки

Параметры командной строки разделяются из переменной `IFS`.

**Специальные переменные** - позиционные параметры, введенные при вызове скрипта параметры командной строки, можно получить:
- `$0` - имя скрипта;
- `$1` - первый параметр;
- `$<n>` - n-ый параметр, вплоть до переменной $9;
- `${<n>}` - n-ый параметр, от 10;
- `$#` - содержит количество параметров, переданных сценарию при вызове;
- `${!#}` - содержит последний параметр;
- `$*` - содержит все параметры командной строки, в виде единого "*слова*";
- `$@` - содержит все параметры командной строки, где параметры разбиты на отдельные "*слова*". Эти параметры можно перебирать в циклах.

### Команда `shift`

Она, по умолчанию, сдвигает значения позиционных параметров влево: `$<n>` становится `$<n-1>`, при этом `$0`, не меняется.

## Конструкция case

```bash
case "<ключ>" in
<значение_1>) <комманды> ;;
...
*) <комманды_при_не_совпадении> ;;
esac
```

```bash
echo
while [ -n "$1" ]
do
    case "$1" in
    -a) echo "Found the -a option" ;;
    -b) echo "Found the -b option" ;;
    -c) echo "Found the -c option" ;;
    *) echo "$1 is not an option" ;;
    esac
    shift
done
```

Сверяет `<ключ>` со значениями и выполняет указанные команды при соответствии значения с ключом. Если соответствия не найдется, будет исполнена ветвь `*`.

Последовательность - двойное тире `--` - признак окончания ключей.


## Функции

Объявление функции, имена для функций, должны быть уникальными, так как новая функция затирает старую.

```bash
function <имя_функции>[()] {
    <код>
    [return <значение>]
}
```
`return <значение>` - позволяет задавать возвращаемый функцией целочисленный код завершения.

Имя функции хранится внутри функции в параметре `$0`, первый переданный ей аргумент - в `$1`, второй - в `$2`, и так далее, а количество переданных аргументов в `$#`, `$@` - содержит все аргументы в виде массива.

```bash
msg() {
    echo >&2 -e "${1-}"
}
```

`<имя_функции> [<аргумент> [...]]` - вызов функции.
> `msg "This is text"`

В переменной `$?` хранится код возврата последней выполненной команды в том числе и функции, тогда максимальное число, которое может вернуть команда `return` - `255`.

`<переменная>=$(<имя_функции> [<аргумент> [...]])` - записывает в переменную результат функции.

Внутри функции можно вызвать саму функцию по имени.

### Переменные

**Глобальные переменные** - это переменные, которые видны из любого места bash-скрипта. По умолчанию все объявленные в скриптах переменные глобальны.  
**Локальные переменные** - их объявляют и используют внутри функции. Если за пределами функции есть переменная с таким же именем, это на нее не повлияет.

`local <имя_переменной>=<значение>` - установка значения локальной переменной для функции.

### Массив

`<имя_переменной>= (<значение_1> [...])` - объявление массива (списка).  
`${<имя_переменной>[<индекс>]}` - возвращает указанный индекс элемента массива, `*` (`@`) - все.  
`${!<имя_переменной>[@]}` - возвращает индексы массива.  
`${#<имя_переменной>[@]}` - возвращает размер массива.  
`<имя_переменной>[<индекс>]=<значение>` - перезаписывает элемент массива.  
`<имя_переменной>+=(<значение>)` - присоединяет к массиву значения.  
`<имя_переменной>=$(<команда>)` - сохраняет вывод команды в виде строки в переменную.  
`<имя_переменной>=( $(<команда>) )` - сохраняет вывод команды в виде массива.  
`${<имя_переменной>[@]:s:n}` - возвращает элементы массива начиная с элемента с индексом `s` до элемента с индексом `s+(n-1)`.

> `str=$(ls)`  
> `arr=( $(ls) )`

Для передачи массива в функцию из него надо извлечь имеющиеся в нем данные и передать их функции как самостоятельные аргументы - `${<имя_переменной>[*]}`.

### Манипуляции со строками

`${#<имя_переменной>}` - возвращает длину строки.  
`` `expr length $<имя_переменной>` `` - возвращает длину строки.  
`` `expr [match] "$<имя_переменной>" : '<регулярное_выражение>'` `` - возвращает длину строки, которая удолетворяет регулярному выражению.
> ``stringZ=abcABC123ABCabc; echo `expr match "$stringZ" 'abc[A-Z]*.2'` ``

`${<имя_переменной>:<позиция>[:<длина>]}` - возвращает подстроку начиная с символа на позиции [указанной длины].  
`${<имя_переменной>:(-<длина>)}` - возвращает подстроку начиная с конца указанной длины.
> `${stringZ:(-4)}`

`` `expr [match] "$<имя_переменной>" : '[.*]\(<регулярное_выражение>\)'` `` - возвращает подстроку, которая удолетворяет регулярному выражению с начала строки [`.*` - с конца].
> `` `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'` ``

`${<имя_переменной>#<строка>}` - возвращает из пременной строку в которой удалена короткая подстрока с начала строки.  
`${<имя_переменной>##<строка>}` - возвращает из пременной строку в которой удалена длинная подстрока с начала строки.  
`${<имя_переменной>%<строка>}` - возвращает из пременной строку в которой удалена короткая подстрока с конца строки.  
`${<имя_переменной>%%<строка>}` - возвращает из пременной строку в которой удалена длинная подстрока с конца строки.
> `${stringZ#a*C}`

`${<имя_переменной>/<строка1>/<строка2>}` - возвращает из пременной строку в которой заменена строка `<строка1>` на строку `<строка2>`.  
`${<имя_переменной>//<строка1>/<строка2>}` - возвращает из пременной строку в которой заменены все строки `<строка1>` на строки `<строка2>`.
> `${stringZ//abc/xyz}`  
> `${<имя_переменной>//:/$'\n'}`

Строку из переменной можно преобразавать к массиву, путем его создания: `<array>=(${<имя_переменной>//<разделитель>/ });`:
> `array=(${string//:/ })`

## Создание и использование библиотек

`source <путь_к_скрипту>` - подключает скрипт как библиотеку к скрипту и в результате функции, объявленные в библиотеке, становятся доступными в скрипте.  
`. <путь_к_скрипту>` - аналогично.
> `source .bashrc`

## Стандартные ключи Linux

- `-a` - вывести все объекты;
- `-c` - произвести подсчет;
- `-d` - указать директорию;
- `-e` - развернуть объект;
- `-f` - указать файл, из которого нужно прочитать данные;
- `-h` - вывести справку по команде;
- `-i` - игнорировать регистр символов;
- `-l` - выполнить полноформатный вывод данных;
- `-n` - использовать неинтерактивный (пакетный) режим;
- `-o` - позволяет указать файл, в который нужно перенаправить вывод;
- `-q` - выполнить скрипт в quiet-режиме;
- `-r` - обрабатывать папки и файлы рекурсивно;
- `-s` - выполнить скрипт в silent-режиме;
- `-v` - выполнить многословный вывод;
- `-x` - исключить объект;
- `-y` - ответить `yes` на все вопросы.

## Ввод значений от пользователя

`read [-p "<текст>"] [-t <время_ожидания>] [-s] <имя_переменной> [...]` - позволяет принимать введенные данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов, после получения данных, эта команда помещает их в указанную переменную, [`-s` - не отображать вывод].
> `read -p "Enter your name: " first last`

Если, не указывать переменную, данные, введенные пользователем, будут помещены в специальную переменную среды `REPLY`.

`read` может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится.

`read line` - такая команда может быть использована в цикле `while` в качестве команды условия, для построчного чтения файла и записи строки в переменную `line`.

```bash
cat myfile | while read line
do
    echo "Line: $line"
done
```

## Дескрипторы файлов

Все в Linux - это файлы, в том числе - ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2. Вот что они означают:
- `0`, `STDIN` - стандартный поток ввода. Для терминала стандартный ввод - это клавиатура. Когда в сценариях используют символ перенаправления ввода - `<`, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры;
- `1`, `STDOUT` - стандартный поток вывода. По умолчанию это - экран. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда `>>`, или перезаписать его содержимое новым, для этого служит команда `>`;
- `2`, `STDERR` - стандартный поток ошибок. По умолчанию этот дескриптор указывает на то же самое, на что указывает `STDOUT`.

### Перенаправление потоков ошибок и вывода

`<команда> [1> <дескриптор>] [2> <дескриптор>]` - перенаправляет потоки вывод и ошибки. Для того чтобы перенаправить `STDERR`, и `STDOUT` в один и тот же файл, воспользовавшись командой `&>`. Где `<дескриптор>` - может быть путь к файлу или дескриптором `&<номер>`.

### Временное перенаправление вывода

`<команда> >&1` - перенаправление вывода команды в поток вывода.  
`<команда> >&2` - перенаправление вывода команды в поток ошибки.

`<команда> 2>&1` - перенаправление вывода ошибок команды в поток вывода.

### Постоянное перенаправление вывода

`exec 1> <дескриптор>` - перенаправляет весь вывод в определенный дескриптор на время выполнения скрипта.  
`exec 2> <дескриптор>` - перенаправляет все ошибки в определенный дескриптор на время выполнения скрипта.

### Перенаправление ввода в скриптах

`exec 0< <дескриптор>` - перенаправляет весь ввод из определенного дескриптора на время выполнения скрипта.

### Создание собственного перенаправления вывода

Шесть дескрипторов с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.

`exec <дескриптор_номер>><дескриптор_источник>`  
`exec <дескриптор_номер><<дескриптор_источник>`

Где `<дескриптор_источник>` - может быть путь к файлу или дескриптором `&<номер>`.

`exec <дескриптор_номер>>&-` - закрывает дескриптор, его потом можно открыть по новой.

### Получение сведений об открытых дескрипторах

`$$` - содержит текущий PID.

`$!` - содержит PID последней запущенной программы в фоновом режиме.

`wait <PID>[ ...]` - ждет завершения программ.  
`wait` - ждет завершения всех фоновых программ.

`lsof -a -p <PID> -d <дескриптор_номер>[, ...]` - выводит сведения о каждом дескрипторе, открытом в системе. Ключ `-a` используется для выполнения операции логического И над результатами, возвращенными благодаря использованию двух других ключей.

### Подавление вывода

Для этого можно перенаправить вывод в `/dev/null`.

`<дескриптор_номер>> /dev/null` - перенаправляет весь вывод в файл.

`cat /dev/null > <файл>` - очищает файл, не удаляя его.  
`: > <файл>` - аналогичное действие.

## Конвеер Pipe `|`

**Pipe** (конвеер) - это однонаправленный канал межпроцессного взаимодействия, используя символ конвеера `|`. Конвеер обеспечивает асинхронное выполнение команд с использованием буферизации ввода/вывода. Таким образом все команды в конвейере работают параллельно, каждая в своем процессе.

Размер буфера начиная с ядра версии 2.6.11 составляет 65536 байт (64Кб) и равен странице памяти в более старых ядрах. При попытке чтения из пустого буфера процесс чтения блокируется до появления данных. Аналогично при попытке записи в заполненный буфер процесс записи будет заблокирован до освобождения необходимого места.

Важно, что несмотря на то, что конвейер оперирует файловыми дескрипторами потоков ввода/вывода, все операции выполняются в памяти, без нагрузки на диск.

`<команда> | <команда> | ...`

> `cat *.txt | sort | uniq > result-file.txt`

## Сигналы Linux

### Основные сигналы

- `1` - `SIGHUP` - закрытие терминала (обрыв связи);
- `2` - `SIGINT` - сигнал остановки процесса пользователем с терминала (`CTRL + C`);
- `3` - `SIGQUIT` - сигнал остановки процесса пользователем с терминала (`CTRL + \`) с дампом памяти;
- `9` - `SIGKILL` - безусловное завершение процесса;
- `15` - `SIGTERM` - сигнал запроса завершения процесса;
- `17` - `SIGSTOP` - принудительная приостановка выполнения процесса, но не завершение его работы;
- `18` - `SIGTSTP` - приостановка процесса с терминала (`CTRL + Z`), но не завершение работы;
- `19` - `SIGCONT` - продолжение выполнения ранее остановленного процесса.
- с помощью сочетания клавиш `CTRL + D` в пустой строке останавливает текущий стандартный поток ввода из терминала.

Префикс `SIG` можно опускать.

### Временная остановка процесса

Сигнал `SIGTSTP` - приостанавливает работу процесса, но не завершает его выполнение. Такой процесс остается в памяти. Оболочка возвращает число в квадратных скобках - это номер задания, который оболочка назначает процессу. Оболочка рассматривает процессы, выполняющиеся в ней, как задания с уникальными номерами. Первому процессу назначается номер 1, второму - 2, и так далее.

`ps -l` - выводит приостановленные задания.  
`jobs` - выводит текущие задания и приостановленные задания.  
`jobs -l` - выводит приостановленные задания с их идентификаторами.  
`disown <идентификатор>` - убирает приостановленное задание по идентификатору.  
`fg %<номер>` - возобновляет приостановленное задание по номеру в списке.  
`bg %<номер>` - переводит приостановленное задание по номеру в списке в фоновый режим.

### Перехват сигналов

`trap "<команды>" <СИГНАЛ> [...]` - перехватывает указанные сигналы и вызывает указанные команды, для перехвата выхода из скрипта нужно указать имя сигнала `EXIT`.

Для модификации перехваченных скриптом сигналов можно выполнить команду `trap` с новыми параметрами.

`trap - <СИГНАЛ> [...]` - отменяет перехват указанных сигналов.

```bash
trap cleanup SIGINT SIGTERM ERR EXIT

cleanup() {
    trap - SIGINT SIGTERM ERR EXIT
    # script cleanup here
}
```

## Выполнение сценариев командной строки в фоновом режиме

Для это нужно запустить его, указав после имени символ амперсанда `&`. Скрипт будет запущен в фоновом процессе, в терминал выведется его идентификатор, а когда его выполнение завершится, выведется сообщение об этом. При этом скрипт продолжает использовать терминал для вывода сообщений в `STDOUT` и `STDERR` и их лучше перенаправить в файлы. Процесс продолжит свое выполнение и после того, как будет произведен выход из системы.

`nohup <скрипт> &` - позволяет запустить программу, блокируя сигналы `SIGHUP`, отправляемые процессу и отвязывает процесс от терминала, что значит что процесс потеряет ссылки на `STDOUT` и `STDERR` и `nohup` автоматически перенаправляет сообщения, поступающие в `STDOUT` и в `STDERR`, в файл `nohup.out` в текущем каталоге; если это невозможно сделать, то перенаправление происходит в файл `$HOME/nohup.out`. Если и это невозможно сделать, то команда не запускается совсем.

`jobs -l` - выводит текущие задания, которые выполняются в оболочке.

## Планирование запуска скриптов

`at [-f <файл>] <время>` - запускает файл в указанное время, где время может быть в виде: `HH:MM`, `now`, `noon`, `midnight`, `MMDDYY`, `MM/DD/YY`, или `DD.MM.YY`.

Ключ `-M` при вызове `at` используется для отправки того, что выведет скрипт, по электронной почте, если система соответствующим образом настроена. Если отправка электронного письма невозможна, этот ключ просто подавит вывод.

`atq` - возвращает список заданий.  
`atrm <номер_задания>` - удаляет задание под указанным номером.

## Запуск скриптов по расписанию

`crontab -l` - выводит существующую таблицу заданий `cron` в консоль.

`crontab -e` - выводит существующую таблицу заданий `cron` в редакторе по умолчанию (`vi`) и позволяет редактировать его.

`<минута> <час> <день_месяца> <месяц> <день_недели> <скрипт>` - запускает указанный скрипт по расписанию в указаное время запуска, т.е. когда время будет равно заданой структуре. Единицы измерения:
- минуты (0-59);
- часы (0-23);
- дни месяца (1-31);
- месяцы (1-12) (jan feb mar apr may jun jul aug sep oct nov dec);
- дни недели (0-6 (0=воскресенье)) (sun mon tue wed thu fri sat).

Единицы измерения можно указывать в виде:
- `<число>` - числа;
- `<число_от>-<число_до>` - диапазон;
- `<число1>[,<число2>[,...]]` - перечисление;
- `*/<шаг>` - шаг (когда остаток от деления на `<шаг>` будет равен 0);
- `<число_от>-<число_до>/<шаг>` - шаг (когда остаток от деления минус `<число_от>` на `<шаг>` будет равен 0);
- `*` - любое значение.

Диапазоны и перечисления можно комбинировать.

Комментарий начинается с `#` и это задание не будет исполняться.

> `10 12 * * * script.sh` - скрипт выполнится в 12 часов 10 минут.  
> `0 22 * * 1-5 echo "Пора домой" | mail -s "Уже 22:00" john` - скрипт выполнится в 22 часа 00 минут по будням.  
> `1-59/2 * * * * echo "Выполняется по нечетным минутам"` - скрипт выполнится по нечетным минутам.

`crontab -r` - удаляет файл текущего расписания.

`sed`
=====

Утилита `sed` называется потоковым текстовым редактором, поточно обрабатывает строки. Схема вызова команды:  
`sed <опции> [<файл>]`

По умолчанию `sed` применяет указанные при вызове правила, выраженные в виде набора команд, к `STDIN`. Это позволяет передавать данные непосредственно `sed` через `|`.

## Опции

`'s/<шаблон_поиска>/<шаблон_замены>/[<флаги>]'` - производит потоковую замену найденных шаблонов.

> `'s/search/replace/'`

Для выполнения нескольких действий с данными, используется ключ `-e` при вызове и опции разделяются символом точкой с запятой `;`, при этом между окончанием команды и точкой с запятой не должно быть пробела:  
`sed -e <опции> [<файл>]`

Для того, чтобы указать `sed` файл, содержащий команды, используют ключ `-f`:  
`sed -f <файл_с_командами> [<файл>]`

### Дополнительные ключи

- `-n` - указанный при вызове sed, подавляет обычный вывод;
- `-e` - добавление скрипта или regex в исполняемые команды;
- `-r` - использовать расширенный синтаксис регулярных выражений (спец символы активны по умолчанию);
- `-d` - удалить;
- `-s` - заменить;
- `-p` - распечатать найденную строку;
- `-i` - выполнять изменения непосредственно в файле.

### Флаги

При передаче номера учитывается порядковый номер вхождения шаблона в строку, заменено будет именно это вхождение.

Флаг `g` указывает на то, что нужно обработать все вхождения шаблона, имеющиеся в строке.  
Флаг `p` указывает на то, что нужно вывести содержимое исходной строки.  
Флаг вида `w <файл>` указывает команде на то, что нужно записать результаты обработки текста в файл.

### Символы-разделители

Разделителем считается первый символ, который будет встречен после `s`:  
`'s<символ_разделитель><шаблон_поиска><символ_разделитель><шаблон_замены><символ_разделитель>[<флаги>]'`

> `'s:as:like:'`

### Выбор фрагментов текста для обработки

Перед `s` можно указать номер строки для обработки:  
`'<номер_строки>s/<шаблон_поиска>/<шаблон_замены>/'`  
`'<номер_строки_начала>,<номер_строки_конца>s/<шаблон_поиска>/<шаблон_замены>/'` - воздействует на диапазон строк. Где концом может выступать символ `$`, означающий номер последней строки.

> `'2,$s/find/replace/'`

`'/<шаблон_строки>/s/<шаблон_поиска>/<шаблон_замены>/'` - только строки, которые удовлетворяют указанному шаблону.

> `'/filter/s/find/replace/'`

### Удаление строк

`'<номер_строки>d'` - удаляет указанную строку из потока вывода.  
`'<номер_строки_начала>,<номер_строки_конца>d'` - удаляет указанный диапазон строк из потока вывода. Где концом может выступать символ `$`, означающий номер последней строки.  
`'/<шаблон_строки>/[,...]d'` - только строки, которые удовлетворяют указанному шаблону [одному из них].

### Вставка текста в поток

`'[<номер_строки>]i\<строка>'` - добавляет новую строку перед заданной.  
`'[<номер_строки>]a\<строка>'` - добавляет новую строку после заданной.

### Замена строк

`'<номер_строки>c\<строка>'` - заменяет указанную строку переданной.  
`'/<шаблон_строки>/c/<строка>'` - заменяет строки удовлетворяющие указанному шаблону переданной.

### Замена символов

`'y/<символы>/<символы_замены>/'` - заменяет символы в соответствии символам замены.

### Вывод номеров строк

`=` - выводит номер строки.  
`'/<шаблон_строки>/='` - выводит номер строки удовлетворяющей указанному шаблону.

### Чтение данных для вставки из файла

`'[<номер_строки>]r <файл>'` - вставляет содержимое файла после [указанной строки] в поток данных.  
`'/<шаблон_строки>/r <файл>'` - вставляет содержимое файла после строк удовлетворяющих указанному шаблону в поток данных.

### Регулярные выражения

Все шаблоны поиска могут представлять из себя регулярное выражение.

`awk`
=====

Утилита **awk** похожа на **sed** , но более разнообразна.

Awk воспринимает поступающие к нему данные в виде **набора записей**. Записи представляют собой наборы полей. **Запись** - это строка. **Поле** - это слово в строке.

Awk обрабатывает текст из потока ввода построчно.

`awk [<опции>] [<программа>] [<файл> [ ...]]`

## Опции

- `-F <символ>` - позволяет указать символ-разделитель для полей в записи;
- `-f <файл>` - указывает имя файла, из которого нужно прочесть awk-скрипт;
- `-v <переменная>=<значение>`- позволяет объявить переменную и задать ее значение по умолчанию, которое будет использовать awk;
- `-mf <кол>` - задает максимальное число полей для обработки в файле данных;
- `-mr <кол>` - задает максимальный размер записи в файле данных;
- `-W <режим>` - позволяет задать режим совместимости или уровень выдачи предупреждений awk.

## Программа

Скрипты awk, которые можно писать прямо в командной строке, оформляются в виде текстов команд, заключенных в фигурные скобки. Кроме того, awk предполагает, что скрипт представляет собой текстовую строку, его нужно заключить в одинарные кавычки.

`'{<команда> [; ...]}'`

Для того, чтобы завершить работу awk, нужно передать ему символ конца файла (*EOF*, *End-of-File*). С помощью сочетания клавиш `CTRL + D`.

`print <текст> [, ...]` - печатает текст, он может состоять из строк и переменных.

`"<текст>"` - строка.

### Позиционные переменные, хранящие данные полей

По умолчанию `awk` назначает следующие переменные каждому полю данных, обнаруженному им в записи:
- `$0` - представляет всю строку текста (запись);
- `$1` - первое поле;
- `$2` - второе поле;
- `$n` - n-ное поле.

Поля выделяются из текста с использованием **символа-разделителя**. По умолчанию - это пробельные символы вроде пробела или символа табуляции.

### Файл скрипта

В файле скрипта может содержаться множество команд, при этом каждую из них достаточно записывать с новой строки, ставить после каждой точку с запятой не требуется.

Внутри скрипта можно объявлять переменные.

### Выполнение команд до начала обработки данных

`BEGIN {<команда> [; ...]}` - выполнит указанную секцию команд до начала обработки данных.

### Выполнение команд после окончания обработки данных

`END {<команда> [; ...]}` - выполнит указанную секцию команд после начала обработки данных.

### Встроенные переменные

- `FIELDWIDTHS` - разделенный пробелами список чисел, определяющий точную ширину каждого поля данных с учетом разделителей полей;
- `FS="<символ>"` - позволяет указать символ-разделитель для полей в записи;
- `RS="<символ>"` - переменная, которая позволяет задавать символ-разделитель записей;
- `OFS="<символ>"` - разделитель полей на выводе awk-скрипта;
- `ORS="<символ>"` - разделитель записей на выводе awk-скрипта;
- `ARGC` - количество аргументов командной строки;
- `ARGV` - массив с аргументами командной строки (`ARGV[<n>]`);
- `ARGIND` - индекс текущего обрабатываемого файла в массиве `ARGV`;
- `ENVIRON` - ассоциативный массив с переменными окружения и их значениями (`ENVIRON["<ключ>"]`);
- `ERRNO` - код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов;
- `FILENAME` - имя входного файла с данными;
- `FNR` - номер текущей записи в файле данных;
- `IGNORECASE` - если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов;
- `NF` - общее число полей данных в текущей записи, $NF позволяет обращаться к последнему полю данных в записи, не зная его точной позиции;
- `NR` - общее число обработанных записей.

### Условный оператор

`if (<условие>) <команда> [; else <команда>]`
```
if (<условие>)
{
    <команды>
}[ else {
    <команды>
}]
```

Операторы сравнения:
- `==` - равно;
- `!=` - не равно;
- `>` - больше;
- `<` - меньше;
- `<=` - больше или равно;
- `>=` - меньше или равно.

### Цикл while

```
while (<условие>)
{
    <команды>
}
```
В циклах `while` можно использовать команды `break` и `continue`.

### Цикл for

```
for (<начало>; <условие>; <итерация>)
{
    <команды>
}
```

## Форматированный вывод данных

Команда `printf` в awk позволяет выводить форматированные данные:  
`printf "<текст_со_спецификаторами>" [, <переменная> [, ...]]`

Первый спецификатор соответствует первой переменной, второй спецификатор - второй, и так далее.

`%[<модификатор>]<символ_спецификатора>` - спецификатор.

### Символы

- `c` - воспринимает переданное ему число как код ASCII-символа и выводит этот символ;
- `d` - выводит десятичное целое число;
- `i` - то же самое, что и d;
- `e` - выводит число в экспоненциальной форме;
- `f` - выводит число с плавающей запятой;
- `g` - выводит число либо в экспоненциальной записи, либо в формате с плавающей запятой, в зависимости - от того, как получается короче;
- `o` - выводит восьмеричное представление числа;
- `s` - выводит текстовую строку.

### Модификаторы

Могут комбинироваться и писаться в указанном порядке.

- `-` - выравнивание по левой стороне;
- ` ` - отрицательные числа пишутся со знака минуса, положительные с пробела;
- `+` - отрицательные числа пишутся со знака минуса, положительные с плюса;
- `0` - дополняет слева число нулями;
- `<число>` - минимальная ширина поля;
- `.<число>` - максимальная ширина поля.

## Встроенные математические функции

- `cos(x)` - косинус x (x выражено в радианах);
- `sin(x)` - синус x;
- `exp(x)` - экспоненциальная функция;
- `int(x)` - возвращает целую часть аргумента;
- `log(x)` - натуральный логарифм;
- `rand()` - возвращает случайное число с плавающей запятой в диапазоне 0 - 1;
- `sqrt(x)` - квадратный корень из x.

## Строковые функции

Используются аналогично математическим.

## Пользовательские функции

Объявляются до всех секций.

```
function <функция>()
{
    <команды>
}
```

`<функция>()` - использование.

Регулярные выражения
====================

Утилита **sed** поддерживает часть стандарта *POSIX Basic Regular Expression* (BRE).  
Регулярное выражение может находиться в шаблоне.

Утилита **awk** поддерживает стандарт *POSIX Extended Regular Expression* (ERE).  
Регулярное выражение может находиться в перед списком команд:  
`/<регулярное_выражение>/{<команда> [; ...]}`

Специальные символы BRE:
- `.` - один любой символ;
- `^` - якорь начала строки (не считается за символ);
- `$` - якорь конца строки (не считается за символ);
- `[<символ_1>[...]]` - один символ, который может быть или символом `<символ_1>`[, или ...];
- `[^<символ_1>[...]]` - один символ, который не может быть или символом `<символ_1>`[, или ...];
- `[<символ_от>-<символ_до>[...]]` - один символ, который может быть в интервале символов `<символ_от>` и до `<символ_до>`, включая эти символы, для включения символа `-`, то он ставится в начало выражения.


Специальные символы ERE, которые дополняют BRE:
- `<выражение_1>|<выражение_2>[|...]` - одно из выражений;
- `(<выражение>)` - группировка выражений;
- `?` - совпадение с предыдущем элементов ноль или один раз;
- `*` - совпадение с предыдущем элементов ноль или более раз;
- `+` - совпадение с предыдущем элементов один или более раз;
- `{<количество>}` - совпадение с предыдущем элементов указанное количество `<количество>` раз;
- `{<количество_от>,<количество_до>}` - совпадение с предыдущем элементов не менее `<количество_от>` раз и не более `<количество_до>`;
- `{<количество_от>,}` - совпадение с предыдущем элементов не менее `<количество_от>` раз;
- `{,<количество_до>}` - совпадение с предыдущем элементов не более `<количество_до>`;

Специальные символы экранируются с помощью обратной косой черты (обратного слэша) - `\`.

## Специальные классы символов

В BRE имеются специальные классы символов, которые можно использовать при написании регулярных выражений:
- `[:alpha:]` - соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре;
- `[:alnum:]` - соответствует любому алфавитно-цифровому символу, а именно - символам в диапазонах 0-9, A-Z, a-z;
- `[:blank:]` - соответствует пробелу и знаку табуляции;
- `[:digit:]` - любой цифровой символ от 0 до 9;
- `[:upper:]` - алфавитные символы в верхнем регистре - A-Z;
- `[:lower:]` - алфавитные символы в нижнем регистре - a-z;
- `[:print:]` - соответствует любому печатаемому символу;
- `[:punct:]` - соответствует знакам препинания;
- `[:space:]` - пробельные символы, в частности - пробел, знак табуляции, символы NL, FF, VT, CR.

Используются в конструкции `[]`: `[<спец_класс>]`:
> `[[:space:]]`

Могут комбинироваться в рамках конструкции `[]`:
> `[[:space:][:punct:]]`

Структура Linux
===============

## Ядро

Ядро - это программа, расположенная в памяти компьютера и от дающая распоряжения центральному процессору. Ядро управляет аппаратными средствами и выступает главным образом в качестве интерфейса между аппаратными средствами и любой запущенной программой.

Ядро отвечает за:
- **процессы** - за их работу, за **переключение контекста**. Так как все процессоры работают определенный отрезок времени - **квант времени**.
- **память** - за состояние всей памяти.
- **драйверы устройст** - в качестве интерфейса между аппаратными средствами и процессами.
- **системные вызовы и поддержка** - для обработки системных вызовов процессов для взаимодействия с ядром.

**Переключение контекста** состоит из шагов:
1. Прерывание процессором текущего процесса, по внутреннему таймеру.
2. Переключение в режим ядра и возврат управления ядру.
3. Сохранения ядром текущего состояния процессора и памяти текущего процесса для его возобновления.
4. Выполнение ядром задач, которые возникли в течении предыдущего кванта времени.
5. Запуск другого процесса по определенным условиям.
6. Подготовка ядром памяти для нового процесса, а затем подготовка процессора.
7. Сообщение ядром процессору длительности кванта для нового процесса.
8. Перевод ядром процессора в режим пользователя и передача управления процессору.

**Управления памятью** использует модуль управления памятью (MMU), который активизирует схему доступа к памяти под названием **виртуальная память**. При использовании виртуальной памяти процесс не обращается к памяти напрямую по ее физическому расположению в аппаратных средствах. Вместо этого ядро настраивает каждый процесс таким образом, словно в его распоряжении находится вся машина. Когда процесс получает доступ к памяти, модуль MMU перехватывает такой запрос и применяет карту адресов памяти, чтобы перевести местоположение памяти, полученное от процесса, в физическое положение памяти на компьютере. Для каждого проесса ядро меняет карту адресов памяти.

## Каталоги

- `/bin` - содержит готовые к запуску команды (известные также как исполняемые файлы), как в двоичном формате, так и сценарии оболочки;
- `/boot` - содержит файлы загрузчика ядра:
    - `/vmlinuz` - содержит ядро.
- `/dev` - содержит файлы устройств:
    - `/sd*` (`*` - `a`, `b`, ...) - жесткие диски:
        - `*` (`*` - `1`, `2`, ...) - разделы жесткого диска.
    - `/sr*` (`*` - `a`, `b`, ...) - приводы CD и DVD;
    - `/hd*` (`*` - `a`, `b`, ...) - жесткие диски PATA;
    - `/tty*` (`*` - `1`, `2`, ...) - виртуальная консоль;
    - `/pts/*` (`*` - `0`, `1`, ...) - псевдотерминальное устройство;
    - `/tty` - управляющий терминал текущего процесса;
    - `/ttyS*` (`*` - `0`, `1`, ...) - последовательные порты (COM);
    - `/ttyUSB*` (`*` - `0`, `1`, ...) - последовательные порты USB;
    - `/ttyACM*` (`*` - `0`, `1`, ...) - последовательные порты ACM;
    - `/lp*` (`*` - `0`, `1`, ...) - параллельные порты (LPT);
    - `/parport*` (`*` - `0`, `1`, ...) - двунаправленные параллельные порты;
    - `/null` - устройство для подавления ввода;
    - `/zero` - устройство для ввода непрерывного количества 0;
- `/etc` - содержит файлы конфигурации, файлы загрузки, файлы устройств, сетевые настройки и другие параметры. Многие элементы каталога зависят от аппаратного обеспечения:
    - `/sudoers` - файл прав привилегированных пользователей `sudo`;
    - `/crontab` - файл, определяющий время запуска автоматизированных заданий;
    - `/fstab` - таблица устройств хранения и соответствующих им точек монтирования;
    - `/passwd` - список всех учетных записей пользователей;
- `/home` - содержит личные каталоги пользователей;
- `/lib` - содержит файлы библиотек для совместного пользования:
    - `/modules` - содержит загружаемые модули ядра;
- `/media` - основная точка подключения для таких съемных устройств, которые монтируются в момент подключения;
- `/opt` - содержит дополнительное ПО сторонних разработчиков;
- `/proc` - содержит информацию о запущенных в данный момент процессах, а также о некоторых параметрах ядра в виде "каталог-файл";
- `/sys` - подобен `/proc`, но предоставляет интерфейс устройствам и системе в виде "каталог-файл";
- `/sbin` - содержит системные исполняемые файлы;
- `/tmp` - содержит небольшие временные файлы. Любой пользователь может выполнять чтение и запись в этом каталоге, однако доступ к файлам другого пользователя может быть запрещен. Многие команды применяют данный каталог в качестве рабочего пространства;
- `/usr` - содержит обширную иерархию каталогов, включающую основную часть системы Linux. Многие имена каталогов здесь такие же, как и в корневом каталоге (типа `/usr/bin` и `/usr/lib`), и содержат те же типы файлов, предназначен для хранения большей части команд и данных пространства пользователя:
    - `/bin` - содержит выполняемые программы;
    - `/sbin` - содержит дополнительные программы для администрирования;
    - `/lib` - содержит разделяемые библиотеки для программ в `/usr/bin`;
    - `/include` - содержит заголовочные файлы, используемые компилятором C;
    - `/info` - содержит руководства GNU в формате info;
    - `/local` - здесь администраторы могут устанавливать собственное программное обеспечение. Структура этого каталога должна выглядеть подобно структуре каталогов `/` и `/usr`;
    - `/man` - содержит страницы руководства;
    - `/share` - содержит файлы для программ в `/usr/bin`, которые должны работать в других типах систем Unix без потери функциональности;
- `/var` - изменяемый подкаталог, в котором команды хранят информацию во время исполнения;
    - `/log` - содержит файлы журналов с записями о различных действиях, выполнявшихся в системе;
- `/vmlinuz` - содержит ядро.

## Устройства

Распологаются по пути: `/dev`.

Виды устройств:
- **блочные устройства** - `b` - доступ к данным в виде фиксированных порций. Поскольку общий объем блочного устройства фиксирован и легко поддается индексации, процессы с помощью ядра получают случайный доступ к любому блоку устройства;
- **символьные устройства** - `c` - работают с потоками данных. Можно лишь считывать символы с таких устройств или записывать символы на них. Символьные устройства не обладают размером;
- **каналы** - `p` - подобны символьным устройствам, но у них на другом конце потока ввода-вывода располагается другой процесс, а не драйвер ядра;
- **сокеты** - `s` - являются специализированными интерфейсами, которые часто используются для взаимодействия между процессами.

`udevadm info --query=all --name=/dev/<устройство>` - показывает путь и другие атрибуты устройства.

В каталоге `/sys/devices` распологаются "каталоги-файлы" для просмотра информации об устройстве и для управления им.

`dd if=<входной_файл> of=<выходной_файл> bs=<размер_блока> [ibs=<размер_блока_чтения> obs=<размер_блока_записи>] count=<количество_блоков> skip=<количество_блоков_пропуска>` - копирует данные блочно из одного файла или устройства в другой.
> `dd if=/dev/zero of=new_file bs=1024 count=1`  
> `dd if=/dev/sdb of=flash_drive.img`

`lsscsi` - выводит список устройств в системе.

### Блочные устройства

Виды таблиц разделов:
- **MBR** - Master Boot Record - главной загрузочная запись;
- **GPT** - Globally Unique Identifier Partition Table - глобальная таблица разделов с уникальными идентификаторами.

`parted -l` - выводи информацию о разделах.

Виды файловых систем:
- **ext4**;
- **ext3**;
- **ext2**;
- **iso9660** - файловая система ISO 9660 для CD-ROM;
- **msdos** - файловая система FAT;
- **vfat** - файловая система FAT;
- **umsdos** - файловая система FAT;
- **hfsplus** - файловая система HFS+ для Macintosh.

`fdisk <устройство>` - запускает программу по форматированию разделов устройства.

`mkfs -t <файловая_система> <раздел>` - создает файловую систему на указаном разделе.
> `mkfs -t ext4 /dev/sdf2`

`mkfs - n` - выводит информацию о суперблоках.

`blkid` - выводит список устройств, соответствующих им файловых систем, а также идентификаторы UUID.

`mount` - выводит построчно примонтированные фаловые системы в виде: `<устройство> on <точка_монтирования> type <тип_системы> (<параметры_монтирования>)`.

`mount -t <тип_файловой_системы> <устройство> <точка_монтирования> [<флаги>]` - монтирует файловую систему типом `<тип_файловой_системы>` устройства `<устройство>` в точку монтирования `<точка_монтирования>`.
> `mount -t ext4 /dev/sdf2 /home/extra`

`mount UUID=<UUID> <точка_монтирования> [<флаги>]` - монтирует файловую систему по UUID `<UUID>` в точку монтирования `<точка_монтирования>`.
> `mount UUID=a9011c2b-1c03-4288-b3fe-8ba961ab0898 /home/extra`

Флаги монтирования для `mount`:
- `-r` - монтирует файловую систему в режиме "только для чтения";
- `-o <параметр1>[,...]` - включает использование длинных параметров:
    - `ro` - только чтение файловой системы;
    - `rw` - чтение-запись файловой системы;
    - `exec` - включает исполнение команд над файловой системой;
    - `noexec` - отключает исполнение команд над файловой системой;
    - `noauto` - отключает автомонтирование;
    - `suid` - включает команды `setuid` (установка идентифи катора пользователя);
    - `nosuid` - отключает команды `setuid` (установка идентифи катора пользователя).

Файл `/etc/fstab` содержит список файловых систем и их параметров в виде строк формата: `<устройство_или_UUID> <точка_монтирования> <тип_файловой_системы> <параметры_монтирования> <частота_резервного_копирования> <порядок_проверки_целостности_системы>`.

`mount -a` - монтирует все системы из файла `/etc/fstab`, кроме `noauto`.

`unmount <точка_монтирования>` - размонтирует систему из точки монтирования `<точка_монтирования>`. Если система используется чем-то, то ее не удастся размонтировать.
> `unmount /home/extra`

`sync` - принудительно записывает изменения из буфера ядра на диск.

`df [-h]` - показывает список всех файловых систем по именам устройств, сообщает их размер, занятое и свободное пространство и точки монтирования [отобразит размер в человеко-читаемом формате, добавив названия единиц]. В отображении занятого и свободного пространства не учтены 5% от общего их размера, так как оно зарезирвированно.

`du -sh <каталог>` - выводит размер директории.  
`du -sh *` - выводит размер файлов и директорий в текущем каталоге.

`fsck [-p] [-n] <устройство>` - проверяет фаловую систему в режиме интерактивного руководства [`-p` с автоматическим исправлением типичных проблем] [`-n` только проверка без изменений].

Специальные фаловые системы:
- `proc` - смонтирована в каталоге `/proc` для хранения каталогов с процессами. Файл `/proc/self` представляет текущий процесс, `/proc/cpuinfo` - информации о ядре и аппаратных средствах.
- `sysfs` - смонтирована в каталоге `/sys`.
- `tmpfs` - смонтирована в каталоге `/run` и д.р.

## Область подкачки

`free` - выводит размер области подкачки.

`mkswap <устройство>` - создает область подкачки на разделе.  
`mkswap <файл>` - создает область подкачки в файле.

`swapon <устройство_или_файл>` - включает область подкачки.  
`swapoff <устройство_или_файл>` - выключает область подкачки.

## Устройство файловой системы

Состоит из двух основных компонентов:
- **пул блоков данных** - где хранятся данные;
- **база данных** - которая управляет пулом данных с основой в виде структруры данных inode.

**Дескриптор inode** - это набор данных, который описывает конкретный файл, включая его тип, права доступа и расположение его данных в пуле данных.

Дескриптор каталога содержит перечень имен файлов и соответствующих ссылок на другие дескрипторы и на каталоги `.` и `..`.

```
 Таблица дескрипторов inode                     Пул данных

| Номер | Счетчик ссылок | Тип  |
| 2     | 4              | dir  | --------> | .      inode 2  |
| 13    | 1              | file | --\       | file_1 inode 13 |
                                    |
                                    \-----> | "a"             |
```

`stat <файл>` - показывает информацию о файле и его дескрипторе.

## Загрузка ядра

Процесс загрузки состоит и следующих шагов:
1. Система BIOS или прошивка загрузки загружают и запускают загрузчик системы, который может:
    - давать выбор среди нескольких ядер;
    - переключаться между наборами параметров ядра;
    - ручное изменение параметров ядра;
    - загрузка других операционных систем.
2. Загрузчик системы отыскивает образ ядра на диске, загружает его в память и запускает.
3. Ядро выполняет инициализацию устройств и их драйверов в следующем порядке:
    1. Проверка центрального процессора.
    2. Проверка оперативной памяти.
    3. Обнаружение шины устройств.
    4. Обнаружение устройств.
    5. Настройка вспомогательной подсистемы ядра (сеть и т. п.).
    6. Монтирование корневой файловой системы.
    7. Запуск пространства пользователя.
4. Ядро монтирует корневую файловую систему.
5. Ядро запускает команду `init` (которая разная для разных версий ОС) с идентификатором процесса `1`. Эта точка является началом пространства пользователя.
6. Команда `init` приводит в действие остальные системные процессы.
7. В определенный момент команда `init` запускает процесс, позволяющий войти в систему в конце или незадолго до окончания загрузки системы.

Сообщения о загрузке хранятся в файле `/var/log/kern.log` или в каталоге `var/log/messages`.

`dmesg` - выводит в консоль сообщения о загрузки.

В файле `/proc/cmdline` содержится информация о параметрах ядра.

Виды команды `init`:
- `systemd` - расположена по пути `/usr/lib/systemd` и `/etc/systemd`;
- `Upstart` - расположена по пути `/etc/init` и использует файлы `.conf`;
- `System V init` - расположена по пути `/etc/inittab`.

### Команда `systemd`

Основные шаги запуска:
1. Загружает своей конфигурации.
2. Определение цели загрузки, которая обычно называется `default.target`.
3. Определение всех зависимостей для цели загрузки по умолчанию, зависимости зависимостей и т. д.
4. Активация зависимых процессов и цели загрузки.
5. Реагирование после загрузки на системные события (такие как `uevents`) и активация дополнительных компонентов.

Основные модули:
- **Модули служб** - контролируют традиционные демоны служб в системе Unix.
- **Модули монтирования** - контролируют присоединение файловых систем.
- **Целевые модули** - контролируют другие модули, как правило группируя их.

Основные зависимости:
- **Requires** - Жесткие зависимости. При активизации модуля с зависимостью **Requires** команда `systemd` пытается активизировать модуль зависимости. Если модуль зависимости дает сбой, то команда `systemd` деактивизирует зависимый модуль.
- **Wants** - Зависимости, предназначенные только для активизации. Во время активизации какого либо модуля команда `systemd` активизирует его **Wants** зависимости, но не обращает внимания, если они дают сбой.
- **Requisite** - Модули, которые уже должны быть активными. Перед активизацией модуля с зависимостью **Requisite** команда `systemd` сначала проверяет состояние зависимости. Если такая зависимость еще не была активизирована, команда `systemd` дает сбой при активизации модуля с этой зависимостью.
- **Conflicts**. Противоположные зависимости. При активизации модуля с зависимостью **Conflict** команда `systemd` автоматически деактивизирует такую зависимость, если она активна. Одновременная активизация двух конфликтующих модулей вызовет сбой.

Порядок следования зависимостей:
- **Before** - текущий модуль будет активизирован до указанного модуля или модулей.
- **After** - текущий модуль будет активизирован после перечисленного модуля или модулей.

Файлы для подключения системных модулей распологаются по пути `/usr/lib/systemd/ system`, а системной и пользовательской конфигурации по пути `/etc/systemd/system`. Выглядят в виде файлов со структурой XDG (`.target`, которые похожи на `.ini`).

Основные секции:
- секция `[Unit]` сообщает некоторые подробности о модуле и содержит описание и сведения о зависимости.
- секция `[Mount]` описывает данный модуль в роли модуля монтирования, а так же сообщает детали о точке монтирования, типе файловой системы и параметрах монтирования.
- секция `[Service]` сообщает о том, как подготовить, запустить и перезагрузить данную службу.
- секция `[Install]` сообщает о том, что делать когда необходимо подключить данную службу - создает символические ссылки на зависимые модули.

Пример монтирования:
```
[Unit]
Description=Media Directory
Before=local-fs.target
[Mount]
What=tmpfs
Where=/media
Type=tmpfs
Options=mode=755,nosuid,nodev,noexec
```

Пример службы:
```
[Unit]
Description=OpenSSH server daemon
After=syslog.target network.target auditd.service
[Service]
EnvironmentFile=/etc/sysconfig/sshd
ExecStartPre=/usr/sbin/sshd-keygen
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
[Install]
WantedBy=multi-user.target
```

**Спецификатор** - это еще одно похожее на переменную средство, которое часто можно увидеть в файлах модулей. Спецификаторы начинаются с символа процента `%`. Например, спецификатор `%n` представляет имя текущего модуля, а специфи катор `%H` - имя текущего хоста.

#### Основные команды

`systemctl [--all] list-units` - выводит список активных [всех] модулей.  
`systemctl status <модуль>` - выводит статус модуля.

`journalctl _SYSTEMD_UNIT=<модуль>` - выводит журнал модуля.

`systemd start <модуль>` - запускает модуль.  
`systemd stop <модуль>` - останавливает модуль.  
`systemd restart <модуль>` - перезапускает модуль.  
`systemd enable <модуль>` - подключает модуль - выполняет секцию `[Install]`.  
`systemd disable <модуль>` - удаляет модуль - удаляет символические ссылки.

`systemctl reload <модуль>` - перезагружает только конфигурацию модуля.  
`systemctl demon-reload` - перезагружает конфигурацию всех модулей.

`systemctl list-jobs` - выводит список заданий на активизацию, повторную активизацию и перезапуск модулей.

Архивирование
=============

## `tar`

### Запаковывание

`tar [-<ключи>] [-] [<название_архива>] [<путь_что_запаковать>]`

Значения ключей:
- `с` - "create" - создать файл архива;
- `v` - "verbose" - выводить информацию в процессе выполнения;
- `z` - "gzip" - запаковать файл при помощи gzip;
- `j` - "bzip2" - запаковать файл при помощи bzip2;
- `f` - "file" - использовать имя файла архива указаное после ключей. Если не указать ключ `f` то команда будет использовать настройки по умолчанию либо выведет результат прямо в консоль.

`-` - обозначает вывод в стандартный поток.

`.tar.gz` = `.tgz`

> `tar -zcvf prog-1-jan-2005.tar.gz /home/jerry/prog`

### Распаковывание

`tar [-<ключи>] [-] [<название_архива>] [<имя_файла1>[ ...]]` - извлекает данные из архива [только указанные файлы].

Значения ключей:
- `x` - "eXtract" - извлечь файлы;
- `v` - "verbose" - выводить информацию в процессе выполнения;
- `z` - "gzip" - распаковать файл при помощи gzip;
- `j` - "bzip2" - распаковать файл при помощи bzip2;
- `p` - при распаковке останутся исходные права, какие были в архиве;
- `f` - "file" - использовать имя файла архива для распаковки указаное после ключей.

`-` - обозначает вывод в стандартный поток.

> `tar -zxvf prog-1-jan-2005.tar.gz`

### Вывод содержания

`tar [-<ключи>] [<название_архива>]`

Значения ключей:
- `t` - извлечь файлы.

> `tar -t prog-1-jan-2005.tar.gz`

### Добавление к концу архива файла

`tar [-<ключи>] [<название_архива>]`

Значения ключей:
- `r` - извлечь файлы;
- `f` - "file" - использовать имя файла архива указаное после ключей.

> `tar -rf prog-1-jan-2005.tar.gz image.png`

## `gzip`

`gzip [-d] [-r] [-c] <файл>` - сжимает [`-d` - включает распаковывание, а не сжатие] файл [`-r` - рекурсивно проходитвсе файлы в каталоге] [`-c` - выводит результат в стандартный поток вывода и сохраняет оригинальный файл] в формате GNU Zip и добавляет к названию этого файла расширение `.gz`, при этом оригинальный файл замещается новым, у которого сохранены все старые атрибуты.  
`gunzip [-d] [-c] <файл>.gz` - распаковывает файл [`-d` - включает сжиматие, а не распаковывание] [`-c` - выводит результат в стандартный поток вывода и сохраняет оригинальный файл] в формате GNU Zip и убирает из названия этого файла расширение `.gz`.

## `bzip2`

`bzip2 <файл>` - сжимает файл в формате GNU BZip и добавляет к названию новому файлу расширение `.bz2`.  
`bunzip2 [-d] [-c] <файл>.bz2` - распаковывает файл [`-d` - включает сжиматие, а не распаковывание] [`-c` - выводит результат в стандартный поток вывода] в формате GNU BZip и убирает из названия нового файла расширение `.bz2`.

## `zip`

`zip <файл>` - сжимает и архивирует файл в формате Zip-архива Windows и добавляет к названию новому файлу расширение `.zip`.  
`unzip [-d] [-c] <файл>.zip [<имя_файла_1> [...]]` - разархивирует и распаковывает файл [`-d` - включает сжиматие, а не распаковывание] [`-c` - выводит результат в стандартный поток вывода] в формате Zip-архива Windows и убирает из названия нового файла расширение `.zip`.

`wget`
======

Загрузка всех URL, указанных в локальном или внешнем ФАЙЛЕ:  
`wget -i <файл>`

Скачивание файлов в указанный каталог `-P`:  
`wget -P <каталог> <ссылка>`

Использование имени пользователя и пароля на FTP/HTTP (вариант 1):  
`wget ftp://<логин>:<пароль>@<ссылка>`

Использование имени пользователя и пароля на FTP/HTTP (вариант 2):  
`wget --user=<логин> --password=<пароль> <ссылка>`

Скачивание в фоновом режиме `-b`:  
`wget -b <ссылка>`

Продолжить (`-c` continue) загрузку ранее не полностью загруженного файла:  
`wget -c <ссылка>`

Скачать содержимое каталога <ссылка> и всех его подкаталогов, при этом не поднимаясь по иерархии каталогов выше:  
`wget -r --no-parent <ссылка>`

Идентификация на сервере:
```
wget --save-cookies <файл_с_куками> \
--post-data '<POST_данные>' \
<ссылка>
```

Скачать весь сайт целиком:  
`wget -r -l <глубина рекурсии> -k -o <файл_лога> -p <ссылка>`

Где:
- `-r`, `--recursive` - включение рекурсивной загрузки;
- `-l`, `--level=<число>` - глубина рекурсии (`inf` и `0` - бесконечность);
- `-k`, `--convert-links` - делать ссылки локальными в загруженном HTML или CSS;
- `-o`, `--output-file=<файл>` - записывать сообщения (логи) в `<файл>`;
- `-p`, `--page-requisites` - загрузить все изображения и проч., необходимые для отображения HTML-страницы;
- `-m`, `--mirror` - короткий параметр, эквивалентный `-N -r -l inf --no-remove-listing`.

`grep`
======

Утилита командной строки, которая находит на вводе строки, отвечающие заданному регулярному выражению, и выводит их, если вывод не отменен специальным ключом.

`cat <файл> | grep [<опции>] <строка_поиска>` - поиск строки из потока ввода.

`grep [<опции>] <строка_поиска> <файл_1>[ ...]` - поиск строки из файлов, строка может быть регулярным выражением ERE.

Опции:
- `-c` - выводит количество отобранных строк;
- `-w` - ищет по слову целиком;
- `-i` - игнорирует регистр при поиске;
- `-C <количество>` - выводит заданное количество строк сверху и снизу от искомой;
- `-A <количество>` - выводит заданное количество строк снизу от искомой;
- `-B <количество>` - выводит заданное количество строк сверху от искомой;
- `-E` - интерпретировать строку поиска как регулярное выражение BRE и по ней искать;
- `-oE` - интерпретировать строку поиска как регулярное выражение и по ней искать и выводить только полное совпадение регулярному выражению;
- `-v` - все строки только без искомой;
- `-n` - выводит номер строки;
- `-r` - ищет по всем файлам каталога;
- `-l` - выводит только имена файлов, в которых есть строка;
- `-L` - выводит только имена файлов, в которых нет, ни одного совпадения;
- `--colour` / `--color` - подсвечивает искомую строку.

Формирование строки поиска:
- `'\<<строка_поиска>'` - поиск по началу слова;
- `'<строка_поиска>\>'` - поиск по концу слова;
- `'^<строка_поиска>'` - поиск по началу строки;
- `'<строка_поиска>$'` - поиск по концу строки.

Для удобства пользования делают цепочки поисков:  
`... | grep <строка_поиска1> | grep <строка_поиска2> | ...`

`grep -rnw '<путь>/' -e '<строка_поиска>'` - рекурсивно ищет строку во всех файлах.

Для файлов `gz` используется `zgrep`.

`rsync`
=======

`rsync -av --progress [--delete] <откуда> <куда>[ --exclude <исключение>[ ...]]` - копирует файлы [`--delete` и удаляет те файлы, которых нет в исходном каталоге].
> `rsync source/ destination` - копирует содержимое каталога в указанный каталог.

Параметр `--rsh=ssh` позволяет производить копирование по сети.
> `rsync -av --delete --rsh=ssh /etc /home /usr/local remotesys:/backup`

Процессы
========

## `ps`

Программа в UNIX, Unix-подобных и других POSIX-совместимых операционных системах, выводящая отчет о работающих процессах.

`ps [<опции>]` - показывает все процессы которые запущены текущим пользователем.

Опции, отбирающие процессы для отчета:
- `-A` - все процессы;
- `-a` - связанные с конкретным терминалом, кроме главных системных процессов сеанса, часто используемая опция;
- `-N` - отрицание выбора;
- `-d` - все процессы, кроме главных системных процессов сеанса;
- `-e` - все процессы;
- `-f` - расширение информации;
- `T` - все процессы на конкретном терминале;
- `a` - процессы, связанные с текущим терминалом, а также процессы других пользователей;
- `r` - информация только о работающих процессах;
- `u` - включает детализированную информацию о работающих процессах;
- `x` - процессы, отсоединенные от терминала.

### Выводимая информация

Столбцы:
- **USER** - идентификатор пользователя владельца процесса;
- **PID** - идентификатор процесса;
- **%CPU** - использование процессора в процентах;
- **%MEM** - использование памяти в процентах;
- **VSZ** - объем виртуальной памяти;
- **RSS** - размер страниц памяти - объем физической памяти (ОЗУ), используемой процессом, кб;
- **TT** (**TTY**) - терминал, с которым связан данный процесс;
- **STAT** - состояние, в котором на данный момент находится процесс. Параметры **STAT**:
    - **R** - процесс выполняется в данный момент;
    - **S** - процесс ожидает (т.е. спит менее 20 секунд);
    - **I** - процесс бездействует (т.е. спит больше 20 секунд);
    - **D** - процесс ожидает ввода-вывода (или другого недолгого события), непрерываемый;
    - **Z** - *zombie* или *defunct* процесс, то есть завершившийся процесс, код возврата которого пока не считанный родителем;
    - **T** - процесс остановлен;
    - **W** - процесс в свопе;
    - **<** - процесс в приоритетном режиме;
    - **N** - процесс в режиме низкого приоритета;
    - **L** - *real-time* процесс, имеются страницы, заблокированные в памяти;
    - **s** - лидер сессии.
- **STARTED** (**START**) - время старта процесса;
- **TIME** - объем процессорного времени, потребленного процессом;
- **COMMAND** - команда, запустившая данный процесс "с некоторыми опциями выводит и каталог откуда процесс был запущен".

Опция o позволяет указать набор столбцов в ответе:
`ps o [<имя_столбца> [, <имя_столбца> [, ...]]]`

## `top`

Выводит периодически обновляемую информацию о запущенных процессах и сводную информацию о них.

## `kill`

Завершает работу процесса, фактически посылает процессу сигнал.

`kill [<сигнал>] [<опция>] <PID1>[ <PID2>[ ...]]`

Основные сигналы:
- `SIGTERM` - этот сигнал запрашивает остановку работы процесса. Он может быть проигнорирован. Процессу дается время на корректное завершение;
- `SIGKILL` - этот сигнал заставляет процесс прекратить работу немедленно. Программа не может проигнорировать этот сигнал. Несохраненные результаты будут потеряны.

Вывод всех видов сигналов: `kill -l`.  
Сигнал по умолчанию (если он не задан) - `SIGTERM`.

> `kill -9 3629`  
> `kill SIGKILL 3629`

## `pkill`

Команда `pkill` позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID можно завершить приложение, введя имя его процесса.

> `pkill firefox`

## `killall`

Команда `killall` позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID можно завершить приложение, введя имя его процесса и завершить все экземпляры процесса с этим именем.

> `killall firefox`

## Остановка системы

`halt` - останавливает систему.

`poweroff` - выключает электропитание.

`reeboot` - перезагружает систему.

`shutdown [-h] [-r] <время>` - [выключает] [перезагружает] систему через определенное время.

`ssh`
=====

`ssh-keygen -t rsa [-f <имя_файла>]` - генерирование пары ключей RSA, создаст ключи по умолчанию:
- `~/.ssh/id_rsa.pub` - открытый ключ;
- `~/.ssh/id_rsa` - закрытый ключ.

> `ssh-keygen -t rsa -b 4096`

`ssh-keygen -l -f <имя_файла>` - проверяет файл на валидность ключа.  
`ssh-keygen -y <имя_файла>` - выводит содержимое ключа после ввода пароля (служит для проверки пароля).

По умолчанию берутся ключи с именем:
- `~/.ssh/id_rsa`;
- `~/.ssh/id_ed25519`;
- `~/.ssh/id_dsa`;
- `~/.ssh/id_ecdsa`.

Для указания определенного ключа для адреса `<url>` используется файл конфигурации `~/.ssh/config` со структурой:
```bash
# <коментарий>
Host <url1>
  Preferredauthentications publickey
  IdentityFile ~/.ssh/<приватный_ключ>
# ...
```

В каталоге пользователя, под которым нужно зайти, если создать файл: `~/.ssh/authorized_keys` и положить туда открытый ключ, то можно будет заходить без пароля, права на файл не должны давать возможность писать в этот файл посторонним пользователям, иначе `ssh` его не примет. В ключе последнее поле - `user@server`. Оно не имеет никакого отношения к авторизации и служит только для удобства определения где чей ключ, это поле может быть поменяно (или даже удалено) без нарушения структуры ключа.

`ssh-add [<key>]` - добавляет ключи по пути `$HOME/.ssh/identity`, `$HOME/.ssh/id_rsa`, `$HOME/.ssh/id_dsa` [или указанный ключ] для ssh-agent на текущую сессию, который будет использоваться для проброса на другие сервера.

`ssh-add -L` - выводит список всех добавленных ключей для агента.

`ssh-add -D` - удаляет все добавленные ключи из агента.

`ssh-add -d <key>` - удаляет указанный ключ из агента.

`ssh-copy-id [-i ~/.ssh/id_rsa.pub] "[-p <port> ]<user>@<server>"` - копирует ключ на машину при этом не редактируя файлы вручную.

`~/.ssh/known_hosts` - хранятся ключи сервера, с которыми есть связь. Узнать, где какой ключ нельзя.

`ssh-keygen -R <server>` - удаляет известный ключ сервера, также необходимо сделать это и для IP, так как они хранятся раздельно: `ssh-keygen -R <IP>`.

Ключ сервера хранится в `/etc/ssh/ssh_host_rsa_key` и `/etc/ssh/ssh_host_rsa_key.pub`.

`scp <путь_к_локальному_файлу> <user>@<server>:<путь_к_каталогу_на_сервере>` - осуществляет копирование файла через ssh-сессию на сервер.

`scp -r <путь_к_локальному_каталогу> <user>@<server>:<путь_к_каталогу_на_сервере>` - осуществляет копирование каталога через ssh-сессию на сервер.

`scp <user>@<server>:<путь_к_файлу_на_сервере> <путь_к_локальному_каталогу>` - осуществляет копирование файла через ssh-сессию с сервера.

`ssh <user>@<server> [-t] <команда>[ <аргумент1>[ ...]]` - выполняет команду на удаленном сервере и тут же закрывает соединение [с управляющим терминалом для команд]. Для таких команд можно использовать pipe `|`, stdin `<`, stout `>` как для простых программ.

> `ssh user@8.8.8.8 command > my_file`  
> `mycommand | ssh user@8.8.8.8 "scp - user@10.1.1.2:/path/to/file"` - позволяет прокидывать файлы с сервера на сервер.  
> `ssh example.com -t "cd /www/example.com && git status -sb | head -1"`

В файле `~/.ssh/config` позволяет задать параметры подключения, в том числе специальные для каждого из серверов, а также задать им алиасы и так для каждого из серверов:
```
Host <алиас>
    Hostname <server>
    User <user>
    ForwardX11 yes
    Compression yes
    PasswordAuthentication no
```

Настройки соединения по умолчанию с помощью конструкции `Host *`.

В файле `/etc/ssh/ssh_config` задаются для всех.

`ssh -D localhost:<port> <user>@<server>` - задает туннелирование порта, заключается в том, что создается сокет для прослушивания порта на локальной машине, привязанный (необязательно) к конкретному адресу. Когда создается соединение к этому порту, это соединение туннелируется по зашифрованному каналу, и протокол приложения затем используется, чтобы определить, куда соединяться с удаленной машиной. При этом SSH работает как SOCKS сервер.

`ssh -L [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<user>@]<server>` - все соединения на `<локальный_адрес>:<локальный_порт>` будут переадресовываться удаленному серверу, который будет соединяться с `<удаленный_адрес>:<удаленный_порт>` от своего имени. По умолчанию `<локальный_адрес>` соответствует `127.0.0.1`. Возможно использование нескольких ключей `-L` в одном клиенте.

`ssh -R [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<user>@]<server>` - работает также как и `-L`, только соединения перебрасываются с удаленной машины на локальную.

`ssh -A <user1>@<server1> ssh <user2>@<server2>` - пробрасывает авторизацию на удаленный сервер.

`ssh -T <url>` - проверяет наличие соединения с `<url>`.

`ssh -vT <user>@<server>` - пытается подключиться к серверу и выводит информацию (дебаг) по попыткам подключения к нему. `-1` - файл не существует, `1` - существует.

`screen`
========

Позволяет сворачивать в фон программы, которые сами этого не умеют, с возможностью последующего возврата к ним.

`screen` - создает новый скрин, в котором откроет сессию командной оболочки.  
`screen <команда>` - создает новый скрин, в котором откроет указаную команду.

`Ctrl+a` - переводит `screen` в командный режим, в котором требуется нажать дополнительные клавиши для дополнительных команд.

`Ctrl+a d` - сворачивает текущий скрин, отключает его от терминала.  
`Ctrl+a k` - завершает текущий скрин вместе со всем, что в нем работает, необходимо подтвердить выход нажав `y`.  
`Ctrl+a c` - запускает новое окно скрина.  
`Ctrl+a w` - выводит список активных окон скрина в верхнем углу окна.  
`Ctrl+a p` - переключает на предыдущее окно скрина.  
`Ctrl+a n` / `Ctrl+a <пробел>` - переключает на следующее окно скрина.  
`Ctrl+a "` - выводит интерактивный список активных окон скрина, по которому можно перемещаться стрелками вверх-вниз и входить с помощью `Enter` в нужное.  
`Ctrl+a <номер_окна>` - переключает на указаное `<номер_окна>` окно скрина (0, 1, ...).  
``Ctrl+a ` `` - а затем номер и будет осуществлен переход на указанный номер окна скрина.  
`Ctrl+a A` - а затем необходимо ввести новое имя окна и с помощью `Enter` задать его.  
`Ctrl+a N` - выводит имя активного окна скрина в верхнем углу окна.  
`Ctrl+a S` - добавляет горизонтальный регион на экран, в котором будет отображено указаное окно скрина.  
`Ctrl+a |` - добавляет вертикальный регион на экран, в котором будет отображено указаное окно скрина.  
`Ctrl+a Tab` - переходит на следующий регион.  
`Ctrl+a X` - закрывает текущий регион.  
`Ctrl+a Q` - закрывает все регионы, кроме текущего региона.  

`screen -r` - возвращает к заранее сернутому скрину.

Для выхода из окна скрина необходимо написать `exit`.

`screen -S <имя> <команда>` - создает новый именованный скрин, в котором откроет указаную команду.  
`screen -r <имя>` - возвращает к заранее сернутому именному скрину.

`screen -list` / `screen -ls` - выводит список запущенных скринов.

wildcards - шаблоны замены
==========================

Командный интерпретатор линукс поддерживает возможность указания множества файлов используя шаблоны. Bash и другие команды линукс выбирают только те файлы, которые совпадают с шаблоном. Шаблоны:
- `*` - соответствует нулю или большему количеству символов;
    > `/tmp/my*1` - все файлы в директории `/tmp` имена которых начинаются с `my` и заканчиваются на `1` (включая файл с именем "my1")
    - `**` - соответствует всем файлам и нулю или более директорий и поддиректорий в пути;
    - `/**` - соответствует нулю или более директорий и поддиректорий:
        > `org/**/servlet/bla.jsp` - все файлы в директории `org/` пути которых заканчиваются на `/servlet/bla.jsp`
- `?` - заменяет один любой символ;
    > `/tmp/notes?txt` - соответствует файлам с именами "`notes.txt`" и "`notes_txt`" (если они существуют в `/tmp/`)
- `[<диапазон>]` - совпадает с одним символом из тех что указаны в скобках. Также в скобках можно указать диапазон символов, для этого используется символ `-` или несколько диапазонов подряд, тогда шаблон будет совпадать с одним любым символом из этого диапазона;
    > `/tmp/[A-Za-z]*` - все файлы в директории `/tmp/` имена которых начинаются с буквы (заглавной или прописной)
- `[[<диапазон>]` (= `[!<диапазон>]`) - похожа на `[]`, за исключением того что она соответствует единичному символу, не упомянутому между `[[` и `]`;
    > `myfile[[9]` - удалит все файлы, имена которых состоят из слова `myfile` и идущей за ним одной цифрой, кроме файла `myfile9`
- `<преамбула>{<значение1>,[ ...]}<эпилог>` - раскроет скобочную группу `{<значение1>,[ ...]}` в количестве элементов в ней содержащихся и превратит в последовательно идущие строки разделенные пробелом: `<преамбула><значение1><эпилог>[ ...]`. Может использоваться диапазон `<преамбула>{<от>..<до>}<эпилог>`.
> `touch app.{html,css,js}` = `touch app.html app.css app.js`  
> `touch version.{01..15}.txt`

Так как bash интерпретирует символы `?`, `[`, `]`, `*` как шаблоны замены, то для использования их как сивмолов их экранировать, т.е. поставить знак `\` перед ними или взять строку в одинарные кавычки `'`. Чтобы указать текстовый символ `\` можно заключить его в одинарные кавычки или написать `'\\\'`.

Вместо `<диапазон>` можно использовать классы символов: `[[:<класс>:]]`.

Для получения списка скрытых файлов, тех которые начинаются на `.` используется конструкция: `.[!.]?*`.
> `ls -d .[!.]?*`

При использовании с командами, они преобразуются в последовательность файлов, т.е. конструкция вида `<команда> <шаблон>` будет равна `<команда> <файл1> <файл2>[ ...]`.

> `ls ./lib*` = `ls ./lib ./lib64 ./libexec`

Поиск файлов
============

`locate <файл>` - выводит все места расположения файла с таким именем.

`updatedb` - запускает создание или обновление БД для поиска через `locate`.

## `find`

`find <каталог>` - выводит список всех файлов в каталоге и его подкаталогах. Опции:
- `-name <имя>` - только те, которые соответствуют имени;
- `-newer <файл>` - только те, которые были изменены (редактированы, или созданы) позже файла с именем `<файл>`;
- `-iname <имя>` - только те, которые соответствуют имени, но без учета регистра в названии файлов;
- `-type {f | d | l}` - только файлы с определенным типом: `f` - обычные файлы, `d` - каталоги, `l` - символичные ссылки;
- `-atime [<мод>]<n>` - производит поиск по дате создания или последнего доступа к ним, где `<n>` - количество суток, в пределах `<n>` и `<n> + 1` дней [при модификаторе `<мод>` равным `-` - меньше `<n>` дней, при `+` - больше `<n>` дней];
- `-ctime [<мод>]<n>` - производит поиск по дате создания или изменения статуса файла или папки;
- `-mtime [<мод>]<n>` - производит поиск файлов, которые были изменены (редактированы, или созданы);
- `-amin [<мод>]<n>` - аналогично `-atime`, только `<n>` - означает количество минут;
- `-cmin [<мод>]<n>` - аналогично `-ctime`, только `<n>` - означает количество минут;
- `-mmin [<мод>]<n>` - аналогично `-mtime`, только `<n>` - означает количество минут;
- `-exec <команда>[<аргумент1>[ ...]] '{}' {\; | +}` - используется для указания другой команды, которую надо выполнить над каждым найденым файлом в результате поиска, где `{}` - заменяется на символическое представление текущего пути к файлу, а `\;` - конец команды, если указан `+`, то `{}` будет представлять собой объединенный список имен файлов результата поиска;
- `-size {+ | -}<n>{c | w | b | k | M | G}` - выводит только файлы, которые больше при знаке `+` или меньше при `-` определенного размера `<n>` в величине измерения: `c` - в байтах, `w` - в 2-байтных словах, `b` - в блоках по 512 байт, `k` - в килобайтах, `M` - в мегабайтах, `G` - в гигабайтах.

> `find . -type d -atime +2`  
> `find . -size +2048k`  
> `find .` - выводит список всех файлов в текущем каталоге и его подкаталогах.  
> `find /home/nobody/public_html -type f -exec chmod 644 '{}' \;` - меняет права на все файлы в папке.  
> `find . -type f -size +100M | xargs ls -lh` - выводит все файлы, размер которых больше 100 Мегабайт.

Поддерживает группировку с помощью логических операторов:
- `-and` (`-a`) - соотвествует логическому и;
- `-or` (`-o`) - соотвествует логическому или;
- `-not` (`-!`) - соотвествует логическому не.

По умолчанию между опциями стоит `-and`.

Рекомендуется блоки условий помещать в `\(` и `\)`.
> `find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)`

Пользователи и группы
=====================

**Пользователь** - это сущность, которая может запускать процессы и обладать файлами, у каждого пользователя есть **имя пользователя** и **идентификатора пользователя**.

**Группы** состоят из пользователей. Основная цель групп заключается в том, чтобы пользователь мог предоставлять файлы для совместного доступа другим пользователям группы.

`id` - выводит информацию о текущем пользователе, его идентификатор **uid**, идентификатор основной группы **gid** и других группах в которых он состоит.

В файле `/etc/passwd` содержится информация о пользователях и содержит:
- имя пользователя (для входа);
- пароль в виде `*`;
- числовой идентификатор пользователя (uid);
- числовой идентификатор основной группы (gid);
- действительное имя пользователя;
- путь к домашнему каталогу;
- путь к командной оболочка входа (login shell).

`users` - выводит список авторизованных пользователей.  
`cut -d: -f1 /etc/passwd | sort | uniq` - выводит список всех пользователей.

`useradd <имя_пользователя>` - добавляет пользователя.  
`userdel <имя_пользователя>` - удаляет пользователя.

`groups [<имя_пользователя>]` - выводит список групп, в которых состоит текущий [указанный] пользователь. Основная (первичная) группа пользователя находится в файле: `/etc/passwd`.

`newgrp <имя_группы>` - производит смену первичной группы на указаную до конца сеанса или вызова команды `exit`.

`cut -d: -f1 /etc/group > | sort` - выводит список всех групп.

`groupadd <имя_группы>` - добавляет группу.  
`groupdel <имя_группы>` - удаляет группу.

`usermod -a -G <имя_группы_1>[, ...] <имя_пользователя>` - добавляет группы пользователю.  
`usermod -g <имя_группы> <имя_пользователя>` - изменяет первичную группу пользователя.  
`usermod -d <имя_пользователя> <имя_группы>` - удаляет пользователя из группы.

`su { - | <имя_пользователя>} [-c '<команда>']` - запускает в текущей консоли командную оболочку c правами другого пользователя `<имя_пользователя>`, по умолчанию - рута [и выполняет в ней одну команду и закрывает ее].  
`sudo [-u <имя_пользователя>] <команда>` - позволяет запустить одиночную команду с правами другого пользователя [`<имя_пользователя>`], по умолчанию - рута.  
Чтобы вернуться в оболочку обычного пользователя, нужно дать команду `exit`, `logout` или нажать `Ctrl + D`.

`w` - выводит список подключенных пользователей и их терминалов.

`whoami` - выводит логин пользователя под которым произведен вход.

`passwd [<имя_пользователя>]` - изменяет пароль текущему пользователю [указаному `<имя_пользователя>`].

Права и владение файлами
========================

Пользователь, который создает файл становится владельцем этого файла, а **первичная** группа, в которую входит этот же пользователь, так же становится владельцем этого файла.

`ls -l` - выводит список файлов с правами на них.

## Права

двоичная | восьмеричная | символьная | права на файл       | права на каталог
-------- | ------------ | ---------- | ------------------- | ---------------
`000`    | `0`          | `---`      | нет                 | нет
`001`    | `1`          | `--x`      | выполнение          | чтение файлов и их свойств
`010`    | `2`          | `-w-`      | запись              | нет
`011`    | `3`          | `-wx`      | запись и выполнение | все, кроме чтения списка файлов
`100`    | `4`          | `r--`      | чтение              | чтение имен файлов
`101`    | `5`          | `r-x`      | чтение и выполнение | доступ на чтение
`110`    | `6`          | `rw-`      | чтение и запись     | чтение имен файлов
`111`    | `7`          | `rwx`      | все права           | все права

`chmod [-R] [[u][g][o][a]{+ | - | =}[w][r][x][s][t]] <файл>` - устанавливает права на файл или каталог [рекурсивно], где: `u` - для пользователя, `g` - группы, `o` - других и `a` - для всех.
> `chmod u+rx file.txt`

`chmod <восмиричные_права_для_пользователя><восмиричные_права_для_группы><восмиричные_права_для_других> <файл>` - устанавливает права на файл или каталог в восьмеричной системе записи.
> `chmod 755 file.txt`

В некоторых исполняемых файлах вместо `x` указано `s` (setuid - 4000) в секции пользователя, что обозначает что данный файл запускается так, словно владельцем файла является пользователь с указанным идентификатором, а не текущий пользователь. Для секции группы (setgid - 2000) обозначает, что вместо идентификатора группы реального пользователя будет группа владельца файла, для какталога это значит, что создаваемые файлы в каталоге будут файлами с группой каталога, а не пользователя. `t` (sticky - 1000) - для остальных вместо `x` обозначает, что нельзя переименовывать каталог, файлы в нем и удалять их, если только пользователь не является из владельцем или суперпользователем.

`umask [<новое_значение>]` - выводит [устанавливает] значение маски в восьмиричной системе для установки прав на новые файлы. В позиции где маска установлена атрибут сбрасывается: `0022 = 000 000 010 010` `000 000 010 010 + --- rw- rw- rw- = --- rw- r-- r--`.
> `umask 0022`

## Владение

`chown [-R] <имя_пользователя>[:[<имя_группы>]] <файл>` - устанавливает владельца [и группу владельцев] (если группа не указана при наличии `:`, то будет группа пользователя) на файл или каталог [рекурсивно].
> `chown luser public`  
> `chown lisa.sales myfile`

`chgrp [-R] <имя_группы> <файл>` - устанавливает группу владельцев на файл или каталог [рекурсивно].
> `chgrp geekpress public`

Сеть
====

`ping <домен>` - посылает специальные сетевые пакеты IMCP ECHO_REQUEST и выводит статистику по их приему.

`traceroute <домен>` - посылает последовательно всем узлам на пути сетевого трафика между локальной системой и указанным узлом сети и выводит список всех "переходов" (hops) со статистикой по ним.

`ip addr show` - выводит на экран список сетевых интерфейсов.  

`ip link set <интерфейс> up` - поднимает сетевой интерфейс.  
`ip link set <интерфейс> down` - отключает сетевой интерфейс.
> `ip link set eth1 up`

`ifup <интерфейс>` - поднимает сетевой интерфейс.  
`ifdown set <интерфейс>` - отключает сетевой интерфейс.

Перезапуск сети: `systemctl restart network`.

`brctl show` - выводит на экран список мостов.

`host <dns_домен>` - возвращает ip-адрес указаного домена и все его dns-алиасы.

## Установка DNS

Для интерфейса `<интерфейс>` выполняется команда `nmcli con mod <интерфейс> ipv4.dns "8.8.8.8 8.8.4.4"` и затем перезапускается с помощью команд `nmcli con down <интерфейс>` и `nmcli con up <интерфейс>`.

Пакеты
======

Управление пакетами (package management) - это методика установки и управления программным обеспечением в системе.

Файл пакета - это сжатая коллекция файлов, составляющих программный пакет. Может включатьв себя множество файлов и программ.

Основные системы пакетов:
- **Debian** (`.deb`) - Debian, Ubuntu, Linux Mint, Raspbian. Основные системы управления пакетами:
    - `dpkg` - низкоуровневый инструмент;
    - `apt-get`, `apt`, `aptitude` - высокуровневые инструменты.
- **Red Hat** (`.rpm`) - Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE. Основные системы управления пакетами:
    - `rpm` - низкоуровневый инструмент;
    - `yum`, `dnf` - высокуровневые инструменты.

`apt-get update` - обновление информации о пакетах, которые содержатся в репозитории.

`apt-cache search <искомая_строка>` - ищет пакеты, которые содержат указанную строку.  
`yum search <искомая_строка>` - аналогично.

`apt-cache install <имя_пакета>` - устанавливает пакет из репозитория с его зависимостями.  
`yum install <имя_пакета>` - аналогично.

`dpkg -i <файл_пакета>` - устанавливает только пакет из файла.  
`rpm -i <файл_пакета>` - аналогично.

`apt-get remove <имя_пакета>` - удаляет пакет с его зависимостями.  
`yum erase <имя_пакета>` - аналогично.

`apt-get upgrade` - обновляет пакеты из репозитория.  
`yum update` - аналогично.

`dpkg -i <файл_пакета>` - обновляет пакет из файла.  
`rpm -U <файл_пакета>` - аналогично.

`dpkg -l` - выводит список установленных пакетов.
`rpm -qa` - аналогично.

`dpkg -s <имя_пакета>` - определяет, установлен ли пакет.  
`rpm -q <имя_пакета>` - аналогично.

`apt-cache show <имя_пакета>` - выводит информацию об устанавленном пакете.  
`yum info <имя_пакета>` - аналогично.

`dpkg -S <имя_файла>` - определяет, с каким пакетом был установлен файл.  
`rpm -qf <имя_файла>` - аналогично.

`yum repolist -v` - (CentOS) выводит список подключенных репозиториев.

Сервисы
=======

`systemctl list-units [-a]` - выводит список служб [все службы].  
`systemctl status <служба>` - посмотреть состояние и вывод службы.  
`systemctl show <служба>` - посмотреть параметры управления службой в Linux.  
`systemctl is-active <служба>` - проверить запущена ли служба linux.

`systemctl start <служба>` - запустить службу linux.  
`systemctl stop <служба>` - остановить службу linux.  
`systemctl reload <служба>` - обновить конфигурацию службы из файла юнита.  
`systemctl restart <служба>` - перезапустить службу.

`systemctl enable <служба>` - добавить службу в автозагрузку.  
`systemctl disable <служба>` - удалить службу из автозагрузки.  
`systemctl is-enabled <служба>` - проверить если ли уже служба в автозагрузке.  
`systemctl reenable <служба>` - сначала выполнить `disable` потом `enable` для службы.

Флаг `--runtime` позволяет не сохранять вносимые изменения после перезагрузки.

Команды для файловой системы
============================


`cd <каталог>` - перемещение в указанный каталог.  
`cd` - перемещение в домашний каталог.  
`cd ..` - перемещение на каталог выше по иерархии.  
`cd -` - перемещение в предыдущий каталог, в котором находились до этого перемещения.

`~` - специальное имя, указывающее в bash на домашнюю директорию пользователя.

`ls [<опции>] {<каталог> | <файл>}` - выводит на экран список файлов хранящихся в указанном каталоге (текущем, если не указан) или информацию о файле. Опции:
- `-a` - все файлы, включая скрытые (имена которых начинаются с точки);
- `-A` - аналогично `a`, только не выводит каталоги `.` и `..`;
- `-l` - выводит подробную информацию, такую как:
    - тип файла - первый символ:
        - `-` - файл;
        - `d` - каталог;
        - `l` - ссылка;
        - `b` - блочное устройство;
        - `c` - символьное устройство;
        - `p` - канал;
        - `s` - сокет;
    - права на файл;
    - число жестких ссылок на файл;
    - имя владельца;
    - имя группы;
    - размер файла в байтах;
    - время последнего изменения файла;
    - имя файла;
    - если это ссылка, то после знака `->` стоит имя объекта на который она ссылается;
- `-h` - вместе с `-l` выводит размер фалов в удобочитаемом формате;
- `-d` - только информация о каталоге, а не о содержимом каталога;
- `-R` - рекурсивный вывод всех файлов находящихся в директории;
- `-i` - показывает **инод** (inode number) - уникальный номер;
- `-F` - показывает типы файлов;
- `-S` - сортирует по размеру;
- `-t` - сортирует по времени последнего изменения;
- `-r` - инвертирует порядок сортировки;
- `-1` - выдавать в одноколоночном формате.

`pwd` - показать текущую директорию.

`cp <откуда>[ ...] <куда>` - копирует файлы, если `<куда>` - существующая директория, то копирует файлы в нее. Дополнительные параметры:
- `-a` - при копировании атрибуты файлов, их владельцы и права доступа;
- `-r` - рекурсивное копирование каталогов и их содержимого;
- `-u` - только файлы, которые отсутствуют или более новые, если они уже есть в каталоге;
- `-v` - включает вывод информационных сообщений.
`cp <файл>{,.copy}` - быстрое создание резервной копии файла.

`mv <откуда>[ ...] <куда>` - перемещает или переименовывает файлы, если `<куда>` - существующая директория, то перемещает файлы в нее.

`ln <имя> <файл>` - создает жесткую ссылку на файл. Таким образом, получается что файл присутствует в системе под несколькими разными именами. Файл существует до тех пор, пока с его инодом связано хотя бы одно имя. Понятия "*жесткая ссылка на файл*" и "*имя файла*" являются синонимами.

`ln -s <имя> <объект>` - создает символьную ссылку на любой объект (файл, директория, сокет...) любой файловой системы. *Симлинк* это специальный вид файла, который ссылается на другой файл по имени, а не напрямую на инод. Симлинки не предохраняют файл от удаления.

`rm <файл>[ ...]` - удаляет файлы. Опции:
- `-i` - запрашивает у пользователя подтверждение удаления каждого файла;
- `-f` - без подтверждения.

`rmdir <каталог>` - удаляет **пустой** каталог.  
`rm -rf <каталог>` - удаляет рекурсивно файлы и каталоги в указаном каталоге.

`touch <файл>` - изменяет временные метки файла или создает его, если его нет.  
`> <файл>` - очистка файла или его создание.

`mkdir [-p] <путь>` - производит создание директории [и всех вложенных директорий, если они отсутствуют].
> `mkdir -p my-app/{css,js}` - создание нескольких поддерикторий

Другие команды
==============

`alias <алиас>="<список_команд>"` - задает алиас для спика команд. Используется как `<алиас>`. Для установки алиасов по умолчанию их добавляют в файл: `~/.bash_profile`.

`alias` - выводит список алиасов.

`unalias <алиас>` - удаляет алиас.

`<команда> | xargs <команда> [<начальный_аргумент>[ ...]]` - объединяет зафиксированный набор заданных в командной строке начальных аргументов с аргументами, прочитанными со стандартного ввода, и выполняет указанную команду.
> `ls -1 | xargs git diff`

Просмотр записи в текстовый файл в реальном времени:  
`tailf <файл>`  
`tail -f <файл>`

`head -n <количество_строк> <файл>` - выводит только указаное количество первых строк.

`tail -n <количество_строк> <файл>` - выводит только указаное количество последних строк.  
`tail -n +<количество_строк> <файл>` - выводит с файла все строки, кроме `<количество_строк> - 1` первых строк.

`time <команда>` - выводит время выполнения команды.

`watch <команда>` - следит за изменениями в выводе команды.

`truncate -s <размер_в_байтах> <файл>` - усекает размер файла до `<размер_в_байтах>`.

`cat <файл1>[ ...]` - вывод файлов в поток вывода. Для вывода многострокового текста используется конструкция:
```bash
cat <<EOF [> <файл>]
...
EOF
```
```bash
cat << EOF > script.sh
printf "Hello\n"
printf "Wordl!\n"
EOF
```

`cut -d<разделитель> -f<номер_колонки_1>[ ...] <файл>` - читает из файла строки и разбивает их по разделителю `<разделитель>` и выводит указанные колонки соединенные разделителем, при этом нумерация идет с 1:
> `cat /etc/passwd | cut -d: -f1 | sort | uniq`

`tee <файл>` - читает данные из стандартного ввода и пишет их одновременно в файл и в стандартный поток вывода.

`more <файл>` - вывод файла в поток вывода.

`less[ <файл>]` - постранично выводит содержимое файла или из стандартного потока ввода. Управление:
- `Пробел` - перемещение на следующий экран;
- `B` - перемещение на предыдущий экран;
- `Q` - выход;
- `N` - продолжение поиска. Поиск происходит вводом:
    - `/<строка_поиска>` - поиск в прямом направлении;
    - `?<строка_поиска>` - поиск в обратном направлении.

`diff [-u] <файл1> <файл2>` - сравнивает два файла.

`comm <файл1> <файл2>` - выводит только те строки, которые есть в обоих файлах.

`file <файл>` - выводит информацию о файле.

Преобразование символов из входящего потока в исходящий:  
`tr "<строка1>" "<строка2>"` - замена каждого символа из входящего потока, который соответствует символу из `"<строка1>"` на соответствующий ему символ по позиции из `"<строка2>"`.  
`tr -d "<строка>"` - удаляет все вхождения символов, указанных в `"<строка>"`.

`sort [-n] [-r] <файл>` - сортирует данные в соответствии в алфавитно-числовом порядке [`-n` в порядке следования чисел] [`-r` - обратная сортировка].

`uniq [-d] <файл>` - удаляет [оставляет только уникальные] повторяющиеся строки в отсортированном списке. Или (с ключом `-с`) не просто удалить, а написать сколько таких строк было. Учитываются только подряд идущие одинаковые строки, поэтому часто данные сортируются перед тем как отправить их на вход программе.

`man <команда>` - выводит информацию о команде.  
`man -k <ключевое_слово>` - производит поиск по онформации о командах по ключевому слову.

`md5sum <файл>` - возвращает md5-хеш для файла.

`cat /proc/cpuinfo` - выводит информацию о процессоре.  
`cat /proc/meminfo` - выводит информацию о памяти.

`free -m` - показывает объем оперативной памяти, весь, свободный и занятый в МБ.

`wc <файл>` - выводящая число (количество) переводов строк, слов и байт для каждого указанного файла и итоговую строку, если было задано несколько файлов. Если входной файл не задан, или равен `-`, то данные считываются со стандартного ввода. Флаги:
- `-l` - только количество строк;
- `-c` - только количество байт;
- `-m` - только количество символов;
- `-L` - только длину самой длинной строки;
- `-w` - только количество слов.

> `ls | wc -l` - считает количество файлов.

`xxd -p <файл>` - выводит в hex-формате содержимое файла

> `xxd -p <файл> | tr -d '\n'` - то же самое, только в одну строку.

`date` - выводит текущую дату в консоль.  
`date +%s` - выводит текущую дату в консоль в секундах.

`cal` - выводит календарь для текущего месяца.

`uptime` - выводит время работы сервера.

`type <команда>` - выводит тип команды и ее расположение.  
`type -t <команда>` - выводит только тип команды.  
`type -a <команда>` - выводит все расположение команды и ее алиасы.

`command -v <команда>` - возвращает путь к команде.  
`command -V <команда>` - возвращает только путь к команде.

`whereis <приложение>` - выводит все возможные местоположения (расположение) программы.

`which <приложение>` - выводит местоположение программы, которое вызовется по умолчанию.

`uname -or` - выводит версию Linux.  
`cat /proc/version` - выводит информацию о версии Linux.

`clear` - очищает терминал.

## Разное

`script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)` - записывает в переменную `script_dir` текущее местоположение скрипта.

Позволяет отображать текст цветными сиволами:
```bash
setup_colors() {
    if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
        NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
    else
        NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
    fi
}

msg() {
    echo >&2 -e "${1-}"
}

setup_colors

msg "This is a ${RED}very important${NOFORMAT} message, but not a script output value!"
```

`cat /dev/urandom | base64 | head -c <N>` - производит случайную генерацию пароля.
