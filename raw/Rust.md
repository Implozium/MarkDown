Установка
=========

`curl https://sh.rustup.rs -sSf | sh` - для MacOS и Linux.

`rustup update` - производит обновление языка.

`rustup self uninstall` - производит удаление инструмента.

`rustc --version` - выводит версию языка.

`rustup doc` - открывает локальную документацию в браузере.

`rustup component add rls rust-analysis rust-src` - устанавливает дополнения для разработки.

Cargo
=====

Система сборки и пакетный менеджер языка Rust.

`cargo --version` - выводит версию.

`cargo new <имя_проекта>` - создает новый проект, в каталоге `<имя_проекта>` котором будет инициирован репозиторий git с файлом `.gitignore`, каталог `src` в котором будет находиться исходный код с файлом `main.rs` внутри. Также в каталоге проекта будет файл `Cargo.toml` со структурой:

```toml
[package]
name = "<имя_проекта>"
version = "0.1.0"
authors = ["Ваше имя <you@example.com>"]
edition = "2018"
description = "<описание>"
license = "MIT OR Apache-2.0"

[dependencies]
<имя_упаковки> = "<версия>"

[profile.release]
panic = 'abort'
opt-level = <уровень>

[profile.dev]

[workspace]
members = [
    "<путь1>",
]
```

Где:
- `[profile.release]` - определяется секция релизной сборки;
- `[profile.dev]` - определяется секция сборки для разработки;
- `panic = 'abort'` - убирает разматывание стека на прерывание;
- `opt-level = <уровень>` - устанавливает уровень оптимизаций от 0 до 3;
- `[workspace]` - определяется секция для рабочих пространств, где в `members` указан путь до подмодулей, которые создаются внутри с помощью `cargo new`.

`cargo init` - создает проект в текущей директории.

`cargo new --lib <имя_проекта>` - создаст проект, аналогично предыдущему, только библиотечный с главным файлом `src/lib.rs`.

`cargo build` - создает исполняемый файл `target/debug/<имя_проекта>`. После выполнения создасться файл `Cargo.lock` который отслеживает точные версии зависимостей в проекте.

`cargo build --release` - создает релизный файл `target/release/<имя_проекта>`.

`cargo run` - создает исполняемый файл и сразу же его выполянет, если ничего не менялось в исходных файлах, то просто его выполянет.

`cargo check` - проверяет исходный код, чтобы убедиться в его компилируемости.

`cargo update` - обновляет упаковки.

`cargo add <упаковка>` - добавляет упаковку в проект.  
`cargo remove <упаковка>` - удаляет упаковку из проект.

`cargo test [<шаблон>]` - выполняет все тесты [которые подходят под указанный шаблон] в проекте в параллельном режиме. Флаги идут после `--`:
- `--test-threads=<количество>` - устанавливает количество потоков выполнения тестов;
- `--nocapture` - разрешает вывод текстовой информации в консоль;
- `--ignored` - включает в запуск и игнорируемые тесты;
- `--test [<шаблон>]` - включает в запуск интеграционные тесты из каталога тестов.

Атрибут `#[cfg(<имя_конфигурации>)]` предназначен для конфигурации и говорит Rust, что следующий элемент должен быть включен только учитывая определенную опцию конфигурации `<имя_конфигурации>`.

`cargo doc [--open]` - генерирует документацию [и открывает ее в браузере] - команда запускает инструмент `rustdoc`, поставляемый с Rust, и помещает сгенерированную HTML-документацию в каталог `target/doc`.

`cargo publish` - публикует библиотеку. При изменении версии будет публиковаться еще одна, новая версия библиотеки  
`cargo yank --vers <версия>` - устанавливает недоступность версии для новых проектов.  
`cargo yank --vers <версия> --undo` - отменяет недоступность версии для новых проектов.

`cargo install <имя_упаковки>` - позволяет локально устанавливать и использовать исполняемые крейты - которыми является запускаемая программа, созданная и имеющая в составе крейта файл `src/main.rs` или другой файл, указанный как исполняемый. Все исполняемые файлы установленные этой командой будут сохранены в корневой установочной папке `bin`.

## Рабочие пространства

Создаются с помощью `cargo new` внутри каталого проекта. Зависимости указывются в файле `Cargo.toml` внутренних крейтов, который имеет структуру подобную главному файлу:
```toml
[dependencies]

<крейт1> = { path = "../<путь_к_крейту1>" }
```

`cargo run -p <крейт>` - создает исполняемый файл для внутреннего крейта `<крейт>` и сразу же его выполянет.

Если в крейтах используется зависимость от внешних файлов, то **Cargo** разрешит все из них в одну версию зависимости и запишет ее в один `Cargo.lock`. Использованием всеми крейтами одинаковых зависимостей в рабочем пространстве означает, что крейты в рабочем пространстве всегда будут совместимы с друг с другом. Каждый крейт, который использует внешнею зависимость, должен ее явно использовать в своем файле `Cargo.toml`.

## Ручная компиляция

`rustc <имя_файла>.rs` - производит компиляцию файла.

Основы
======

## Точка входа

```rust
fn main() {
    // ...
}
```

## Переменные и изменяемость

Переменные именуются в стиле **snake_case** - змеином_регистре.

`let [mut] <имя_переменной>[: <тип>] = <значение>;` - объявление неизменяемой [с `mut` изменяемой] переменной с указанным значением и автовыводом типа [с указаным типом `<тип>`].
> `let x = 5;`  
> `let guess: u32 = "42".parse().expect("Не является числом!");`

Переменные можно затенять, то есть повторно их объявлять с одинаковым именем, при этом можно изменять тип. Главное отличие от `mut` то, что можно выполнить множество трансформаций значения, но после всех трансформаций переменная будет неизменяемой.
```rust
let spaces = " ";
let spaces = spaces.len();
```

Константы именуются в стиле **SCREAMING_SNAKE_CASE** - КРИЧАЩЕМ_ЗМЕИНОМ_РЕГИСТРЕ.

`const <ИМЯ_КОНСТАНТЫ>: <тип> = <значение>;` - объявление константы с указанным значением и типом.
> `const MAX_POINTS: u32 = 100_000;`

## Типы данных

### Скалярные типы

#### Целочисленные типы

Целое число - это число без дробной составляющей.

Длина   | Знаковый   | Беззнаковый
------- | ---------- | -----------
8 бит   | `i8`       | `u8`
16 бит  | `i16`      | `u16`
32 бит  | `i32`      | `u32`
64 бит  | `i64`      | `u64`
128 бит | `i128`     | `u128`
arch    | `isize`    | `usize`

Типы `isize` и `usize` зависят от типа компьютера, на котором выполняется программа: 64 бита, если используется 64-битная архитектура, и 32 бита, если 32-битная архитектура.

Типы `isize` или `usize` по преимуществу используются в индексировании коллекции.

`_` можно применять в качестве визуального разделителя разрядов.

Системы счисления:
- `0x<значение>` - число в 16 системе.
    > 0xff
- `0o<значение>` - число в 8 системе.
    > 0o77
- `0b<значение>` - число в 2 системе.
    > 0b1111_1111
- `b'<значение>'` - число в байтовой системе.
    > b'A'

#### Типы с плавающей точкой

Тип `f32` представляет собой вещественное число с одинарной точностью, а `f64` имеет двойную точность. По умолчанию используется `f64`. Всегда должны иметь `.` в значении.

#### Булев тип

Тип `bool` имеет два возможных значения: `true` и `false`.

#### Символьный тип

Тип `char` равен четырем байтам и представляет собой скалярное значение Юникод и задается одинарными кавычками.
> `let z = 'ƶ';`

### Составные типы

Составные типы группируют многочисленные значения в один тип.

#### Кортежный тип

**Кортеж** - это часто встречающийся способ группирования ряда других значений с разнообразными типами в один составной тип. Кортежи имеют фиксированную длину: после объявления они не могут увеличиваться или уменьшаться в размере.

Кортеж создают, записывая список значений через запятую внутри круглых скобок. Каждая позиция в кортеже имеет свой тип, а типы разных значений в кортеже не обязательно должны быть одинаковыми.

`let <кортеж>: (<тип1>[, <тип2>[, ...]]) = (<значение1>[, <значение2>[, ...]]);`
> `let tup: (i32, f64, u8) = (500, 6.4, 1);`

Для доступа к значениям кортежа используется **деструктурирование**:  
`let (<переменная1>[, <переменная2>[, ...]]) = <кортеж>;` - значения кортежа запишутся в отдельные переменные.
> `let (x, y, z) = tup;`

Или доступ по индексу (начиная с 0):  
`let <переменная> = <кортеж>.<индекс>;`
> `let one = tup.0;`

#### Массив

Имеет фиксированную длину, где каждый элемент массива должен иметь один и тот же тип. Массив представляет собой отдельную часть памяти, выделенную в стеке.

`let <массив>: [<тип>; <количество>] = [<значение1>[, <значение2>[, ...]]];`
> `let a: [i32; 5] = [1, 2, 3, 4, 5];`

`let <массив>: [<тип>; <количество>] = [<значение_по_умолчанию>; <количество>];` - заполнение значением по умолчанию всех элементов массива.
> `let a = [3; 5];`

Для доступа к значениям массива используется доступ по индексу (начиная с 0):  
`let <переменная> = <массив>[<индекс>];`
> `let one = a[0];`

`<массив>.len();` - возвращает длину массива.

`<массив>.starts_with(<срез>);` - возвращает `true` если массив начинается со среза `<срез>` типа `&[<тип>]`, иначе `false`.

`let (<срез1>, <срез2>) = <массив>.split_at_mut(<индекс>);` - возвращает кортеж из двух слайсов типа `&mut [<тип>]` в которых содержится по части массива, разбитых по индексу.

## Сложные типы

Хранятся в куче.

## Тип `Never`

Это пустой тип, который не имеет значений: `!`. Используется по умолчанию в `continue`, которая его возвращает и макросе `panic!`. Выражения типа `!` могу быть приведены (coerced) к любому другому типу.

## Функции

Имя функции пишется в *змеином_регистре*.

Языку Rust все равно, где определены функции; главное, чтобы они были где-то определены.

```rust
fn <имя_функции>([<аргумент1>: <тип>[, <аргумент2>: <тип>[, ...]]]) [-> <тип_возвращаемого_значения>] {
    // <код>
}
```

```rust
fn another_function(x: i32, y: i32) {
    println!("Значение x равно {}", x);
    println!("Значение y равно {}", y);
}
```

Массивы и строки передаются в функции в виде срезов.

### Инструкции и выражения

Инструкции - не возвращают значения.

Вызов функции является выражением. Вызов макрокоманды является выражением. Блок, который используется для создания новых областей, `{}`, является выражением. Выражения не включают конечные точки с запятой. Если добавляется точка с запятой в конец выражения, то оно превращается в инструкцию, которая в таком случае не возвращает значение.
```rust
let y = {
    let x = 3;
    x + 1
};
```

Можно вернуться из функции досрочно, используя ключевое слово `return` и указав значение, но большинство функций неявным образом возвращают последнее выражение.
```rust
fn five() -> i32 {
    5
}
```

Если функция не возвращает значение, то она возвращает тип `Never`:
> `fn bar() {/* ... */}` = `fn bar() -> ! {/* ... */}`

### Типы

У каждой функции есть свой тип, который описывает сигнатуру функции. Этот тип может использоваться в качестве типа для параметров. Этот тип является **указателем функции**.  
`fn ([<аргумент1>: <тип>[, <аргумент2>: <тип>[, ...]]]) [-> <тип_возвращаемого_значения>]`
```rust
fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}
```

## Комментарии

`// <комментарий>`

## Управление потоком

### Выражения `if`

Выражение `if` позволяет ветвить код в зависимости от условий. Условия должны возвращать булевый тип.

```rust
if <условие> {
    // код истиности условия
}[ else if <условие2> {
    // код истиности условия2 и ложности предыдущих условий
}][ else {
    // код ложности
}]
```

```rust
let number = 6;

if number % 3 == 0 {
    println!("число делится на 3");
} else if number % 2 == 0 {
    println!("число делится на 2");
} else {
    println!("число не делится на 3 и 2");
}
```

Выражение `if` можно присваивать переменным, так как блоки `{}`, являются выражением и возвращают значения. Возвращаемые значения должны быть одного типа.

```rust
let <переменная> = if <условие> {
    // код истиности условия
    <значение>
}[ else if <условие2> {
    // код истиности условия2 и ложности предыдущих условий
    <значение>
}][ else {
    // код ложности
    <значение>
}];
```

```rust
let condition = true;
let number = if condition {
    5
} else {
    6
};
```

### Повторение с помощью циклов

`break` - прерывает выполнение цикла.

`continue` - прерывает текущую итерацию цикла.

#### `loop`

Выполняется бесконечно.

```rust
loop {
    // код итерации цикла
}
```

```rust
loop {
    println!("еще раз!");
}
```

Выражение `loop` можно присваивать переменным, как и в случае `if`. Для этого используется конструкция `break <значение>;` внутри цикла.

```rust
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};
```

#### `while`

Выполняется пока условие истино.

```rust
while <условие> {
    // код итерации цикла
}
```

```rust
let mut number = 3;
while number != 0 {
    println!("{}!", number);
    number = number - 1;
}
```

#### `for`

Выполняет, пока не переберет коллекцию.

```rust
for <переменная> in <коллекция> {
    // код итерации цикла
}
```

Для обычного перебора значений используется конструкция вида: `for i in 0..<длина> { /* ... */}`.

```rust
let a = [10, 20, 30, 40, 50];
for element in a.iter() {
    println!("Значение равно {}", element);
}
```

Если Rust знает количество циклов, то он использует **разворачивание** - это оптимизация, которая устраняет издержки кода управления циклом и вместо этого генерирует повторяющийся код для каждой итерации цикла.

Макрокоманды
============

`print!("<текст> {} <текст>"[, <значение1>[, ...]]);` - производит вывод текста в консоль. Заменяет все `{}` на значения последующих значений.  
`println!("<текст> {} <текст>"[, <значение1>[, ...]]);` - аналогично `print!`, только вконце переносит текст на новую строку.

`eprintln!("<текст> {} <текст>"[, <значение1>[, ...]]);` - аналогично `print!`, только пишет в поток для вывода ошибок.

Спецификаторы:
- `{}` - вывод простого значения или строки;
- `{:?}` - вывод значения с помощью типажа `#[derive(Debug)]` - средства форматированной отладки;
- `{:#?}` - расширенный вывод значения.

Концепция владения
==================

Существует три основных способа передачи данных в функции: перемещение (move), копирование (copy) и заимствование (borrow - передача по ссылке).

Владеть можно значениями, которые выделяются в куче. Так как типы, размер которых во время компиляции известен, хранятся полностью в стеке, и поэтому копии фактических значений создаются быстро.

Правила владения:
- Каждое значение в языке Rust имеет переменную, которая называется его владельцем.
- В каждый момент времени может существовать только один владелец.
- Если владелец выйдет из области видимости `{...}`, значение будет отброшено методом *drop*.

Во время переприсваивания переменной, которая ссылается на значение, выделенное на куче, другой переменной, то **владение** значением устанавливается на второй переменной и первой переменной нельзя пользоваться - т.е. изменять или передавать в функции. Это все делает недействительной первую переменную, эта операция называется "*перемещение*" (*move*).

```rust
let s1 = String::from("hello");
let s2 = s1; // после этого переменная s1 не действительна
```

Владение переменной всякий раз следует одному и тому же паттерну: присвоение (передача) значения другой переменной перемещает его. Если переменная, содержащая данные в куче, выходит из области видимости, то значение будет очищено методом *drop*, если только данные не были перемещены в другую переменную.

Передача переменной функции приведет к перемещению или копированию, так же как и присвоение значения переменной. Если попытаться использовать переменную после передачи ее в функцию, то будет ошибка.

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s); // значение s перемещается в функцию...
                        // ... и поэтому больше здесь не действует
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}
```

Возвращаемые значения также передают владение.

Выделение и освобождение объектов происходит в порядке, обратном порядку объявления.

## Ссылки и заимствование

Амперсанды `&` являются ссылками, они позволяют ссылаться на некое значение, не беря его во владение.

Синтаксис `&<переменная>` позволяет создать ссылку, которая ссылается на значение переменной `<переменная>`, но не владеет им. Поскольку она не является ее владельцем, значение, на которое ссылка указывает, не будет отброшено, когда ссылка выйдет из области видимости.

Синтаксис `&<тип>` - обозначает ссылочный тип.

```rust
let str = String::from("hello");
let str2: &String = &str;

println!("len {}, {}", str.len(), str2.len());
```

### Изменяемые ссылки

Имеют вид `&mut <переменная>` для переменных и `&mut <тип>` для типа. Могут быть переменные только с модификатор `mut`.

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

Изменяемые ссылки имеют одно существенное ограничение: может быть только одна изменяемая ссылка на отдельный фрагмент данных в отдельной области видимости. Преимущество этого ограничения в том, что Rust предотвращает гонку данных во время компиляции. При выходе изменяемой ссылки за область видимости, можно создать новую изменяемую ссылку.

```rust
let mut s = String::from("hello");
{
    let r1 = &mut s;
}
let r2 = &mut s;
```

Для модификации элемента или доступа к значению по ссылке используется конструкция с помощью разыменовывания `*<ссылка>`:
```rust
let mut v = vec![1, 2, 3];
v[0] = 12;
let link = &mut v[2];
*link = 13;
```

Если есть изменяемая ссылка на структуру, то создать изменяемую ссылку или константную ссылку на ее поле нельзя. Если нет изменяемой ссылки на структуру, то можно создать множесто изменяемых ссылок или константных ссылок на ее поля.

Нельзя создать изменяемую ссылку, если есть уже неизменяемая.

### Правила ссылок

Основные правила ссылок:
- В любой момент времени может быть один из двух вариантов, но не оба: одна изменяемая ссылка либо любое число неизменяемых ссылок.
- Ссылки всегда должны быть действительными, то есть ссылки нельзя передавать на уровень выше, чем было объвление переменной.

Видимость ссылки заканчивается там, где она в последний раз используется.

При передаче владения все ссылки ивалидируется, а также при изменении значения.

Из функций можно возвращать изменяемые и константные ссылки, если они относятся к передаваемой ссылке и при этом относятся к разным частям ее для изменяемых ссылок:
```rust
fn split_user(user: &mut User) -> (&mut String, &mut String) {
    (&mut user.login, &mut user.password)
}
```

Времена жизни должны быть статически проверены во время компиляции, и анализатор заимствований выполняет только очень ограниченный анализ потока управления, поэтому он предполагает, что каждый блок в операторе `if-else` и каждая ветвь выражения `match` могут быть выполнены, а затем выбирает самое короткое из возможных времен жизни для переменной. Как только переменная ограничена временем жизни, она ограничена этим временем жизни навсегда. Время жизни переменной может только сокращаться, и это сокращение полностью определяется на этапе компиляции.

### Заимствование ссылок

Из ссылки `&mut <тип>` можно породить другую ссылку `&mut <тип>` или `&<тип>`, которые заимствуют владение из исходной ссылки и делают оригинальную ссылку временно не действительной на момент заимствования. Если использовать оригинальную ссылку, то все заимствованные ссылки инвалидируются.

`let <ссылка>: &<тип> = &*<изменяемая_ссылка>;` - создает константную ссылку из изменяемой.  
`let <ссылка>: &mut <тип> = &mut *<изменяемая_ссылка>;` - создает изменяемую ссылку из изменяемой.

При этом заимствованная ссылка продлевает время жизни оригинальной ссылки.

### `ref`

Ключевое слово `ref` позволяет делать ссылки на поля структур или кортежей при сопоставлении шаблонов или деструктуризации.

`let <Структура> {ref [mut] <поле>} = <переменная>;` - создает [изменяемую] ссылку на поле структуры.
> `let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;`

`let ref <ссылка> = <переменная>;` - аналогично `let <ссылка> = &<переменная>;`.

### Срезовый тип

Срезы позволяют ссылаться не на всю коллекцию, а на сплошную последовательность элементов в коллекции. **Срезы** - это ссылки на часть и количество. Занимают в памяти два указателя.

Взятие среза "одалживает" всю последовательность.

#### Интервал

`<начальный_индекс>..<конечный_индекс>` - интервальный синтаксис, создает интервал от индекса `<начальный_индекс>` и до `<конечный_индекс>`, но не включая его. Если не указывать `<начальный_индекс>`, то он будет равен `0`. Если не указывать `<конечный_индекс>`, то он будет равен длине. Если перед `<конечный_индекс>` стоит знак `=`, то конечный индекс будет включен.
> `0..=20`

#### Строковые срезы

Это ссылка на часть значения типа `String`. Имеет тип `&str`.

`let <срез> = &<строка>[<интервал>];` - создает срез из строки по интервалу `<интервал>`.

```rust
let s = String::from("hello");
let len = s.len();
let slice: &str = &s[0..len];
let slice = &s[..];
```

**Строковые литералы** - это срезы и являются неизменяемыми, так как `&str` - это неизменяемая ссылка.
> `let s = "Hello, world!";`

#### Другие срезы

Для массивов срезы имеют тип `&[<тип_массива>]` и работают по аналогии со строковыми.

```rust
let arr: [f64; 3] = [0.1, 0.2, 0.3];
let slice: &[f64] = &arr[0..2];
```

Структуры
=========

Структура, или `struct`, - это настраиваемый тип данных, который позволяет именовать и упаковывать вместе несколько связанных значений, составляющих смысловую группу.

Объявление структуры:
```rust
struct <ИмяСтруктуры> {
    <поле1>: <тип>,
    [<поле2>: <тип>,]
    [...]
}
```

```rust
struct User {
    username: String,
    sign_in_count: u64,
    active: bool,
}
```

Создание структуры:
```rust
let <структура> = <ИмяСтруктуры> {
    <поле1>: <значение>,
    [<поле2>: <значение>,]
    [...,]
};
```

```rust
let mut user = User {
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
```

`<структура>.<поле>` - доступ к значению поля. Изменять поля структуры можно только, если весь экземпляр структуры изменяемый, то есть имеет модификатор `mut`.
> `user.username = String::from("noname");`

Если переменные совпадают по имени и типу в структуре, то можно использовать сокращенный синтаксис присвоения значений только по имени переменной в создании структуры.
```rust
fn build_user(username: String) -> User {
    User {
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

Для обновления экземпляра структуры другой подобной структурой используется синтаксис обновления структуры:
```rust
let <структура> = <ИмяСтруктуры> {
    <поле1>: <значение>,
    [<поле2>: <значение>,]
    [...,]
    ..<структура_источник_значений>
};
```

Этот синтаксис указывает на то, что остальные поля, не заданные явно, должны иметь то же значение, что и поля в конкретном экземпляре.

```rust
let user2 = User {
    username: String::from("anotherusername567"),
    ..user1
};
```

## Кортежные структуры

`struct <ИмяСтруктуры>(<тип1>[, <тип2>[, ...]])` - объявление.
> `struct Color(i32, i32, i32);`

`let <структура> = <Имя>(<значение1>[, <значение2>[, ...]]);` - создание.
> `let black = Color(0, 0, 0);`

Можно создать пустые структуры, которые ведут себя аналогично `()`, типу `unit`, пустому типу.

## Методы

Объявляет метод `<метод>` для структуры `<ИмяСтруктуры>`, где `&self` обозначает ссылку на текущий экземпляр структуры, для которого вызывается метод и имеет тип `&<ИмяСтруктуры>`.
```rust
impl <ИмяСтруктуры> {
    fn <метод1>([&[mut]] self[, <аргумент1>: <тип>[, <аргумент2>: <тип>[, ...]]]) [-> <тип_возвращаемого_значения>] {
        // ...
    }
    // ...
}
```

Чтобы была возможность изменять структуру в методе используется вместо параметра `&self` параметр `&mut self`. Для владения используется `self`.

Параметр `self` может типизироваться, как другие параметры, тогда этот синтаксис означает, что метод действителен только при вызове у другого типа содержащем этот тип.
```rust
trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
} // означает, что метод действителен только при вызове у Box содержащем тип.
```

Для вызова метода используется синтаксис:  
`<структура>.<метод1>([<значение1>[, <значение2>[, ...]]]);`

Учитывая получателя и имя метода, Rust может точно определить, что в данном случае делает код: читает ли метод (`&self`), делает ли изменение (`&mut self`) или поглощает (`self`). Rust автоматически добавляет `&`, `&mut` или `*`, таким образом, чтобы `<структура>` соответствовал сигнатуре метода. Это **автоматическое обращение по ссылке и разыменование** (*automatic referencing and dereferencing*).

Это аналогично вызову `(&<структура>).<метод1>([<значение1>[, <значение2>[, ...]]]);`.

Каждая структура может иметь несколько блоков `impl`.

```rust
struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Площадь прямоугольника равна {} квадратным пикселам.", rect1.area());
}
```

## Связанные функции

Это функции, которые объявляются в `impl <ИмяСтруктуры> { ... }`, но не используют параметр `self`, то есть экземпляр структуры.

Вызываются через использования пространства имен структуры, с помощью синтаксиса `::`:  
`<ИмяСтруктуры>::<функция1>([<значение1>[, <значение2>[, ...]]]);`

Внутри связанных функций можно вызывать другие связанные функции с помощью `Self` вместо `<ИмяСтруктуры>`:
> `Self::new()`

```rust
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}

fn main() {
    let sq = Rectangle::square(3);
}
```

Перечисления и сопоставление с паттернами
=========================================

Объявление перечисления:
```rust
enum <ИмяПеречисления> {
    <Вариант1>,
    <Вариант2>(<тип1>[, <тип2>[, ...]]),
    <Вариант3> { <поле1>: <тип>[, ...] },
    [...]
}
```

Где возможны варианты:
- `<Вариант1>` - вариант, который не имеет связанных с ним данных;
- `<Вариант2>` - вариант, который включает в себя анонимную структуру;
- `<Вариант3>` - вариант, который включает в себя значения.

Перечесление имеет тип: `<ИмяПеречисления>`. Для использования конкретных вариантов значений перечесления используется:
- `<ИмяПеречисления>::<Вариант1>`;
- `<ИмяПеречисления>::<Вариант2>(<значение>[, <значение>[, ...]])`;
- `<ИмяПеречисления>::<Вариант1> { <поле1>: <значение>[, ...] }`.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let m: Message = Message::Move { x: 3, y: 4 };
```

Для перечислений можно определять методы с помощью ключевого слова `impl` точно так же, как для структур.

## Инициализаторы

**Инициализатор** - реализован как функция, возвращающая экземпляр, который построен из их аргументов. Использует `()` в качестве синтаксиса, который выглядит как вызов функции. Его можно использовать как указатели на функции, который реализует типаж замыканий, что означает можно указать инициализирующие функции в качестве аргументов для методов, которые принимают замыкания.
```rust
enum Status {
    Value(u32),
    Stop,
}

let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
```

## Выражение `match` как оператор управления потоком

Оно позволяет сравнивать значение с серией паттернов, а затем исполнять код, основываясь на том, какой паттерн совпадает. Паттерны могут состоять из буквенных значений, имен переменных, подстановочных знаков и других элементов.

```rust
match <переменная> {
    <ИмяПеречисления>::<Вариант1> => <код>,
    <ИмяПеречисления>::<Вариант2>(<переменная_кортежа1>[, <переменная_кортежа2>[, ...]]) => <код>,
    <ИмяПеречисления>::<Вариант3>{ <поле_структуры1>[, ...] } => <код>,
    _ => <код>,
}
```

Если `<код>` заключен в `{` и `}`, то `,` после скобок не ставится.

Когда выражение `match` исполняется, оно по порядку сравнивает полученное значение с паттерном каждого рукава. Если паттерн совпадает со значением, то код, связанный с этим паттерном, исполняется. Если этот паттерн не совпадает со значением, то исполнение продолжается и переходит к следующему рукаву.

Количество рукавов должно охватывать все варианты перечисления, если не охватывает, то нужно добавить вариант `_` - заполнитель, который используется как заглушка для всех остальных вариантов. Если вообще не нужно никак обрабатывать, то используется код: `_ => ()`.

```rust
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("Четвертак из штата {:?}!", state);
            25
        },
    }
}
```

## Сжатое управление потоком с помощью `if let`

Синтаксис `if let` позволяет кратко совместить `if` и `let` для обработки значений, которые совпадают с одним паттерном, игнорируя остальные.

```rust
if let <ИмяПеречисления>::<Вариант> = <переменная> {
    // код совпадения
}[ else {
    // код ложности
}]
```

```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("Четвертак из штата {:?}!", state);
} else {
    count += 1;
}
```

## Перечисление `Option`

Используется для ситуаций, когда нет значения, как в других языках `null`. Имеет вид:
```rust
enum Option<T> {
    Some(T),
    None,
}
```

Где:
- `Some(T)` - есть значение;
- `None` - нет значения.

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

`let <value>: Option<T> = <option>.take();` - возвращает `Option` со значением, если оно есть в виде `Some`, а иначе `None` и на своем месте оставляет `None`.  
`let <value>: Option<&T> = <option>.as_ref();` - возвращает `Option` с ссылкой на значение, если оно есть в виде `Some`, а иначе `None`.  
`let <value>: Option<&mut T> = <option>.as_mut();` - возвращает `Option` с изменяемой ссылкой на значение, если оно есть в виде `Some`, а иначе `None`.

`let <переменная>: Result<T, E> = <option>.ok_or(<ошибка>);` - преобразует `Option` в `Result` и возвращает его, в случае `Some` будет `Ok` иначе если равно варианту `None`, то будет `Err` с переданной ошибкой.

Шаблоны
=======

Это специальный синтаксис в Rust для сопоставления со структурой типов, как сложных, так и простых.

Шаблоны деляться на два вида:
- **исчерпывающие** (*exhaustive*) - они должны учитывать все возможности для значения;
- **неисчерпывающие** (*unexhaustive*) - они должны учитывать некоторые значения.

Шаблоны бывают двух форм:
- **опровержимые** - это шаблоны, которые могут не соответствовать некоторому возможному значению:
> `if let Some(x) = a_value`
- **неопровержимые** - это шаблоны, которые будут соответствовать любому возможному переданному значению.
> `let v = 5;`

Параметры функций, операторы `let` и `for` могут принимать только неопровержимые шаблоны, поскольку программа не может сделать ничего значимого, если значения не совпадают. А выражения `if let` и `while let` принимают опровержимые и неопровержимые шаблоны.

Основной вид:
```rust
match <значение> {
    <шаблон1> => <выражение>,
    <шаблон2> => <выражение>,
}
```
```rust
if let <шаблон> = <значение> {
    /* ... */
}
```
```rust
let <шаблон> = <значение>;
```
```rust
while let <шаблон> = <значение> {
    /* ... */
}
```
```rust
for <шаблон> in <значение> {
    /* ... */
}
```
```rust
fn <функция>(<шаблон1>: <тип>) {
    /* ... */
}
```
```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}
```

Игнорирование значений:
- для одного значения шаблон `_` будет соответствовать чему угодно, но он никогда не привязывается к переменной. Могут повторяться.
    > `Some(_)`
- для оставшейся части значений кортежа (в начале или в конце) или структуры шаблон `..` - игнорирует любые части значения, которые явно нельзя сопоставить с остальной частью шаблона.
    > `Point { x, .. }`

**Именованные переменные** - это неопровержимые шаблоны, которые соответствуют любому значению.

В шаблонах опровержимых шаблонах можно использовать синтаксис `|`, что означает логическое **или**, для перечисления возможных значений.
> `if let Some(2 | 3) = a_value { /* ... */}`

Также можно использовать диапазоны для целых чисел и типа `char` с помощью синтаксиса:
- `<от>..=<до_включая>` - от зачения `<от>` и до значения `<до_включая>`, включая его;
- `<от>..<до>` - от зачения `<от>` и до значения `<до>`, не включая его;
> `1..=5` = `1 | 2 | 3 | 4 | 5`  
> `'a'..='j'`

Конструкция **match guard** является дополнительным условием `if`, указанным после шаблона в ветке `match`, которое также должно выполняться наряду с сопоставлением образца, чтобы ветка была выбрана. Условия сопоставления полезны для выражения более сложных идей, чем позволяет только шаблон. По аналогии с *и*.
> `Some(x) if x < 5 => println!("less than five: {}", x),`

Оператор **at** (`@`) для ветки `match` позволяет создать переменную, которая содержит значение, которое мы одновременно сравниваем со значением, соответствует ли оно шаблону. Использование `@` позволяет проверять значение и сохранять его в переменной в пределах одного шаблона.  
`<переменная> @`
```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello {
        id: id_variable @ 3..=7,
    } => println!("Found an id in range: {}", id_variable),
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    }
    Message::Hello { id } => println!("Found some other id: {}", id),
}
```

## Макрос `matches!`

Используется для сопоставления с шаблоном в произвольном месте: `matches!(<значение>, <шаблон>)` - возвращает `true` при совпадении, иначе `false`.
> `matches!(str.to_lowercase().as_str(), "russia" | "ru")`

## Ссылки

Если сопостовляется с шаблоном ссылка, то для совпадения с шаблоном она должна сопостовляться с ссылкой:
```rust
let reference = &4;

match reference {
    &val => println!("Got a value via destructuring: {:?}", val),
}
```

Если нужно не захватывать значение для сопостовления, а использовать его по ссылке, то используется конструкция `ref [mut]` перед шаблоном:
```rust
let mut mut_value = 6;

match mut_value {
    ref mut m => {
        *m += 10;
        println!("We added 10. `mut_value`: {:?}", m);
    },
}
```

По умолчанию `match` пытается захватить переданное значение во владение.

## Деструктуризация для получения значений

С помощью шаблонов можно извлекать части из значений. Можно смешивать, сопоставлять и вкладывать шаблоны деструктуризации друг в друга.
> `let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });`

### Кортежи

`(<переменная_кортежа1>[, <переменная_кортежа2>[, ...]]) = <значение>`
> `let (x, y, z) = (1, 2, 3);`

### Структуры

`<Структура>{ <поле1>[: <новое_имя>][, ...] } = <значение>`. Если необходимо новое имя переменной для вложеного поля, то используется для него новое имя.
```rust
let p = Point { x: 0, y: 7 };
let Point { x: a, y: b } = p;
```

### Перечисления

Для перечисления используется в зависимости от типа:
- `<Перечисление>::<Вариант1> = <значение>`;
- `<ИмяПеречисления>::<Вариант2>(<переменная_кортежа1>[, <переменная_кортежа2>[, ...]])`;
- `<ИмяПеречисления>::<Вариант3>{ <поле_структуры1>[, ...] }`.

```rust
let msg = Message::ChangeColor(0, 160, 255);

match msg {
    Message::Quit => {/* ... */}
    Message::Move { x, y } => {/* ... */}
    Message::Write(text) => {/* ... */}
    Message::ChangeColor(r, g, b) => {/* ... */}
}
```

Управление проектами
====================

## Пакеты и упаковки

**Упаковка** (crate) - это двоичный или библиотечный файл.

**Корень упаковки** (crate root) - это исходный файл, с которого компилятор Rust начинает работу, он составляет корневой модуль упаковки.

**Пакет** - это одна или несколько упаковок, которые обеспечивают функциональность. Пакет содержит файл `Cargo.toml`, который описывает то, как создавать эти упаковки.

Пакет должен включать ноль или одну библиотечную упаковку, но не более. Он может содержать столько двоичных упаковок, сколько нужно, но в нем должна быть по крайней мере одна упаковка (библиотечная либо двоичная).

**Cargo** следует соглашению о том, что `src/main.rs` является упаковочным корнем двоичной упаковки с тем же именем, что и пакет.

**Cargo** знает, что если каталог пакета содержит `src/lib.rs`, то указанный пакет содержит библиотечную упаковку с тем же именем, что и пакет, а `src/lib.rs` является его упаковочным корнем. Cargo передает файлы корня упаковки в `rustc` для построения библиотеки или двоичного файла.

Если в пакете есть `src/main.rs` и `src/lib.rs`, то он имеет две упаковки: библиотечную и двоичную - обе с тем же именем, что и пакет. Пакет может иметь несколько двоичных упаковок, помещая файлы в каталог `src/bin`: каждый файл будет отдельной двоичной упаковкой.

Упаковка будет группировать связанную функциональность в область видимости, вследствие чего эту функциональность можно легко использовать совместно в нескольких проектах.

## Структура проекта

В файле `src/lib.rs` должна находиться вся основная логика проекта. В файле `src/main.rs` должен использоваться файл `src/lib.rs` и из него конструироваться все окружения, а также инициализация приложения.

## Модули и `use`

Позволяют управлять организацией, областью видимости и приватностью путей.

Модули позволяют организовывать код внутри упаковки в группы для удобства чтения и многоразового использования. Модули также контролируют конфиденциальность элементов, которая заключается в том, может ли элемент использоваться внешним кодом (публичный) или же он является деталью внутренней реализации и не доступен для внешнего использования (конфиденциальный).

Определение модуля:
```rust
mod <имя_модуля> {
    // содержимое
}
```

Внутри модулей могут быть другие модули. Модули также могут содержать определения других элементов, таких как структуры, перечисления, константы, типажи или функции.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
        fn seat_at_table() {}
    }
}
```

Главный модуль - это модуль с именем `crate` ("упаковка").
```
crate
└── front_of_house
    └── hosting
        ├── add_to_waitlist
        └── seat_at_table
```

Путь принимает две формы:
- **Абсолютный путь** начинается с корня упаковки, используя имя упаковки либо литерал `crate` - для файловой системы аналогично `/`;
- **Относительный путь** начинается с текущего модуля и использует `self`, `super` - для файловой системы аналогично `..` или идентификатор в текущем модуле.

Как асолютные, так и относительные пути сопровождаются одним или несколькими идентификаторами, разделенными двойными двоеточиями `::`.

```rust
fn main() {
    // Абсолютный путь
    crate::front_of_house::hosting::add_to_waitlist();
    // Относительный путь
    front_of_house::hosting::add_to_waitlist();
}
```

Элементы в родительском модуле не могут использовать конфиденциальные элементы внутри дочерних модулей, но элементы дочерних модулей могут использовать элементы в своих предковых модулях. Причина этого заключается в том, что дочерние модули обертывают и скрывают детали своей реализации, но они видят контекст, в котором определены.

Добавление ключевого слова `pub` перед сущностью (модулем, функцией, структурой и т.п.) делает модуль публичным.

Если использовать pub перед определением структуры, то это сделает структуру публичной, но поля структуры все равно будут **конфиденциальными**. Можно сделать каждое поле публичным на индивидуальной основе добавив `pub` перед свойством.

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("персики"),
            }
        }
    }
}
```

Если у публичной структуры есть приватное поле, то должен быть публичная связанная функция, которая конструирует экземпляр структуры.

Если у перечисления стоит модификатор `pub`, то все его варианты будут публичными.

Если что-то определено на одном уровне с модулем, то оно может использовать модуль, даже в том случае, если он не публичный.

`use <имя_модуля>[::<имя_подмодуля>[::...]] [as <алиас>];` - вводит модуль[ или его подструктуры] в область видимости [под указанным алиасом `<алиас>`]. Подобно символической ссылке.
> `use crate::front_of_house::hosting as host;`

Указание относительного пути с помощью `use` начинается с префикса `self`.
> `use self::front_of_house::hosting;`

Добавление `pub` к `use` осуществляет **реэкспорт** указаного модуля наружу.

Идиоматически функции вводятся как часть модуля, где определены, а другие структуры самостоятельно.

Для множественного ввода элементов модуля используется структура:  
`use <имя_модуля>[::<имя_подмодуля>[::...]]::{[self, ]<имя_подмодуля_или_структуры1>[, ...]};` - таким образом будут введены подмодули или структуры [и сам модуль, благодаря ключевому слову `self`].

`use <имя_модуля>[::<имя_подмодуля>[::...]]::*` - вводит все элемены подмодуля в видимость.

Ключевое слово `mod` объявляет модули, и Rust ищет в файле с тем же именем, что и модуль, код, который входит в этот модуль.

`mod <имя_модуля>;` - сообщает языку Rust о том, что нужно загрузить содержимое модуля из другого файла с тем же именем, что и модуль. И тогда можно использовать ввод элементов модуля с помощью `use`:
```rust
mod <имя_модуля>;
use <имя_модуля>[::<имя_подмодуля>[::...]];
```

Внутри модуля конструкция `use super::*;` позволяет ввести в него код из внешнего модуля.

Общие коллекции
===============

В отличие от встроенных массивного и кортежного типов, данные, на которые указывают эти коллекции, хранятся в куче, то есть необходимости знать объем данных во время компиляции нет, и они увеличиваются или уменьшаются в ходе выполнения программы. Каждый вид коллекции имеет разные возможности и затраты.

## Векторы `Vec<T>`

Векторы позволяют хранить более одного значения одного и того же типа в одной структуре данных, которая помещает все значения рядом в памяти.

`let mut <вектор>: Vec<<тип>> = Vec::new();` - создание вектора, с хранением значений определенного типа.  
`let mut <вектор> = vec![<значение1>[, ...]];` - создание вектора через макрокоманду.  
`let mut <вектор> = vec![<значение>; <количество>];` - создание вектора через макрокоманду с указанным количеством элементов по аналогии с массивом.

`<вектор>.len();` - возвращает длину вектора.

`<вектор>.push(<значение>);` - добавляет значение в вектор.
`<вектор>.insert(<индекс>, <значение>);` - добавляет значение в вектор по указанной позиции, а остальные элементы сдвигает вправо, `<индекс>` должен быть в интервале от 0 и до длины вектора, если он равен ей, то добавляет его в конец.

Как и любая другая структура, вектор высвобождается, когда он выходит из области видимости. Когда вектор отбрасывается, все его содержимое тоже отбрасывается, то есть те значения, которые он содержит, будут очищены.

`let <переменная>: &<тип> = &<вектор>[<индекс>];` - доступ к элементу вектора по индексу `<индекс>`, возвращает ссылку на элемент типа `&<тип>`. При вызове недоступного индекса будет произведена паника.

`let <переменная>: Option<&<тип>> = <вектор>.get(<индекс>);` - доступ к элементу вектора через метод, возвращает его в типе `Option<&<тип>>`.

`let <переменная>: <тип> = <вектор>.remove(<индекс>);` - удаляет элемент по индексу и возвращает его, а остальные элементы сдвигает влево, если индекс выходит за границы, то паникует.  
`let <переменная>: <тип> = <вектор>.swap_remove(<индекс>);` - удаляет элемент по индексу и возвращает его, при этом на его место ставит последний элемент в векторе, если индекс выходит за границы, то паникует.

`let <переменная>: Option<&<тип>> = <вектор>.pop();` - выталкивает из вектора последний элемент и возвращает его в типе `Option<&<тип>>`.

`let <переменная>: boolean = <вектор>.contains(&<значение>);` - возвращает `true`, если вектор содержит значение.

Если у вектора взят первый элемент, то его уже модифицировать нельзя.

Для перебора используется конструкция:
```rust
for <переменная> in &[mut ]<вектор> {
    // код
}
```
Где в переменную `<переменная>` будут последовательно помещаться значения из вектора.

## Строковый тип `String`

Строки реализованы как коллекция байтов, плюс некоторые методы обеспечивают полезную функциональность, когда эти байты интерпретируются как текст.

Тип `String` представляет собой обертку для `Vec<u8>`.

Строковые литералы `"<текст>"` типа `&str`, хранятся в двоичном коде программы и поэтому являются строковыми срезами.
> `let s: &str = "Hello, world!";`

`let <строка> = String::new();` - создание строки.  
`let <строка> = String::from(["<текст>"]);` - создание строки [с указанным текстом из строкового литерала].  
`let <строка> = String::from_utf8_lossy(<байтовый_срез>[..]);` - создание строки из байтового среза типа `&[u8]` в UTF-8 при этом конвертирую недопустимые последовательности в символ `�`, символ замены **U+FFFD** **REPLACEMENT CHARACTER**.  
`let <maybe_string>: Result<&str, Utf8Error> = std::str::from_utf8(<байтовый_срез>[..]);` - создание строки из байтового среза типа `&[u8]` если это допустимая последовательность UTF-8, иначе будет ошибкой.

`let <строка> = <строковый_литерал>.to_string();` - преобразует строковый литерал в строку.

`let <строка2> = <строка>.clone();` - копирует строку.

`let <slice>: &str = <строка>.as_str();` - возвращает строку в виде среза.

`<строка>.len();` - возвращает длину строки в байтах.

`<строка>.clear();` - очищает строку.

`let <slice>: &[u8] = <строка>.as_bytes();` - возвращает срез типа `&[u8]`, из содержимого строки.  
`let <slice>: &[u8] = b"<текст>";` - аналогичное действие.

`let <slice>: &str = r"<текст>";` - необработанный строковый литерал, в котором не обрабатываются escape-символы.

`let <maybe_slice>: Option<&str> = <строка>.get(<диапазон>);` - возвращает подстроку указанную в диапазоне если возможно, иначе `None`.  

`<строка>.to_lowercase();` - возвращает строку, в которой символы преобразованы к нижнему регистру.

`<строка>.contains(<строка2>);` - возвращает `true` если строка содержит переданную строку.

`<строка>.push_str("<текст>");` - добавляет текст к строке.  
`<строка>.push('<символ>');` - добавляет символ к строке.  
`<строка>.insert_str(<индекс>, "<текст>");` - вставляет текст в строку в указанной позиции и при этом смещая остальные символы.  
`<строка>.insert(<индекс>, '<символ>');` - вставляет символ в строку в указанной позиции и при этом смещая остальные символы.  
`let <новая_строка> = <строка1> + &<строка2>;` - возвращает строку из двух строк, при этом берет `<строка1>` во владение и ее возвращает.  
`let <строка> = format!("<шаблон>", <строка1>[, ...]);` - макрокоманда, которая возвращает строку, которая отформатирована по аналогии с командой `print!`.

Для перебора используется итераторы, которые можно перебрать в `for`:
- `<строка>.chars();` - возвращает итератор из символов типа `char`, каждый из которых равен 4 байта;
- `<строка>.bytes();` - возвращает итератор из байтов строки типа `u8`, каждый из которых равен 1 байт.
- `<строка>.split_whitespace();` - возвращает итератор из слов разбитых по пробелам.
- `<строка>.split("<разделитель>");` - возвращает итератор из подстрок разбитых по указанному символу.
- `<строка>.lines();` - возвращает итератор из строк разбитых по знакам переноса строк.

```rust
for c in "Здравствуйте".chars() {
    println!("{}", c);
}
```

`let <maybe_number>: Result<<тип>, std::num::ParseFloatError> = <строка>.parse::<<тип>>();` - пытается привести строку к указанному типу, если удается то возвращает его иначе возвращает ошибку.

Обработка ошибок
================

## Макрокоманда `panic!`

`panic!("<текст>");` - используется в случае неустранимой ошибки, она напечатает сообщение об ошибке, размотает и очистит стек, а затем завершит работу программы.

**Обратная трассировка** - это список всех функций, которые были вызваны, чтобы добраться до этой точки.

## Устранимые ошибки `Result`

Используется для ситуаций, когда есть ошибка, которую можно обработать. Имеет вид:
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Где:
- `Ok(T)` - есть результат;
- `Err(E)` - ошибка.

Если результат не важен, то он может иметь тип `()`: `Result<(), E>`.

Для обработки используется конструкция `match` или `if let`.
```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("Проблема с открытием файла: {:?}", error)
        },
    };
}
```

### Методы

`<result>.is_err();` - возвращает `true`, если это ошибка.

`let <переменная>: Option<T> = <result>.ok();` - преобразует `Result` в `Option` и возвращает его, в случае `Ok` будет `Some` иначе если равно варианту `Err`, то будет `None`.

`let <переменная>: Result<T, F> = <result>.map_err(|<ошибка>| { /* ... */});` - преобразует ошибку `Result` в другую с помощью `FnOnce(E) -> F` и возвращает ее.

### Общие методы `Result` и `Option`

Эти методы существуют у обоих перечислений. Они просто называются одинаково, без общего предка.

`let <переменная>: T = <result>.unwrap();` - является сокращенным вариантом `match`, если значение `Result` / `Option` является вариантом `Ok` / `Some`, то вернет значение внутри `Ok` / `Some` инача если равно варианту `Err` / `None`, то вызовет макрокоманду `panic!`.  
`let <переменная>: T = <result>.unwrap_or(<значение_по_умолчанию>);` - аналогично методу `unwrap`, только при варианте `Err` / `None` вернет значение по умолчанию `<значение_по_умолчанию>`.
`let <переменная>: T = <result>.unwrap_or_default();` - аналогично методу `unwrap`, только при варианте `Err` / `None` вернет значение по умолчанию для типа.

`let <переменная>: T = <result>.expect("<текст>");` - аналогично методу `unwrap`, только вызовет `panic!` с текстом `<текст>`.

`<result>.and_then(|<значение>| { /* ... */});` - если значение является `Ok` / `Some`, то вызывает замыкание типа `FnOnce(T)` в который передается значение внутри `Ok` / `Some` иначе вернет `Err` / `None`;

### Прокидывание ошибок на уровень выше

Для этого используется возвращение из функции типа `Result` и возвращения значения `Err`.
```rust
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");
    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
    let mut s = String::new();
    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```

#### Краткая форма распространения ошибок - оператор `?`

Оператор `?` может использоваться только в функциях, которые имеют возвращаемый тип `Result`. Для функции `main` можно сделать возвращаемый тип: `Result<(), Box<dyn Error>>`.

`let <переменная> = <result>?;` - является сокращенной записью для:
```rust
let <переменная> = match <result> {
    Ok(value) => value,
    Err(e) => return Err(e),
}
```

```rust
use std::io;
use std::io::Read;
use std::fs::File;
fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();
    File::open("hello.txt")?.read_to_string(&mut s)?;
    Ok(s)
}
```

Также оператор `?` пытается преобразовать ошибки к типу ошибки указанной в сигнатуре функции типа `Result`.

Обобщения
=========

Используются для того чтобы обобщить некоторые параметры функций, структур, перечислений и т.п. На этапе компиляции, все обобщенные типы становятся конкретными, путем *мономорфизациии* - это процесс превращения обобщенного кода в конкретный путем вставки конкретных типов, которые используются во время компиляции.

`fn <имя><T[, ...]>(<аргумент1>: T[, ...]) -> T { /* ... */}` - объявляет функцию, которая обобщена типом `T`, который будет использоваться в качестве конктретного типа, когда функция будет использоваться.

```rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }
    largest
}
```

Объявление обобщенной структуры:
```rust
struct <ИмяСтруктуры><T[, ...]> {
    <поле1>: T,
    [<поле2>: <тип>,]
    [...]
}
```

```rust
struct Point<T, U> {
    x: T,
    y: U,
}
```

Для инициализации структуры определенной обобщенным типом используется:
```rust
let <переменная> = <ИмяСтруктуры><T[, ...]> {
    <поле1>: <значение>,
    [<поле2>: <значение>,]
    [...]
};
```

```rust
let point = Point<usize, u16> {
    x: 0,
    y: 100,
};
```

Обощенные методы:
```rust
impl<T[, ...]> <ИмяСтруктуры><T[, ...]> {
    fn <метод1>(&[mut] self[, <аргумент1>: T[, <аргумент2>: <тип>[, ...]]]) [-> T] {
        // ...
    }
    // ...
}
```

После ключевого слова `impl` `T` обозначает, что в результате можно использовать этот тип для уточнения, что реализуется методы в типе `<ИмяСтруктуры><T>`.

```rust
impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}
```

Связанный обобщенный метод может вызываться в виде: `<ИмяСтруктуры>::<<тип>>::<метод1>(...)`:
> `Vec::<u32>::new()`

Можно реализовывать методы, только для конкретных типов, когда вместо типа `T` пишется конкретный тип для структуры.

```rust
impl Point<f32, f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```
Это обозначает, что только тип `Point<f32, f32>` имеет метод `distance_from_origin`, а другие типы, которые не относятся к этому типу не имеют его.

## Параметры типа по умолчанию

У обобщений может быть значение по умолчанию, которое задается через `=` после его определения: `T = <Тип>`, где тип `Self` - это тип структуры, которая реализует типаж:
> `trait Add<Rhs = Self> { /* ... */ }`

Используются в двух основных случаях:
- чтобы расширить тип без внесения изменений ломающих существующий код;
- чтобы позволить пользовательское поведение в специальных случаях, которые не нужны большинству пользователей.

Значения по умолчанию можно переопределить.

Типажи `trait`
==============

Используются для определения совместного поведения в абстрактном виде. По принципу похоже на интерфейсы. Определения типажей являются способом группирования вместе сигнатур методов с целью описания множества поведений, необходимых для достижения некой цели.
```rust
trait <ИмяТипажа> {
    fn <метод1>(&[mut] self[, <аргумент1>: <тип>[, <аргумент2>: <тип>[, ...]]]) [-> <тип>];
    // ...
}
```

Некоторые методы могут иметь реализацию по умолчанию. В этом методе можно использовать другие методы из этого типажа, даже которые еще не реализованые. Нет возможности вызывать реализацию по умолчанию из реализации этого же метода. Этот метод можно не переопределять в реализаторе типажа.

Для реализации типажа используется:
```rust
impl <ИмяТипажа> for <ИмяСтруктуры> {
    fn <метод1>(&[mut] self[, <аргумент1>: <тип>[, <аргумент2>: <тип>[, ...]]]) [-> <тип>] {
        // реализация метода
    }
    // ...
}
```

Можно делать реализацию для всех типов `<тип>`, которые удолетворяют определенному типажу `<ИмяТипажа1>` указанный типаж `<ИмяТипажа>`:
```rust
impl<<тип>: <ИмяТипажа1>> <ИмяТипажа> for <тип> {
    fn <метод1>(&[mut] self[, <аргумент1>: <тип>[, <аргумент2>: <тип>[, ...]]]) [-> <тип>] {
        // реализация метода
    }
    // ...
}
```

У каждого типа, реализующего типаж, должно быть собственное индивидуальное поведение для тела каждого метода с идентичной сигнатурой его в типаже.

После реализации типажа можно вызывать методы для экземпляров типа `<ИмяСтруктуры>` таким же образом, как вызываются обычные методы.

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}
impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

При реализации типажей есть одно ограничение - можно реализовать типаж в типе только в том случае, если либо типаж, либо тип являются локальными для упаковки. Это правило обеспечивает, чтобы код других людей не мог нарушать ваш код, и наоборот. Без этого правила две упаковки могли бы реализовать один и тот же типаж в одном и том же типе, и язык Rust не знал бы, какую реализацию использовать.

Для использования типажа в качестве параметра функции или ее результата используется конструкция вместо типа: `impl <ИмяТипажа>` - это обозначает, что передаваться могут все значения, которые реализуют указанный типаж:  
`fn <имя>(<аргумент1>: impl <ИмяТипажа>[, ...]) -> <тип_возвращаемого_значения> { /* ... */}`
```rust
fn notify(item: impl Summary) {
    println!("Срочные новости! {}", item.summarize());
}
```

Это в свою очередь является аналогом ограничения обобщения типажом:
`fn <имя><T: <ИмяТипажа>[, ...]>(<аргумент1>: T[, ...]) -> <тип_возвращаемого_значения> { /* ... */}`
```rust
fn notify<T: Summary>(item: T) {
    println!("Срочные новости! {}", item.summarize());
}
```

Если необходимо ограничить функцию несколькими типажами, то используется конструкция для типа `impl <ИмяТипажа1> + <ИмяТипажа2>[ + ...]` или для обобщения `<ИмяТипажа1> + <ИмяТипажа2>[ + ...]`.
> `fn notify(item: impl Summary + Display) { /* ... */ }`  
> `fn notify<T: Summary + Display>(item: T) { /* ... */ }`

Для улучшенной читаемости обобщений типажами используется конструкция `where` после сигнатуры функции с уточнением обобщений типажами:
```rust
fn <имя><T[, ...]>(<аргумент1>: T[, ...]) -> <тип_возвращаемого_значения>
    where T: <ИмяТипажа>[ + ...]
{ /* ... */}
```

```rust
fn some_function<T, U>(t: T, u: U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{ /* ... */}
```

С помощью `where` можно накладывать ограничения на ассоциированные типы:  
`where T::<Тип>: <ИмяТипажа>[ + ...]`

Можно использовать синтаксис `impl <ИмяТипажа>` в позиции `return` для возвращения значения некоего типа, реализующего типаж в функциях:  
`fn <имя>() -> impl <ИмяТипажа> { /* ... */}`

```rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("конечно, как вы, наверное, уже знаете, люди"),
        reply: false,
        retweet: false,
    }
}
```

Для того чтобы использовать методы типажа, для какой-то структуры, которая его реализует, то он должен быть явно импортирован.
> `use std::io::Read;`

Ограничение в виде `?Sized` указывает что размер типа не может быть вычислен.
> `where T: Read + ?Sized`

## Типажи-объекты

Указывает как на экземпляр типа, реализующего указанный типаж, так и на внутреннюю таблицу, используемую для поиска методов типажа указанного типа во время выполнения. Использует **динамическую диспетчеризацию**, когда компилятор генерирует код, который во время выполнения определяет, какой метод необходимо вызывать.

Используются типажы-объекты вместо универсального или конкретного типа. Так как **обобщенный параметр типа** может быть заменен только одним конкретным типом, тогда как типаж-объекты позволяют нескольким конкретным типам замещать типаж-объект во время выполнения.

Похожи на концепцию *duck typing*.

Только **объектно-безопасные** типажи можно превратить в типаж-объекты. Это те типажи, которые удолетворяют условиям:
- Тип возвращаемого значения не является `Self`. Если метод типажа возвращает тип `Self`, но типаж-объект забывает чем является этот точный тип `Self`, то у метода нет возможности использовать исходный точный тип.
- Нет обобщенных параметров типа.

Синтаксис: `Box<dyn <Тип>>`, `&dyn <Тип>`, `&mut dyn <Тип>`.
> `let components: Vec<Box<dyn Draw>>;`  
> `let component: &dyn Rule = &forwarding_rule;`

```rust
pub trait Draw {
    fn draw(&self);
}

pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}

impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

## Ассоциированные типы

**Ассоциированные типы** (Associated types) связывают заполнитель типа с типажом, таким образом что объявления методов типажа могут использовать эти заполнители типов в своих сигнатурах. Реализация типажа будет указывать конкретный, используемый тип на месте заполнителя типа, при конкретной реализации.

Он определяется внутри `trait`: `type <Тип>;` и может использоваться в определении сигнатуры методов как `Self::<Тип>`.
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

При реализации типажа для структуры, он должен быть объявлен конкретным типом: `type <Тип> = <Тип>;`
```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {/* ... */}
}
```

## Вызов методов с одинаковым именем у разных типажей

При реализации множества типажей, у структуры могут возникнуть методы с одинаковыми именами. Для того чтобы вызвать конкретный метод типажа используется конструкции:
- `<Типаж>::<метод>(<структура>[, <значение1>[, ...]]);` - для методов, которые используют `self`:
    > `Wizard::fly(&person);`
- `<<Структура> as <Типаж>>::<метод>([, <значение1>[, ...]]);` - общий вызов, а также для связанных методов:
    > `<Dog as Animal>::baby_name()`

По умолчанию вызывается метод самой структуры, если он есть.

## Ограничение типажа

Используется когда необходимо чтобы один типаж мог реализовываться на структуре, только когда она реализует другой типаж. То есть у типажа есть *супер типаж*.

`trait <Типаж>: <СуперТипаж>[ + <СуперТипаж2> [+ ...]] {/* ... */}` - позволяет реализовывать типаж `<Типаж>` только тем структурам, которые реализовали типаж `<СуперТипаж>` [и типаж `<СуперТипаж2>` [и ...]].
> `trait OutlinePrint: fmt::Display {/* ... */}`

## Шаблон **Newtype**

**Шаблон нового типа** (newtype pattern) - включает в себя создание нового типа в кортежной структуре. Для того чтобы можно было добавлять методы или реализовывать типажы в структуры, которые не локальные для упаковки.

`struct <Newtype>(<Структура>);`

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}
```

Недостатком использования этой техники является то, что `<Newtype>` является новым типом, поэтому он не имеет методов для значения, которое он держит в себе. Это можно обойти реализуя типаж `Deref` для доступа по ссылке или переопределяя необходимые методы.

## Псевдонимы типов

Используются для того чтобы делать синонимы для сложных типов: `type <Тип> = <Тип>;`
> `type Thunk = Box<dyn Fn() + Send + 'static>;`

## Стандартные типажи

### `Clone`

Используется для полноценного клонирования объектов, реализует у структур метод `clone()`.

```rust
#[derive(Clone)]
struct <Структура> {
    // ...
}
```

Реализация этого метода позволяет использовать:
- `<структура>.clone()` - возвращает копию `<структура>`.

Изначально есть у:
- элементарных типов;
- кортежей состоящих из элементов Clone-типов;
- массивов состоящих из элементов Clone-типов;
- `Vec`, `String`, `HashMap` и подобных.

### `Copy`

Используется для тривиального копирования (memcpy). Его можно реализовать любым типам, у которых нет деструкторов.

Изначально есть у:
- элементарных типов;
- кортежей состоящих из элементов Copy-типов;
- массивов состоящих из элементов Copy-типов.

```rust
#[derive(Clone, Copy)]
struct <Структура> {
    // ...
}
```

### `PartialEq`

Используется для частичного сравнения значений. Так как некоторые значения не могут быть равны сами себе (как NaN).

```rust
pub trait PartialEq<Rhs = Self>
where
    Rhs: ?Sized,
{
    fn eq(&self, other: &Rhs) -> bool;
    fn ne(&self, other: &Rhs) -> bool { ... }
}
```

Метод `eq` должен возвращать значение `true` когда значения равны.

Метод `ne` автоматически реализуется на основании `eq`.

Реализация этих методов позволяет использовать:
- `<x>.eq(<y>)` - `<x> == <y>`;
- `<x>.ne(<y>)` - `<x> != <y>`.

Можно реализовать с помощью для структур и перечислений, в этом случае будут сравниваться все поля:
```rust
#[derive(PartialEq)]
struct <Структура> {
    // ...
}
```

### `Eq`

Используется для полного сравнения значений, что позволяет делать транзитивные сравнения.

```rust
pub trait Eq: PartialEq<Self> { }
```

Можно реализовать с помощью для структур и перечислений, в этом случае будут сравниваться все поля:
```rust
#[derive(PartialEq, Eq)]
struct <Структура> {
    // ...
}
```

### `PartialOrd`

Используется для частичного сравнения значений, больше, меньше или равно - порядка. Так как некоторые значения не могут быть равны сами себе (как NaN).

```rust
pub trait PartialOrd<Rhs = Self>: PartialEq<Rhs> 
where
    Rhs: ?Sized,
{
    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

    fn lt(&self, other: &Rhs) -> bool { ... }
    fn le(&self, other: &Rhs) -> bool { ... }
    fn gt(&self, other: &Rhs) -> bool { ... }
    fn ge(&self, other: &Rhs) -> bool { ... }
}
```

Перечисление `std::cmp::Ordering` используется для сравнения и состоит из:
```rust
enum Ordering {
    Equal,
    Less,
    Greater,
}
```

Метод `partial_cmp` должен возвращать значения:
- `Some(Equal)` - когда `self` равен `other`;
- `Some(Less)` - когда `self` меньше `other`;
- `Some(Greater)` - когда `self` больше `other`;
- `None` - когда `self` не равен `other`.

Методы `lt`, `le`, `gt`, `ge` автоматически реализуется на основании `partial_cmp`.

Реализация этих методов позволяет использовать:
- `<x>.lt(<y>)` - `<x> < <y>`;
- `<x>.le(<y>)` - `<x> <= <y>`;
- `<x>.gt(<y>)` - `<x> > <y>`;
- `<x>.ge(<y>)` - `<x> >= <y>`.

Можно реализовать с помощью для структур и перечислений, в этом случае будут сравниваться все поля в порядке объявления:
```rust
#[derive(PartialEq, PartialOrd)]
struct <Структура> {
    // ...
}
```

### `Ord`

Используется для полного сравнения значений, больше, меньше или равно - порядка.

```rust
pub trait Ord: Eq + PartialOrd<Self> {
    fn cmp(&self, other: &Self) -> Ordering;

    fn max(self, other: Self) -> Self { ... }
    fn min(self, other: Self) -> Self { ... }
    fn clamp(self, min: Self, max: Self) -> Self { ... }
}
```

Метод `cmp` должен возвращать значения:
- `Equal` - когда `self` равен `other`;
- `Less` - когда `self` меньше `other`;
- `Greater` - когда `self` больше `other`.

Методы `max`, `min`, `clamp` автоматически реализуется на основании `cmp`.

Реализация этих методов позволяет использовать:
- `<x>.max(<y>)` - возвращает максимальное из двух;
- `<x>.min(<y>)` - возвращает минимальное из двух;
- `<x>.clamp(<min>, <max>)` - возвращает `<min>` если `<self>` меньше его, `<max>` если `<self>` больше, иначе `<self>`.

Можно реализовать с помощью для структур и перечислений, в этом случае будут сравниваться все поля в порядке объявления:
```rust
#[derive(Eq, PartialOrd, Ord)]
struct <Структура> {
    // ...
}
```

### `std::ops::Index`

Используется для доступа по индексу через `[<индекс>]`.

```rust
pub trait Index<Idx>
where
    Idx: ?Sized,
{
    type Output: ?Sized;
    fn index(&self, index: Idx) -> &Self::Output;
}
```

Метод `index` должен возвращать значения по индексу или паниковать, если оно вышло за границы.

Реализация этого метода позволяет использовать:
- `*<container>.index(<index>)` - `<container>[<index>]`.

Для получения мутабельного доступа по индексу должен реализовываться трейт `std::ops::IndexMut`.

```rust
pub trait IndexMut<Idx>: Index<Idx>
where
    Idx: ?Sized,
{
    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;
}
```

### `std::convert::From`

Используется для преоброзования из определенного типа в этот тип.

```rust
pub trait From<T> {
    fn from(T) -> Self;
}
```

Реализация этого метода позволяет использовать:
- `<Структура>.from(<значение>)` - возвращает экземпляр структуры преобразованый из значения.

### `std::convert::Into`

Используется для преоброзования из этого типа в другой определенный тип.

```rust
pub trait Into<T> {
    fn into(self) -> T;
}
```

Реализация этого метода позволяет использовать:
- `<структура>.into()` - возвращает значение типа из этой структуры.

### `std::any::Any`

Реализуется для всех типажей, у которых нет параметров с временами жизни.

```rust
pub trait Any: 'static {
    fn type_id(&self) -> TypeId;
}
```

Этот трейт даст методы для типа `&dyn Any`:
- `let <is>: boolean = <any>.is<<тип>: Any>()` - возвращает `true` если значение типа `<тип>`;
- `let <option_value>: Option<&T> = <any>.downcast_ref<<тип>: Any>()` - возвращает ссылку на значение типа `<тип>`, если значение типа `<тип>`, иначе `None`.

Жизненный цикл ссылок
=====================

У каждой ссылки в Rust есть жизненный цикл, то есть протяженность, в течение которой эта ссылка действительна. В большинстве случаев жизненные циклы выводятся логически неявно. Когда жизненные циклы у ссылок могут быть взаимосвязаны разными способами, необходимо аннотировать их.

Главная цель жизненного цикла - предотвращать висячие ссылки, из-за которых программа ссылается на данные, отличные от тех, на которые она должна ссылаться.

У аннотаций жизненных циклов указанный синтаксис: `&'a <тип>`. Где вместо `a` может быть любой символ в нижнем регистре.
> `&'a i32 // ссылка с явно выраженным жизненным циклом a`  
> `&'a mut i32 // изменяемая ссылка с явно выраженным жизненным циклом a`

Аннотации жизненных циклов указывают на то, что ссылки, с одинаковым жизненным циклом, должны жить в течение этого обобщенного жизненного цикла. Обобщенный жизненный цикл получит конкретный жизненный цикл, равный меньшему из жизненных циклов ссылок с одинаковым жизненным циклом.

Во время аннотирования жизненных циклов в функциях аннотации находятся в сигнатуре функции, а не в теле функции, внутри угловых скобок, между именем функции и списком параметров, как обобщение. Должны располагаться перед обобщениями в угловых скобках.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Во время возвращения ссылки из функции параметр жизненного цикла для возвращаемого типа должен совпадать с параметром жизненного цикла одного из параметров. Если возвращаемая ссылка не ссылается на один из параметров, то она должна ссылаться на значение, созданное внутри этой функции, но это не позволяет сделать компилятор, так как в итоге получится висячая ссылка, поэтому нужно возвращать тип данных, который передасться во владение.

Возвращаемая функция валидна до тех пор, пока валидны обе входные ссылки.

Синтаксис жизненных циклов предназначен для соединения жизненных циклов различных параметров и возвращаемых значений функций.

Структуры можно также анотировать жизненными циклами, как и функциях, внутри угловых скобок, после имени, для указания жиненных циклов полей ссылочного типа. Эта аннотация означает, что экземпляр структуры не может пережить ссылки, которые он содержит в полях ссылочного типа.

Имена жизни для полей структуры всегда должны объявляться после ключевого слова `impl` и затем использоваться после имени структуры, потому что эти жизненные циклы являются частью типа структуры.

В сигнатурах методов внутри блока `impl` ссылки могут быть привязаны к жизненному циклу ссылок в полях структуры, либо они могут быть независимыми.

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Пожалуйста, внимание: {}", announcement);
        self.part
    }
}

fn main() {
    let novel = String::from("Зовите меня Измаил. Несколько лет тому назад...");
    let first_sentence = novel.split('.')
        .next()
        .expect("Не смог отыскать '.'");
    let i = ImportantExcerpt { part: first_sentence };
}
```

Время жизни указывается внутри угловых скобок до обобщенных параметров.

Конструкция: `'a: 'l` - обозначает, что время жизни `'l` включает в себя `'a`.
```rust
struct Context<'l> {
    data: &'l str,
}
struct Parser<'s, 'l: 's> {
    ctx: &'s Context<'l>,
    internal_data: &'s str,
}
```

## Правила пропуска жизненного цикла

Применяются тогда, когда сам компилятор может вывести жизненные циклы, по каким-то паттернам.

Первое правило применяется к входным жизненным циклам, а второе и третье - к выходным. Если компилятор дойдет до конца этих трех правил и все еще останутся ссылки, для которых он не может выяснить жизненный цикл, то компилятор остановится с ошибкой.

Первое правило состоит в том, что каждый параметр, являющийся ссылкой, получает собственный параметр жизненного цикла. Другими словами, функция с одним параметром получает один параметр жизненного цикла, функция с двумя параметрами получает два отдельных параметра жизненного цикла и так далее.
> `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`

При этом неуказанные времена жизни во входных параметрах функции автоматически проставляются и полагаются разными.
> `fn get_radius<'a, 'b, T>(c: &'a Circle<'b, T>) -> &'c T`

Второе правило состоит в том, что, если имеется ровно один параметр входного жизненного цикла, то этот параметр жизненного цикла назначается всем параметрам выходных жизненных циклов.
> `fn foo<'a>(x: &'a i32) -> &'a i32`

Третье правило заключается в том, что, если имеется несколько параметров входных жизненных циклов, но один из них является `&self` или `&mut self`, так как это метод, то жизненный цикл параметра `self` назначается всем параметрам выходных жизненных циклов.

## Статический жизненный цикл

`'static` - обозначает всю продолжительность программы.

Все строковые литералы имеют жизненный цикл `'static` и хранятся непосредственно в двоичном файле программы, который всегда доступен.

Тестирование
============

Тесты - это функции, которые проверяют, что не-тестовый код функционирует ожидаемым образом.
Тела тестовых функций обычно выполняют следующие действия:
1. Настраивают необходимые данные или состояние.
2. Выполняют код, который вы хотите протестировать.
3. Подтверждают, что результаты соответствуют ожиданиям.

Если тестовая функция паникует, то он считается не успешным.

Аннотация `#[cfg(test)]` - перед модулем указывает что в нем содержаться тесты.

Аннотация `#[test]` перед функцией указывает на то, что функция является тестовой, поэтому исполнитель теста знает, что эту функцию нужно рассматривать как тест.

Аннотация `#[should_panic]` обозначает что тест успешен только когда функция паникует. `#[should_panic(expected = "ошибка")]` - с указанным текстом ошибки.

Аннотация `#[ignore]` - игнорирует указанный тест.

## Макрокоманды проверки

`assert_eq!(<значение1>, <значение2>[, "<шаблон>", <строка1>[, ...]]);` - проверяет что значения равняются друг другу `==`, а если не равняются, то выбрасывает панику [с указанным форматированным шаблоном].  
`assert_ne!(<значение1>, <значение2>[, "<шаблон>", <строка1>[, ...]]);` - проверяет что значения не равняются друг другу `!=`, а если равняются, то выбрасывает панику [с указанным форматированным шаблоном].  
`assert!(<значение>[, "<шаблон>", <строка1>[, ...]]);` - проверяет что значение равно `true`, а если не равно, то выбрасывает панику [с указанным форматированным шаблоном].

Когда проверочные утверждения не срабатывают, эти макрокоманды печатают аргументы с помощью отладочного форматирования - это означает, что сравниваемые значения должны реализовать типажи `PartialEq` и `Debug`. Для этого можно добавить им аннотацию `#[derive(PartialEq, Debug)]`.

```rust
pub fn greeting(name: &str) -> String {
    format!("Здравствуй {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn greeting_contains_name() {
        let result = greeting("Кэрол");
        assert!(
            result.contains("Кэрол"),
            "Приветствие не содержало имя, предоставлено значение `{}`", result
        );
    }
}
```

Тестовая функция может также возвращать `Result<T, E>` что позволяет использовать оператор вопросительного знака в теле тестов, что бывает удобно в написании тестов, которые должны закончиться неуспешно, если какая-либо операция в них возвращает вариант `Err`.

## Деление тестов

**Модульные тесты** это небольшие и более сфокусированные на тестировании одного модуля в отдельности или могут тестироваться приватные интерфейсы.

**Интеграционные тесты** являются полностью внешними по отношению к библиотеке и используют код библиотеки так же, как любой другой внешний код, используя только общедоступные интерфейсы и потенциально выполняя тестирование нескольких модулей в одном тесте.

### Модульные тесты

В Rust принято создавать тестирующий модуль `tests` и код теста сохранять в файлы с таким же именем, как компоненты которые предстоит тестировать. Модульные тесты идут в тех же файлах что и основной код.

Аннотация `#[cfg(test)]` у модуля с тестами указывает Rust компилировать и запускать только код тестов, когда выполняется команда `cargo test`, а не когда запускается `cargo build`.

### Интеграционные тесты

Для создания интеграционных тестов, создают папку `tests` в корневой папке проекта, рядом с папкой `src`. Cargo знает, что файлы с интеграционными тестами будут храниться в этой директории. Каждый такой файл будет компилироваться в отдельный крейт.

Не нужно комментировать код в файлах с помощью `#[cfg(test)]`.

Именование файла `tests/<имя>/mod.rs` говорит, что Rust не следует рассматривать модуль `<имя>` как файл интеграционных тестов.

## Комментарии к документации

Они генерируются для документации в виде HTML-кода, в котором отображается содержимое комментариев к документации для **публичных элементов API**, предназначенных для программистов, заинтересованных в знании того, как использовать библиотеку, в отличие от того, как она реализована.

Комментарии к документации используют три слеша, `///` вместо двух и поддерживают нотацию Markdown для форматирования текста.

```rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

Запуск команды `cargo test` запустит примеры кода в документации как тесты.

Комментарии к документу внутри корневого файла крейта (`src/lib.rs` по соглашению) или внутри модуля для документирования крейта или модуля в целом с помощью `//!` используются для добавления документации к элементу, содержащему комментарии, а не добавления документации к элементам, следующим за комментариями.

Замыкания
=========

Замыкания - это анонимные функции, которые можно сохранить в переменной или передать в качестве аргументов другим функциям. Можно создать замыкание в одном месте, а затем вызвать замыкание, чтобы вычислить его в другом контексте. В отличие от функций, замыкания могут захватывать значения из области видимости где они определены.

Определения замыкания:
```rust
let <замыкание> = |[<аргумент1>[, ...]]| {
    /* код */
};
```

```rust
let expensive_closure = |num| {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
```

Замыкания можно как и функции анотировать типами. Но обычно это не требуется так как компилятор автоматически выводит тип.
```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 } // функция
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

Вызов замыканий без типов требует, чтобы они могли скомпилироваться, поэтому при компиляции типы будут выводиться на основе их использования. Определения замыканий будут иметь конкретные типы выведенные только один раз - для каждого из ее параметров и для возвращаемого значения.

Фигурные скобки могут не использоваться, если код функции состоит только из одной строчки кода.

Вызывается замыкание подобно вызову функции.

## Тип замыкания

Для того чтобы передавать замыкания в качестве параметров, у них есть типы:
- `Fn([<тип1>[, <тип2>]]) -> <возвращаемый_тип>` - заимствуют значения из окружения без их изменения;
- `FnOnce([<тип1>[, <тип2>]]) -> <возвращаемый_тип>` - может использовать переменные из окружения замыкания становясь при этом их владельцем и перемещает в замыкание во время определения и это замыкание можно вызвать только один раз;
- `FnMut([<тип1>[, <тип2>]]) -> <возвращаемый_тип>` - могут изменять значения переменных из окружения, поскольку они заимствуют изменяемые значения.

Когда создают замыкание Rust определяет какой типаж использовать, основываясь на том как замыкание использует значения из окружения. Все замыкания реализуют `FnOnce`, потому что все они могут быть вызваны хотя бы один раз. Замыкания, которые не перемещают захваченные переменные, также реализуют `FnMut`, а замыкания которым не требуется изменяемый доступ к захваченным переменным, также реализуют `Fn`.

Ключевое слово `move` перед списком параметров замыкания при определении, указывает что замыкание становится владельцем захваченных рпеременных.
```rust
let x = vec![1, 2, 3];

let equal_to_x = move |z| z == x;
```

Вместо замыканий, в качестве значений можно использовать функции. Так как указатели функций реализуют все три типажа замыканий (`Fn`, `FnMut` и `FnOnce`), и поэтому можно всегда передать указатель функции в качестве аргумента функции ожидающей замыкание.

## Возврат замыканий из функции

Для этого должен использоваться в качестве возвращаемого типа, тип `Box<T>`, так как замыкания имеют не известный размер.
```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```

Итераторы
=========

Шаблон итератора позволяет выполнять некоторые задачи над последовательностью элементов. Итератор отвечает за логику итерации по каждому элементу и определяет, когда последовательность завершилась.

Итераторы В Rust ленивы, то есть они не делают ничего, пока не вызовутся методы, которые потребляют итератор.

Методы для создания итераторов:
- `let <итератор> = <объект>.iter();` - создает и возвращет итератор по неизменяемым ссылкам на значения;
- `let <итератор> = <объект>.into_iter();` - создает и возвращет итератор, который становится владельцем значения и возвращает принадлежащие ему значения;
- `let <итератор> = <объект>.iter_mut();` - создает и возвращет итератор по изменяемым ссылкам на значения.

Цикл `for` забирает итератор во владение.

`let <value>: Option<T> = <итератор>.next();` - возвращает текущее значение итератора, если оно есть в виде `Some<T>` или `None`, если его нет. Используется для перебора итератора, конец перебора обозначается возвращением значения `None`.
- `<итератор>.skip(<количество>);` - пропускает указаное количество элементов из итератора.

Потребляющие методы итератора получают итератор во владение:
- `<итератор>.sum();` - потребляет итератор и возвращает сумму его элементов;
- `<итератор>.collect();` - потребляет итератор и возвращает все его элементы в виде коллекции `Vec<T>`;
- `<итератор>.collect::<<тип>>();` - потребляет итератор и возвращает все его элементы в виде `<тип>`;
- `<итератор>.flatten();` - потребляет итератор и возвращает новый итератор, в котором развернуты в плоский вид все элементы;
- `<итератор>.cloned();` - потребляет итератор и возвращает новый итератор, в котором к каждому элементу применен метод `<элемент>.clone()`;
- `<итератор>.for_each(|<элемент>| { /* ... */});` - потребляет итератор, где к каждому элементу применено замыкание типа `Fn(T)`;
- `<итератор>.map(|<элемент>| <новый_элемент>);` - потребляет итератор и возвращает новый итератор, где к каждому элементу применено замыкание типа `Fn(T) -> B`;
- `<итератор>.filter(|<элемент>| <результат>);` - потребляет итератор и возвращает новый итератор, где к каждому элементу применено замыкание типа `Fn(T) -> bool` и если замыкание для значения вернуло `true`, то включет этот элемент в новый итератор;
- `<итератор>.enumerate();` - потребляет итератор и возвращает новый итератор, где каждый элемент состоит из кортежа вида `(<индекс>, <элемент>)`;
- `<итератор>.take(<количество>);` - потребляет итератор и возвращает новый итератор с максимум элементов равных `<количество>`;
- `<итератор>.zip(<итератор2>);` - потребляет итератор и переданный итератор и возвращает новый итератор, в котором все элементы в виде кортежа `(<элемент_из_итератора>, <элемент_из_итератора2>)`, при этом количество элементов равно минимальному количеству элементов в итераторах;
- `<итератор>.count();` - потребляет итератор и возвращает количество элементов.

Для реализации итератора необходимо реализовать типаж в собственной структуре:
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}

#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new()
        .zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();
    assert_eq!(18, sum);
}
```

Есть возможность извлекать значения последовательно с помощью конструкции:
```rust
let query = match args.next() {
    Some(arg) => arg,
    None => return Err("Didn't get a query string"),
};
```

**Итераторы** - это одна из абстракций с нулевой стоимостью (*zero-cost abstractions*) в Rust, под которой подразумевается, что использование абстракции не накладывает дополнительных расходов во время выполнения.

Умные указатели
===============

**Указатель** - это общая концепция для переменной, которая содержит адрес на участок памяти. Этот адрес "*относится к*", или "*указывает на*" некоторые другие данные.

**Умные указатели** - являются структурами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и дополнительные возможности.

**Ссылки** `&` - являются указателями, которые только заимствуют данные; против того, что во многих случаях умные указатели владеют данными на которые они указывают.

Обычная ссылка является типом указателя и для того чтобы получить значение ссылки, ее необходимо **разыменовать** (*dereference*) с помощью `*`.

**Разыменованное приведение** (*Deref coercion*) - это удобство, которое **Rust** выполняет над аргументами функций и методов. Разыменованное приведение преобразует ссылку на исходный тип, реализующий типаж `Deref`, в ссылку на целевой тип, в который `Deref` может преобразовать исходный тип.

Разыменованное приведение происходит автоматически, когда передают ссылку на значение определенного типа в качестве аргумента функции или метода, который не соответствует типу параметра в определении функции или метода.

Последовательность вызовов метода `deref` преобразует предоставленный исходный тип, в целевой тип необходимый параметру. Количество раз, которое нужно вставить `Deref::deref` определяется во время компиляции, поэтому использование разыменованного приведения не имеет накладных расходов во время выполнения.

Типы `String` и `Vec<T>` - являются умными указателями.

## Умный указатель на кучу `Box<T>`

Позволяет хранить данные в куче, а не в стеке. Используется когда:
- неизвестен размер данных и его невозможно вычислить на этапе компиляции, как рекурсивные типы;
- большой объем данных и их нужно передавать во владение без копирования.

`let <box>: Box<<тип>> = Box::new(<значение>);` - создает умный указатель со значением.
> `let b = Box::new(5);`

## Типаж `Defer`

Реализация типажа `Deref` позволяет настроить поведение оператора разыменования (*dereference operator*) `*` и это позволяет использовать умный указатель как обычную ссылку, и можно писать код, который работает с ссылками и использовать этот код также с умными указателями.

Для реализации возможности разыменовывания необходимо реализовать типаж `Deref` в собственной структуре:
```rust
pub trait Deref {
    type Target;

    fn deref(&self) -> &Self::Target;
}
```

Без типажа `Deref` компилятор может только разыменовывать `&` ссылки. Метод `deref` дает компилятору возможность принимать значение любого типа, реализующего `Deref` и вызывать метод `deref` чтобы получить ссылку `&`, которую он знает, как разыменовывать.

При вызове `*<значение>` Rust заменяет оператор `*` вызовом метода `deref`: `*(<значение>.defer())`.

Типаж `DerefMut` используется для переопределения оператора `*` у изменяемых ссылок.

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

## Типаж `Drop`

Используется для того, чтобы настроить то, что происходит, когда значение собирается выйти из области видимости.

```rust
pub trait Drop {
    fn drop(&mut self);
}
```

В теле функции `drop` можно разместить любую логику, которую необходимо запустить, когда экземпляр указанного типа выходит из области видимости.

Rust автоматически вызывает `drop`, когда экземпляры выходят из области видимости, вызывая указанный код. Функция `drop` в Rust является определенным **деструктором**.

Функция `drop(<переменная>);` позволяет вызвать метод `drop` у переменной преждевременно.

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
```

## Умный указатель `Rc<T>`

Используется для реализации множественного владения через механизм **подсчета ссылок** (*reference counting*).

Тип `Rc<T>` отслеживает количество ссылок на значение, где количество ссылок определяет используется ли еще значение. Если у значения остается ноль ссылок, это значение можно очистить и ссылки станут недействительными.

Использование `Rc<T>` позволяет одному значению иметь нескольких владельцев, а подсчет ссылок гарантирует, что значение остается действительным до тех пор, пока существует любой из владельцев.

С помощью неизменяемых ссылок, тип `Rc<T>` позволяет обмениваться данными между несколькими частями программы только для чтения данных.

Реализовано в `std::rc::Rc`.

`let <rc>: Rc<<тип>>: Rc::new(<значение>);` - создает умный указатель со значением.
> `let a = Rc::new(5);`

`let <значение> = *<rc>;` - доступ к значению.

`let <rc_clone>: Rc<<тип>> = Rc::clone(&<rc>);` - увеличивает счетчик количества ссылок на 1 и возвращает клона с сылкой на значение. При освобождении значения уменьшается счетчик на 1.  
`let <rc_clone>: Rc<<тип>> = <rc>.clone();` - аналогично.

`let <clone>: &mut Rc<<тип>> = Rc::make_mut(&mut <rc>);` - возвращает мутабельную ссылку на объект, если если количество ссылок = 1, иначе копирует его и возвращает копию объекта, и теперь умный указатель будет ссылаться на свой объект.

Разница между `Rc::clone(&<rc>)` и `<rc>.clone()` в том, что при **динамической типизации** `dyn <Типаж>` у конструкции `<rc>.clone()` будет использоваться нужный тип, а при `Rc::clone(&<rc>)` нужно задавать тип структуры: `Rc::<тип_структуры>::clone(&<rc>)`.

`let <count>: usize = Rc::strong_count(&<rc>);` - возвращает счетчик количества ссылок.

### Слабые ссылки `Weak<T>`

Используются для того чтобы не влиять на освобождение значений и используются для устранения цикличных зависимостей.

Реализовано в `std::rc::Weak`.

`let <weak>: Weak<<тип>>: Weak::new();` - создает слабую ссылку. Используется для заглушки.

`let <weak>: Weak<<тип>> = Rc::downgrade(&<rc>);` - увеличивает счетчик количества слабых ссылок на 1 и возвращает клона с сылкой на значение. При освобождении значения уменьшается счетчик слабых ссылок на 1. Слабые ссылки не влияют на очистку значения.  
`let <weak_value>: Option<Rc<T>> = <weak>.upgrade();` - возвращает результат `Some`, если значение `Rc<T>` еще не было удалено и результат `None`, если значение `Rc<T>` было удалено.  
`let <count>: usize = Rc::weak_count(&<rc>);` - возвращает счетчик количества слабых ссылок.

## Умный указатель `Cell<T>`

**Внутренняя изменяемость** - это шаблон проектирования в Rust, позволяющий изменять данные даже если ссылки на эти данные неизменяемые.

Используется для изменяемости значений в неизменяемых методах.

Реализовано в `std::cell::Cell`.

`let <cell>: Cell<<тип>>: Cell::new(<значение>);` - создает умный указатель со значением.
> `let a = Cell::new(vec![]);`

`<cell>.set(<новое_значение>);` - устанавливает новое значение.  
`let <старое_значение> = <cell>.replace(<новое_значение>);` - устанавливает новое значение и возвращает старое.  
`let <значение> = <cell>.into_inner();` - преобразует `<cell>` в значение и возвращает его, при этом `<cell>` пропадает.  
`let <значение> = <cell>.get();` - возвращает значение (копирует его), если оно поддерживает трейт `Copy` и возвращает его.  

### Умный указатель `RefCell<T>`

Тип `RefCell<T>` предоставляет единоличное владение данными, которые он содержит. Правила заимствования применяются во время работы программы. Если правила нарушатся, то программа вызовет панику и завершится.

Тип `RefCell<T>` полезен, когда есть увереность, что код соответствует правилам заимствования, но компилятор не может понять и гарантировать этого.

Поскольку `RefCell<T>` разрешает изменяемые заимствования, проверенные во время выполнения, можно изменять значение внутри `RefCell<T>` даже если `RefCell<T>` является неизменным.

Реализовано в `std::cell::RefCell`.

`let <refcell>: RefCell<<тип>>: RefCell::new(<значение>);` - создает умный указатель со значением.
> `let a = RefCell::new(vec![]);`

`let <ref>: RefMut<T> = <refcell>.borrow_mut();` - возвращает ссылку на изменяемое значение. При повторном вызове, если предыдущее значение не было освобождено будет выброшена паника.  
`let <ref>: Ref<T> = <refcell>.borrow();` - возвращает ссылку на значение, если предыдущее изменяемое значение не было освобождено будет выброшена паника.

`let <result_ref>: Result<RefMut<T>, BorrowErrorMut> = <refcell>.try_borrow_mut();` - возвращает ссылку на изменяемое значение, если можно ее вернуть, иначе возвращает ошибку.  
`let <result_ref>: Result<Ref<T>, BorrowError> = <refcell>.try_borrow();` - возвращает ссылку на значение, если можно ее вернуть, иначе возвращает ошибку.

`let mut <ref>: &mut T = <refcell>.get_mut();` - возвращает чисто ссылку на изменяемое значение.

## Тип `Rc<RefCell<T>>`

Может использоваться для того чтобы получить значение, которое может иметь несколько владельцев и которое можно изменять.

Многопоточное программирование
==============================

**Многопоточное программирование** - это когда разные части программы выполняются независимо.

**Параллельное программирование** - это когда разные части программы выполняются одновременно.

## Потоки

**Блокировка потока** означает, что потоку запрещено выполнять работу или выходить из него.

При окончании работы главного потока происходит завершение программы и всех других потоков.

Реализовано в `use std::thread;`.

`let <handle>: thread::JoinHandle<_> = thread::spawn(|| { /* ... */});` - запускает указанное замыкание в отдельном потоке, возвращает "ручку" потока. Поскольку `thread::spawn` запускает это замыкание в новом потоке, он должен иметь доступ ко всем захваченным переменным внутри этого потока, поэтому используют `move`.

`let <result>: thread::Result<()> = <handle>.join();` - блокирует текущий поток до тех пор пока указанный поток не завершиться.
> `handle.join().unwrap();` - для того чтобы значение было использовано

`thread::sleep(<duration>: Duration);` - блокирует текущий поток выполнения на указанное время.

## Передача данных между потоками

Реализуется с помощью **каналов** посредством отправки сообщений. Канал состоит из одного **приемника** и множества **передатчиков**. Канал может быть **закрыт**, если приемник или предатчик закрылись. Данные в канале храняться в бесконечном буфере.

Реализовано в `use std::sync::mpsc;`

`let (<tx>, <rx>) = mpsc::channel();` - создает канал и возвращает кортеж, где первый элемент которого является отправляющей стороной, а второй элемент - принимающей стороной.

`let <result>: Result<(), SendErr<T>> = <tx>.send(<значение>);` - отправляет сообщение в канал, возвращает результат отправки, ошибку если канал закрылся. Не блокирует текущий поток.  
`let <tx_clone> = <tx>.clone();` - клонирует отправителя.

`let <result>: Result<T, RecvError> = <rx>.recv();` - блокирует текущий поток и ожидает значение из канала. Возвращает ошибку, если канал закрылся.  
`let <result>: Result<T, RecvError> = <rx>.try_recv();` - неблокирует текущий поток и возвращает значение из канала, если оно есть. Возвращает ошибку, если канал закрылся.

Для ожидания всех значений из канала, до его закрытия используется цикл:
```rust
for <received> in <rx> {
    /* ... */
}
```
Где в `<received>` будет значение, цикл заершиться когда канал закроется.

## Многопоточное разделяемое состояние

**Mutex** - это сокращение от **взаимное исключение** (*mutual exclusion*), так как мьютекс позволяет только одному потоку получать доступ к некоторым данным в любой момент времени. Для того, чтобы получить доступ к данным в мьютексе, поток должен сначала подать сигнал, что он хочет получить доступ запрашивая блокировку (`lock`) мьютекса.

**Блокировка** - это структура данных, являющаяся частью мьютекса, которая отслеживает кто в настоящее время имеет эксклюзивный доступ к данным. Поэтому мьютекс описывается как объект защищающий данные, которые он хранит через систему блокировки.

**Правила использования**:
- перед тем как попытаться получить доступ к данным необходимо получить блокировку.
- по окончании работы с данными, которые защищает мьютекс, нужно разблокировать данные, чтобы другие потоки могли получить блокировку.

Реализовано в `use std::sync::Mutex;`.

`let <mutex> = Mutex::new(<значение>);` - создает мьютекс со значением.

`let <result>: Mutex::LockResult<Mutex::MutexGuard<T>> = <mutex>.lock();` - блокирует текущий поток и ожидает разблокирования мьютекса. Возвращает ошибку, если поток заблокировавший мьютекс запаниковал. Умный указатель типа `MutexGuard` реализует типаж `Deref` для указания на внутренние данные; умный указатель также имеет реализацию типажа `Drop` автоматически снимающего блокировку, когда `MutexGuard` выходит из области видимости.
> `let mut num = mutex.lock().unwrap();`

## Атомарный счетчик ссылок `Arc<T>`

`Arc<T>` является типом аналогичным типу `Rc<T>` и имеет одинаковый API, который безопасен для использования в ситуациях многопоточности.

Реализовано в `std::sync::atomic;`

## Маркерный типаж `Send`

Указывает, что владение типом реализующим `Send`, может передаваться между потоками. Почти каждый тип Rust является типом `Send`, кроме некоторых `Rc<T>` и др.

## Маркерный типаж `Sync`

Указывает, что на тип реализующий `Sync` можно безопасно ссылаться из нескольких потоков. Другими словами, любой тип `T` является типом `Sync`, если `&T` (ссылка на `T`) является типом `Send`, что означает что ссылку можно безопасно отправить в другой поток. Семейство связанных типов `Cell<T>` (`RefCell<T>`) не являются `Sync`.

Объектно-ориентированное программирование
=========================================

Объектно-ориентированные программы состоят из объектов. Объект объединяет данные и процедуры, которые работают с этими данными. Эти процедуры обычно называются методами или операциями.

**Инкапсуляция** - детали реализации объекта недоступны для кода, использующего этот объект.

**Наследование** - это механизм, с помощью которого объект может быть определен, унаследовав данные и поведение от родительского объекта без необходимости их повторного определения. **Не присутствует**.

**Полиморфизм** - означает возможность подменять объекты во время исполнения, если они имеют одинаковые характеристики.

Небезопасный Rust
=================

Небезопасный Rust существует, потому что по своей природе статический анализ является консервативным и может считать некоторые части кода ошибочными и для взаимодествия с аппаратным обеспечением.

Используется для:
- Разыменование сырого указателя;
- Вызов небезопасной функции или небезопасного метода;
- Доступ или изменение изменяемой статической переменной;
- Реализация небезопасного типажа;
- Доступ к полям в `union`.

При этом не отключается проверка заимствования или любые другие проверки безопасности Rust: если используется ссылка в небезопасном коде, она все равно будет проверена.

## Разыменование сырых указателей

В отличие от ссылок и умных указателей, сырые указатели:
- могут игнорировать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых указателей на одну и ту же область памяти;
- не гарантируют что ссылаются на действительную память;
- могут быть `null`;
- не реализуют автоматическую очистку памяти.

`let <переменная> = &mut <переменная> as *mut <тип>;` - создание указателя на указанный участок памяти в переменной в виде изменяемой ссылки.  
`let <переменная> = &<переменная> as *const <тип>;` - создание указателя на указанный участок памяти в переменной в виде неизменяемой ссылки.

Разименовывать указатели можно только в блоках `{}` с префиксом `unsafe` или в функциях с таким же префиксом. В этих блоках можно также вызывать функции с префиксом `unsafe`.
```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

## Использование `extern` функций для вызова внешнего кода

Специальное ключевое слов `extern`, облегчает создание и использование **интерфейса внешних функций** (FFI - *Foreign Function Interface*). FFI в языке программирования является способом определять функции и давать возможность другому (внешнему) языку программирования вызывать эти функции. Функции объявленные в этом блоке можно использовать только в `unsafe` функциях или блоках.
```rust
extern "<Язык>" {
    fn <функция>([<параметр1>: <тип>[, ...]])[ -> <возвращаемый_тип>];
}
```

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

Для экспорта функций из Rust используется префикс перед именем функции: `pub extern "<Язык>"` и директива `#[no_mangle]` для того чтобы Rust не изменял название функции.
```rust
#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```

## Статические переменные

`static [mut] <ИМЯ_ПЕРЕМЕННОЙ>: <тип> = <значение>;` - объявление статической переменной. Статические переменные могут хранить только ссылки со временем жизни `'static`.

Чтение и изменение **изменяемых** статических переменных является небезопасным и может быть выполнено только в `unsafe` функциях или блоках.
```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

Стандартная библиотека
======================

## Коллекции общего назначения `std::collections`

### Хеш-отображения `std::collections::HashMap`

Хеш-отображения хранят данные в куче. Они однородны: у всех ключей должен быть один и тот же тип, и у всех значений тоже должен быть один и тот же тип.

`let <map>: HashMap<<тип_ключа>, <тип_значения>> = HashMap::new();` - создание.

`<map>.insert(<ключ>, <значение>);` - вставка значения по ключу в хеш-отображение.  
`<map>.entry(<ключ>).or_insert(<значение>);` - вставка значения по ключу в хеш-отображение, если этого ключа нет в хеше и возвращает изменяемую ссылку на значение этого ключа `&mut V`.

`<map>.contains_key(<ключ>)` - возвращает `true` если ключ есть в хеш-отображение.

`let <переменная>: Option<&<тип>> = <map>.get(<ключ>);` - доступ к значению по ключу хеша, возвращает его в типе `Option<&<тип>>`.

`let <переменная>: usize = <map>.len();` - возвращает размер.

Для перебора используется цикл `for`:
```rust
for (<переменная_ключа>, <переменная_значения>) in &<map> {
    // ...
}
```

### Хеш-набор `std::collections::HashSet`

Хеш-набор хранят данные в куче. Они однородны: у всех один и тот же тип.

`let <set>: HashSet<<тип>> = HashSet::new();` - создание.

`<set>.insert(<значение>);` - вставка значения в хеш-набор.  
`<set>.contains(<значение>);` - возвращает `true` если значение есть в хеш-наборе.

`let <переменная>: usize = <set>.len();` - возвращает размер.

Для перебора используется цикл `for`:
```rust
for <переменная_значения> in &<set> {
    // ...
}
```

### `std::collections::VecDeque`

Используется для двунаправленной очереди.

`let <queue>: VecDeque<<тип>> = VecDeque::new();` - создание.

`<queue>.push_back(<значение>);` - вставка значения в конец очереди.  
`<queue>.push_front(<значение>);` - вставка значения в начало очереди.  
`let <переменная>: Option<<тип>> = <queue>.pop_front();` - возвращает элемент в начале очереди в типе `Option<<тип>>`.  
`let <переменная>: Option<<тип>> = <queue>.pop_back();` - возвращает элемент в конце очереди в типе `Option<<тип>>`.  


`let <переменная>: usize = <queue>.len();` - возвращает размер.

## `std::env`

Используется для работы с аргументами командной строки.

`let <args>: Vec<String> = env::args().collect();` - возвращает итератор и преобразует его в коллекцию `Vec<String>`. В первом аргументе содержится название двоичного файла программы.  
`let <value>: Result<String, VarError> = env::val(<имя_переменной_окружения>);` - возвращает значение переменной окружения в структуре: `Result<String, VarError>`.

## `std::fs`

Используется для работы с файловой системой.

`let <content_wrapper>: Result<String> = fs::read_to_string(<имя_файла>);` - возвращает текстовое содержимое файла в виде `Result<String>` из модуля `std::fs`.

### `std::fs::File`

Используется для работы с файломи.

`let <maybe_file>: Result<File, IOError> = File::open("<имя_файла>");` - открывает файл в режиме чтения или выбрасывает ошибку если его нет или его не возможно открыть.

## `std::io`

### `std::io::BufReader`

Используется для буферизированного чтения.

`let <buffer> = BufReader::new(<file>);` - использует файл для чтения.  
`<buffer>.lines();` - возвращает итератор со строками в файле.

## `std::process`

Используется для работы с процессом программы.

`process::exit(<код>);` - завершает программу с указанным кодом.

## `std::time::Duration`

Используется для времени.

`let <duration> = Duration::new(<количество_сек>, <количество_нс>);` - создает время по количеству сек и нс.  
`let <duration> = Duration::from_millis(<количество_мс>);` - создает время по количеству мс.  
`let <duration> = Duration::from_secs(<количество_сек>);` - создает время по количеству сек.

## `std::net::TcpListener`

Используется для сети.

`let <listener_wrapper>: Result<TcpListener> = TcpListener::bind("<ip>:<port>");` - слушателя порта ip-адреса в виде `TcpListener<String>` из модуля `std::net::TcpListener`.

Для обработки всех потоков используется итератор из метода `<listener>.incoming()`, который дает последовательность потоков (стримов) представляющих из себя открытое соединение между клиентом и сервером:
```rust
for stream in listener.incoming() {
    let stream = stream.unwrap(); // раскрывает поток
    // код для обработки потоков
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap(); // читает из потока 1024 байта и записывает их в буффер

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write(response.as_bytes()).unwrap(); // записывает в поток строку в 
    stream.flush().unwrap();
}
```

`let <count>: usize = <stream>.read(&mut <buffer>).unwrap();` - читает из потока количество байт, максимум размером с буффер, и записывает в него в формате `[u8]` и возвращает количество записанных байт.  
`<stream>.write(&<buffer>[..]).unwrap();` - записывает в поток буффер в формате `[u8]`.  
`<stream>.flush().unwrap();` - ждет и предотвратит продолжение программы, пока все байты не будут записаны в соединение.  
