Описание
========

MongoDB реализует новый подход к построению баз данных, где нет таблиц, схем, запросов SQL, внешних ключей и многих других вещей, которые присущи объектно-реляционным базам данных. MongoDB предлагает документо-ориентированную модель данных, благодаря чему MongoDB работает быстрее, обладает лучшей масштабируемостью, ее легче использовать.

Вся система MongoDB может представлять не только одну базу данных, находящуюся на одном физическом сервере. Функциональность MongoDB позволяет расположить несколько баз данных на нескольких физических серверах, и эти базы данных смогут легко обмениваться данными и сохранять целостность.

## Формат данных в MongoDB

Способ хранения данных в MongoDB в этом плане похож на JSON, хотя формально JSON не используется. Для хранения в MongoDB применяется формат, который называется BSON (binary JSON). BSON позволяет работать с данными быстрее: быстрее выполняется поиск и обработка. Хотя  BSON в отличие от хранения данных в формате JSON имеет небольшой недостаток: в целом данные в JSON-формате занимают меньше места, чем в формате BSON, с другой стороны, данный недостаток с лихвой окупается скоростью.

## Структура хранения

MongoDB хранит документы. В отличие от строк, которые хранят реляционные базы данных, документы могут хранить сложную по структуре информацию. Документ можно представить как хранилище **ключей** и **значений**.

**Ключ** - представляет простую метку, с которым ассоциировано определенный кусок данных.

В MongoDB для каждого документа имеется уникальный идентификатор, который называется `_id`. И если явным образом не указать его значение, то MongoDB автоматически сгенерирует для него значение.

Каждому ключу сопоставляется определенное значение. Если какому-то ключу не сопоставлено значение, то этот ключ просто опускается в документе и не употребляется.

В **коллекциях** могут содержаться самые разные объекты, имеющие различную структуру и различный набор свойств.

Система хранения данных в MongoDB представляет набор реплик. В этом наборе есть основной узел, а также может быть набор вторичных узлов. Все вторичные узлы сохраняют целостность и автоматически обновляются вместе с обновлением главного узла. И если основной узел по каким-то причинам выходит из строя, то один из вторичных узлов становится главным.

MongoDB позволяет сохранять различные документы с различным набором данных, однако при этом размер документа ограничивается 16 мб. Но MongoDB предлагает решение - специальную технологию GridFS, которая позволяет хранить данные по размеру больше, чем 16 мб. Система GridFS состоит из двух коллекций. В первой коллекции, которая называется `files`, хранятся имена файлов, а также их метаданные, например, размер. А в другой коллекции, которая называется `chunks`, в виде небольших сегментов хранятся данные файлов, обычно сегментами по 256 кб.

## Содержимое пакета MongoDB

- `bsondump` - считывает содержимое BSON-файлов и преобразует их в читабельный формат, например, в JSON;
- `mongo` - представляет консольный интерфейс для взаимодействия с базами данных, своего рода консольный клиент;
- `mongod` - сервер баз данных MongoDB. Он обрабатывает запросы, управляет форматом данных и выполняет различные операции в фоновом режиме по управлению базами данных. Флаги:
    - `--dbpath <каталог>` - позволяет задать путь к файлам БД.
- `mongodump` - утилита создания бэкапа баз данных;
- `mongoexport` - утилита для экспорта данных в форматы JSON, TSV или CSV;
- `mongofiles` - утилита, позволяющая управлять файлами в системе GridFS;
- `mongoimport` - утилита, импорирующая данных в форматах JSON, TSV или CSV в базу данных MongoDB;
- `mongooplog` - приложение, позволяющее опрашивать удаленные серверы на наличие операций с БД и применять полученные данные к локальному серверу;
- `mongoperf` - проверяет производительность жесткого диска на предмет операций ввода-вывода;
- `mongorestore` - позволяет записывать данные из дампа, созданного mongodump, в новую или существующую базу данных;
- `mongos` - служба маршрутизации MongoDB, которая помогает обрабатывать запросы и определять местоположение данных в кластере MongoDB;
- `mongorestat` - представляет счетчики операций с бд;
- `mongotop` - предоставляет способ подсчета времени, затраченного на операции чтения-записи в бд.

Структура
=========

```
         +--------- База Данных MongoDB -------+
        /                   |                   \
    Коллекция1          Коллекция2          КоллекцияN
        |                   |                   |
    Документ1,          Документ1,          Документ1,
    Документ2,          Документ2,          Документ2,
    .........           .........           .........
    ДокументN           ДокументN           ДокументN
```

В MongoDB база данных состоит из **коллекций**. Каждая коллекция имеет свое уникальное имя - произвольный идентификатор, состоящий из не более чем 128 различных алфавитно-цифровых символов и знака подчеркивания.

**Документ** можно представить как объект, хранящий некоторую информацию. В некотором смысле он подобен строкам в реляционных субд, где строки хранят информацию об отдельном элементе.

Документ представляет набор пар ключ-значение. Ключи представляют строки. Значения же могут различаться по типу данных. Всего имеется следующие типы значений:
- `String` - строковый тип данных, как в приведенном выше примере (для строк используется кодировка UTF-8);
- `Array` - (массив): тип данных для хранения массивов элементов;
- `Binary data` - (двоичные данные): тип для хранения данных в бинарном формате;
- `Boolean` - булевый тип данных, хранящий логические значения `TRUE` или `FALSE`, например, {"married": FALSE};
- `Date` - хранит дату в формате времени Unix;
- `Double` - числовой тип данных для хранения чисел с плавающей точкой;
- `Integer` - используется для хранения целочисленных значений, например, {"age": 29};
- `JavaScript` - тип данных для хранения кода javascript;
- `Min key`/`Max key` - используются для сравнения значений с наименьшим/наибольшим элементов BSON;
- `Null` -  тип данных для хранения значения `Null`;
- `Object` - строковый тип данных, как в приведенном выше примере;
- `ObjectID` - тип данных для хранения id документа;
- `Regular expression` - применяется для хранения регулярных выражений;
- `Symbol` -  тип данных, идентичный строковому. Используется преимущественно для тех языков, в которых есть специальные символы;
- `Timestamp` -  применяется для хранения времени.

В MongoDB запросы обладают регистрозависимостью и строгой типизацией.

Для каждого документа в MongoDB определен уникальный идентификатор, который называется `_id`. При добавлении документа в коллекцию данный идентификатор создается автоматически если его не задать.

Данное поле должно иметь уникальное значение в рамках коллекции. При добавлении в коллекцию два документа с одинаковым идентификатором, то добавится только один из них, а при добавлении второго будет ошибка.

Если идентификатор не задан явно, то MongoDB создает специальное бинарное значение размером 12 байт. Это значение состоит из нескольких сегментов: значение типа timestamp размером 4 байта, идентификатор машины из 3 байт, идентификатор процесса из 2 байт и счетчик из 3 байт. Таким образом, первые 9 байт гарантируют уникальность среди других машин, на которых могут быть реплики базы данных. А следующие 3 байта гарантируют уникальность в течение одной секунды для одного процесса. Такая модель построения идентификатора гарантирует с высокой долей вероятности, что он будет иметь уникальное значение, ведь она позволяет создавать до 16 777 216 уникальных объектов ObjectId в секунду для одного процесса.

Команды
=======

`use <имя_базы_данных>` - устанавливает в качестве используемой указанную базу данных. При этом не важно, существует ли такая бд или нет. Если ее нет, то MongoDB автоматически создаст ее при добавлении в нее данных. Для базы данных можно задать любое имя, однако есть некоторые ограничения. Например, в имени не должно быть символов /, \, ., ", *, <, >, :, |, ?, $. Кроме того, имена баз данных ограничены 64 байтами. Также есть зарезервированные имена, которые нельзя использовать: `local`, `admin`, `config`.

`show dbs` - выводит названия всех имеющихся бд на консоль.  
`db` - выводит какая бд используется в текущей момент.

`show collections` - выводит названия всех имеющихся коллекций на консоль.

`db.stats()` - выводит статистику по текущей базе данных.  
`db.<коллекция>.stats()` - выводит статистику по коллекции.

При добавлении в коллекцию данных она автоматически создается. Имя коллекции - произвольный идентификатор, состоящий из не более чем 128 различных алфавитно-цифровых символов и знака подчеркивания. В то же время имя коллекции не должно начинаться с префикса `system`., так как он зарезервирован для внутренних коллекций (например, коллекция `system.users` содержит всех пользователей базы данных). И также имя не должно содержать знака доллара - `$`.

`db.<коллекция>.insertOne(<документ>)` - добавляет один документ, где `<документ>` представляет собой объект JSON.  
`db.<коллекция>.insertMany([<документ1>[, ...]])` - добавляет несколько документов.  
`db.<коллекция>.insert({<документ> | [<документ1>[, ...]]})` - может добавлять как один, так и несколько документов.

`db.<коллекция>.find()` - выводит содержимое коллекции (действует аналогично `SELECT * FROM <коллекция>`).  
`db.<коллекция>.find().pretty()` - выводит содержимое коллекцию в более читабельном виде.

`load("<файл>.js")` - выполняет указанный файл с коммандами.

## Выборка из БД

`db.<коллекция>.find({<объект_запроса> | {}}[, <объект_проекции>])` - возвращает выборку в виде курсора из содержимого коллекции, которое удолетворяет запросу. Где:
- `<объект_запроса>` - это простой JSON объект, который содержит ключи, по которым нужно искать и значения с которыми нужно сравнивать, значение может быть регулярным выражением. Объект должен быть одновложеным, для подвложености используется: `"<ключ>.<ключ>[....]"`.
    > `{number: 4, languages: ["english", "german"], "selected.0": "english", "person.name": "Tom", group: /T\w+/i}`

    Может быть также функцией JS, которая должна возвращать `true` если документ подходит иначе `false`, в которой `this` указывает на текущий документ.

- `<объект_проекции>` - это простой JSON объект, который содержит ключи, которые нужно отобразить, значение `true` (`1`) - указывает что свойство нужно отобразить, `false` (`0`) - не нужно. Объект должен быть одновложеным, для подвложености используется: `"<ключ>.<ключ>[....]"`. Для массивом может использоваться опрератор `$slice`, который бывает двух видов:
    - `$slice: <количество>` - где `<количество>` - указывает на общее количество возвращаемых элементов из массива, отрицательное количество обозначает с конца;
    - `$slice: [<смещение>, <количество>]` - где `<смещение>` - указывает на смещение относительно начала, отрицательное количество обозначает с конца, а `<количество>` - указывает на общее количество возвращаемых элементов из массива;
    > `db.users.find ({name: "Tom"}, {languages: {$slice : [-1, 1]}});`

`db.<коллекция>.findOne({<объект_запроса> | {}}[, <объект_проекции>])` - только извлекает первый документ коллекции.

`<выборка>.limit(<количество>)` - возвращает выборку, которая ограничина указанным количеством документов.  
`<выборка>.skip(<количество>)` - возвращает выборку, у которой пропущенно указанное количество документов.  
`<выборка>.sort(<объект_сортировки>)` - возвращает выборку, у которой отсортированы документы по `<объект_сортировки>`, который содержит ключи, которые нужно отсортировать, значение `1` - по возрастанию, `-1` - по убыванию, ключ `$natural` - обозначает сортировку в порядке добавления в коллекцию.

### Курсоры

Результат выборки, получаемой с помощью функции `find`, называется курсором. Курсоры инкапсулируют в себе наборы получаемых из бд объектов.

`var <курсор> = db.<коллекция>.find(); null;` - выражение `null` позволяет сразу же не выводить все содержащиеся в курсоре данные.

`<курсор>.hasNext()` - возвращает `true`, если имеется ли еще в наборе документ.  
`<курсор>.next()` - возвращает (извлекает) текущий документ и перемещает курсор к следующему документу в наборе.  
`<курсор>.forEach(function (obj) {...})` - перебирает элементы курсора, где `obj` текущий документ перебора.

К курсору применимы все теже функции что и к выборке, так как это одно и тоже.

```javascript
var cursor = db.users.find(); null;
while (cursor.hasNext()) {
    obj = cursor.next();
    print(obj["name"]);
}
```

### Команды группировки

`<выборка>.count([true])` - возвращает число элементов в коллекции[, с учетом примененных ранее функций `limit` и `skip`].

`<выборка>.distinct("<ключ>")` - возвращает уникальные значения ключа в виде массива.

```javascript
<выборка>.group({
    key: {<ключ>: true[, ...]}, // указывает на ключи, по которым надо проводить группировку

    initial: {<ключ>: <значение>[, ...]}, // представляет базовое значение (начальный объект) для каждого сгруппированного результата

    reduce: function (obj, result) {...}, // представляет функцию, для агрегации, для каждого сгруппированного результата. Эта функция принимает в качестве аргументов два параметра obj - текущий документ перебора, result - результат для групировки, изначально равен значению ключа initial

    [, keyf: function () {} // используется вместо параметра key и представляет функцию, которая возвращает объект key]

    [, cond: // представляет собой условие, которое должно возвращать true, иначе документ не примет участия в группировке. Если данный параметр неуказан, то в группировке участвуют все документы]

    [, finalize: // представляет функцию, которая срабатывает перед тем, как будут возвращены результаты группировки]
})
```

`db.users.group({key: {name : true}, initial: {total : 0}, reduce : function (obj, result){result.total += 1}})`

### Операторы

#### Условные операторы

Условные операторы задают условие, которому должно соответствовать значение поля документа:
- `$eq` - равно;
- `$ne` - не равно;
- `$gt` - больше чем;
- `$lt` - меньше чем;
- `$gte` - больше или равно;
- `$lte` - меньше или равно;
- `$in` - определяет массив значений, одно из которых должно иметь поле документа;
- `$nin` - определяет массив значений, которые не должно иметь поле документа.

Используются в объекте `<объект_запроса>` для метода `find`:  
`<ключ>: {<оператор>: <значение>[, ...]}`

> `db.users.find({age: {$nin : [22, 32]}})`

#### Логические операторы

Логические операторы выполняются над условиями выборки:
- `$or` - соединяет два условия, и документ должен соответствовать одному из этих условий;
- `$and` - соединяет два условия, и документ должен соответствовать обоим условиям;
- `$not` - документ должен НЕ соответствовать условию;
- `$nor` - соединяет два условия, и документ должен НЕ соответстовать обоим условиям.

Используются в объекте `<объект_запроса>` для метода `find`:  
`<оператор>: [<значение1>[, ...]]`

> `db.users.find({name: "Tom", $or: [{age: 22}, {languages: "german"}]})`

#### Поиск по массивам

Ряд операторов предназначены для работы с массивами:
- `$all` - определяет массив возможных выражений и требует, чтобы документы имели весь определяемый набор выражений. Соответственно он применяется для поиску по массиву
    > `db.users.find({languages: {$all : ["english", "french"]}})`
- `$size` - определяет количество элементов, которые должны быть в массиве
    > `db.users.find({languages: {$size:2}})`
- `$elemMatch` - определяет условие, которым должны соответствовать элемены в массиве
    > `db.grades.find({courses: {$elemMatch: {name: "MongoDB", grade: {$gt: 3}}}})`

#### Оператор `$exists`

Оператор `$exists` позволяет извлечь только те документы, в которых определенный ключ присутствует при значении `true` или отсутствует при значении `false`.

> `db.users.find({company: {$exists: true}})`

#### Оператор `$type`

Оператор `$type` извлекает только те документы, в которых определенный ключ имеет значение определенного типа, например, строку или число.

> `db.users.find({age: {$type: "string"}})`

#### Оператор `$regex`

Оператор `$regex` задает регулярное выражение, которому должно соответствовать значение поля. `$regex` принимает не просто строки, а именно регулярные выражения.

> `db.users.find({name: {$regex: "b"}})`

## Обновление данных

`db.<коллекция>.save(<документ>)` - обновляет документ при наличии ключа `_id`, если он совпадает с документом с таким значением `_id` иначе вставляет документ и если нет ключа `_id`, то генерирует его. Возвращает объект `WriteResult` с ключами:
- `nInserted` - количество вставленных записей.

`db.<коллекция>.update(<объект_запроса>, <документ>[, {[upsert: true,][multi: true]}])` - обновляет выборку документов по запросу `<объект_запроса>` новым документом `<документ>`, где при:
- `upsert: true` - будет обновлять документ, если он найден, и создавать новый, если такого документа нет;
- `multi: true` - указывает что должны обновляться все документы в выборке.

Возвращает объект `WriteResult` с ключами:
- `nMatched` - количество выбраных записей;
- `nUpserted` - количество вставленных записей;
- `nModified` - количество измененных записей.

> `db.users.update({name : "Tom"}, {name: "Tom", age : 25}, {upsert: true})`

Изменение отдельных полей для этого вместо документа `<документ>` передается специальный объект с ключами:
- `$set: {<ключ>: <значение>[, ...]}` - обновляет только указаные поля, в документах из выборки
    > `db.users.update({name : "Tom"}, {$set: {name: "Tom", age: 25}}, {multi: true})`
- `$inc: {<ключ>: <значение>[, ...]}` - увеличивает значения числового поля на определенное количество единиц;
- `$unset: {<ключ>: true[, ...]}` - удаляет заданые ключи, в документах из выборки;
- `$push: {<ключ>: <значение>[, ...]}` - добавляет еще одно значение к уже существующему массиву;
- `$push: {$each: [<значение1>[, ...]][, $position: <позиция_вставки>][, $slice: <количество_оставленых_элементов>]}` - добавляет значения к уже существующему массиву;
    > `db.users.update({name : "Tom"}, {$push: {languages: {$each: ["german", "spanish", "italian"], $position:1, $slice:5}}})`
- `$addToSet: {<ключ>: <значение>[, ...]}` - добавляет значение к уже существующему массиву, если его нет в массиве;
- `$pop: {<ключ>: <номер>[, ...]}` - удаляет элемент по номеру из массива с конца, при отрицательном значении с начала;
- `$pull: {<ключ>: <значение>[, ...]}` - удаляет все элементы по значению из массива;
- `$pullAll: {<ключ>: [<значение1>[, ...]]}` - удаляет все элементы по указаным значениям из массива
    > `db.users.update({name : "Tom"}, {$pullAll: {languages: ["english", "german", "french"]}})`

`db.<коллекция>.updateOne(<объект_запроса>, <документ>)` - обновляет только один документ.  
`db.<коллекция>.updateMany(<объект_запроса>, <документ>)` - обновляет все документы из выборки.

## Удаление данных

`db.<коллекция>.remove(<объект_запроса>[, true])` - удаляет документ по запросу `<объект_запроса>`[ все документы из выборки].

`db.<коллекция>.remove({}, true)` - удаляет все элементы в коллекции.

`db.<коллекция>.drop()` - удаляет коллекцию.

`db.dropDatabase()` - удаляет текущую БД.

## Установка ссылок в БД

MongoDB позволяет как и в реляционных базах данных устанавливать внешние ключи, когда поля из одного документа ссылаются на поля в другом документе.

Ручная установка ссылок сводится к присвоению значения поля `_id` одного документа полю другого документа.

### Автоматическое связывание

Для этого используется `DBRef`, который устанавливает автоматическое связывание между документами.

`<ключ>: new DBRef("<коллекция>", <ид_записи>[, "<БД>"])`

У `DBRef` есть свойства:
- `$ref` - название коллекции;
- `$id` - значение;
- `$db` - название бд.

```javascript
apple = ({"name": "apple", "year": 1976})
db.companies.save(apple)
steve = ({"name": "Steve", "age": 25, company: new DBRef('companies', apple._id)})
db.users.save(steve)
db.companies.findOne({_id: steve.company.$id})
```

## Индексы

Индексы позволяют упорядочить данные по определенному полю, что впоследствии ускорит поиск.

`db.<коллекция>.createIndex({<ключ>: true[, ...]}[, {"unique" : true}])` - создает индекс по указанным полям[, которые должны быть уникальны в рамках коллекции].

`db.<коллекция>.getIndexes()` - возвращает все индексы коллекции.

`db.system.indexes.find()` - возвращает все индексы всех коллекций.

`db.<коллекция>.dropIndex("<имя_индекса>")` - удаляет индексы по имени из коллекции.

## Управление коллекциями

`db.createCollection("<коллекция>"[, <опции>])` - явное создание коллекции. Где `<опции>` - объект со свойствами:
- `capped` - при значении `true` обозначает что документы будут располагаться в коллекции в том же порядке, в котором они добавлялись в коллекцию;
- `size: <количество>` - указывает максимальный размер коллекции в байтах;
- `max: <количество>` - указывает максимальный размер коллекции в количестве документов, если все место под коллекцию заполнено, а количество документов еще не достигло максимума, то в этом случае при добавлении нового документа самый старый документ будет удаляться, а на его место будет вставляться новый документ.

`db.<коллекция>.renameCollection("<новое_имя>")` - переименовывает коллекцию.

## Подколлекции

Для упрощения организации данных в коллекциях можно использовать подколлекции. Эти коллекции ни как не связаны с основной колекцией. Они создаются как:

`db.<коллекция>.<подколлекция>`