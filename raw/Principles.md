Принципы наименования
=====================

Чем больше делает код, тем сложнее дать ему имя.

## Общие правила

Чем больше область видимости, тем длиннее нужно называть переменную, чем меньше область видимости, тем короче можно ее называть.

Чем длиннее область использования класса или метода, тем короче должно быть название.

- **конкретность** - именование, должно содержать в своем имени, как конкретность того что оно обозначает, так и краткость, но конкретность не должна страдать из-за краткости;
    > `removeObjectAtIndex` - хорошо  
    > `remove` - плохо, нет конкретики что именно удаляется
- **сокращения** - в общих случаях, сокращения нужно избегать, так как они могут быть неоднозначными;
    > `setBackgroundColor` - хорошо  
    > `setBkgdColor` - плохо
- **двусмысленость** - необходимо называть методы конкретными именами, чтобы методы могли интерпритироваться только одним способом;
    > `sendPort` - двусмысленость, так как не понятно, порт устанавливается или возвращается

### Префиксы

**Префиксы** - префиксы позволяют обезопасить пересечение именований между разными библиотеками или стандартными функциям. Префикс должен состоять из двух или трех букв в верхнем регистре и использоваться только при именовании классов, функций, констант или структур, но не в именованиях методов или полей.
> `AB` - Address Book  
> `ABStorage` - Address Book Storage  
> `IB` - Interface Builder  

### Типографические условные обозначения

Для именований, которые состоят больше чем из одного слова, используется *CamelCase* нотация, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово внутри фразы пишется с заглавной буквы.
> `fileExistsAtPath`  
> `UIApplication`  
> `ApplicationKit`  

Имя класса должно содержать существительные, которые конкретно указывают, что класс представляет или что он делает.

### Имена файлов

Каждый класс, если он не часть группы, должен объявляться в отдельном файле с именем, которое будет равно имени класса.
> `Locale.<расширение>` - содержит только класс `Locale`

Группа связанных классов или сущностей, должна объявляться в файле, с именем главного класса.
> `Lock.<расширение>` - содержит классы `Lock`, `ConditionLock` и `RecursiveLock`

Классы, которые расширяют классы другого фреймворка (добавляют методы), именуются с помощью суффикса `"Additions"` к имени оригинального класса.
> `<Класс>Additions.<расширение>` - содержит класс, который расширяет класс `<Класс>`

Связанные функции, типы, константы, структуры помещаются в соответствующий файл, с именем их общности.

### Области видимости

Если переменная, метод или функция должны обладать определенной областью видимостью, то нужно воспользоваться стандартными средствами, иначе применить префиксы:
- `_` - для **private**:
    > `_cell`
- `$` - для **protected**:
    > `$cell`

### Сокращения

Сокращение | Значение
---------- | --------
`alt`      | Alternate
`app`      | Application
`calc`     | Calculate
`func`     | Function
`info`     | Information
`init`     | Initialize
`max`      | Maximum
`min`      | Minimum
`msg`      | Message
`temp`     | Temporary

## Именование свойств и переменных

Имя переменной экземпляра должно кратко описывать хранимый атрибут.

Если переменная представлена существительным, то она должна быть определенным типом, на который она ссылается и иметь имя существительного.
> `title`

Если переменная представлена глаголом, то она должна быть булевым типом и иметь имя начинающее с глагола (должен быть в *simple present tense*).
> `showsAlpha`

Если переменная представлена прилагательным, то она должна быть булевым типом и иметь имя прилагательное.
> `editable`

Если свойство не должно использоваться вне или у него есть методы доступа, то его обычно именуют с помощью префикса `_`.

Константы в большинстве случаем пишутся заглавными буквами и разделяются с помощью `_`.
> `DEBUG_TYPE`

## Именование перечислений (Enum)

Имя перечисления должно быть существительным, а его значения - должны быть прилагательными или наречиями, потому что они всегда описывают либо состояния, либо какую-то характеристику объекта, то есть это Color, FuelType, DriveStatus - это все прилагательные.

## Именование методов и функций

### Схема имени

[`<префикс>`] + `<действие>` + `<высокоуровневый_контекст>` + [`<низкоуровневый_контекст>`]

Где:
- `<префикс>` - расширяет смысл функции, некоторые:
    - `is` - используется для описания наличия свойства в общем или состояние текущего контекста - для прилагательных / глаголов, имеет логическое значение:
        > `isPresent`
    - `has` - используется для описания наличия определенного свойства или состояния - для существительных, имеет логическое значение:
        > `hasProducts`
    - `should` - используется для описания наличия положительного результата связанного с определенным действием:
        > `shouldUpdateUrl`

- `<действие>` - это глагольная часть имени функции, которая описывает что именно функция делает, некоторые:
    - `get` - используется для обозначения немедленного доступа к данным:
        > `getFruitsCount`
    - `set` - используется для безусловного присваивания данных:
        > `setFruits`
    - `reset` - используется для сброса к начальному значению или состоянию:
        > `resetFruits`
    - `fetch` - используется для получения данных для которого требуется время:
        > `fetchPosts`
    - `remove` - используется для удаления чего-то откуда-то:
        > `removeFilter`
    - `delete` - используется для полного стирания чего-то:
        > `deletePost`
    - `compose` - используется для создания новых данных из существующих:
        > `composePageUrl`
    - `handle` - используется для обработки действий:
        > `handleLinkClick`

- `<высокоуровневый_контекст>` - это область работы функции, то над чем производися действие;
- `<низкоуровневый_контекст>` - это область работы функции, то над чем производися действие, более уточненный контекст.

### Общие правила

Имя должно быть в нотации *CamelCase*, без использования префиксов.

Для методов, которые представляют собой действия, которые принимает объект над которым это действие было вызвано, должны начинаться с глаголов.
> `invokeWithTarget(target)`

Если метод возвращает свойство объекта, имя этого метода должно быть именем свойства.
> `cellSize()` - хорошо  
> `getCellSize()` - плохо

Необходимо писать слова в конце имени метода, которые описывают аргумент с помощью которого работает этот метод.
> `viewWithTag(aTag)` - хорошо  
> `taggedView(aTag)` - плохо

### Методы доступа

Это методы, которые возвращают или устанавливают свойства объекта. Именуются:
- если свойство `<свойство>` выражено как существительное, то:
    - `<свойство>()` - получение значения;
    - `set<Свойство>(a<Свойство>)` - установка значения;
    > `title()`  
    > `setTitle(aTitle)`

- если свойство `<свойство>` выражено как прилагательное, то:
    - `is<Свойство>()` - получение значения, должно возвращать `true` или `false`;
    - `set<Свойство>(flag)` - установка значения, где `flag` может быть `true` или `false`;
    > `isEditable()`  
    > `setEditable(flag)`

- если свойство `<свойство>` выражено как глагол (должен быть в *simple present tense*) в виде `<глагол><Объект>` (`verbObject`), то:
    - `<свойство>()` - получение значения, должно возвращать `true` или `false`;
    - `set<Свойство>(flag)` - установка значения, где `flag` может быть `true` или `false`;
    > `showsAlpha()`  
    > `setShowsAlpha(flag)`

    Глагол в методе не должен превращаться в прилагательное с помощью причастия.  
    Для уточнения смысла, можно использовать различные модальные глаголы ("can", "should", "will"), но не "do" или "does".

### Методы изменения коллекций

Для объектов, которые реализуют управление коллекциями объектов (имя коллекции задается в виде множественного числа тех объектов, которые он принимает), тогда для каждой коллекции должны быть методы:
- `add<ЭлементКоллекции>(<элементКоллекции>)` - для добавления элемента в коллекцию;
- `remove<ЭлементКоллекции>(<элементКоллекции>)` - для удаления элемента из коллекции;
- `<имяКоллекции>()` - для получении коллекции;
- `insert<ЭлементКоллекции>(<элементКоллекции>, index)` - для добавления элемента в коллекцию по определенному индексу;
- `remove<ЭлементКоллекции>AtIndex(index)` - для удаления элемента из коллекции по индексу;
> `addLayoutManager(layoutManager)`  
> `removeLayoutManager(layoutManager)`  
> `layoutManagers()`  
> `insertLayoutManager(layoutManager, index)`  
> `removeLayoutManagerAtIndex(index)`

### Аргументы методов

Для указания того, что аргумент может быть любым представителем указаного класса, можно использовать префиксы `a` / `an`, а дальше имя класса в нотации *CamelCase*.
> `aSelector`  
> `anObject`

## Именование классов

Каждый класс в своем имени должен хранить информацию о том зачем он нужен или по его области видимости должно быть это ясно. Для этого могут быть использоваться суффиксы и префиксы:
- `Coordinator` - для координации объектов;
- `Builder` - для создания экземпляров по шагам;
- `Writer` - для записи;
- `Reader` - для чтения;
- `Handler` - для обработки;
- `Container` - для хранения;
- `Protocol` - для реализации протокола;
- `Converter` - для преобразования;
- `Controller` - для управления;
- `View` - для отображения;
- `Factory` - для создания экземпляров;
- `Entity` - для сущности.

Каждый раз делая наследника, в название добавляется прилагательное, для того, чтобы расширить его или сделать от него экземпляр. Чем больше цепочка наследования тем длиннее имена.

Комментарии в коде
==================

Главные проблемы комментариев - это:
- **устаревание** - при рефакторинге кода и создании новых функций разработчики часто забывают их актуализировать;
- **избыточность** - часто содержимое комментариев очень избыточно и делают код больше, не неся в себе смысл.

**Универсальная стратегия избавления от комментариев** - использовать временные переменные с правильно подобранными именами или названия методов, передающие их назначение.

Правильное присваивание имен - это мощный инструмент, позволяющий заменить комментарии и помочь писать самодокументируемый код. Благодаря этому код можно безжалостно рефакторить, не боясь, что комментарии не будут соответствовать коду.

Комментарии должны использоваться, когда они отвечают на вопрос **"зачем?"**, а на **"что?"**, и когда **"зачем?"** нельзя объяснить именами.

## Пример рефакторинга кода

Исходный код:
```python
# Seller is eligible to be paid under the following conditions:
# 1. It's past 2020/5/1 when we got legal approval to make payouts
# 2. It’s Nov/Dec since those are the only months eligible
# 3. User is not from list of countries that are banned
today = date.today()
if today > date(2020, 1, 1) and (today.month == 11 or today.month == 12) and user.country not in ['Narnia', 'Odan', 'Maldonia']:
    # This function does the actual payout by calling Stripe
    # It saves the response asynchronously.
    payoutHandler()
```

Отрефакторенный без использования комментариев:
```python
PAYOUT_APPROVAL_DATE = date(2020, 5, 1)
BANNED_COUNTRIES = ['Narnia', 'Odan', 'Maldonia']
NOVEMBER, DECEMBER = 11, 12
ELIGIBLE_MONTHS = [NOVEMBER, DECEMBER]
today = date.today()
is_past_approval_date = today > PAYOUT_APPROVAL_DATE
is_eligible_month = today.month in ELIGIBLE_MONTHS
is_user_from_banned_country = user.country in BANNED_COUNTRIES
if is_past_approval_date and is_eligible_month and not is_user_from_banned_country:
    stripe_payout_resp = callStripeToPayout(user)
    saveResponseAsync(stripe_payout_resp)
```

Обдуманное программирование
===========================

Основные рекомендации:
- необходимо стараться всегда понимать что сейчас вы делаете, чтобы не оказаться в ситуации, когда разрабатываемый код перестает внезапно работать, когда он прежде работал;
- разрабатываемый код должен писаться так, чтобы быть подробно объяснен менее опытному программисту и это позволит исключить совпадения в разработке;
- не программировать в темноте - то есть не использовать технологии, которые не понимаете или приложения, которые не поняты, то есть вероятность не знать причин почему она работает и почему она не сможет не работать;
- разрабатывать на основании плана;
- полагаться только на факты, а не на предположения, или выбирать из предположений только худшие варианты;
- документирование предположений позволит прояснить свои предположения или поделиться ими;
- тестирование не только кода, но и предположений позволяет улучшить документирование кода;
- разработка на основании приоритетов, так как важные аспекты становятся прочными и верными основами;
- старый или текущий код не должен диктовать условия будущему коду, можно его даже весь заменить, если он не годиться. То что сделано не должно накладывать ограничения на то что будет сделано.

Рефакторинг
===========

**Рефакторинг** - это практическое подмножество переписывания, переработки и переделки архитектуры кода. Это дисциплинированная методика перестройки структуры существующего теля кода, изменение его внутренней структуры без изменения его внешнего поведения.

Причины рефакторинга:
- **Дублирование знаний** - нарушается принцип DRY.
- **Неортогональный дизайн**.
- **Устаревшие знания** - из-за изменения обстоятельств, смены требований или расширения знаний решаемой задачи.
- **Применение системы**.
- **Производительность системы**.
- **Прохождение тестов** - из-за появления новых тестов или их изменения.

Функциональное программирование
===============================

**Функциональная программа** - программа, состоящая из чистых функций.

Функция `f` является **чистой** если выражение `f(x)` является ссылочно прозрачным для всех ссылочно прозрачных `x`.

**Ссылочная прозрачность** - свойство, при котором замена выражения на вычисленный результат этого выражения не изменяет желаемых свойств программы.
