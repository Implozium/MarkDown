Микрофронтенды
==============

**Микрофронтенд** - это концепция, которая распространяет принципы архитектуры микросервисов на мир фронтенда - фронтенд-приложения декомпозируют на части, которые можно разрабатывать, тестировать и развертывать независимо друг от друга.

Разбиение происходит по такой логике:
- каждый микрофронтенд отвечает за отдельную функцию или область приложения;
- микрофронтенды объединяют в целостный пользовательский опыт.

Основные преимущества микрофронтендов:
- **повышение организационной гибкости**, что позволяет различным командам работать параллельно, не завися друг от друга при развертывании;
- **можно использовать несколько технологических стеков** в зависимости от задач;
- **упрощение управления кодом**, так как каждая команда управляет только тем кодом, который относится к ее функциональности, что значительно облегчает сопровождение: обновление или исправление одного раздела не вызовет непредвиденных последствий в других частях приложения;
- **более управляемое масштабирование** из-за того, что каждый микрофронтенд развернут независимо от остальных;
- **повышение отказоустойчивости**, так как изоляция микрофронтендов повышает общую устойчивость приложения и в случае отказа микрофронтенда откажет только этот микрофронтенд;
- **ускорение времени выхода на рынок**  из-за того, что дает возможность разрабатывать, тестировать и внедрять обновления мелкими порциями, что позволяет больше экспериментировать и оперативно реагировать на изменения рынка.

Основные компоненты:
- **модули микрофронтенда** - это основные элементы архитектуры. Каждый модуль - это определенная бизнес-область или функциональность. Модули разрабатывают, тестируют и развертывают независимо друг от друга;
- **слой композиции** - отвечает за сборку различных модулей микрофронтенда в целостное приложение, а также управляет потоком данных и взаимодействием между клиентом и сервером. Компоновка модулей может происходить на стороне сервера, на стороне клиента или с помощью гибридного подхода;
- **маршрутизация** - отвечает за то, что запросы будут направляться к нужному микрофронтенду, что помогает сохранить модульность приложения (независимость микрофронтендов друг от друга) и при этом обеспечить плавную навигацию для пользователей;
- **коммуникационный слой** - управляет взаимодействием между микрофронтендами и остальной инфраструктурой приложения посредством API, шины сообщений или собственных систем событий.

## Стратегии проектирования микрофронтендов

### Стратегия вертикальной нарезки

**Стратегия вертикальной нарезки** основана на *предметно-ориентированном проектировании* (Domain-Driven Design, DDD), что предполагает, что приложение делится на **домены** (domain) - предметные области, которые описывают разные цели бизнеса.

Суть вертикальной нарезки в том, чтобы спроектировать каждый микрофронтенд как самодостаточную систему, которая соответствует отдельной бизнес-функции. Тогда он будет включать всю необходимую внешнюю логику: от пользовательского интерфейса до уровня получения данных, который относится к его области.

Плюсы:
- каждый микрофронтенд предоставляет полный набор функций, который можно разрабатывать, тестировать и развертывать независимо от других;
- снижает зависимость между командами;
- упрощает управление проектами и масштабирование.

Минусы:
- тяжело определить границы каждого домена, так как на это влияет бизнес и тщательное планирование разработки.

Использование:
- когда есть **сложные пользовательские интерфейсы**, которые обслуживают разные бизнес-функции;
- когда есть **кросс-функциональные команды** вокруг бизнес-возможностей или клиентских путей, а не технологических стеков.

### Стратегия автономность команд

**Стратегия автономность команд** основана на том, что каждая команда имеет возможность выбрать технологический стек, который подходит под ее задачи и использовать сильные стороны технологий, чтобы достичь оптимальной производительности и удобства работы пользователей.

Плюсы:
- способствует росту инноваций;
- помогает создавать более адаптированные технические решения;
- ускоряет разработку и улучшает качество продукта.

Минусы:
- может привести к фрагментации и трудностям в управлении сквозными проблемами (стилизацией, доступностью и общей согласованностью пользовательского опыта).

Использование:
- когда есть **разные технологические потребности** из-за того, что разные части приложения выиграют от разных технологических стеков;
- когда есть **проекты, ориентированные на инновации и эксперименты**.

### Стратегия изоляции

**Стратегия изоляции** основана на том, что у микрофронтендов нет общих зависимостей во время выполнения. То есть каждый микрофронтенд должен включать все свои зависимости. Они инкапсулируются в пакет развертывания микрофронтенда. Общие библиотеки в микрофронтендах будут дублироваться, но их можно совместить с помощью стратегического управления версиями на более широком уровне. Изоляция необходима, чтобы избежать конфликтов версий и облегчить обновление или замену отдельных микрофронтендов.

Плюсы:
- снижается риск того, что изменения в одном микрофронтенде повлияют на другие;
- упрощается обновление и сопровождение, так как не нужно подстраиваться под все приложение.

Минусы:
- общие библиотеки включены в несколько микрофронтендов, и из-за этого размер приложения увеличится.

Использование:
- когда есть **частые обновления и развертывания** в средах, где микрофронтенды должны обновляться часто и независимо друг от друга. Это гарантирует, что обновления не помешают друг другу;
- когда нужно **независимо масштабировать разные части приложения** у которых разные нагрузки и требования к производительности.

## Методы интеграции микрофронтендов

**Build time** - это объединение во время сборки - когда все компоненты помещаюся в контейнер. Мало отличается от монолитного фреймворка так как:
- нужно синхронизировать разные версии библиотек, иначе возникнут проблемы со сборкой;
- сложно использовать разные технологии;
- конечный бандл получится большим, ведь он содержит все зависимости;
- при появлении изменений в зависимостях, придется развертывать пакет заново;
- между контейнером и микрофронтендами будет тесная связь.

Подходит:
- когда нужно **упростить развертывание**, так как интеграция во время сборки ориентирована на единый механизм развертывания и единый исходный код, что дает на выходе единый пакет для развертывания;
- когда нужно **оставить тесное взаимодействие функций**, так как микрофронтенды тесно интегрированы с общими зависимостями;
- когда нужно **оптимизировать производительность**, так как интеграция во время сборки позволяет использовать разные техники оптимизации (tree-shaking, разделение кода), что способствует повышению производительности.

**Run time** - это объединение во время выполнения исполнения кода на стороне пользователя.

Подходит:
- когда нужно **развертывать модули независимо**, что позволит каждой команде развертывать свои изменения, не затрагивая другие части приложения;
- когда нужно **динамически обновлять отдельные модули** без переразвертывания всего приложения;
- когда нужно **сделать масштабирование гибким**, что позволит масштабировать разные части приложения независимо.

## Методы композиции микрофронтендов

Это процесс сборки нескольких микрофронтендов в единое целое.

**Серверная композиция** - когда все микрофронтенды собирают на сервере. Вся функциональность находится в бэкенде. Он решает, какой микрофронтенд собрать и загрузить. Сервер будет решать, к какому URL направить запрос.

Используется когда важен SEO и быстрый первоначальный отклик.

**Клиентская композиция** - когда браузер отвечает за динамическую загрузку каждого микрофронтенда во время выполнения.

Используется когда много интерактивного контента, который меняется в зависимости от взаимодействия с пользователем.

**Гибридная композиция** - состоит из серверной и клиентской композиции и использует для каждого микрофронтенда свой выделенный бэкенд *Backend for Frontend* (BFF). BFF обрабатывает все данные, взаимодействует с API и при необходимости предоставляет клиенту предварительно отрендеренный HTML. Это полезно для начальной загрузки страниц и SEO. Сервер передает клиенту полностью сформированную страницу.

## Инструменты для создания микрофронтендов

### Module Federation

Это отдельный плагин Webpack.

Module Federation позволяет независимым приложениям использовать общий код во время выполнения. Он основан на функции **lazy loading**, которая позволяет приложению загружать фрагменты кода по требованию, что сокращает время первоначальной загрузки и помогает оптимизировать использование ресурсов.

Есть две роли:
- **хост** (host) - это основное приложение, которое при запуске динамически загружает удаленные модули;
- **удаленный модуль** (remote) - это отдельный микрофронтенд, который предоставляет часть своей функциональности хосту или другим удаленным модулям.

Хост и удаленные модули могут использовать **общие зависимости**, используя функцию **shared dependencies**, которая позволяет эффективно управлять версиями и гарантирует, что приложение загрузит одну версию библиотеки, если это возможно.

### Single SPA

Это JavaScript-фреймворк. Он позволяет использовать несколько JavaScript-фреймворков на одной странице, не обновляя ее целиком. Он предназначен для управления маршрутизацией и координацией между различными микрофронтендами.

Основные особенности:
- **framework agnostic** (независимость от фреймворков) - приложение не зависит от какого-то конкретного фреймворка, поэтому можно поддерживать сразу нескольких фреймворков на одной странице;
- **lazy loading** (ленивая загрузка) - приложение загружает фрагменты кода по требованию, что улучшает время первоначальной загрузки и производительность;
- **независимая развертываемость** - каждый микрофронтенд может быть развернут независимо и из-за этого проще поддерживать большие приложения, над которыми работают несколько команд.

Состоит из:
- **root** (рут, корень) - основное приложение, которое подгружает разные микрофронтенды;
- **микрофронтендов**, которые подключают к руту.

## Стратегии управления состоянием

### Взаимодействие на основе API

Коммуникация на основе API подразумевает, что бэкенд и микрофронтенды взаимодействуют через HTTP-запросы. Для обмена данными используют RESTful или GraphQL API.

Подходит когда:
- **микрофронтенды должны взаимодействовать с бэкендом, а не напрямую друг с другом** - они в основном занимаются получением или обновлением данных из централизованного бэкенда;
- **есть простой обмен данными**, которые нужны только чтобы отобразить их в компоненте или отправить форму;
- **есть высокие требования к производительности и масштабируемости**, так как каждый микрофронтенд самостоятельно получает данные и обновляет свое состояние, что позволяет каждому микрофронтенду обеспечить независимое масштабирование и оптимальную производительность.

### Паттерн Pub/Sub

Используется паттерн проектирования **Pub/Sub**, при котором компоненты системы выступают в роли **издателей** (publisher) или **подписчиков** (subscriber). При таком подходе компоненты не знают о существовании друг друга, они взаимодействуют только с **событиями** - публикуют их или подписываются на них.

**Event Bus** (шина событий) - это система обмена сообщениями, которая основана на паттерне **Pub/Sub**. События публикуются в шине событий. Компоненты-подписчики регистрируются в шине и указывают список событий, которые они хотят получать. Шина событий разделяет микрофронтенды, убирает взаимозависимость и обеспечивает гибкость.

Подходит когда:
- **предпочтительно несвязанное соединение** между микрофронтендами, что позволяет им взаимодействовать без прямых зависимостей, что упрощает добавление, удаление или обновление микрофронтендов;
- **используется архитектура, управляемая событиями** (event-driven architecture, EDA) - действия или обновления в одной части приложения вызывают реакции в других частях и это эффективно для обновлений в реальном времени и асинхронных коммуникаций;
- **есть независимое развертывание**, так как помогает отделить логику взаимодействия от фактической реализации.

### Библиотека глобального состояния

При использовании библиотеки глобального состояния разные микрофронтенды могут получить доступ к общему состоянию и изменять его. Библиотека сама ходит в базу данных через API и обновляет данные на фронтенде.

Этот подход гарантирует, что все части приложения синхронизируются и последовательно взаимодействуют с пользователем.

Подходит когда:
- **есть тесная связь между разными частями приложения** и нужно, чтобы разные части приложения совместно использовали глобальное состояние и информация там всегда была актуальной, так как несколько микрофронтендов читают из одного состояния и записывают в него обновления;
- **важно поддерживать последовательный пользовательский опыт**, это получается благодаря общему состоянию, из-за которого поддерживается единообразие и согласованность в разных частях приложения;
- **есть сложные требования к управлению состояниями** и когда оно вложенное или иерархическое.

## Паттерн Backend for Frontend

**Backend for Frontend** (бэкенд для фронтенда, BFF) - это подход к проектированию, при котором каждый фронтенд обслуживает специальный бэкенд - промежуточный слой между фронтендом и внутренними сервисами, для того чтобы абстрагировать фронтенд от сложностей бэкенда. BFF отвечает за сбор информации от разных микросервисов, ее обработку и доставку на фронтенд в удобном формате.

Используется при архитектурах когда есть:
- **монолитный фронтенд и микросервисы** - для того чтобы абстрагировать фронтенд от сложностей бэкенда;
- **несколько клиентов, которые используют разные технологии для передачи данных** - для того чтобы не усложнять бекенды поддержкой разных технологий;
- **микросервисы и микрофронтенды** - для организации взаимодействие между ними.

Этот подход позволяет:
- **подготавливать данные для конкретного фронтенда**, что снижает необходимость дополнительной обработки данных на стороне клиента;
- **упростить логику на стороне клиента**, так как обрабатывает сложные логические операции на стороне сервера - агрегацию, композицию и преобразованию данных, что снижает сложность кода фронтенда и улучшает его сопровождение;
- **увеличить производительность**, так как передается меньше данных по сети и выполняется меньше запросов из фронтенда;
- **усилить безопасность**, так как запросы пользователей на BFF могут аутентифицироваться и авторизовываться перед передачей внутренним службам.

Микросервисы
============

## Паттерн Strangler Fig

Этот паттерн предлагает итеративный подход к миграции от монолита к микросервисам, когда новую систему постепенно создают по краям старой: компоненты по очереди извлекают из монолита и заменяют на микросервисы. При релизе каждого микросервиса запросы от монолита перенаправляют к новой системе. В итоге бэкенд отмирает по кусочкам, а команда может дорабатывать готовые микросервисы по отзывам пользователей.

Такой подход позволяет постоянно совершенствовать систему и минимизировать риски, которые связаны с большими изменениями.

Основные преимущества:
- **постепенная замена монолита**, что позволяет уменьшить количество сбоев и повысить адаптивность новой системы из-за того, что части монолита заменяются микросервисами итеративно;
- **снижение рисков и управление ими**, так как инкрементные изменения небольшие, то их легче тестировать, отслеживать и откатывать, что уменьшает количество сбоев. Микросервисы запускают параллельно с существующими монолитными компонентами, что позволяет в случае проблем перенаправить запросы обратно на компонент монолита с помощью маршрутизации;
- **инкрементная доставка новых функций в процессе миграции** из-за того, что приложение продолжает развиваться и новые функции и улучшения можно релизить по готовности не дожидаясь окончания миграции;
- **эффективное решение проблемы технического долга**, так как есть систематический рефакторинг вследствие того, что каждый микросервис можно спроектировать и разработать с использованием лучших практик и современных технологий, а также позволит разработать документацию и поддержать стандарты. В первую очередь замена начинается с устаревших компонентов, тогда каждое обновление будет повышать производительность системы и упрощать ее обслуживание.

Шаги по реализации паттерна Strangler Fig:
1. **Определение компонента, который нужно извлечь из монолита** - нужно определить и приоритизировать компоненты монолитного приложения, которые должны быть извлечены. Компонент выбирается с помощью техник:
    - **анализ домена бизнеса** - основан на Domain-Driven Design (DDD) и представляет из себя разделение приложения на домены, которые представляют собой ограниченный контекст бизнес-проблем и целей. Применяется когда монолитное приложение содержит сложную бизнес-логику и поддерживается крупными командами и эта техника помогает структурировать код так, чтобы он лучше отражал бизнес-процессы и был проще в сопровождении и развитии;
    - **технический анализ** - представляет из себя разделение приложения по части кода, который часто меняются или который сложно поддерживать - тесно связанные компоненты, помогает выявить скрытые зависимости и взаимодействия, которые не видны только при бизнес-анализе;
    - **анализ показателей производительности** - представляет из себя разделение приложения по компонентам, вызывающих проблемы с производительностью или требующих больших ресурсов. Применяется в приложениях, которым необходимо эффективное масштабирование.

2. **Проектирование и разработка нового микросервиса** с учетом принципов проектирования:
    - у микросервиса есть единственная, четко определенная зона ответственности;
    - микросервис должен минимально зависить от других сервисов;
    - связанная функциональность должна быть сгруппирована в рамках одного сервиса для поддержания высокой согласованности.

3. **Перенаправление запросов от монолита к микросервису** с помощью:
    - **маршрутизации на основе прокси**:
        - **обратный прокси-сервер**, который будет использоваться для маршрутизации запросов либо к монолиту, либо к новым микросервисам на основе определенных правил;
        - **API-шлюз** - реализуется для управления и маршрутизации трафика, обеспечивая единую точку входа для всех клиентских запросов;
    - **фича-тогглов** - (переключатели функций), которые нужны для управления развертыванием новых функций, чтобы постепенно перенаправлять трафик на новые сервисы;
    - **канареечных релизов**, которые постепенно переводят трафик на новые микросервисы, отслеживая производительность и стабильность перед полным развертыванием.

4. **Внедрения мониторинга и верификаци для микросервиса**. Для оценки производительности и надежности микросервисов используются количественные показатели - **метрики производительности** для каждого микросервиса с пороговым значением уровня производительности:
    - **ключевые показатели эффективности** (Key Performance Indicators, KPI), которые состоят из показателей:
        - времени отклика;
        - частоты ошибок;
        - пропускной способности;
        - количество запросов в секунду.
    - **цели уровня сервиса** (Service-Level Objectives, SLO) - это четко определенные цели в области производительности и доступности сервиса, которые ставятся на основе бизнес-требований, таких как время безотказной работы или время отклика;
    - **индикаторы уровня обслуживания** (Service Level Indicator, SLI) - это количественная оценка работы сервиса, показывающая, выполняются ли SLO, определяются для критических показателей и отслеживаются на соответствие с заданными SLO. К ним относят:
        - латентность - время, необходимое для обработки запроса;
        - доступность - доля времени, в течение которого сервис работает;
        - частота ошибок.

    Для отслеживания производительности, работоспособности и доступности сервисов используются **средства мониторинга**, которые собирают и анализируют данные, чтобы помочь обнаружить проблемы и обеспечить бесперебойную работу служб:
    - **мониторинг производительности приложений** (Application Performance Monitoring, APM), которые отслеживают производительность приложений и отдельных микросервисов в режиме реального времени, предоставляют информацию о времени отклика, количестве ошибок и взаимодействии с пользователями;
    - **централизованное логирование**, которые объединяют журналы различных служб в одном месте, что упрощает поиск, анализ и устранение проблем;
    - **мониторинг инфраструктуры**, которые следят за состоянием и производительностью базовой инфраструктуры (серверы, контейнеры, сетевые компоненты и т.п.).

    Для обеспечивания правильного функционирования новых микросервисов в соответствии с ожидаемым стандартом производительности и надежности используются **методы верификации**:
    - **автоматизированное тестирование** - юнит-тесты, интеграционные тесты, e2e-тесты, которые проверяет функциональность, производительность и интеграцию микросервисов на их соответствие заданным критериям при каждом коммите кода в системе контроля версий;
    - **А/B-тестирование** - для того чтобы сравнивать производительность и влияние на пользователей двух версий сайта, приложения или сервиса, чтобы определить, какая из них работает лучше с помощью перенаправления части запросов на новую версию, а остальную часть - на старую.

5. **Возвращение к шагу 1 до тех пор, пока весь монолит не будет заменен на микросервисы**. Состоит из:
    - **инкрементального извлечения**, которое предполагает разбиение монолитного приложения на более мелкие, управляемые компоненты и постепенную замену их микросервисами;
    - **непрерывного улучшения**, которое направлено на регулярное усовершенствование новых микросервисов с помощью рефакторинга и оптимизации (по мере необходимости) и всей системы в целом, на основе данных о производительности с помощью инструментов APM, анализу обратной связи и меняющихся потребностей бизнеса;
    - **координации работы команды** с помощью сотрудничества между кросс-функциональными командами - разработки, эксплуатации и бизнеса для согласования целей и прогресса, четкой коммуникации с помощью регулярных встреч которые необходимы для обсуждения прогресса, выявления препятствий и планирования следующих шагов, и последовательного документирование на протяжении всего процесса для обеспечения последовательности и обмена знаниями.

Распространенные проблемы:
- **недостаточное планирование** из-за слишком поспешной реализация миграции без четкого плана;
- **отсутствие поддержки заинтересованных сторон** из-за отсутствия понимания предполагаемых рисков;
- **недостаточный мониторинг и тестирование** из-за неспособности адекватно контролировать новые сервисы, что может привести к незамеченным проблемам, влияющим на производительность;
- **игнорирование зависимостей** между компонентами, которые приводят к сбоям или неожиданному поведению;
- **неполная документация** которая может привести к путанице и несогласованным реализациям;
- **игнорирование проблем управления и обмен данными** между монолитом и микросервисами, которые приводят к несогласованности и проблемам целостности данных.

### Методы расстановки приоритетов

#### MoSCoW

Метод приоритизации **MoSCoW** разделяет требования на четыре категории:
- **Must have** (обязательно);
- **Should have** (нужно);
- **Could have** (желательно);
- **Won't have** (можно перенести).

Используется когда у проекта есть четко определенные бизнес-цели, и необходимо тесно увязать технические задачи с приоритетами бизнеса и в процесс вовлечено множество заинтересованных сторон и их согласие крайне важно.

Используется для стратегического планирования.

#### Матрица Эйзенхауэра

**Матрица Эйзенхауэра** - это инструмент управления временем, который помогает расставить приоритеты задач, разделяя их на четыре категории:
- **срочные и важные**;
- **важные, но не срочные**;
- **срочные, но не важные**;
- **не срочные и не важные**.

Используется когда необходимо учитывать срочность задач и где быстрое принятие решений имеет решающее значение.

Используется для повседневного планирования.

## Anti-Corruption Layer

**Anti-Corruption Layer** (ACL) - это паттерн проектирования помогающий создать границу между новой системой и унаследованной. Через этот уровень проходят все данные, которые системы передают друг другу. ACL знает их форматы и модели данных. Он адаптирует информацию под требования получателя.

Создается с помощью паттернов **Facade** и **Adapter** и располагается в монолите.

Основные задачи ACL:
- **изоляция микросервисов от сложностей и проблем унаследованной системы** для того чтобы повысить шансы на то, что новые системы будут работать эффективно;
- **управление маршрутизацией запросов между монолитом и микросервисами**;
- **адаптация данных под требования разных систем**;
- **инкапсуляция монолитной системы**, чтобы микросервисы взаимодействовали с чистым и последовательным интерфейсом унаследованной системы, что упрощает разработку и сопровождение новых сервисов.

Принцип работы:
1. **Микросервис** взаимодействует с **монолитной системой** - он посылает запрос на **ACL**;
2. **ACL** передает запрос **адаптеру**, чтобы он перевел запрос микросервиса в формат и семантику монолитной системы;
3. **Адаптер** переводит запрос и отправляет его **монолитной системе**;
4. **Монолитная система** обрабатывает запрос и отправляет ответ **адаптеру**;
5. **Адаптер** переводит ответ в формат и семантику микросервиса, а затем передает запрос **ACL**;
6. **ACL** отправляет переведенные данные **микросервису**.

ACL используется только в процессе перехода, позволяя провести постепенную миграцию. ACL выводят из эксплуатации, когда все зависимые сервисы перенесли в архитектуру микросервисов.

Не используется когда:
- прямую интеграцию просто осуществить;
- разрабатывается краткосрочный проект или временное решение;
- критически важна производительность приложения;
- ограниченность ресурсов;
- при внедрении система станет слишком сложной.

Внедрение состоит из указанных шагов:
1. **Определение границ и зависимостей** между унаследованной системой и микросервисами - какие части унаследованной системы будут взаимодействовать с новыми сервисами и должны быть доступны и какие у них будут общие данные, процессы и функциональные возможности;
2. **Разработка интерфейса ACL**, который абстрагирует сложности унаследованной системы и должен быть чистым и четко определенным, а также согласованым с требованиями микросервисов;
3. **Внедрение ACL-компонентов**:
    - **адаптеров данных**, которые преобразуют форматы данных и обеспечивают совместимость унаследованной системы и микросервисов;
    - **шлюзов сервисов**, которые нужны для управления взаимодействием между старой системой и микросервисов - преобразованием протоколов, маршрутизацией запросов и преобразованием ответов;
    - **инкапсуляция бизнесс-логики** для того чтобы микросервисы могли взаимодействовать с упрощенным и согласованным интерфейсом.
4. **Тестирование ACL** чтобы убедиться что он правильно транслирует данные и протоколы между старой системой и новыми сервисами и не вносит значительных задержек или накладных расходов;
5. **Развертывание ACL и внедрение мониторинга**.

## Маршрутизация в микросервисах

**Маршрутизация** - это способы управления и направления потока трафика между различными частями системы.

Польза маршрутизации в период миграции:
- **безболезненное взаимодействие с пользователями** для обеспечения минимальных перебоев в работе пользователей и стабильную производительность при замене одной части системы на другую или ее обновлении;
- **непрерывность работы**, так как она позволяет старой и новой системам сосуществовать и работать одновременно;
- **инкрементное развертывание** что позволяет поддерживать поэтапное развертывание новых функций и сервисов;
- **управление рисками** за счет возможности отката или перенаправления трафика.

Основные проблемы:
- **сложность управления трафиком** из-за управления **множеством путей** трафика как к монолиту, так и к микросервисам, что повышает сложность и обеспечение **согласованности данных и состояния** как монолитного компонента, так и микросервиса, особенно при записи;
- **задержка и производительность** из-за наличия дополнительного уровня, который может стать узким местом;
- **обработка сбоев** при отказе сервисов и создания **механизмов аварийного восстановления** (fallback mechanisms) для перенаправления трафика с сервисов;
- **безопасность данных и управление доступом** между старой системой и новыми микросервисами;
- **полная видимость потока трафика и отладка проблем в гибридной среде**.

### Техники маршрутизации между монолитом и новыми сервисами

#### Обратный прокси

**Обратный прокси-сервер** (reverse proxy) - это промежуточный сервер, который ретранслирует запросы клиентов из внешней сети на один или несколько серверов внутренней сети.

Правила и условия маршрутизации определяют на основе шаблонов URL, заголовков или других атрибутов запроса, которые обозначают назначение трафика.

Имеет такие преимущества:
- **упрощенная маршрутизация**, так как логика маршрутизации централизуется, что упрощает управление и обновление в процессе миграции;
- **балансировка нагрузки** из-за распределения входящего трафика между несколькими экземплярами службы, что повышает производительность и надежность;
- **безопасность**, так как действует в виде барьера между клиентами и внутренними серверами, что обеспечивает дополнительный уровень безопасности;
- **кэширование** для того, чтобы снизить нагрузку на внутренние службы и улучшить время отклика.

#### API-шлюз

**API-шлюз** (Gateway API) - это продвинутая и многофункциональная альтернатива обратному прокси-серверу, которая обрабатывает все входящие запросы и перенаправляет их на основе заранее определенных правил (которые можно определить), управлять эндпоинтами, применять политики безопасности и преобразовывать запросы или ответы.

Имеет такие преимущества:
- **унифицированная точка входа** для всех сервисов, что упрощает взаимодействие с клиентами;
- **централизованное управление системами безопасности, аутентификации и авторизации** для того чтобы обеспечить последовательное применение политик;
- **ограничение скорости и дробление входящих запросов** для того чтобы защитить внутренние службы от перегрузки;
- **аналитика и мониторинг** для отслеживания шаблонов запросов, производительности и ошибок.

#### Service Mesh

**Service Mesh** - это выделенный инфраструктурный уровень для обработки взаимодействия между сервисами в архитектуре микросервисов. Он обеспечивает расширенную маршрутизацию, управление трафиком и возможности наблюдения.

Он предполагает, что рядом с каждым экземпляром микросервиса развертывается прокси-сервер **Sidecar** в рамках одного пода или контейнера, который управляет всеми сетевыми соединениями с микросервисом - координирует запросы к нему и от него.

## Проектирования микросервисов

Состоит из определения:
1. **Границ сервисов** - идентификации бизнес-доменов и субдоменов и обеспечения того, чтобы сервисы инкапсулировали конкретные бизнес-функции;
2. **Методов взаимодействия** между микросервисами с помощью:
    - **синхронного** взаимодействия чтобы обеспечить высокую производительность и быстрый отклик;
    - **асинхронного** взаимодействия, которое эффективнее для развязки и масштабируемости;
3. **Управления данными** которое должно обеспечивать в нескольких сервисах:
    - **согласованность данных** - чтобы изменение данных в одной системе предсказуемо влияло на другие системы;
    - **целостность данных** - поддержание корректности и надежности данных при их распределении;
    - **производительность** за счет масштабируемости, балансировки для уменьшения задержки;
    - **конкурентность** для одновременного доступа к данным и их обновления без конфликтов;
    - **доступность** для служб даже в случае сбоев.
4. **Стратегии развертывания** которые определяют, как новые версии микросервисов будут вводиться в эксплуатацию, минимизируя риски и обеспечивая непрерывность работы системы. А также совместимость новых версий микросервисов с текущими, возможность тестирования в реальной среде, механизмы для мониторинга состояния системы и быстрого отката в случае проблем;
5. **Балансировки нагрузки**, которая обеспечивает равномерное распределение трафика, для того чтобы входящие запросы равномерно распределялись между несколькими экземплярами сервиса, не позволяя какому-либо одному экземпляру стать узким местом. Способствует:
    - **повышению производительности и пропускной способности** из-за равномерного распределения запросов, чтобы каждый экземпляр службы обрабатывал управляемую нагрузку, обеспечивая более быстрое время отклика для пользователей;
    - **высокой доступности и надежности** так как направляет трафик от отказавших или перегруженных экземпляров к исправным, что гарантирует, что приложение останется доступным, даже если некоторые экземпляры сервисов не работают или испытывают большую нагрузку;
    - **масштабируемости**, позволяя плавно добавлять новые экземпляры сервиса, что даст возможность по мере роста нагрузки подключить дополнительные экземпляры, на которые балансировщик нагрузки начнет направлять трафик, обеспечивая способность системы справляться с возросшим трафиком;
    - **устойчивости к сбоям** благодаря мониторингу состояния экземпляров сервисов, чтобы автоматически обнаруживать и удалять из пула нездоровые экземпляры, не позволяя им принимать трафик, что повышает отказоустойчивость системы, гарантируя, что сбои изолированы и не влияют на общую производительность.
6. **Устойчивости к сбоям**, которая обеспечивает проектировку микросервисов таким образом, чтобы легко справляться с отказами некоторых сервисов и не приводить к отказу всей системы благодаря внедрению механизмов повторных попыток, использованием прерывателей для предотвращения каскадных отказов и проектированию сервисов без состояний;
7. **Масштабируемости** в зависимости от нагрузки и проектированию сервисов без состояний;
8. **Безопасности** за счет внедрения сегментации сети из-за распределенной системы, которая ограничивает доступ между различными частями системы и внедрения **HTTPS** для защиты данных при передаче между микросервисами и внешними клиентами, и использование стандартов **OAuth2** / **OpenID Connect** для управления доступом и подтверждения личности пользователей и сервисов;
9. **Мониторинга и наблюдения** за состоянием и производительностью микросервисов для обеспечения надежности и доступности систем, а также агрегирование и анализ данных по всем сервисам;
10. **Хранения данных**, так как каждый микросервис может иметь уникальные требования к хранению данных и правильное разделение данных между микросервисами помогает минимизировать зависимости и улучшить управляемость системы, способствуя независимому масштабированию и развертыванию отдельных компонентов;
11. **API-менеджмента** для создания, публикации, мониторинга, управления и обеспечения безопасности интерфейсов прикладного программирования (API) в безопасной и масштабируемой среде, чтобы централизованно управлять доступом, маршрутизацией запросов, мониторингом и безопасностью API и обеспечивать балансировку нагрузки и защиту от атак. А также документирование API для того, чтобы обеспечить ясное описание функциональности и использования интерфейсов, чтобы разработчики могли быстро и правильно интегрировать API в свои приложения;
12. **Тестирования и валидации** чтобы проверять работоспособность и соответствие функциональных требований разрабатываемого продукта и убеждаться, что созданный продукт соответствует ожиданиям пользователей и бизнес-задачам;
13. **DevOps-практик** для обеспечивания быстрых итераций и непрерывных доставок, способствуя созданию гибкой среды разработки;
14. **Версионирования и совместимости** различных версий микросервисов друг с другом путем управление API и контрактами данных между сервисами, и обеспечивания обратной совместимости новых версий API с предыдущими.

## Процесс взаимодействия между микросервисами

### Синхронное взаимодействие

#### REST

**REST** (Representational State Transfer) - это архитектурный стиль, использующий стандартные методы HTTP (`GET`, `POST`, `PUT`, `DELETE`) для связи между сервисами. Он основан на связи без статических параметров и на архитектуре клиент-сервер, когда клиент отправляет запросы, а сервер отвечает соответствующими ресурсами.

**Принципы**:
- **отсутствие статуса у сервера** - когда каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для понимания и обработки запроса и сервер не хранит контекст клиента между запросами;
- **унифицированный интерфейс** - согласованный способ взаимодействия с ресурсами, обычно использующий стандартные методы HTTP;
- **Resource-Based** - когда сервисы моделируются как ресурсы, идентифицируются по URL и управляются с помощью форматов (JSON, XML и т.п.);
- **архитектура клиент-сервер** - когда клиент и сервер разделены, что позволяет им развиваться независимо друг от друга;
- **кэшируемость** - так как ответы могут определять, можно ли их кэшировать для повышения производительности.

**Преимущества использования**:
- **стандартизация** - обеспечивается стандартизированный способ доступа к ресурсам, что облегчает понимание и использование разработчиками;
- **масштабируемость** - из-за отсутствие статичности, что позволяет сервисам легко масштабироваться;
- **интероперабельность** - так как взаимодействие происходит на основе HTTP, что обеспечивает совместимость различных платформ и языков;
- **отсутствие специализированных фреймворков** - так как стандартная реализация есть в большинстве современных языков программирования.

**Используется для**:
- **общедоступных API** благодаря своей простоте и широкому распространению;
- **CRUD-операции** (create, read, update, delete) из-за ресурсного подхода;
- **связи микросервисов** в сценариях, в которых сервисы должны предоставить *endpoints* для доступа к данным или работы с ними.

#### RPC

**RPC** (Удаленный вызов процедур) - это метод связи между серверами в распределенной системе, который позволяет программе вызывать функции или процедуры, находящиеся на удаленном сервере, как если бы они были локальными.

RPC абстрагирует сетевую коммуникацию, предоставляя разработчикам более простой и понятный способ взаимодействия между компонентами распределенных систем.

**Основные характеристики**:
- **прозрачность** - так как вызов удаленной функции выглядит так же, как и вызов локальной функции;
- **синхронность** - когда клиент ожидает ответа от сервера для продолжения выполнения;
- **типизация** - что позволяет проверять корректность данных на этапе компиляции.

### Асинхронное взаимодействие

#### Event-Driven Architecture

**Event-Driven Architecture** (EDA, Архитектура, управляемая событиями) - это парадигма проектирования, в которой поток программы определяется событиями, такими как действия пользователя, выходы датчиков или сообщения от других сервисов.

EDA способствует свободному соединению, масштабируемости и обработке данных в реальном времени, позволяя сервисам реагировать на события асинхронно.

**Ключевые принципы**:
- **продюсеры** генерируют события, а **консьюмеры** прослушивают и реагируют на них;
- **брокеры** являются посредниками между продюсерами и консьюмерами, обеспечивая надежную доставку событий;
- **потоки** событий непрерывны, и их можно обрабатывать в режиме реального времени.

**Преимущества архитектуры**:
- **масштабируемость** - так как сервисы могут масштабироваться независимо в зависимости от нагрузки на события;
- **разделение** - сервисы могут работать независимо друг от друга, уменьшая взаимозависимость;
- **обработка в реальном времени**, которая обеспечивает аналитику в реальном времени и быстро реагирующие системы;
- **устойчивость к сбоям** - когда сообщения могут быть поставлены в очередь, что гарантирует, что они не будут потеряны и смогут быть обработаны, когда потребитель будет доступен.

**Системы обмена сообщениями** обеспечивают асинхронную связь между сервисами, позволяя им обмениваться сообщениями через инфраструктуру обмена сообщениями. Они помогают разделять сервисы, улучшать масштабируемость и повышать отказоустойчивость, предоставляя буфер, способный справиться с переменной нагрузкой и временной недоступностью сервисов. Являются основой для EDA.

### Выбор метода взаимодействия

Осуществляется по ключевым факторам:
- **латентности** (время, необходимое для прохождения сообщения от отправителя к получателю и обратно):
    - синхронные методы для задач, где требуется немедленный ответ;
    - асинхронные методы для некритичных по времени операций, где задержка может быть терпимой или не требуется немедленного ответа на запрос.
- **консистентности данных** для обеспечения целостности данных в распределенных сервисах:
    - синхронные методы для операций, требующих немедленной согласованности;
    - асинхронные методы для сценариев, в которых допустима конечная согласованность.
- **масштабируемости** - способность справляться с растущими нагрузками путем добавления дополнительных ресурсов:
    - синхронные методы для более простых, тесно связанных взаимодействий;
    - асинхронные методы для сервисов, которые должны масштабироваться независимо друг от друга и обрабатывать всплески трафика.
- **отказоустойчивости** - способность системы продолжать работу в случае сбоя:
    - синхронные методы требуют надежной обработки ошибок и механизмов повторных попыток для достижения отказоустойчивости;
    - асинхронные методы для повышения отказоустойчивости и предотвращения потери сообщений при сбоях в работе служб.

## Работа с данными

Работа с данными должна подчиняться требованиям ACID:
- **Atomicity** - атомарность - все операции в транзакции либо завершаются успешно, либо откатываются;
- **Consistency** - целостность - любое изменение данных проходит через транзакционные контексты, которые следят за соблюдением всех ограничений;
- **Isolation** - изолированность - позволяет избежать конфликтов между параллельными транзакциями;
- **Durability** - надежность - все изменения, сделанные в рамках транзакции, применяются и сохраняются даже в случае сбоя системы.

Стратегии обеспечения согласованности данных:
- **конечная согласованность**, которая гарантирует, что при необходимом времени все реплики данных придут к одному и тому же значению. Используется в распределенных системах, где не требуется немедленная согласованность. Подходит для сценариев, в которых высокая доступность и устойчивость к разделениям более важны, чем немедленная согласованность;
- **строгая согласованность**, которая гарантирует, что все операции чтения возвращают последнюю запись. Используется когда требуется строгая точность данных. Подходит для критически важных операций, где точность данных не может быть нарушена;
- **партицирование данных**, которое подразумевает разделение большого набора данных на более мелкие и управляемые части (партиции), распределенные между несколькими узлами. Используется когда требуется сбалансировать нагрузку и повысить производительность. Подходит для крупномасштабных систем, где различные разделы могут управляться независимо друг от друга для обеспечения масштабируемости и производительности.

### Распределенные транзакции

Распределенные транзакции координируют выполнение операций в нескольких сервисах, чтобы гарантировать, что все части транзакции либо зафиксируются, либо откатятся вместе.

#### Протокол двухфазной фиксации 

**Протокол двухфазной фиксации** (2 Phase Commit, 2PC) - это подход к управлению распределенными транзакциями, которы включает в себя две фазы:
- **фаза подготовки**, когда координатор отправляет сообщение `prepare` всем участвующим сервисам с просьбой подготовиться к фиксации транзакции. На что каждый сервис отвечает голосованием (**зафиксировать** или **прервать**) в зависимости от того, сможет ли он успешно зафиксировать транзакцию;
- **фаза фиксации**, когда все сервисы голосуют за фиксацию, координатор отправляет сообщение о фиксации всем сервисам, указывая им на фиксацию транзакции. Если какая-либо служба голосует за отказ, координатор посылает сообщение об **отказе**, предписывая всем службам откатить транзакцию.

**Проблемы**:
- **блокировка** - в случае если координатор не справляется, участники могут остаться в неопределенном состоянии, ожидая решения;
- **производительность**, так как протокол может вносить задержки из-за необходимости многократных обходов между координатором и участниками.

#### Паттерн Saga

**Паттерн Saga** - это архитектурный паттерн для управления распределенными транзакциями в микросервисных системах, который обеспечивает целостность данных и позволяет управлять ошибками при выполнении долговременных бизнес-процессов, которые включают несколько микросервисов. Это решается с помощью набора локальных транзакций и компенсирующих действий. Каждая транзакцию дробиться системой на шаги, которыми занимаются разные микросервисы. В случае ошибки система активирует отмену действия, которая распространяется на все вовлеченные микросервисы.

Подходы к координации шагов:
- **оркестрацию** - которая подразумевает наличие отдельного сервиса-оркестратора, который управляет последовательностью выполнения шагов и при необходимости инициирует компенсирующие действия. Применяется когда есть:
    - **сложные бизнес-процессы** с четкой последовательности действий;
    - **потребность в централизованном управлении** потоком операций и логикой обработки ошибок;
    - **координация транзакций** с обеспечением согласованности и возможности отката;
    - **сложная бизнес-логика и управление состоянием** которые реализуются в центральном оркестраторе.
- **хореографию** - когда микросервисы взаимодействуют через события и знают что делать после выполнения своего шага, а также сами инициируют компенсирующие действия. Применяется когда есть:
    - **простые взаимодействия** и не требуется сложная координации между ними;
    - **независимые микросервисы** и изменение одного сервиса не сильно влияет на другие;
    - **в приоритете гибкость и масштабируемость в системе**. чтобы изменения в одном микросервисе не требовали изменения в других;
    - **событийно-ориентированная архитектура**.

Требования ACID соблюдаются в:
- **атомарности** - так как транзакции разделяются на последовательные шаги, где каждый шаг — это локальная транзакция в отдельном микросервисе и атомарность достигается за счет независимого выполнения каждого шага и применения компенсирующих действий для отката изменений;
- **целостности** - которая обеспечивается через компенсирующие действия, которые откатывают предыдущие шаги в случае ошибки, так как микросервисы координируют между собой состояние транзакции, что иногда требует дополнительной логики;
- **изолированности** - только в конце транзакции, так как микросервисы работают независимо и пока все шаги Saga не завершатся, система может столкнуться с временной неконсистентностью данных;
- **надежности** - которая зависит от отдельных микросервисов и их способности сохранять состояние и поэтому компенсирующие действия должны быть надежными и обеспечивать сохранение состояния даже при сбоях.

**Компенсационные транзакции** - это действия, которые откатывают результаты уже выполненных шагов, если на любом из следующих шагов возникла ошибка.

**Преимущества**:
- **неблокируемость**, поскольку сервисы не блокируются из-за того, что каждый шаг независим и может быть отменен при необходимости;
- **масштабируемость и устойчивость к сбоям**.

**Процесс внедрения**:
1. **Анализ бизнес-процесса** и разделение его на последовательные шаги, которые будет выполнять отдельный микросервис. Для каждого шага определяется **основное действие** (do) и **компенсирующее действие** (undo), которое нужно выполнить в случае ошибки;
2. **Проектирование API у микросервисов** для выполнения действий и компенсирующих действий. Каждая операция для всех действий и компенсирующих действий должна быть **идемпотентной**, для этого используются уникальные идентификаторы транзакций и проверяется состояние перед выполнением операции, чтобы избежать повторного выполнения;
3. **Обеспечение хранения состояния** своей части транзакции в каждом микросервисе. Состояние должно включать уникальный идентификатор транзакции и текущий статус операции, чтобы избежать повторения уже совершенных действий. И выбора подхода к координации шагов;
4. **Реализация действий и компенсирующие действий** в каждом микросервисе, которые должны быть **идемпотентны**;
5. **Добавление логирования** для всех действий и компенсирующих действий, которые должны включать информацию о транзакциях, их статусе и любых ошибках. А также **настройка мониторинга** микросервисов (оркестратора);
6. **Тестирование** основных действий и компенсирующие действий в каждом микросервисе, а также цельной транзакции.

## Стратегии развертывания

### Обновление на месте

**Обновление на месте** - это когда новая версия приложения заменяет старую версию на той же инфраструктуре. Часто это делается путем остановки службы, развертывания нового кода и перезапуска службы.

### Сине-зеленые релизы (Blue-Green)

**Сине-зеленые релизы** - это когда поддерживаются два идентичных окружения - синее и зеленое. Пока одно работает и обслуживает продакшн, другое используется для развертывания и тестирования новой версии. Затем, когда новая версия прошла тестирование в новом окружении, трафик переключается на него. Так как старое теперь простаивает, то может быть использована для следующего обновления. И так далее.

**Основное преимущество**: отсутствие простоев и простой откат, так как при обнаружении проблем трафик можно быстро переключить на исходную среду.

**Основной недостаток**: нужно поддерживать две идентичные среды, что может быть дорогостоящим и ресурсоемким.

### Канареечные релизы (Canary)

**Канареечные релизы** - это когда при обновления новая версия разворачивается на каком-то количестве серверов (**канареечные серверы**) и затем туда направляется небольшой процент трафика. Развертывание отслеживается на предмет ошибок и, если проблем не обнаружено, туда направляется все больше трафика. В конце концов новая версия разворачивается на всех серверах.

**Основное преимущество**: позволяет проводить мониторинг и тестирование в реальных условиях с минимальным риском и ограничивает влияние потенциальных проблем небольшой базой пользователей.

**Основной недостаток**: требуются сложные механизмы маршрутизации и мониторинга трафика.

### Скользящие релизы (Rolling)

**Скользящие релизы** - это когда при релизе экземпляры приложения постепенно обновляются по одному или небольшими партиями без простоев, что обеспечивает постоянное обслуживание трафика одними экземплярами, в то время как другие находятся в процессе обновления.

**Основное преимущество**: обеспечивается постоянная доступность сервиса и снижается риск сбоев за счет обновления небольшими порциями.

**Основной недостаток**: необходимость тщательной координации, чтобы обеспечить бесперебойное обновление и механизмы отката.

## Стратегии балансировки нагрузки

### Round Robin

**Round Robin** - эта стратегия последовательно распределяет запросы между доступными экземплярами. Каждый экземпляр получает равную долю запросов в круговом порядке.

Применяется в системах, где все экземпляры имеют схожие характеристики мощности и производительности.

### Least Connections

**Least Connections** - эта стратегия направляет запросы к экземпляру с наименьшим количеством активных соединений, что помогает распределить нагрузку более равномерно, особенно когда есть экземпляры с разной производительностью.

Применяется в системах, где экземпляры могут обрабатывать запросы разной сложности и продолжительности.

### IP Hash

**IP Hash** - эта стратегия использует хэш IP-адреса клиента, чтобы определить, какой экземпляр будет обрабатывать запрос, что гарантирует, что запросы от одного и того же клиента будут последовательно направляться к одному и тому же экземпляру.

Применяется в системах, в которых требуется сохранение сеанса (для продолжительных пользовательских сеансов в сервисе с состоянием).

### Weighted Round Robin

**Weighted Round Robin** - эта стратегия аналогична стратегии **Round Rrobin**, но с весами, присваиваемыми каждому экземпляру на основе его возможностей или характеристик производительности. Экземпляры с более высокими весами получают больше запросов.

Применяется в системах, где некоторые экземпляры более мощные и могут обрабатывать большую долю нагрузки.

### Случайное распределение

**Случайное распределение** - эта стратегия случайным образом направляет запросы к экземплярам.

Применяется в системах, с равномерно распределенными экземплярами и когда другие стратегии могут не дать значительных преимуществ.
