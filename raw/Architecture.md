Микрофронтенды
==============

**Микрофронтенд** - это концепция, которая распространяет принципы архитектуры микросервисов на мир фронтенда - фронтенд-приложения декомпозируют на части, которые можно разрабатывать, тестировать и развертывать независимо друг от друга.

Разбиение происходит по такой логике:
- каждый микрофронтенд отвечает за отдельную функцию или область приложения;
- микрофронтенды объединяют в целостный пользовательский опыт.

Основные преимущества микрофронтендов:
- **повышение организационной гибкости**, что позволяет различным командам работать параллельно, не завися друг от друга при развертывании;
- **можно использовать несколько технологических стеков** в зависимости от задач;
- **упрощение управления кодом**, так как каждая команда управляет только тем кодом, который относится к ее функциональности, что значительно облегчает сопровождение: обновление или исправление одного раздела не вызовет непредвиденных последствий в других частях приложения;
- **более управляемое масштабирование** из-за того, что каждый микрофронтенд развернут независимо от остальных;
- **повышение отказоустойчивости**, так как изоляция микрофронтендов повышает общую устойчивость приложения и в случае отказа микрофронтенда откажет только этот микрофронтенд;
- **ускорение времени выхода на рынок**  из-за того, что дает возможность разрабатывать, тестировать и внедрять обновления мелкими порциями, что позволяет больше экспериментировать и оперативно реагировать на изменения рынка.

Основные компоненты:
- **модули микрофронтенда** - это основные элементы архитектуры. Каждый модуль - это определенная бизнес-область или функциональность. Модули разрабатывают, тестируют и развертывают независимо друг от друга;
- **слой композиции** - отвечает за сборку различных модулей микрофронтенда в целостное приложение, а также управляет потоком данных и взаимодействием между клиентом и сервером. Компоновка модулей может происходить на стороне сервера, на стороне клиента или с помощью гибридного подхода;
- **маршрутизация** - отвечает за то, что запросы будут направляться к нужному микрофронтенду, что помогает сохранить модульность приложения (независимость микрофронтендов друг от друга) и при этом обеспечить плавную навигацию для пользователей;
- **коммуникационный слой** - управляет взаимодействием между микрофронтендами и остальной инфраструктурой приложения посредством API, шины сообщений или собственных систем событий.

## Стратегии проектирования микрофронтендов

### Стратегия вертикальной нарезки

**Стратегия вертикальной нарезки** основана на *предметно-ориентированном проектировании* (Domain-Driven Design, DDD), что предполагает, что приложение делится на **домены** (domain) - предметные области, которые описывают разные цели бизнеса.

Суть вертикальной нарезки в том, чтобы спроектировать каждый микрофронтенд как самодостаточную систему, которая соответствует отдельной бизнес-функции. Тогда он будет включать всю необходимую внешнюю логику: от пользовательского интерфейса до уровня получения данных, который относится к его области.

Плюсы:
- каждый микрофронтенд предоставляет полный набор функций, который можно разрабатывать, тестировать и развертывать независимо от других;
- снижает зависимость между командами;
- упрощает управление проектами и масштабирование.

Минусы:
- тяжело определить границы каждого домена, так как на это влияет бизнес и тщательное планирование разработки.

Использование:
- когда есть **сложные пользовательские интерфейсы**, которые обслуживают разные бизнес-функции;
- когда есть **кросс-функциональные команды** вокруг бизнес-возможностей или клиентских путей, а не технологических стеков.

### Стратегия автономность команд

**Стратегия автономность команд** основана на том, что каждая команда имеет возможность выбрать технологический стек, который подходит под ее задачи и использовать сильные стороны технологий, чтобы достичь оптимальной производительности и удобства работы пользователей.

Плюсы:
- способствует росту инноваций;
- помогает создавать более адаптированные технические решения;
- ускоряет разработку и улучшает качество продукта.

Минусы:
- может привести к фрагментации и трудностям в управлении сквозными проблемами (стилизацией, доступностью и общей согласованностью пользовательского опыта).

Использование:
- когда есть **разные технологические потребности** из-за того, что разные части приложения выиграют от разных технологических стеков;
- когда есть **проекты, ориентированные на инновации и эксперименты**.

### Стратегия изоляции

**Стратегия изоляции** основана на том, что у микрофронтендов нет общих зависимостей во время выполнения. То есть каждый микрофронтенд должен включать все свои зависимости. Они инкапсулируются в пакет развертывания микрофронтенда. Общие библиотеки в микрофронтендах будут дублироваться, но их можно совместить с помощью стратегического управления версиями на более широком уровне. Изоляция необходима, чтобы избежать конфликтов версий и облегчить обновление или замену отдельных микрофронтендов.

Плюсы:
- снижается риск того, что изменения в одном микрофронтенде повлияют на другие;
- упрощается обновление и сопровождение, так как не нужно подстраиваться под все приложение.

Минусы:
- общие библиотеки включены в несколько микрофронтендов, и из-за этого размер приложения увеличится.

Использование:
- когда есть **частые обновления и развертывания** в средах, где микрофронтенды должны обновляться часто и независимо друг от друга. Это гарантирует, что обновления не помешают друг другу;
- когда нужно **независимо масштабировать разные части приложения** у которых разные нагрузки и требования к производительности.

## Методы интеграции микрофронтендов

**Build time** - это объединение во время сборки - когда все компоненты помещаюся в контейнер. Мало отличается от монолитного фреймворка так как:
- нужно синхронизировать разные версии библиотек, иначе возникнут проблемы со сборкой;
- сложно использовать разные технологии;
- конечный бандл получится большим, ведь он содержит все зависимости;
- при появлении изменений в зависимостях, придется развертывать пакет заново;
- между контейнером и микрофронтендами будет тесная связь.

Подходит:
- когда нужно **упростить развертывание**, так как интеграция во время сборки ориентирована на единый механизм развертывания и единый исходный код, что дает на выходе единый пакет для развертывания;
- когда нужно **оставить тесное взаимодействие функций**, так как микрофронтенды тесно интегрированы с общими зависимостями;
- когда нужно **оптимизировать производительность**, так как интеграция во время сборки позволяет использовать разные техники оптимизации (tree-shaking, разделение кода), что способствует повышению производительности.

**Run time** - это объединение во время выполнения исполнения кода на стороне пользователя.

Подходит:
- когда нужно **развертывать модули независимо**, что позволит каждой команде развертывать свои изменения, не затрагивая другие части приложения;
- когда нужно **динамически обновлять отдельные модули** без переразвертывания всего приложения;
- когда нужно **сделать масштабирование гибким**, что позволит масштабировать разные части приложения независимо.

## Методы композиции микрофронтендов

Это процесс сборки нескольких микрофронтендов в единое целое.

**Серверная композиция** - когда все микрофронтенды собирают на сервере. Вся функциональность находится в бэкенде. Он решает, какой микрофронтенд собрать и загрузить. Сервер будет решать, к какому URL направить запрос.

Используется когда важен SEO и быстрый первоначальный отклик.

**Клиентская композиция** - когда браузер отвечает за динамическую загрузку каждого микрофронтенда во время выполнения.

Используется когда много интерактивного контента, который меняется в зависимости от взаимодействия с пользователем.

**Гибридная композиция** - состоит из серверной и клиентской композиции и использует для каждого микрофронтенда свой выделенный бэкенд *Backend for Frontend* (BFF). BFF обрабатывает все данные, взаимодействует с API и при необходимости предоставляет клиенту предварительно отрендеренный HTML. Это полезно для начальной загрузки страниц и SEO. Сервер передает клиенту полностью сформированную страницу.

## Инструменты для создания микрофронтендов

### Module Federation

Это отдельный плагин Webpack.

Module Federation позволяет независимым приложениям использовать общий код во время выполнения. Он основан на функции **lazy loading**, которая позволяет приложению загружать фрагменты кода по требованию, что сокращает время первоначальной загрузки и помогает оптимизировать использование ресурсов.

Есть две роли:
- **хост** (host) - это основное приложение, которое при запуске динамически загружает удаленные модули;
- **удаленный модуль** (remote) - это отдельный микрофронтенд, который предоставляет часть своей функциональности хосту или другим удаленным модулям.

Хост и удаленные модули могут использовать **общие зависимости**, используя функцию **shared dependencies**, которая позволяет эффективно управлять версиями и гарантирует, что приложение загрузит одну версию библиотеки, если это возможно.

### Single SPA

Это JavaScript-фреймворк. Он позволяет использовать несколько JavaScript-фреймворков на одной странице, не обновляя ее целиком. Он предназначен для управления маршрутизацией и координацией между различными микрофронтендами.

Основные особенности:
- **framework agnostic** (независимость от фреймворков) - приложение не зависит от какого-то конкретного фреймворка, поэтому можно поддерживать сразу нескольких фреймворков на одной странице;
- **lazy loading** (ленивая загрузка) - приложение загружает фрагменты кода по требованию, что улучшает время первоначальной загрузки и производительность;
- **независимая развертываемость** - каждый микрофронтенд может быть развернут независимо и из-за этого проще поддерживать большие приложения, над которыми работают несколько команд.

Состоит из:
- **root** (рут, корень) - основное приложение, которое подгружает разные микрофронтенды;
- **микрофронтендов**, которые подключают к руту.

## Стратегии управления состоянием

### Взаимодействие на основе API

Коммуникация на основе API подразумевает, что бэкенд и микрофронтенды взаимодействуют через HTTP-запросы. Для обмена данными используют RESTful или GraphQL API.

Подходит когда:
- **микрофронтенды должны взаимодействовать с бэкендом, а не напрямую друг с другом** - они в основном занимаются получением или обновлением данных из централизованного бэкенда;
- **есть простой обмен данными**, которые нужны только чтобы отобразить их в компоненте или отправить форму;
- **есть высокие требования к производительности и масштабируемости**, так как каждый микрофронтенд самостоятельно получает данные и обновляет свое состояние, что позволяет каждому микрофронтенду обеспечить независимое масштабирование и оптимальную производительность.

### Паттерн Pub/Sub

Используется паттерн проектирования **Pub/Sub**, при котором компоненты системы выступают в роли **издателей** (publisher) или **подписчиков** (subscriber). При таком подходе компоненты не знают о существовании друг друга, они взаимодействуют только с **событиями** - публикуют их или подписываются на них.

**Event Bus** (шина событий) - это система обмена сообщениями, которая основана на паттерне **Pub/Sub**. События публикуются в шине событий. Компоненты-подписчики регистрируются в шине и указывают список событий, которые они хотят получать. Шина событий разделяет микрофронтенды, убирает взаимозависимость и обеспечивает гибкость.

Подходит когда:
- **предпочтительно несвязанное соединение** между микрофронтендами, что позволяет им взаимодействовать без прямых зависимостей, что упрощает добавление, удаление или обновление микрофронтендов;
- **используется архитектура, управляемая событиями** (event-driven architecture, EDA) - действия или обновления в одной части приложения вызывают реакции в других частях и это эффективно для обновлений в реальном времени и асинхронных коммуникаций;
- **есть независимое развертывание**, так как помогает отделить логику взаимодействия от фактической реализации.

### Библиотека глобального состояния

При использовании библиотеки глобального состояния разные микрофронтенды могут получить доступ к общему состоянию и изменять его. Библиотека сама ходит в базу данных через API и обновляет данные на фронтенде.

Этот подход гарантирует, что все части приложения синхронизируются и последовательно взаимодействуют с пользователем.

Подходит когда:
- **есть тесная связь между разными частями приложения** и нужно, чтобы разные части приложения совместно использовали глобальное состояние и информация там всегда была актуальной, так как несколько микрофронтендов читают из одного состояния и записывают в него обновления;
- **важно поддерживать последовательный пользовательский опыт**, это получается благодаря общему состоянию, из-за которого поддерживается единообразие и согласованность в разных частях приложения;
- **есть сложные требования к управлению состояниями** и когда оно вложенное или иерархическое.

## Паттерн Backend for Frontend

**Backend for Frontend** (бэкенд для фронтенда, BFF) - это подход к проектированию, при котором каждый фронтенд обслуживает специальный бэкенд - промежуточный слой между фронтендом и внутренними сервисами, для того чтобы абстрагировать фронтенд от сложностей бэкенда. BFF отвечает за сбор информации от разных микросервисов, ее обработку и доставку на фронтенд в удобном формате.

Используется при архитектурах когда есть:
- **монолитный фронтенд и микросервисы** - для того чтобы абстрагировать фронтенд от сложностей бэкенда;
- **несколько клиентов, которые используют разные технологии для передачи данных** - для того чтобы не усложнять бекенды поддержкой разных технологий;
- **микросервисы и микрофронтенды** - для организации взаимодействие между ними.

Этот подход позволяет:
- **подготавливать данные для конкретного фронтенда**, что снижает необходимость дополнительной обработки данных на стороне клиента;
- **упростить логику на стороне клиента**, так как обрабатывает сложные логические операции на стороне сервера - агрегацию, композицию и преобразованию данных, что снижает сложность кода фронтенда и улучшает его сопровождение;
- **увеличить производительность**, так как передается меньше данных по сети и выполняется меньше запросов из фронтенда;
- **усилить безопасность**, так как запросы пользователей на BFF могут аутентифицироваться и авторизовываться перед передачей внутренним службам.

Архитектурные стили
===================

## Монолитная архитектура

Особенности:
- **развертывание и обновление**: изменения требуют перезапуск всего приложения;
- **масштабируемость**: масштабировать можно только все приложение целиком;
- **гибкость в выборе технологий**: все компоненты работают в единой технологической среде;
- **устойчивость к отказам**: отказ одной части системы может привести к отказу всего приложения;
- **управление командами**: трудно управлять большими командами, которые работают с одним кодом;
- **время разработки и внедрения**: длительные циклы разработки и внедрения;
- **тестирование**: трудно тестировать все компоненты вместе;
- **производительность**: может страдать из-за тесной связи компонентов;
- **масштаб проекта**: хорошо подходит для небольших и средних проектов;
- **риск изменений**: высокий риск сбоев при внесении изменений.

## Модульный монолит

Особенности:
- **развертывание и обновление**: изменения требуют перезапуск всего приложения;
- **масштабируемость**: масштабировать можно только все приложение целиком;
- **гибкость в выборе технологий**: все компоненты работают в единой технологической среде;
- **устойчивость к отказам**: отказ одной части системы может привести к отказу всего приложения;
- **управление командами**: модулями легче управлять, но все еще требуется координация;
- **время разработки и внедрения**: умеренные циклы разработки и внедрения;
- **тестирование**: отдельные модули легче тестировать, но все еще нужно тестировать весь монолит;
- **производительность**: может страдать из-за тесной связи компонентов;
- **масштаб проекта**: хорошо подходит для средних и больших проектов;
- **риск изменений**: умеренный риск сбоев, так как изменения затрагивают модули.

## Микросервисная архитектура

Особенности:
- **развертывание и обновление**: каждый сервис можно обновлять и разворачивать независимо;
- **масштабируемость**: можно отдельно масштабировать сервисы, которые испытывают нагрузку;
- **гибкость в выборе технологий**: разные сервисы могут использовать разные технологии и языки;
- **устойчивость к отказам**: отказ одного сервиса не влияет на работу остальных сервисов;
- **управление командами**: команды могут работать независимо, что упрощает управление проектом;
- **время разработки и внедрения**: быстрые циклы разработки и внедрения;
- **тестирование**: отдельные сервисы легче тестировать;
- **производительность**: обычно выше благодаря независимой работе сервисов;
- **масштаб проекта**: подходит для больших и сложных проектов;
- **риск изменений**: низкий риск, так как изменения затрагивают только отдельные сервисы.

Микросервисы
============

## Особенности

**Плюсы**:
- **независимость компонентов**, так как микросервисы представляют собой отдельные блоки, которые можно разрабатывать, тестировать, развертывать и масштабировать независимо друг от друга, поскольку команды работают над своими задачами параллельно, не мешая друг другу, что позволяет быстро внедрять изменения;
- **модульность** из-за того, что приложение разбито на небольшие модули, каждый из которых отвечает за конкретную бизнес-функцию, что упрощает понимание кода, управление им и его повторное использование;
- **легковесные коммуникации** посредством общения друг с другом через легковесные протоколы - HTTP/HTTPS, REST или сообщения в очередях, что минимизирует накладные расходы и упрощает интеграцию сервисов;
- **автономность** из-за того, что каждый микросервис работает в своем собственном процессе и может быть развернут независимо от других, что снижает риски сбоев и повышает гибкость системы;
- **устойчивость к отказам** так как отказ одного микросервиса не приводит к отказу всей системы, что делает систему более надежной и устойчивой к ошибкам;
- **масштабируемость** так как микросервисы можно масштабировать независимо, что позволяет эффективно использовать ресурсы и справляться с увеличивающейся нагрузкой;
- **ориентация на бизнес** из-за того, что каждый микросервис ориентирован на конкретную бизнес-функцию и разрабатывается вокруг нее, что упрощает управление системой и ее развитие в соответствии с бизнес-требованиями.

**Минусы**:
- **более сложное управление**, потому что приходится отслеживать и поддерживать множество независимых сервисов и это требует более сложной инфраструктуры и использованию специализированных инструментах для мониторинга и логирования;
- **более сложная разработка**, так как нужно продумывать, как микросервисы будут взаимодействовать друг с другом, что приводит к тому, что нужно тщательно проектировать интерфейсы и взаимодействия между сервисами, а еще согласовывать между собой контракты API;
- **распределенные системы**, так как микросервисы работают в распределенной среде, что усложняет отладку и тестирование и проблемы становится сложнее диагностировать, потому что ошибки могут возникать в разных частях системы; в распределенной среде сложнее обеспечить согласованность данных и управлять транзакциями;
- **сетевые задержки и надежность**, из-за взаимодействия друг с другом через сеть, что может вызывать задержки и создавать дополнительные точки отказа, так как сетевые задержки могут ухудшить производительность системы;
- **более сложное управление конфигурацией**, так как нужно централизованое управление конфигурациями и секретами и необходимо обеспечивание согласованности конфигураций между разными окружениями;
- **повышенные требования к DevOps и инфраструктуре**, так как нужно автоматизировать развертывания, мониторинг и управление микросервисами с помощью контейнеров и оркестраторов;
- **повышение затрат**, так как разработка и поддержка выходит дороже, чем монолитная архитектура из-за затрат на разработку, тестирование, развертывание и инструментов с инфраструктурой для управления микросервисами.

## Жизненный цикл микросервиса

**Жизненный цикл микросервиса** - это этапы, которые микросервис проходит от первоначальной идеи до вывода из эксплуатации.

Состоит из этапов:
1. **Проектирование**:
    - определение бизнес-функции, которую будет выполнять микросервис;
    - определение границы микросервиса и его взаимодействия с другими сервисами;
    - выбор технологии и инструментов для реализации микросервиса.
2. **Разработка**:
    - написание исходного кода микросервиса;
    - тестирование кода - юнит-тесты и интеграционные тесты;
    - документирование API и внутренней логики микросервиса.
3. **Тестирование**:
    - проведение модульных тестов, чтобы проверить отдельные компоненты микросервиса;
    - проведение интеграционных тестов, чтобы проверить, как микросервис взаимодействует с другими микросервисами;
    - проведение нагрузочного тестирования, чтобы оценить производительность микросервиса.
4. **Развертывание**:
    - подготовка среды для развертывания - настройка серверов и контейнеров;
    - автоматизация процесса развертывания с помощью CI/CD-инструментов;
    - развертывание микросервиса в производственной среде.
5. **Мониторинг и поддержка**:
    - настройка мониторинга, чтобы отслеживать состояние и производительность микросервиса;
    - реагирование на инциденты и устранение неполадок;
    - обновление микросервиса и внедрение улучшений на основе собранных данных.
6. **Масштабирование**:
    - анализ метрик и логов, чтобы выявить потребность в масштабировании;
    - увеличение ресурсов (CPU, память) или количества экземпляров микросервиса;
    - обеспечивание балансировки нагрузки между экземплярами.
7. **Обновление и улучшение**:
    - сбор обратной связи от пользователей и анализ метрик, чтобы выявить области для улучшения;
    - разработка и тестирование новых функций;
    - обновление микросервиса в производственной среде.
8. **Вывод из эксплуатации**:
    - оповещение пользователей и других команд о том, что планируется вывод микросервиса из эксплуатации;
    - перенос данных и функций на другие сервисы;
    - отключение микросервиса и удаление его из производственной среды.

## Паттерны проектирования микросервисов

**Паттерны проектирования микросервисов** - это лучшие практики и стандарты, которые используются для решения общих задач и проблем, возникающих при проектировании микросервисных систем.

**Язык паттернов** - это организованный и согласованный набор паттернов, каждый из которых описывает проблему и суть решения.

### Паттерны уровня приложений

**Паттерны уровня приложений** (application patterns) фокусируются на управлении данными и организации микросервисов, помогают создавать независимые, изолированные и хорошо структурированные микросервисы, обеспечивая гибкость и масштабируемость системы.

#### Паттерн Database per Service

**Паттерн Database per Service** предполагает, что у каждого микросервиса есть своя собственная база данных для обеспечивания независимости и изоляции данных внутри микросервисов, чтобы каждый микросервис был полностью автономным. Это предотвращает проблемы, которые могут возникнуть из-за совместного использования одной базы данных несколькими микросервисами и упрощает управление данными.

Плюсы:
- **изоляция данных**, так как у каждого микросервиса своя база данных и им не нужно конкурировать за ресурсы;
- **автономность**, так как микросервисы можно развернуть и масштабировать независимо друг от друга;
- **гибкость** потому что можно использовать разные типы баз данных для разных микросервисов и ориентироваться на их потребности.

Минусы:
- **более сложное управление**, так как приходится управлять множеством баз данных, что усложняет администрирование;
- **сложно поддерживать согласованность** данных между микросервисами.

#### Паттерн Service per Team

**Паттерн Service per Team** предполагает, что каждая команда разработки отвечает за один или несколько микросервисов для распределения ответственности и улучшения управление проектом, чтобы каждая команда могла сосредоточиться на своей области и автономно принимать решения.

Плюсы:
- **четкие зоны ответственности**, так как каждая команда отвечает за свои микросервисы, что упрощает управление и улучшает качество;
- **гибкость** из-за того, что команды могут самостоятельно выбирать технологии и инструменты, которые лучше всего подходят для их задач;
- **улучшение коммуникаций**, поскольку в небольших командах проще выстраивать коммуникацию и еще можно быстрее принимать решения.

Минусы:
- **возможные конфликты** из-за несогласованности между командами, которые могут привести к проблемам в интеграции и взаимодействии микросервисов;
- **различия в технологиях**, поскольку использование разных технологий может усложнить интеграцию и поддержку системы.

#### Паттерн Event Sourcing

**Паттерн Event Sourcing** предполагает, что вместо того чтобы хранить текущее состояние объекта, система сохраняет последовательность событий, которые привели к этому состоянию, что обеспечивает гибкость и возможность воспроизводить историю изменений.

Плюсы:
- **полная история изменений** и из-за это можно воспроизвести любое состояние объекта в любой момент времени;
- **гибкость** так как легко добавлять такие функциональности, как аудит и аналитика;
- **повышенная согласованность**, так как все изменения фиксируются в виде событий.

Минусы:
- **сложность реализации**, так как требуется сложная логика для управления событиями и воспроизведения состояния;
- **рост объема данных** из-за сохранение всех событий.

#### Паттерн CQRS

**Паттерн Command Query Responsibility Segregation** (CQRS) разделяет операции чтения и записи данных в системе на два отдельных интерфейса.

Плюсы:
- **масштабируемость**, так как чтение и запись данных можно масштабировать независимо друг от друга, что улучшает производительность системы;
- **оптимизация запросов**, поскольку запросы на чтение могут быть оптимизированы для быстрого получения данных, а команды записи - для эффективного обновления данных;
- **улучшенная согласованность** при разделение операций на чтение и запись.

Минусы:
- **сложность реализации**, так как необходимо поддерживать два отдельных интерфейса и механизмы синхронизации данных;
- **увеличение объема кода** из-за разделения операций, который необходимо поддерживать.

При использовании паттерна операции чтения (запросы) и записи (команды) выполняются через разные модели данных и интерфейсы:
- **команды** (commands) используются для изменения состояния системы - изменяет состояние системы и генерирует соответствующие события;
- **запросы** (queries) используются для получения данных из системы - не изменяют состояние системы и оптимизированы для быстрого получения данных.

Основные этапы по реализации:
1. Определения команд для операций записи данных и разработки соответствующей модели данных для записи;
2. Создание модели данных для чтения, оптимизированная для быстрых операций чтения;
3. Реализация механизмов обработки команд и запросов и настраивание системы для использования отдельных хранилищ данных, при необходимости;
4. Тестирование и отладка системы, чтобы убедиться в корректной работе разделенных операций чтения и записи.

### Паттерны уровня инфраструктуры

Паттерны уровня инфраструктуры приложений помогают управлять распределенными системами, обеспечивая их наблюдаемость и безопасность.

#### Паттерн Distributed Tracing

**Паттерн Distributed Tracing** позволяет отслеживать запросы и операции в распределенной системе - путь запроса через несколько микросервисов, что помогает диагностировать проблемы и улучшать производительность.

Плюсы:
- **улучшенная наблюдаемость**, поскольку можно проследить полный путь запроса - через все микросервисы, участвующие в обработке;
- **улучшенная диагностика проблем**, поскольку облегчается поиск и устранение проблем производительности и ошибок;
- **оптимизация производительности** из-за возможности выявлять и устранять узкие места в системе.

Минусы:
- **сложность реализации**, так как нужно настроить и интегрировать инструменты для отслеживания запросов;
- **дополнительные накладные расходы**, так как внедрение трейсинга может увеличить накладные расходы на обработку запросов.

#### Паттерн Audit Logging

**Паттерн Audit Logging** предполагает ведение журнала всех действий и изменений в системе, что помогает обеспечить безопасность системы и соответствие нормативным требованиям.

Плюсы:
- **безопасность и соответствие** нормативным требованиям и стандартам безопасности;
- **отслеживание изменений** для того, чтобы обеспечивать прозрачность всех изменений в системе.
- **решение инцидентов** безопасности и устранение их причин.

Минусы:
- **рост объема данных** из-за ведение журналов аудита;
- **организация управления и хранения** больших объемов данных.

### Паттерны уровня инфраструктуры

Паттерны уровня инфраструктуры помогают координировать взаимодействие микросервисов, обеспечивают автоматическое обнаружение микросервисов, их безопасность и управление коммуникациями между микросервисами - сетевыми взаимодействиями, что делает систему более устойчивой и управляемой.

#### Паттерн Service Discovery

**Паттерн Service Discovery** обеспечивает автоматическое обнаружение и подключение микросервисов, позволяет микросервисам динамически находить друг друга: не нужно жестко кодировать адреса и эндпоинты.

Плюсы:
- **автоматизация подключения** микросервисов, чтобы они автоматически находили друг друга, упрощая управление связями;
- **гибкость и масштабируемость**, так как легко добавлять и удалять микросервисы без изменения конфигурации;
- **устойчивость к сбоям**, так как в случае сбоя микросервиса обеспечивается возможность динамического переключения на доступные микросервисы.

Минусы:
- **сложно настроить** систему обнаружения и управлять ею;
- **задержки** в коммуникации из-за процесса обнаружения.

#### Паттерн Service Mesh

**Паттерн Service Mesh** обеспечивает управление сетью микросервисов, включая маршрутизацию, безопасность, наблюдаемость и политику управления, что позволяет отделить сетевые функции от логики приложения, улучшая управляемость и безопасность системы.

Плюсы:
- **безопасность** посредством обеспечивания сквозного шифрование и управления доступом между микросервисами;
- **наблюдаемость**, так как есть детализированные метрики, трассировки и логи для мониторинга и диагностики;
- **управляемость**, которая позволяет централизованно управлять политиками и конфигурациями сети микросервисов.

Минусы:
- **сложно внедрить**, так как нужно приложить много усилий, чтобы настроить Service Mesh и управлять им;
- **производительность** из-за добавления дополнительных накладных расходов на обработку сетевых запросов.

#### Паттерн Service Registry

**Паттерн Service Registry** предоставляет централизованный реестр, который хранит информацию - метаданные о каждом микросервисе, его местоположении и состоянии, для управления взаимодействием микросервисов.

Плюсы:
- **обеспечивание централизованного хранение и управление** информацией о микросервисах;
- **упрощение управления**, так как легко добавлять, удалять и обновлять микросервисы в реестре;
- **интеграция с другими системами** обнаружения сервисов и другими инструментами управления.

Минусы:
- **единая точка отказа**, если не обеспечить надежность реестра;
- **зависимость** микросервисов от доступности реестра.

## Паттерн Strangler Fig

Этот паттерн предлагает итеративный подход к миграции от монолита к микросервисам, когда новую систему постепенно создают по краям старой: компоненты по очереди извлекают из монолита и заменяют на микросервисы. При релизе каждого микросервиса запросы от монолита перенаправляют к новой системе. В итоге бэкенд отмирает по кусочкам, а команда может дорабатывать готовые микросервисы по отзывам пользователей.

Такой подход позволяет постоянно совершенствовать систему и минимизировать риски, которые связаны с большими изменениями.

Основные преимущества:
- **постепенная замена монолита**, что позволяет уменьшить количество сбоев и повысить адаптивность новой системы из-за того, что части монолита заменяются микросервисами итеративно;
- **снижение рисков и управление ими**, так как инкрементные изменения небольшие, то их легче тестировать, отслеживать и откатывать, что уменьшает количество сбоев. Микросервисы запускают параллельно с существующими монолитными компонентами, что позволяет в случае проблем перенаправить запросы обратно на компонент монолита с помощью маршрутизации;
- **инкрементная доставка новых функций в процессе миграции** из-за того, что приложение продолжает развиваться и новые функции и улучшения можно релизить по готовности не дожидаясь окончания миграции;
- **эффективное решение проблемы технического долга**, так как есть систематический рефакторинг вследствие того, что каждый микросервис можно спроектировать и разработать с использованием лучших практик и современных технологий, а также позволит разработать документацию и поддержать стандарты. В первую очередь замена начинается с устаревших компонентов, тогда каждое обновление будет повышать производительность системы и упрощать ее обслуживание.

Шаги по реализации паттерна Strangler Fig:
1. **Определение компонента, который нужно извлечь из монолита** - нужно определить и приоритизировать компоненты монолитного приложения, которые должны быть извлечены. Компонент выбирается с помощью техник:
    - **анализ домена бизнеса** - основан на Domain-Driven Design (DDD) и представляет из себя разделение приложения на домены, которые представляют собой ограниченный контекст бизнес-проблем и целей. Применяется когда монолитное приложение содержит сложную бизнес-логику и поддерживается крупными командами и эта техника помогает структурировать код так, чтобы он лучше отражал бизнес-процессы и был проще в сопровождении и развитии;
    - **технический анализ** - представляет из себя разделение приложения по части кода, который часто меняются или который сложно поддерживать - тесно связанные компоненты, помогает выявить скрытые зависимости и взаимодействия, которые не видны только при бизнес-анализе;
    - **анализ показателей производительности** - представляет из себя разделение приложения по компонентам, вызывающих проблемы с производительностью или требующих больших ресурсов. Применяется в приложениях, которым необходимо эффективное масштабирование.

2. **Проектирование и разработка нового микросервиса** с учетом принципов проектирования:
    - у микросервиса есть единственная, четко определенная зона ответственности;
    - микросервис должен минимально зависить от других сервисов;
    - связанная функциональность должна быть сгруппирована в рамках одного сервиса для поддержания высокой согласованности.

3. **Перенаправление запросов от монолита к микросервису** с помощью:
    - **маршрутизации на основе прокси**:
        - **обратный прокси-сервер**, который будет использоваться для маршрутизации запросов либо к монолиту, либо к новым микросервисам на основе определенных правил;
        - **API-шлюз** - реализуется для управления и маршрутизации трафика, обеспечивая единую точку входа для всех клиентских запросов;
    - **фича-тогглов** - (переключатели функций), которые нужны для управления развертыванием новых функций, чтобы постепенно перенаправлять трафик на новые сервисы;
    - **канареечных релизов**, которые постепенно переводят трафик на новые микросервисы, отслеживая производительность и стабильность перед полным развертыванием.

4. **Внедрения мониторинга и верификаци для микросервиса**. Для оценки производительности и надежности микросервисов используются количественные показатели - **метрики производительности** для каждого микросервиса с пороговым значением уровня производительности:
    - **ключевые показатели эффективности** (Key Performance Indicators, KPI), которые состоят из показателей:
        - времени отклика;
        - частоты ошибок;
        - пропускной способности;
        - количество запросов в секунду.
    - **цели уровня сервиса** (Service-Level Objectives, SLO) - это четко определенные цели в области производительности и доступности сервиса, которые ставятся на основе бизнес-требований, таких как время безотказной работы или время отклика;
    - **индикаторы уровня обслуживания** (Service Level Indicator, SLI) - это количественная оценка работы сервиса, показывающая, выполняются ли SLO, определяются для критических показателей и отслеживаются на соответствие с заданными SLO. К ним относят:
        - латентность - время, необходимое для обработки запроса;
        - доступность - доля времени, в течение которого сервис работает;
        - частота ошибок.

    Для отслеживания производительности, работоспособности и доступности сервисов используются **средства мониторинга**, которые собирают и анализируют данные, чтобы помочь обнаружить проблемы и обеспечить бесперебойную работу служб:
    - **мониторинг производительности приложений** (Application Performance Monitoring, APM), которые отслеживают производительность приложений и отдельных микросервисов в режиме реального времени, предоставляют информацию о времени отклика, количестве ошибок и взаимодействии с пользователями;
    - **централизованное логирование**, которые объединяют журналы различных служб в одном месте, что упрощает поиск, анализ и устранение проблем;
    - **мониторинг инфраструктуры**, которые следят за состоянием и производительностью базовой инфраструктуры (серверы, контейнеры, сетевые компоненты и т.п.).

    Для обеспечивания правильного функционирования новых микросервисов в соответствии с ожидаемым стандартом производительности и надежности используются **методы верификации**:
    - **автоматизированное тестирование** - юнит-тесты, интеграционные тесты, e2e-тесты, которые проверяет функциональность, производительность и интеграцию микросервисов на их соответствие заданным критериям при каждом коммите кода в системе контроля версий;
    - **А/B-тестирование** - для того чтобы сравнивать производительность и влияние на пользователей двух версий сайта, приложения или сервиса, чтобы определить, какая из них работает лучше с помощью перенаправления части запросов на новую версию, а остальную часть - на старую.

5. **Возвращение к шагу 1 до тех пор, пока весь монолит не будет заменен на микросервисы**. Состоит из:
    - **инкрементального извлечения**, которое предполагает разбиение монолитного приложения на более мелкие, управляемые компоненты и постепенную замену их микросервисами;
    - **непрерывного улучшения**, которое направлено на регулярное усовершенствование новых микросервисов с помощью рефакторинга и оптимизации (по мере необходимости) и всей системы в целом, на основе данных о производительности с помощью инструментов APM, анализу обратной связи и меняющихся потребностей бизнеса;
    - **координации работы команды** с помощью сотрудничества между кросс-функциональными командами - разработки, эксплуатации и бизнеса для согласования целей и прогресса, четкой коммуникации с помощью регулярных встреч которые необходимы для обсуждения прогресса, выявления препятствий и планирования следующих шагов, и последовательного документирование на протяжении всего процесса для обеспечения последовательности и обмена знаниями.

Распространенные проблемы:
- **недостаточное планирование** из-за слишком поспешной реализация миграции без четкого плана;
- **отсутствие поддержки заинтересованных сторон** из-за отсутствия понимания предполагаемых рисков;
- **недостаточный мониторинг и тестирование** из-за неспособности адекватно контролировать новые сервисы, что может привести к незамеченным проблемам, влияющим на производительность;
- **игнорирование зависимостей** между компонентами, которые приводят к сбоям или неожиданному поведению;
- **неполная документация** которая может привести к путанице и несогласованным реализациям;
- **игнорирование проблем управления и обмен данными** между монолитом и микросервисами, которые приводят к несогласованности и проблемам целостности данных.

### Методы расстановки приоритетов

#### MoSCoW

Метод приоритизации **MoSCoW** разделяет требования на четыре категории:
- **Must have** (обязательно);
- **Should have** (нужно);
- **Could have** (желательно);
- **Won't have** (можно перенести).

Используется когда у проекта есть четко определенные бизнес-цели, и необходимо тесно увязать технические задачи с приоритетами бизнеса и в процесс вовлечено множество заинтересованных сторон и их согласие крайне важно.

Используется для стратегического планирования.

#### Матрица Эйзенхауэра

**Матрица Эйзенхауэра** - это инструмент управления временем, который помогает расставить приоритеты задач, разделяя их на четыре категории:
- **срочные и важные**;
- **важные, но не срочные**;
- **срочные, но не важные**;
- **не срочные и не важные**.

Используется когда необходимо учитывать срочность задач и где быстрое принятие решений имеет решающее значение.

Используется для повседневного планирования.

## Anti-Corruption Layer

**Anti-Corruption Layer** (ACL) - это паттерн проектирования помогающий создать границу между новой системой и унаследованной. Через этот уровень проходят все данные, которые системы передают друг другу. ACL знает их форматы и модели данных. Он адаптирует информацию под требования получателя.

Создается с помощью паттернов **Facade** и **Adapter** и располагается в монолите.

Основные задачи ACL:
- **изоляция микросервисов от сложностей и проблем унаследованной системы** для того чтобы повысить шансы на то, что новые системы будут работать эффективно;
- **управление маршрутизацией запросов между монолитом и микросервисами**;
- **адаптация данных под требования разных систем**;
- **инкапсуляция монолитной системы**, чтобы микросервисы взаимодействовали с чистым и последовательным интерфейсом унаследованной системы, что упрощает разработку и сопровождение новых сервисов.

Принцип работы:
1. **Микросервис** взаимодействует с **монолитной системой** - он посылает запрос на **ACL**;
2. **ACL** передает запрос **адаптеру**, чтобы он перевел запрос микросервиса в формат и семантику монолитной системы;
3. **Адаптер** переводит запрос и отправляет его **монолитной системе**;
4. **Монолитная система** обрабатывает запрос и отправляет ответ **адаптеру**;
5. **Адаптер** переводит ответ в формат и семантику микросервиса, а затем передает запрос **ACL**;
6. **ACL** отправляет переведенные данные **микросервису**.

ACL используется только в процессе перехода, позволяя провести постепенную миграцию. ACL выводят из эксплуатации, когда все зависимые сервисы перенесли в архитектуру микросервисов.

Не используется когда:
- прямую интеграцию просто осуществить;
- разрабатывается краткосрочный проект или временное решение;
- критически важна производительность приложения;
- ограниченность ресурсов;
- при внедрении система станет слишком сложной.

Внедрение состоит из указанных шагов:
1. **Определение границ и зависимостей** между унаследованной системой и микросервисами - какие части унаследованной системы будут взаимодействовать с новыми сервисами и должны быть доступны и какие у них будут общие данные, процессы и функциональные возможности;
2. **Разработка интерфейса ACL**, который абстрагирует сложности унаследованной системы и должен быть чистым и четко определенным, а также согласованым с требованиями микросервисов;
3. **Внедрение ACL-компонентов**:
    - **адаптеров данных**, которые преобразуют форматы данных и обеспечивают совместимость унаследованной системы и микросервисов;
    - **шлюзов сервисов**, которые нужны для управления взаимодействием между старой системой и микросервисов - преобразованием протоколов, маршрутизацией запросов и преобразованием ответов;
    - **инкапсуляция бизнесс-логики** для того чтобы микросервисы могли взаимодействовать с упрощенным и согласованным интерфейсом.
4. **Тестирование ACL** чтобы убедиться что он правильно транслирует данные и протоколы между старой системой и новыми сервисами и не вносит значительных задержек или накладных расходов;
5. **Развертывание ACL и внедрение мониторинга**.

## Маршрутизация в микросервисах

**Маршрутизация** - это способы управления и направления потока трафика между различными частями системы.

Польза маршрутизации в период миграции:
- **безболезненное взаимодействие с пользователями** для обеспечения минимальных перебоев в работе пользователей и стабильную производительность при замене одной части системы на другую или ее обновлении;
- **непрерывность работы**, так как она позволяет старой и новой системам сосуществовать и работать одновременно;
- **инкрементное развертывание** что позволяет поддерживать поэтапное развертывание новых функций и сервисов;
- **управление рисками** за счет возможности отката или перенаправления трафика.

Основные проблемы:
- **сложность управления трафиком** из-за управления **множеством путей** трафика как к монолиту, так и к микросервисам, что повышает сложность и обеспечение **согласованности данных и состояния** как монолитного компонента, так и микросервиса, особенно при записи;
- **задержка и производительность** из-за наличия дополнительного уровня, который может стать узким местом;
- **обработка сбоев** при отказе сервисов и создания **механизмов аварийного восстановления** (fallback mechanisms) для перенаправления трафика с сервисов;
- **безопасность данных и управление доступом** между старой системой и новыми микросервисами;
- **полная видимость потока трафика и отладка проблем в гибридной среде**.

### Техники маршрутизации между монолитом и новыми сервисами

#### Обратный прокси

**Обратный прокси-сервер** (reverse proxy) - это промежуточный сервер, который ретранслирует запросы клиентов из внешней сети на один или несколько серверов внутренней сети.

Правила и условия маршрутизации определяют на основе шаблонов URL, заголовков или других атрибутов запроса, которые обозначают назначение трафика.

Имеет такие преимущества:
- **упрощенная маршрутизация**, так как логика маршрутизации централизуется, что упрощает управление и обновление в процессе миграции;
- **балансировка нагрузки** из-за распределения входящего трафика между несколькими экземплярами службы, что повышает производительность и надежность;
- **безопасность**, так как действует в виде барьера между клиентами и внутренними серверами, что обеспечивает дополнительный уровень безопасности;
- **кэширование** для того, чтобы снизить нагрузку на внутренние службы и улучшить время отклика.

#### API Gateway

**API Gateway** выполняет функции прокси-сервера, принимая все клиентские запросы и маршрутизируя их к соответствующим микросервисам. Позволяет скрыть внутреннюю структуру микросервисов от клиентов, предоставляет единый интерфейс для взаимодействия с системой. Также может выполнять множество дополнительных задач, таких как трансформация запросов и ответов, кэширование, мониторинг, логирование, управление сессиями, аутентификацией и авторизацией.

Плюсы:
- **единая точка входа** так как клиенты взаимодействуют с системой через единый интерфейс, что упрощает управление и мониторинг;
- **управление аутентификацией и авторизацией**, проверяя учетные данные клиентов и контролируя доступ к различным микросервисам на основе ролей и прав доступа;
- **безопасность** - шифрование данных, защиту от DDoS-атак и ограничение скорости запросов (rate limiting) - для защиты системы от угроз и атак;
- **кэширование запросов** на часто запрашиваемые ресурсы, для того, чтобы уменьшить нагрузку на микросервисы и повысить производительность системы;
- **маршрутизация и балансировка нагрузки** к соответствующим микросервисам и балансировка нагрузки между ними;
- **мониторинг и логирование**, поскольку собираются и анализируются метрики и логи запросов, что помогает отслеживать производительность и обнаруживать проблемы.

Минусы:
- **единая точка отказа**, если не обеспечены механизмы высокой доступности;
- **сложность** в управлении и настройке: а также требование дополнительных ресурсов.

Основные подходы:
- **монолитный API Gateway** - для всех групп микросервисов он един:
    - плюсы:
        - единая точка управления всеми API запросами;
        - централизованное управление безопасностью и логированием.
    - минусы:
        - единая точка отказа;
        - возможная сложность управления при масштабировании системы.
- **распределенный API Gateway** - для каждой группы микросервисов есть свой:
    - плюсы:
        - уменьшение единой точки отказа;
        - улучшенная масштабируемость и производительность.
    - минусы:
        - повышенная сложность управления и настройки;
        - возможные проблемы с согласованностью данных.
- **многослойный API Gateway** - когда есть внешний и внутренний:
    - плюсы:
        - улучшенная безопасность;
        - улучшенная масштабируемость;
        - упрощенное управление и мониторинг;
        - повышенная производительность.
    - минусы:
        - повышенная сложность;
        - трудности настройки;
        - увеличение времени отклика;
        - затраты на инфраструктуру.
- **serverless API Gateway**:
    - плюсы:
        - высокая масштабируемость;
        - отсутствие необходимости управления инфраструктурой;
        - уменьшение затрат на ресурсы.
    - минусы:
        - возможные ограничения в функциональности и производительности;
        - зависимость от облачного провайдера.

Ключевые метрики анализа API Gateway:
1. **Метрики производительности**:
    1. **Запросы в секунду** (Requests per Second, RPS) - количество запросов, обрабатываемых API Gateway в секунду, которая помогает определить нагрузку на систему и выявить пиковые моменты активности;
    2. **Время отклика** (Response Time) - среднее время, затрачиваемое на обработку запросов. При этом важно отслеживать как среднее время отклика, так и 95-й и 99-й процентили для выявления долгих запросов;
    3. **Время до первого байта** (Time to First Byte, TTFB) - время, прошедшее от отправки запроса до получения первого байта ответа. Высокий TTFB может указывать на проблемы с сервером или сетью.
2. **Метрики ошибок**:
    1. **Количество ошибок** (Error Rate) - процент запросов, завершившихся ошибками (например, HTTP 4xx и 5xx). Высокий уровень ошибок может указывать на проблемы с API или инфраструктурой;
    2. **Виды ошибок** (Error Types) - распределение ошибок по типам (4xx - ошибки клиента, 5xx - ошибки сервера), которые помогает определить источник проблемы;
    3. **Ошибки авторизации и аутентификации** (Authentication and Authorization Failures) - количество запросов, не прошедших проверку аутентификации или авторизации. Высокий уровень таких ошибок может указывать на проблемы с безопасностью.
3. **Метрики безопасности**:
    1. **Неудачные попытки входа** (Failed Login Attempts) - количество неудачных попыток входа может свидетельствовать о возможных атаках;
    2. **IP-адреса с наибольшим количеством запросов** (Top Requesting IPs) - IP-адреса, с которых поступает наибольшее количество запросов. Это помогает выявить потенциальные DDoS-атаки;
    3. **Аномалии в трафике** (Traffic Anomalies) - внезапные изменения в объеме или характере трафика могут указывать на атаки или другие проблемы безопасности.
4. **Метрики использования ресурсов**:
    1. **Память** (Memory Usage) - объем памяти, используемой API Gateway. Высокое потребление памяти может привести к снижению производительности или сбоям;
    2. **Использование сети** (Network Usage) - объем входящего и исходящего трафика через API Gateway. Помогает определить нагрузку на сеть и выявить проблемы с пропускной способностью.
5. **Метрики отказоустойчивости**:
    1. **Время безотказной работы** (Uptime) - время, в течение которого API Gateway остается доступным и функционирующим для того, чтобы оценить надежность системы;
    2. **Частота отказов** (Failure Frequency) - количество отказов API Gateway за определенный период. Высокая частота отказов указывает на проблемы с надежностью.
6. **Метрики производительности кэша**:
    1. **Процент попаданий в кэш** (Cache Hit Rate) - процент запросов, которые обрабатываются из кэша. Высокий процент попаданий в кэш улучшает производительность и снижает нагрузку на сервер;
    2. **Процент промахов в кэше** (Cache Miss Rate) - процент запросов, которые не были найдены в кэше и потребовали обращения к исходному серверу.

#### Service Mesh

**Service Mesh** - это выделенный инфраструктурный уровень для обработки взаимодействия между микросервисами. Он обеспечивает надежное и безопасное общение между сервисами, позволяя автоматизировать маршрутизацию запросов, балансировку нагрузки, управление трафиком и мониторинг.

Он предполагает, что рядом с каждым экземпляром микросервиса развертывается прокси-сервер **Sidecar** в рамках одного пода или контейнера, который управляет всеми сетевыми соединениями с микросервисом - координирует запросы к нему и от него.

Основные концепции:
- **Data Plane** (плоскость данных):
    - обработка и управление сетевыми запросами между микросервисами;
    - состоит из **Sidecar Proxy** (прокси-серверов), которые установлены рядом с каждым микросервисом, для перехватывания трафика;
    - реализация функций маршрутизации, балансировки нагрузки, шифрования и аутентификации.
- **Control Plane** (плоскость управления):
    - управляет и конфигурирует **Data Plane**;
    - предоставляет интерфейсы для настройки и управления политиками сетевого взаимодействия;
    - содержит компоненты для мониторинга, логирования и управления конфигурациями.
- **Sidecar Proxy**:
    - легковесный прокси-сервер, установленый рядом с каждым микросервисом;
    - перехватывает все входящие и исходящие запросы микросервиса, обеспечивает управление трафиком и безопасность.
- **Политики безопасности**:
    - определяют правила аутентификации и авторизации для взаимодействий между микросервисами;
    - содержит механизмы шифрования трафика и контроля доступа.
- **Политики маршрутизации**:
    - определяют правила маршрутизации трафика;
    - определяют пути прохождения запросов в зависимости от различных условий.
- **Мониторинг**:
    - сбор метрик производительности и доступности микросервисов.
- **Триссировка** (tracing):
    - отслеживает путь прохождения запрососв через микросервисы, выявляя узкие места и задержки.
- **Fault Injection** (введение ошибок):
    - позволяет тестировать устойчивость системы к отказам путем намеренного введения ошибок;
    - позволяет симулировать различные виды сбоев - задержки, отказ сервисов и нарушения сетевых взаимодействий;
    - помогает выявлять и устранять уязвимости в системе до их реального появления.
- **Ретрайлы и тайм-ауты**:
    - позволяет настраивать ретрайлы (повторные попытки) и тайм-ауты для взаимодействия между микросервисами;
    - обеспечивает устойчивость системы при временных сбоях и перегрузках.
- **Канареечные развертывания и A/B-тестирование**:
    - позволяет развертывать новые версии микросервисов на небольшую часть пользователей для тестирования;
    - позволяет минимизировать риски при внедрении изменений.

##### Feature Toggling

**Feature Toggling** (Feature Flags) - это подход, который позволяет включать и отключать функциональные возможности приложения без необходимости развертывания нового кода, что особенно полезно для управления рисками при выпуске новых функций и проведения экспериментов.

Этот подход позволяет:
- **выпускать новые функции постепенно**, так как новые функции можно включать только для части пользователей, чтобы оценить их работу и устранить возможные проблемы;
- **проводить A/B-тестирование** версий функций на разных группах пользователей для оценки их эффективности;
- **управлять рисками**, поскольку есть возможность быстро отключить проблемную функцию, если она вызывает ошибки или негативные последствия для пользователей.

## Проектирования микросервисов

Состоит из определения:
1. **Границ сервисов** - идентификации бизнес-доменов и субдоменов и обеспечения того, чтобы сервисы инкапсулировали конкретные бизнес-функции;
2. **Методов взаимодействия** между микросервисами с помощью:
    - **синхронного** взаимодействия чтобы обеспечить высокую производительность и быстрый отклик;
    - **асинхронного** взаимодействия, которое эффективнее для развязки и масштабируемости;
3. **Управления данными** которое должно обеспечивать в нескольких сервисах:
    - **согласованность данных** - чтобы изменение данных в одной системе предсказуемо влияло на другие системы;
    - **целостность данных** - поддержание корректности и надежности данных при их распределении;
    - **производительность** за счет масштабируемости, балансировки для уменьшения задержки;
    - **конкурентность** для одновременного доступа к данным и их обновления без конфликтов;
    - **доступность** для служб даже в случае сбоев.
4. **Стратегии развертывания** которые определяют, как новые версии микросервисов будут вводиться в эксплуатацию, минимизируя риски и обеспечивая непрерывность работы системы. А также совместимость новых версий микросервисов с текущими, возможность тестирования в реальной среде, механизмы для мониторинга состояния системы и быстрого отката в случае проблем;
5. **Балансировки нагрузки**, которая обеспечивает равномерное распределение трафика, для того чтобы входящие запросы равномерно распределялись между несколькими экземплярами сервиса, не позволяя какому-либо одному экземпляру стать узким местом. Способствует:
    - **повышению производительности и пропускной способности** из-за равномерного распределения запросов, чтобы каждый экземпляр службы обрабатывал управляемую нагрузку, обеспечивая более быстрое время отклика для пользователей;
    - **высокой доступности и надежности**, так как направляет трафик от отказавших или перегруженных экземпляров к исправным, что гарантирует, что приложение останется доступным, даже если некоторые экземпляры сервисов не работают или испытывают большую нагрузку;
    - **масштабируемости**, позволяя плавно добавлять новые экземпляры сервиса, что даст возможность по мере роста нагрузки подключить дополнительные экземпляры, на которые балансировщик нагрузки начнет направлять трафик, обеспечивая способность системы справляться с возросшим трафиком;
    - **устойчивости к сбоям** благодаря мониторингу состояния экземпляров сервисов, чтобы автоматически обнаруживать и удалять из пула нездоровые экземпляры, не позволяя им принимать трафик, что повышает отказоустойчивость системы, гарантируя, что сбои изолированы и не влияют на общую производительность.
6. **Устойчивости к сбоям**, которая обеспечивает проектировку микросервисов таким образом, чтобы легко справляться с отказами некоторых сервисов и не приводить к отказу всей системы благодаря внедрению механизмов повторных попыток, использованием прерывателей для предотвращения каскадных отказов и проектированию сервисов без состояний;
7. **Масштабируемости** в зависимости от нагрузки и проектированию сервисов без состояний;
8. **Безопасности** за счет внедрения сегментации сети из-за распределенной системы, которая ограничивает доступ между различными частями системы и внедрения **HTTPS** для защиты данных при передаче между микросервисами и внешними клиентами, и использование стандартов **OAuth2** / **OpenID Connect** для управления доступом и подтверждения личности пользователей и сервисов;
9. **Мониторинга и наблюдения** за состоянием и производительностью микросервисов для обеспечения надежности и доступности систем, а также агрегирование и анализ данных по всем сервисам;
10. **Хранения данных**, так как каждый микросервис может иметь уникальные требования к хранению данных и правильное разделение данных между микросервисами помогает минимизировать зависимости и улучшить управляемость системы, способствуя независимому масштабированию и развертыванию отдельных компонентов;
11. **API-менеджмента** для создания, публикации, мониторинга, управления и обеспечения безопасности интерфейсов прикладного программирования (API) в безопасной и масштабируемой среде, чтобы централизованно управлять доступом, маршрутизацией запросов, мониторингом и безопасностью API и обеспечивать балансировку нагрузки и защиту от атак. А также документирование API для того, чтобы обеспечить ясное описание функциональности и использования интерфейсов, чтобы разработчики могли быстро и правильно интегрировать API в свои приложения;
12. **Тестирования и валидации** чтобы проверять работоспособность и соответствие функциональных требований разрабатываемого продукта и убеждаться, что созданный продукт соответствует ожиданиям пользователей и бизнес-задачам;
13. **DevOps-практик** для обеспечивания быстрых итераций и непрерывных доставок, способствуя созданию гибкой среды разработки;
14. **Версионирования и совместимости** различных версий микросервисов друг с другом путем управление API и контрактами данных между сервисами, и обеспечивания обратной совместимости новых версий API с предыдущими.

### Принципы 12-факторных приложений

Основные принципы:
1. **Кодовая база** (Codebase) - каждое приложение должно иметь одну кодовую базу, отслеживаемую в системе контроля версий, и множество развертываний;
2. **Зависимости** (Dependencies) - все зависимости должны быть явными и управляться через декларацию в манифесте;
3. **Конфигурация** (Config) - конфигурация приложения должна храниться в переменных окружения, а не в коде;
4. **Сторонние службы** (Backing Services) - все сторонние службы должны рассматриваться как внешние сервисы, которые могут быть легко заменены;
5. **Сборка, выпуск, запуск** (Build, Release, Run) - процесс сборки приложения, выпуска, где добавляются конфигурационные параметры, и запуска на сервере должен быть разделен на отдельные стадии;
6. **Процессы** (Processes) - приложение должно работать как одно или несколько stateless-процессов;
7. **Порт привязки** (Port Binding) - приложение должно быть самодостаточным и не зависеть от внешнего веб-сервера;
8. **Конкурентные процессы** (Concurrency) - приложение должно уметь масштабироваться путем запуска множества процессов или потоков;
9. **Утилизируемость** (Disposability) - процессы должны быть легкими для запуска и остановки, что позволяет легко масштабировать приложение в зависимости от нагрузки и быстро реагировать на изменения;
10. **Среды разработки и эксплуатации** (Dev/Prod Parity) - среда разработки должна максимально приближаться к среде эксплуатации;
11. **Логи** (Logs) - приложение должно писать свои логи в *stdout*;
12. **Административные процессы** (Admin Processes) - административные задачи должны выполняться как одноразовые процессы.

### Легковесные микросервисы

**Легковесные микросервисы** (Lightweight Microservices) - это подход к проектированию программных компонентов, при котором каждый микросервис минимален по своему размеру и функциональности, что позволяет ему быстро запускаться и эффективно использовать ресурсы.

Основная цель легковесных микросервисов - обеспечить гибкость, масштабируемость и независимость развертывания различных частей системы.

Основные принципы:
1. **Минимализм** - каждый микросервис должен выполнять одну конкретную задачу, что помогает уменьшить сложность кода и облегчает их тестирование и отладку, что способствует тому, что микросервисы имеют меньше зависимостей, что сокращает их размер и время запуска;
2. **Независимость** - микросервисы должны быть независимы друг от друга, что означает, что они могут разрабатываться, развертываться и масштабироваться независимо за счет четко определенных API для взаимодействия между микросервисами;
3. **Быстрое время запуска** - микросервисы должны быстро запускаться для автоматического масштабирования и развертывания, что позволяет быстрее реагировать на изменения нагрузки и быстро восстанавливаться после сбоев;
4. **Эффективное использование ресурсов** - микросервисы должны эффективно использовать ресурсы, такие как память и процессорное время, что достигается за счет оптимизации кода и использования легковесных библиотек и фреймворков;
5. **Упрощение зависимостей** - микросервисы должны иметь минимальное количество зависимостей, что снижает риск конфликтов версий и упрощает процесс обновления и развертывания;
6. **Обеспечение изоляции** - каждый микросервис должен быть изолирован от других, что позволяет избежать проблем с совместным использованием ресурсов и облегчает отладку, что достигается за счет использования контейнеров;
7. **Документирование и автоматизация** - каждый микросервис должен быть хорошо задокументирован и иметь автоматизированные процессы развертывания и тестирования, что позволяет быстрее внедрять изменения и уменьшает вероятность ошибок.

## Процесс взаимодействия между микросервисами

### Синхронное взаимодействие

**Синхронное взаимодействие** - это подход к обмену данными между компонентами системы, при котором клиент (инициатор запроса) ожидает завершения операции и получения ответа от сервера (обработчика запроса) до продолжения своей работы.

Плюсы:
- простота реализации;
- предсказуемость времени отклика;
- легкость отладки и мониторинга запросов.

Минусы:
- высокая задержка в случае медленного ответа;
- увеличение зависимости между сервисами;
- ограниченная масштабируемость из-за блокирующих вызовов.

Ключевые концепции:
- **запрос-ответ** (request-response) - когда клиент отправляет запрос серверу и ожидает получения ответа. Сервер обрабатывает запрос и возвращает результат клиенту. Особенности:
    - **плюсы**: простой и понятный подход, обеспечивает четкую последовательность операций;
    - **минусы**: клиент блокируется, пока сервер не завершит обработку запроса, что может привести к задержкам и снижению производительности.
- **таймауты** (timeouts) - используются для ограничения времени ожидания ответа от сервера. Если сервер не отвечает в установленное время, клиент получает ошибку таймаута. Особенности:
    - **плюсы**: помогает избежать бесконечного ожидания и позволяет клиенту обработать ошибки;
    - **минусы**: таймауты могут быть сложны в настройке и управлении, особенно при высоких нагрузках и изменяющихся условиях сети.
- **блокировка** (blocking) - когда клиентский поток блокируется до получения ответа от сервера. В этот период клиент не может выполнять другие операции. Особенности:
    - **плюсы**: простота реализации и отладки;
    - **минусы**: может привести к снижению производительности и отзывчивости системы, особенно при высоких нагрузках.
- **зависимости** (dependencies) - когда операции часто зависят друг от друга. Если одна операция не завершена, последующие операции не могут быть выполнены. Особенности:
    - **плюсы**: позволяет легко отслеживать порядок выполнения операций и управлять им;
    - **минусы**: могут возникать узкие места и блокировки, особенно при сбоях или перегрузках в системе.
- **управление состоянием** (state management) - может быть сложным, поскольку состояние может изменяться в зависимости от результата каждого запроса. Особенности:
    - **плюсы**: легкость в управлении состоянием при небольших масштабах и простой архитектуре;
    - **минусы**: может стать сложным при увеличении масштабов системы и увеличении числа взаимодействующих компонентов.
- **изоляция ошибок** (error isolation) - когда ошибки, возникающие в одном компоненте, могут передаваться и влиять на другие компоненты, поскольку клиент ожидает завершения всей цепочки операций. Особенности:
    - **плюсы**: простота обработки ошибок при небольших системах;
    - **минусы**: ошибки могут распространяться по всей системе, что усложняет управление и отладку.
- **параллелизм** (parallelism) - ограничен, поскольку клиент блокируется до получения ответа. Особенности:
    - **плюсы**: упрощает поток выполнения операций в определенном порядке;
    - **минусы**: ограничивает возможности масштабирования и параллельного выполнения задач.

#### REST

**REST** (Representational State Transfer) - это архитектурный стиль, использующий стандартные методы HTTP (`GET`, `POST`, `PUT`, `DELETE`) для связи между сервисами. Он основан на связи без статических параметров и на архитектуре клиент-сервер, когда клиент отправляет запросы, а сервер отвечает соответствующими ресурсами.

**Принципы**:
- **отсутствие статуса у сервера** - когда каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для понимания и обработки запроса и сервер не хранит контекст клиента между запросами;
- **унифицированный интерфейс** - согласованный способ взаимодействия с ресурсами, обычно использующий стандартные методы HTTP;
- **Resource-Based** - когда сервисы моделируются как ресурсы, идентифицируются по URL и управляются с помощью форматов (JSON, XML и т.п.);
- **архитектура клиент-сервер** - когда клиент и сервер разделены, что позволяет им развиваться независимо друг от друга;
- **кэшируемость** - так как ответы могут определять, можно ли их кэшировать для повышения производительности.

**Преимущества использования**:
- **стандартизация** - обеспечивается стандартизированный способ доступа к ресурсам, что облегчает понимание и использование разработчиками;
- **масштабируемость** - из-за отсутствие статичности, что позволяет сервисам легко масштабироваться;
- **интероперабельность** - так как взаимодействие происходит на основе HTTP, что обеспечивает совместимость различных платформ и языков;
- **отсутствие специализированных фреймворков** - так как стандартная реализация есть в большинстве современных языков программирования.

**Используется для**:
- **общедоступных API** благодаря своей простоте и широкому распространению;
- **CRUD-операции** (create, read, update, delete) из-за ресурсного подхода;
- **связи микросервисов** в сценариях, в которых сервисы должны предоставить *endpoints* для доступа к данным или работы с ними.

#### RPC

**RPC** (Удаленный вызов процедур) - это метод связи между серверами в распределенной системе, который позволяет программе вызывать функции или процедуры, находящиеся на удаленном сервере, как если бы они были локальными.

RPC абстрагирует сетевую коммуникацию, предоставляя разработчикам более простой и понятный способ взаимодействия между компонентами распределенных систем.

**Основные характеристики**:
- **прозрачность** - так как вызов удаленной функции выглядит так же, как и вызов локальной функции;
- **синхронность** - когда клиент ожидает ответа от сервера для продолжения выполнения;
- **типизация** - что позволяет проверять корректность данных на этапе компиляции.

### Асинхронное взаимодействие

**Асинхронное взаимодействие** - это подход к обмену данными между компонентами системы, позволяющее микросервисам общаться без необходимости немедленного ответа, что значительно улучшает масштабируемость и надежность системы.

Плюсы:
- высокая масштабируемость за счет немедленного освобождения ресурсов;
- устойчивость к сбоям благодаря очередям и повторной обработке сообщений;
- снижение зависимости между сервисами.

Минусы:
- сложность реализации и отладки;
- временная несогласованность данных;
- потребность в дополнительных компонентах для обеспечения доставки и хранения сообщений.

Основные концепции:
- **сообщения** - представляют собой единицы данных, которые отправляются от одного микросервиса к другому. Могут содержать информацию о событиях, данных или командах для выполнения определенных действий;
- **события** - это уведомления о произошедших изменениях в системе. Они позволяют микросервисам реагировать на изменения состояния системы;
- **очереди** - используются для временного хранения сообщений или событий до тех пор, пока получатель не будет готов их обработать. Очереди обеспечивают надежную доставку и помогают справляться с пиковыми нагрузками, распределяя обработку сообщений во времени.

Основные подходы:
- **push-подход** - когда отправитель данных (продюсер) активно отправляет данные получателю (консьюмеру). Подход часто используется в моделях **Publish/Subscribe** и **Event Sourcing**;
- **pull-подход** - когда получатель данных (консьюмер) активно запрашивает данные у отправителя (продюсера) или из хранилища (например, очереди сообщений). Подход часто используется в моделях **Message Queueing**.

Основные паттерны:
1. **Message Queueing** (Очередь сообщений) - это модель взаимодействия, при которой сообщения отправляются в очередь, где они хранятся до тех пор, пока получатель (консьюмер) не будет готов их обработать;
2. **Event Sourcing** (Хранение событий) - это паттерн, при котором состояние системы сохраняется как последовательность событий. Каждое изменение состояния записывается как событие, и текущее состояние системы можно восстановить путем проигрывания всех событий;
3. **Publish/Subscribe** (Публикация/Подписка) - это модель взаимодействия, при которой продюсеры отправляют сообщения в один или несколько топиков, на которые подписаны консьюмеры. Все подписчики получают сообщения асинхронно;
4. **Choreography** (Хореография) - это паттерн, при котором каждый микросервис реагирует на события и производит собственные события для других микросервисов. Взаимодействие координируется без центрального контроля;
5. **Orchestration** (Оркестрация) - это паттерн, при котором централизованный компонент (оркестратор) управляет взаимодействием между микросервисами, инициируя и контролируя выполнение задач.

#### Event-Driven Architecture

**Event-Driven Architecture** (EDA, Архитектура, управляемая событиями) - это парадигма проектирования, в которой поток программы определяется событиями, такими как действия пользователя, выходы датчиков или сообщения от других сервисов.

EDA способствует свободному соединению, масштабируемости и обработке данных в реальном времени, позволяя сервисам реагировать на события асинхронно.

**Ключевые принципы**:
- **продюсеры** генерируют события, а **консьюмеры** прослушивают и реагируют на них;
- **брокеры** являются посредниками между продюсерами и консьюмерами, обеспечивая надежную доставку событий;
- **потоки** событий непрерывны, и их можно обрабатывать в режиме реального времени.

**Преимущества архитектуры**:
- **масштабируемость** - так как сервисы могут масштабироваться независимо в зависимости от нагрузки на события;
- **разделение** - сервисы могут работать независимо друг от друга, уменьшая взаимозависимость;
- **обработка в реальном времени**, которая обеспечивает аналитику в реальном времени и быстро реагирующие системы;
- **устойчивость к сбоям** - когда сообщения могут быть поставлены в очередь, что гарантирует, что они не будут потеряны и смогут быть обработаны, когда потребитель будет доступен.

**Системы обмена сообщениями** обеспечивают асинхронную связь между сервисами, позволяя им обмениваться сообщениями через инфраструктуру обмена сообщениями. Они помогают разделять сервисы, улучшать масштабируемость и повышать отказоустойчивость, предоставляя буфер, способный справиться с переменной нагрузкой и временной недоступностью сервисов. Являются основой для EDA.

##### Kafka

**Kafka** - это распределенная потоковая платформа, разработанная для публикации, подписки, хранения и обработки потоков данных в реальном времени.

Основные компоненты:
1. **Брокеры** (Brokers) - узлы в кластере, которые хранят и обрабатывают данные. Каждый брокер отвечает за управление одним или несколькими разделами (partitions) топиков. Применяются для хранения сообщений, репликации данных для обеспечения отказоустойчивости, обработки запросов от продюсеров и консьюмеров;
2. **Топики** (Topics) - логические каналы, по которым передаются сообщения. Каждый топик может состоять из нескольких **разделов** для параллельной обработки. Основное назначение разделов - организация сообщений по категориям, обеспечение параллельной обработки данных;
3. **Продюсеры** (Producers) - клиенты, которые публикуют сообщения в топики. Продюсеры могут отправлять данные в один или несколько топиков одновременно. Занимаются публикацией данных в топики, выбирают разделы для отправки сообщений (например, по ключу);
4. **Консьюмеры** (Consumers) - клиенты, которые читают сообщения из топиков. Консьюмеры могут объединяться в группы, чтобы обеспечить балансировку нагрузки. Выполняют функции чтения и обработки сообщений из топиков, управления смещениями (offsets) для отслеживания состояния обработки;
5. **Зоокипер** (ZooKeeper) - сервис для координации и управления кластером. Используется для хранения метаданных о топиках, брокерах и смещениях консьюмеров. Предназначен для управления конфигурацией кластера, координации работы брокеров, поддержки лидерства разделов.

### Выбор метода взаимодействия

Осуществляется по ключевым факторам:
- **латентности** (время, необходимое для прохождения сообщения от отправителя к получателю и обратно):
    - синхронные методы для задач, где требуется немедленный ответ;
    - асинхронные методы для некритичных по времени операций, где задержка может быть терпимой или не требуется немедленного ответа на запрос.
- **консистентности данных** для обеспечения целостности данных в распределенных сервисах:
    - синхронные методы для операций, требующих немедленной согласованности;
    - асинхронные методы для сценариев, в которых допустима конечная согласованность.
- **масштабируемости** - способность справляться с растущими нагрузками путем добавления дополнительных ресурсов:
    - синхронные методы для более простых, тесно связанных взаимодействий;
    - асинхронные методы для сервисов, которые должны масштабироваться независимо друг от друга и обрабатывать всплески трафика.
- **отказоустойчивости** - способность системы продолжать работу в случае сбоя:
    - синхронные методы требуют надежной обработки ошибок и механизмов повторных попыток для достижения отказоустойчивости;
    - асинхронные методы для повышения отказоустойчивости и предотвращения потери сообщений при сбоях в работе служб.

## Работа с данными

Работа с данными должна подчиняться требованиям ACID:
- **Atomicity** - атомарность - все операции в транзакции либо завершаются успешно, либо откатываются;
- **Consistency** - целостность - любое изменение данных проходит через транзакционные контексты, которые следят за соблюдением всех ограничений;
- **Isolation** - изолированность - позволяет избежать конфликтов между параллельными транзакциями;
- **Durability** - надежность - все изменения, сделанные в рамках транзакции, применяются и сохраняются даже в случае сбоя системы.

Стратегии обеспечения согласованности данных:
- **конечная согласованность**, которая гарантирует, что при необходимом времени все реплики данных придут к одному и тому же значению. Используется в распределенных системах, где не требуется немедленная согласованность. Подходит для сценариев, в которых высокая доступность и устойчивость к разделениям более важны, чем немедленная согласованность;
- **строгая согласованность**, которая гарантирует, что все операции чтения возвращают последнюю запись. Используется когда требуется строгая точность данных. Подходит для критически важных операций, где точность данных не может быть нарушена;
- **партицирование данных**, которое подразумевает разделение большого набора данных на более мелкие и управляемые части (партиции), распределенные между несколькими узлами. Используется когда требуется сбалансировать нагрузку и повысить производительность. Подходит для крупномасштабных систем, где различные разделы могут управляться независимо друг от друга для обеспечения масштабируемости и производительности.

### Распределенные транзакции

Распределенные транзакции координируют выполнение операций в нескольких сервисах, чтобы гарантировать, что все части транзакции либо зафиксируются, либо откатятся вместе.

#### Протокол двухфазной фиксации 

**Протокол двухфазной фиксации** (2 Phase Commit, 2PC) - это подход к управлению распределенными транзакциями, которы включает в себя две фазы:
- **фаза подготовки**, когда координатор отправляет сообщение `prepare` всем участвующим сервисам с просьбой подготовиться к фиксации транзакции. На что каждый сервис отвечает голосованием (**зафиксировать** или **прервать**) в зависимости от того, сможет ли он успешно зафиксировать транзакцию;
- **фаза фиксации**, когда все сервисы голосуют за фиксацию, координатор отправляет сообщение о фиксации всем сервисам, указывая им на фиксацию транзакции. Если какая-либо служба голосует за отказ, координатор посылает сообщение об **отказе**, предписывая всем службам откатить транзакцию.

**Проблемы**:
- **блокировка** - в случае если координатор не справляется, участники могут остаться в неопределенном состоянии, ожидая решения;
- **производительность**, так как протокол может вносить задержки из-за необходимости многократных обходов между координатором и участниками.

#### Паттерн Saga

**Паттерн Saga** - это архитектурный паттерн для управления распределенными транзакциями в микросервисных системах, который обеспечивает целостность данных и позволяет управлять ошибками при выполнении долговременных бизнес-процессов, которые включают несколько микросервисов. Это решается с помощью набора локальных транзакций и компенсирующих действий. Каждая транзакцию дробиться системой на шаги, которыми занимаются разные микросервисы. В случае ошибки система активирует отмену действия, которая распространяется на все вовлеченные микросервисы.

Подходы к координации шагов:
- **оркестрацию** - которая подразумевает наличие отдельного сервиса-оркестратора, который управляет последовательностью выполнения шагов и при необходимости инициирует компенсирующие действия. Применяется когда есть:
    - **сложные бизнес-процессы** с четкой последовательности действий;
    - **потребность в централизованном управлении** потоком операций и логикой обработки ошибок;
    - **координация транзакций** с обеспечением согласованности и возможности отката;
    - **сложная бизнес-логика и управление состоянием** которые реализуются в центральном оркестраторе.
- **хореографию** - когда микросервисы взаимодействуют через события и знают что делать после выполнения своего шага, а также сами инициируют компенсирующие действия. Применяется когда есть:
    - **простые взаимодействия** и не требуется сложная координации между ними;
    - **независимые микросервисы** и изменение одного сервиса не сильно влияет на другие;
    - **в приоритете гибкость и масштабируемость в системе**. чтобы изменения в одном микросервисе не требовали изменения в других;
    - **событийно-ориентированная архитектура**.

Требования ACID соблюдаются в:
- **атомарности** - так как транзакции разделяются на последовательные шаги, где каждый шаг - это локальная транзакция в отдельном микросервисе и атомарность достигается за счет независимого выполнения каждого шага и применения компенсирующих действий для отката изменений;
- **целостности** - которая обеспечивается через компенсирующие действия, которые откатывают предыдущие шаги в случае ошибки, так как микросервисы координируют между собой состояние транзакции, что иногда требует дополнительной логики;
- **изолированности** - только в конце транзакции, так как микросервисы работают независимо и пока все шаги Saga не завершатся, система может столкнуться с временной неконсистентностью данных;
- **надежности** - которая зависит от отдельных микросервисов и их способности сохранять состояние и поэтому компенсирующие действия должны быть надежными и обеспечивать сохранение состояния даже при сбоях.

**Компенсационные транзакции** - это действия, которые откатывают результаты уже выполненных шагов, если на любом из следующих шагов возникла ошибка.

Плюсы:
- **согласованность данных** в распределенных системах;
- **устойчивость к сбоям**, так как каждый шаг транзакции может быть компенсирован, что позволяет системе восстанавливаться после сбоев;
- **гибкость**, так как легко адаптировать к различным бизнес-процессам и сценариям.

Минусы:
- **сложность реализации** из-за требованиям тщательного планирования и реализации компенсирующих операций;
- **временная несогласованность** данных до завершения всех шагов транзакции.

**Процесс внедрения**:
1. **Анализ бизнес-процесса** и разделение его на последовательные шаги, которые будет выполнять отдельный микросервис. Для каждого шага определяется **основное действие** (do) и **компенсирующее действие** (undo), которое нужно выполнить в случае ошибки;
2. **Проектирование API у микросервисов** для выполнения действий и компенсирующих действий. Каждая операция для всех действий и компенсирующих действий должна быть **идемпотентной**, для этого используются уникальные идентификаторы транзакций и проверяется состояние перед выполнением операции, чтобы избежать повторного выполнения;
3. **Обеспечение хранения состояния** своей части транзакции в каждом микросервисе. Состояние должно включать уникальный идентификатор транзакции и текущий статус операции, чтобы избежать повторения уже совершенных действий. И выбора подхода к координации шагов;
4. **Реализация действий и компенсирующие действий** в каждом микросервисе, которые должны быть **идемпотентны**;
5. **Добавление логирования** для всех действий и компенсирующих действий, которые должны включать информацию о транзакциях, их статусе и любых ошибках. А также **настройка мониторинга** микросервисов (оркестратора);
6. **Тестирование** основных действий и компенсирующие действий в каждом микросервисе, а также цельной транзакции.

## Стратегии развертывания

### Обновление на месте

**Обновление на месте** - это когда новая версия приложения заменяет старую версию на той же инфраструктуре. Часто это делается путем остановки службы, развертывания нового кода и перезапуска службы.

### Сине-зеленые релизы (Blue-Green)

**Сине-зеленые релизы** - это когда поддерживаются два идентичных окружения - синее и зеленое. Пока одно работает и обслуживает продакшн, другое используется для развертывания и тестирования новой версии. Затем, когда новая версия прошла тестирование в новом окружении, трафик переключается на него. Так как старое теперь простаивает, то может быть использована для следующего обновления. И так далее.

**Основное преимущество**: отсутствие простоев и простой откат, так как при обнаружении проблем трафик можно быстро переключить на исходную среду.

**Основной недостаток**: нужно поддерживать две идентичные среды, что может быть дорогостоящим и ресурсоемким.

### Канареечные релизы (Canary)

**Канареечные релизы** - это когда при обновления новая версия разворачивается на каком-то количестве серверов (**канареечные серверы**) и затем туда направляется небольшой процент трафика. Развертывание отслеживается на предмет ошибок и, если проблем не обнаружено, туда направляется все больше трафика. В конце концов новая версия разворачивается на всех серверах.

**Основное преимущество**: позволяет проводить мониторинг и тестирование в реальных условиях с минимальным риском и ограничивает влияние потенциальных проблем небольшой базой пользователей.

**Основной недостаток**: требуются сложные механизмы маршрутизации и мониторинга трафика.

### Скользящие релизы (Rolling)

**Скользящие релизы** - это когда при релизе экземпляры приложения постепенно обновляются по одному или небольшими партиями без простоев, что обеспечивает постоянное обслуживание трафика одними экземплярами, в то время как другие находятся в процессе обновления.

**Основное преимущество**: обеспечивается постоянная доступность сервиса и снижается риск сбоев за счет обновления небольшими порциями.

**Основной недостаток**: необходимость тщательной координации, чтобы обеспечить бесперебойное обновление и механизмы отката.

## Оркестрация контейнеров

**Оркестрация контейнеров** - это процесс автоматизации развертывания, управления, масштабирования и сетевого взаимодействия контейнеризированных приложений.

Основные задачи:
- **автоматическое развертывание контейнеров и управление их состоянием** на кластере серверов;
- **масштабирование контейнеров** в зависимости от нагрузки - добавление или удаление, чтобы эффективно использовать ресурсы и поддерживать производительность приложений;
- **обнаружение сервисов и балансировка нагрузки**, чтобы равномерно распределять запросы и обеспечивать высокую доступность приложений;
- **управление конфигурацией и секретами** для повышения безопасности и упрощения администрирования;
- **мониторинг состояния контейнеров и их восстановление** для обеспечивания непрерывности работы приложений.

Масштабирование решения
=======================

**Масштабирование решения** - это адаптация программного обеспечения к увеличению нагрузки или требований с сохранением высокой производительности и доступности.

**Вертикальное масштабирование** - это добавление ресурсов (оперативной памяти (RAM), мощности процессора (CPU), объема жесткого диска (HDD) и т.п.) к одному узлу на сервере. Имеет физические ограничения и часто стоит дорого.

**Горизонтальное масштабирование** - это добавление новых узлов в систему, что позволяет распределить нагрузку между ними. Это обеспечивает практически неограниченный рост и лучшую отказоустойчивость, но требует более сложной настройки и управления.

## Нагрузка

**Нагрузка** - это интенсивность взаимодействия пользователя с приложением. Чем более активны пользователи и чем их больше, тем выше нагрузка. Приложения с высокой нагрузкой называют **высоконагруженными** (high-load) приложениями.

Основные метрики:
- **DAU** (Daily Active Users) - количество пользователей в день;
- **MAU** (Monthly Active Users) - количество пользователей в месяц;
- **RPS** (Requests Per Second) - количество запросов, которые сервер приложения обрабатывает в секунду;
- **QPS** (Queries Per Second) - количество запросов в секунду к базе данных.

**Пиковая нагрузка**, как правило, превышает среднюю в два раза и на нее следует ориентироваться.

### Паттерн Backpressure

**Паттерн Backpressure** позволяет ограничить давление или противодействовать потоку данных. Он обеспечивает обратную связь, с помощью которой регулируется скорость работы производителя данных в соответствии со скоростью работы потребителя. Без этой связи быстрый производитель может заполнить буфер потребителя или, если буфер неограничен, исчерпать всю оперативную память.

Механизм работы:
1. **Производитель данных** (producer), отправляет данные в очередь потребителя;
2. **Потребитель данных** (consumer), обрабатывает данные из очереди;
3. **Канал обратной связи** (feedback channel), обеспечивает коммуникацию между потребителем и производителем, чтобы у потребителя была возможность давать сигналы обратной связи производителю о способности обрабатывать поступающие данные;
4. **Механизм регулирования** (flow control mechanism), управляет потоком данных от производителя к потребителю на основе полученной обратной связи, чтобы производитель мог корректировать скорость или поведение передачи данных в соответствии с возможностями потребителя. Может включать такие методы, как ограничение скорости, буферизация или динамическая настройка обработки данных;
5. **Механизм сигнализации** (pressure signal mechanism) это средства, с помощью которых потребитель отправляет сигналы об обратном давлении производителю данных: сообщения, управляющие сообщения, сигнальные флаги или индикаторы доступности ресурсов.

### Паттерн Curcuit Breaker

**Паттерн Curcuit Breaker** позволяет снизить использования ресурсов (CPU, Memory) и предотвращение ошибок в работе приложения, путем быстрого отказа в выполнении запросов на раннем этапе к внешнему сервису и защищает от каскадных сбоев при сбое внешнего сервиса.

Может находиться в трех состояниях:
- **закрыт** - когда пропускаются все запросы к внешнему сервису;
- **открыт** - когда не пропускаются все запросы к внешнему сервису; переходит в это состояние если превышается определенный порог сообщений о сбое;
- **полуоткрыт** - когда пропускаются определенная часть запросов к внешнему сервису; переходит в это состояние через определенное время, а затем если запросы к внешнему сервису успешны, то переходит в состояние **закрыт**, а иначе в **открыт**.

Используется для того, чтобы предотвратить попытки приложения обратиться к удаленной службе или общему ресурсу, если высока вероятность сбоя операции.

## Репликация

**Репликация** - это создание и поддержание копий базы данных на нескольких серверах, что обеспечивает высокую доступность, повышенную производительность и отказоустойчивость.

**Преимущества**:
- **высокая доступность данных**, так как данные дублируются на нескольких серверах, что позволяет обеспечить непрерывность работы системы;
- **высокая производительность системы** из-за распределения нагрузки на чтение между несколькими узлами, что снижает нагрузку на основной сервер и улучшает производительность;
- **отказоустойчивость**, так как при сбое одного из серверов данные остаются доступными на других репликах, что минимизирует риск потери данных и простоев;
- **гибкость в распределении нагрузки**, так как запросы на чтение отправляются в улзы, которые ближе всего к пользователю географически, что снижает задержки и повышает скорость доступа к данным.

**Ограничения**:
- **сложности с консистентностью данных** (устареванию) на узлах в случае задержек репликации, что требует дополнительных механизмов синхронизации и управления конфликтами;
- **ресурсозатратность**, поскольку поддержание нескольких копий данных требует дополнительных вычислительных и дисковых ресурсов;
- **сложность управления** системой с несколькими репликами усложняется необходимостью мониторинга состояния каждой реплики, обеспечения их синхронизации и обработки сбоев.

### Репликация master-slave

**Репликация master-slave** устраняет узкие места в производительности и обеспечивает доступность данных в условиях увеличения пользовательского трафика или сбоев оборудования.

Состоит из:
- **главного, первичного узла** (мастера, master) - ответственного за обработку всех операций записи и управление данными;
- **подчиненого, вторичного узла** (реплики, слейва, slave) - который пассивно реплицируешего данные от главного узла и обслуживает запросы на чтение в случае применения паттерна read-replica. Их может быть несколько.

Когда на главном узле происходит операция записи, он регистрирует изменения в журнале транзакций. Затем подчиненные узлы извлекают эти журналы и применяют изменения к своим копиям данных. В зависимости от требований к согласованности, ведомые узлы могут:
- приостановить свою работу до получения обновлений от главного;
- продолжать обслуживать возможно устаревшие данные, одновременно применяя последние изменения в фоновом режиме.

В случае *потери* мастера, следующим мастером становится кто-то из подчиненных узлов, в зависимости от настройки.

#### Паттерн read-replica

**Паттерн read-replica** заключается в чтении только с подчиненных узлов, а записи только в главный узел.

При применении этого паттерна существует проблема - **задержка репликации**, когда данные в подчиненных могут отставать от главного узла. Для решения используется:
- считывания с учетом задержки отправляются в главный узел;
- чтения, за которыми сразу следуют записи, направляются в главный узел;
- проверка совпадения данных в главном узле и подчиненным и при не совпадении чтением из главного.

### Репликация multi-master

**Репликация multi-master** - это репликация master-slave только когда несколько узлов выполняют роль главных узлов со своими подчиненными узлами. Данные синхронизируются между узлами, а запись может происходить на любом из главных узлов. В результате создается несколько копий данных. Система решает проблему конфликтов между одновременными изменениями.

**Преимущества**:
- в случае сбоя одного главного узла другой главный узел может обновить и вставить данные;
- главные узлы находятся в разных местах, поэтому вероятность сбоя всех главных узлов крайне мала;
- обновления данных возможны на нескольких серверах;
- приложению не нужно направлять трафик только на один главный узел.

**Недостатки**:
- сложность настройки и поддержки;
- потенциальные задержки в данных.

## Кэширование

**Кэширование** снижает нагрузку при большом количестве операций чтения одинаковых данных.

**Принцип работы**:
1. Приложение проверяет наличие нужных данных в кэше;
2. Если данных в кэше нет, то запрос направляется в хранилище;
3. На обратном пути данные передаются в кэш, а запрос возвращается пользователю.

**Используется**:
- при высокой нагрузке на чтение для текущих ресурсов;
- при наличии редко изменяемой информации, которую необходимо часто получать из хранилища.

**Основная сложность**: данными в кэше нужно управлять, чтобы поддерживать их согласованность.

### Паттерн Cache-Aside

Механизм работы:
1. Пользователь отправляет запрос на чтение данных;
2. Приложение проверяет кэш, если данные найдены, происходит попадание в кэш;
3. Если данные не найдены, происходит кэш-промах и приложение отправляет запрос к базе данных;
4. Приложение получает ответ;
5. Данные заносятся в кэш.

Плюсы:
- **устойчивость к сбоям кэша**, так как если сервер кэша выходит из строя, система все равно может работать, обращаясь напрямую к базе данных;
- **модель данных в кэше может отличаться от модели данных в БД**, что позволяет выполнить запрос к БД, объединяющий несколько таблиц, и сохранить его в кэше под одним ключом для того, чтобы избежать дальнейшего выполнения сложной логики.

Минусы:
- **низкая скорость обновления данных**, так как обрабатываются только операции чтения, а не записи, которые минуют кэш и выполняются непосредственно в базу данных, что считается медленной операцией;
- **несогласованность данных в кэше с базой данных**, так как запись делается в базу данных, но не в кэш и в нем остаются старые данные, и чтобы избавиться от этого можно вручную инвалидировать кэш, используя одну из стратегий инвалидации.

Лучше всего подходит для приложений с большим объемом запросов на чтение, где практически отсутствуют операции записи.

### Паттерн Read-Through

Механизм работы состоит в том, что актуальные данные из базы данных сразу кладутся в кэш и только потом возвращаются приложению и к базе данных обращается именно кэш, а не приложение.

Плюсы:
- **меньшая сложность приложения и низкая вероятность ошибок**, так как кэш не обновляется на стороне приложения, а является вспомогательным сервисом базы данных, которая его обновляет, и приложению не нужно обновлять кэш при чтении.

Минусы:
- **кэш-промах при первом запросе**, что влечет за собой дополнительное время на загрузку данных в кэш, что исправляется с помощью *"прогрева кэша"* - ручной отправки запросов на старте приложения, чтобы данные из базы данных успешно подгрузились в кэш;
- **ограничения на выбор модели данных в кэше**, так как модель данных в кэше должна быть идентична модели базы данных;
- **чувствительность к ошибкам** из-за того, что к базе обращается не приложение, а кэш, и в случае ошибки данные будет брать неоткуда.

Лучше всего подходит для приложений с большим объемом запросов на чтение, где практически отсутствуют операции записи.

### Паттерн Refresh-ahead

Механизм работы состоит в том, что часто используемые кэшированные данные принудительно асинхронно обновляются в кэше до истечения срока их действия, чтобы приложение не ощущало эффекта медленного чтения при извлечении объекта из хранилища данных в случае истечения срока его действия.

Плюсы:
- **низкая стоимость чтения данных из БД**;
- **согласованность записей кеша**, к которым часто обращаются пользователи;
- **высокая чувствительность к задержкам**.

Минусы:
- **кэш должен работать без ошибок**, поскольку в случае ошибки это будет не сразу определено и приведет к неконсистентности данных, работу с устаревшими данными или чтению из базы.

### Паттерн Write-Through

Механизм работы:
1. Приложение обновляет базу данных через кэш;
2. Кэш обновляет базу данных;
3. База данных возвращает результат запроса;
4. Кэш обновляется данными из БД;
5. Данные из БД возвращается клиенту.

Плюсы:
- **данные между кэшем и базой данных всегда будут синхронизированы**, что исключает возможность неконсистентности кэша и его инвалидацию.

Минусы:
- **необходимость ждать, пока кэш обновит базу данных**, так как эта операция синхронная, клиент не получит ответа, пока база не обновится.

### Паттерн Write-Behind

Механизм работы:
1. Приложение обновляет кэш;
2. Кэш возвращает клиенту ответ;
3. Кэш планирует асинхронную задачу на обновление базы данных;
4. База данных обновляется в соответствии с задачей.

Плюсы:
- **низкая стоимость**;
- **консистентность данных**;
- **высокая скорость передачи данных**.

Минусы:
- **потенциальные ошибки при обновлении базы данных**, так как эта операция асинхронная, и клиент не получит ответа что база не смогла обновить данные.

### Способы инвалидации кэша

Основные способы:
- **временная инвалидация**, когда устанавливается фиксированное время жизни данных в кэше;
- **инвалидация, основанная на запросах**, когда кэш инвалидируется каждый раз, когда приходит запрос на обновление данных;
- **инвалидация на основе изменений**, когда кэш инвалидируется каждый раз, когда происходят изменения в данных;
- **программная инвалидация**, когда кэш должен быть инвалидирован на основе определенных условий или событий в приложении;
- **инвалидация по ключу**, когда кэш может быть инвалидирован для конкретных данных или ключей.

### Виды кэширования

Виды кэширования:
- **FIFO** - если искомый элемент не находится в кэше, он вставляется в хвост очереди. Если нужно освободить место, удаляются элементы из головы очереди. Таким образом вытесняется элемент, находящийся в кэше дольше всех.
- **LRU** - новый элемент вставляется в голову списка. При запроса из кэша элемент перемещается в голову списка. Если нужно освободить место, вытесняется элемент из хвоста списка.
- **MRU** - последний использованный вылетает из кэша.
- **LFU** - каждый элемент имеет счетчик обращений. Новый элемент вставляется в кэш со значением счетчика равным 1. При попадании в кэш счетчик найденного элемента увеличивается на 1. Если нужно освободить место, нужно найти элемент с самым маленьким значением счетчика.
- **SNLRU** (сегментированный LRU) - это N кэшей LRU. Новый элемент вставляется в нулевой LRU кэш. При попадании в кэш элемент перемещается в следующий LRU кэш, либо на MRU (Most Recently Used) позицию последнего LRU кэша, если выше уже идти некуда. При вытеснении элемента из k-го LRU кэша он перемещается в k-1 LRU кэш. По достижению нулевого LRU кэша элемент удаляется.
- **2Q** - кэш разделяется на три части:
    - **In** - FIFO кэш, в который попадают все новые элементы, запрошенные отсюда элементы никуда не перемещаются;
    - **Out** - FIFO кэш, в который попадают элементы, вытесненные из **In**. При этом этот кэш хранит ключ и не хранит значение, поэтому его можно сделать достаточно большим;
    - **Main** - главный LRU кэш, в который попадают новые элементы запрошенные из **Out**, в котором они удаляются. При вытеснении элемента из главного кэша он удаляется.
- **MQ** - сегментированный LRU в котором запоминается позиция с которой элемент вылетел - и при повторном запросе - возвращается туда, где был, если не вылетел из очереди запомненных позиций.

### Распределенный кэш

**Распределенный кэш** - это система, в которой данные хранятся на нескольких узлах кластера и в нескольких кластерах в разных центрах обработки данных по всему миру.

Система распределенного кэша объединяет оперативную память нескольких сетевых компьютеров в единое хранилище данных в оперативной памяти, которое используется в качестве кэша для быстрого доступа к данным. Она позволяет постепенно расширять и масштабировать систему, добавляя новые компьютеры в кластер.

## Шардирование и партиционирование

**Партиционирование** (секционирование) - метод разделения больших объемов данных на отдельные сегменты. **Шардирование** - это частный случай партиционирования.

**Вертикальное партиционирование** - это метод разделения одной большой таблицы на несколько меньших, которые физически хранятся отдельно и которые по структуре отличаются от исходной таблицы. Оно позволяет повысить производительность и доступность данных, поскольку операции выполняются над меньшим количеством данных.

**Горизонтальное партиционирование** (шардирование, сегментирование) - распределение данных по нескольким базам, чаще всего на отдельных физических серверах. Оно предполагает разделение данных на группы по определенным **критериям** и в результате разделения данных каждый **сегмент** (шард) включает одни и те же столбцы, но разные строки информации.

Преимущества горизонтального партиционирование:
- **преодолевание технических ограничений**, так как позволяет распределить данные по разным серверам;
- **повышение надежности**, так как шарды базы данных расположены на разных серверах, отказ одного из них не приведет к полной остановке работы;
- **ускорение доступа к данным с простыми запросами** из-за распредения нагрузки и увеличения объемов и скорости обработки данных.

Ограничения горизонтального партиционирование:
- **сложность реализации**;
- **риск снижения эффективности разработки** из-за необходимости управлять данными из нескольких сегментов вместо единой точки;
- **неравномерность загрузки серверов** из-за несбалансированности данных, когда одни серверы оказываются загружены больше, чем другие, что потребует повторного сегментирования;
- **снижение скорости обработки сложных запросов**, требующих обращения к нескольким шардам одновременно, что может привести к потере производительности и замедлению процесса получения данных по сравнению с обращением к одной таблице.

### Методы шардирования

**Хэшированное шардирование** (key based sharding) - это разделение данных на шарды на основе хэш-функции, которая принимает входные данные и возвращает хэш-значение, которое определяет, в какой шард попадет каждая запись данных.

Особенности:
- риск потери данных: **низкий**, так как отсутствует единая точка отказа;
- распределение данных: **равномерное**;
- поиск данных: **средний**;
- реализуемость: **легкая**;
- масштабируемость хранилища: **высокая**;
- геораспределение данных: **отсутствует**.

Подходит для равномерного распределения данных.

**Диапазонное шардирование** (range based sharding) - разделение данных на шарды на основе диапазона значений (chunk). Значения разделяются не с помощью функции, а по ключу или другим атрибутам. Каждому фрагменту присваивается диапазон на основе значений ключа сегментирования. Ключи сегментов, чьи значения близки друг к другу, чаще всего оказываются в одном диапазоне. Это упрощает выполнение целевых операций.

Особенности:
- риск потери данных: **низкий**;
- распределение данных: **неравномерное**;
- поиск данных: **легкий**;
- реализуемость: **легкая**;
- масштабируемость хранилища: **высокая**;
- геораспределение данных: **отсутствует**.

Подходит для данных временных рядов или последовательных данных (журналы, события с временными метками, цены на товары и т. д.).

**Динамическое шардирование** (dynamic sharding) - автоматическое масштабирование хранилища в зависимости от текущей производительности и объема данных. Оно очень гибкое, но требует сложной балансировки нагрузки, надежного мониторинга и тщательно продуманной архитектуры базы данных.

Для определения местоположения записей используется **внешний поисковый сервис**, что помогает решать проблемы, возникающие при динамическом сегментировании. Внешний поиск предоставляет полную информацию о том, в каком сегменте находятся данные, что позволяет перемещать пользователей по отдельности, а не большими группами, из одного сегмента в другой. Это помогает снизить нагрузку на перегруженные сегменты. При этом поисковый сервис становится единственным местом взаимодействия с системой и потенциальным источником сбоев.

Особенности:
- риск потери данных: **высокий**;
- распределение данных: **неравномерное**;
- поиск данных: **сложный**;
- реализуемость: **сложная**;
- масштабируемость хранилища: **автоматическая**;
- геораспределение данных: **возможно**.

**Геошардинг** (geo sharding) - это хранение в разных сегментах информации, относящейся к определенной географической зоне. Его можно комбинировать с другими методами шардирования, если это необходимо.

Особенности:
- риск потери данных: **низкий**;
- распределение данных: **неравномерное**;
- поиск данных: **легкий**;
- реализуемость: **легкая**;
- масштабируемость хранилища: **средняя**;
- геораспределение данных: **реализована**.

Подходит для сервисов, которым важна локальность данных (для сетей доставки контента и мобильных приложений с учетом геолокации).

### Способы реализации шардирования

Основные способы реализации шардирование:
- **средствами базы данных**, которые могут автоматически распределять данные между своими экземплярами, что задается через конфигурацию баз данных;
- **с использованием надстроек к базе данных** - сторонние утилиты, которые выполняют шардирование;
- **с применением клиентских средств**, когда экземпляры базы данных не знают о существовании друг друга, а шардированием управляет сервис.

## Горизонтальное масштабирование приложения

### Способы сохранения состояний приложения

**Stateful** (с сохранением состояния) - подход, при котором система сохраняет информацию о предыдущих состояниях или взаимодействиях с клиентами. Применяется в ситуациях, когда экземпляров (инстансов) приложения несколько, но пользователю нужно всегда попадать на сервер, который владеет конкретным закрепленным за ним состоянием.

Приложения с состояниями обычно масштабируют не напрямую, а через масштабирование базы данных, распределенное кэширование и разделение на более независимые микросервисы, каждый из которых работает только над отдельными частями процесса независимо.

**Stateless** (без сохранения состояния) - подход, при котором архитектура приложения не сохраняет информацию о предыдущих состояниях или сеансах где-то отдельно от остальных сервисов. Каждый запрос рассматривается как изолированное взаимодействие.

Масштабируется горизонтально с помощью балансировщика нагрузки.

### Балансировщик нагрузки

**Сервис балансировки нагрузки** - это инструмент для распределения запросов между серверами внутри кластера.

Основные решаемые задачи:
- **обеспечивание непрерывной работы приложения** из-за автоматического направления трафика с проблемных серверов на здоровые, что позволит избежать простоя в работе приложения;
- **обеспечивание горизонтального масштабирования** для возможности добавления новых экземпляров приложения и равномерного распределения нагрузки между несколькими экземплярами приложения;
- **повышение безопасности** из-за анализа трафика, фильтрования запросов, а также направление их через брандмауэры и другие защитные механизмы.

Виды по устройству:
- **программные** - это сервисы, которые обычно работают на отдельном сервере;
- **виртуальные** - это решение работает на виртуальной машине (VM) или как экземпляр программного обеспечения в виртуализированной среде;
- **аппаратные** - это непосредственно физические устройства, работающие на 4 и 7 уровнях модели OSI, которые способны обрабатывать все виды трафика: HTTP, HTTPS, TCP и UDP.

Виды по функциям:
- **на 4, транспортном уровне** - когда балансировщик быстрее обрабатывает запросы, поскольку не анализирует содержимое пакетов и имеет возможность работать с адресами серверов. Особенности:
    - использует протоколы TCP и UDP;
    - распределяет трафик, опираясь на IP-адреса и номера портов;
    - может применять базовое преобразование сетевых адресов (NAT), скрывая таким образом адреса серверов.
- **на 7, уровне приложений** - когда балансировщик маршрутизирует контент с учетом содержимого и позволяет принимать сложные решения о маршрутизации, используя данные, специфические для конкретного приложения. Особенности:
    - работает на уровне приложений с протоколами HTTP и HTTPS;
    - способен закрывать SSL-соединения.

#### Стратегии балансировки нагрузки

##### Round Robin

**Round Robin** - эта стратегия последовательно распределяет запросы между доступными экземплярами. Каждый экземпляр получает равную долю запросов в круговом порядке.

Применяется в системах, где все экземпляры имеют схожие характеристики мощности и производительности.

##### Least

Семейство стратегий особенность которых - это направлять запросы к экземплярам, по **особому критерию**, что помогает распределить нагрузку более равномерно, особенно когда есть экземпляры с разной производительностью. Бывают:
- **Least Connections** - когда критерий это наименьшее количество активных соединений;
- **Least Response Time** - когда критерий это наименьшее среднее время обработки ответа;
- **Least Bandwidth** - когда критерий это наименьший трафик.

Применяется в системах, где экземпляры могут обрабатывать запросы разной сложности и продолжительности.

##### IP Hash (Sticky sessions)

**IP Hash** - эта стратегия использует хэш IP-адреса клиента, чтобы определить, какой экземпляр будет обрабатывать запрос, что гарантирует, что запросы от одного и того же клиента будут последовательно направляться к одному и тому же экземпляру.

Применяется в системах, в которых требуется сохранение сеанса (для продолжительных пользовательских сеансов в сервисе с состоянием).

##### Weighted Round Robin

**Weighted Round Robin** - эта стратегия аналогична стратегии **Round Rrobin**, но с весами, присваиваемыми каждому экземпляру на основе его возможностей или характеристик производительности. Экземпляры с более высокими весами получают больше запросов.

Применяется в системах, где некоторые экземпляры более мощные и могут обрабатывать большую долю нагрузки.

##### Случайное распределение

**Случайное распределение** - эта стратегия случайным образом направляет запросы к экземплярам.

Применяется в системах, с равномерно распределенными экземплярами и когда другие стратегии могут не дать значительных преимуществ.

#### Настройка балансировщика нагрузки

Реализуются направлением всех запросов в **API Gateway**, который обращаясь к **Service Registry** получает адреса микросервисов, которые в нем регистрируются при создании, а затем направляет по полученным адресам запросы в микросервисы.

##### Паттерн API Gateway

**Паттерн API Gateway** - это единая точка входа для клиентских приложений, которая регламентирует коммуникации между клиентом и сервисами, убирая прямую привязку сервисов к клиентам, абстрагирует сервисы от клиентов.

Кроме основных функций имеет дополнительную функциональность: аутентификацию, походы в кэш, роутинг, логирование и другие функции и инструменты.

##### Паттерн Service Discovery

**Паттерн Service Discovery** - это паттерн, который облегчает коммуникацию между приложениями, даже если меняется количество их инстансов или сетевое расположение.

В основе лежит **Service Registry** - реестр (маленькая база данных), в котором хранится метаинформация о микросервисах, их экземплярах и сетевом расположении.

## Гибридная архитектура

**Гибридная архитектура** - это когда часть архитектуры лежит в публичном облаке, а часть внутри компании - либо тоже в облаке, но частном, либо просто на "железе".

Преимущества:
- **гибкость в поддержке**, так как доступ к данным возможен в любое время из любой точки мира и можно быстро заказать нужные ресурсы;
- **сокращение расходов**, которое происходит благодаря экономии на капитальных вложениях в расширение инфраструктуры;
- **улучшение масштабируемости** из-за использования ресурсов облачного провайдера, что позволяет адаптироваться к взлетам и падениям нагрузки;
- **быстрый выход на рынок**, который увеличивается за счет повышения производительности IT и гибкости;
- **непрерывность бизнеса** благодаря тому что гарантируется созданием резервных копий критически важных данных и масштабированием в случае увеличения спроса;
- **сохраняется безопасность** благодаря контролю над данными и ограничению доступа;
- **оптимизация скорости и увеличение отказоустойчивости за счет увеличения географии**, так как облачная инфраструктура, как правило, находится в разных ЦОДах и в разных регионах, что облегчает доступ к данным пользователям из определенных близких к этим ЦОДам регионам — получается что-то вроде геошардирования. В случае аварии в каком-то регионе остальные продолжают работать.

Недостатки:
- **сложность интеграции** внутренней инфраструктуры и публичного облака, которая требует сложной настройки мониторинга и инструментов управления инфраструктурой;
- **недостаточная безопасность** из-за строгих требований к безопасности, которые не допускают хранения многих данных в публичном облаке.

### Распределенное облачное кэширование

Преимущества:
- **высокая доступность данных** (high availability) благодаря репликации данных и механизмам аварийного переключения, так как даже если один узел выйдет из строя, другие узлы смогут взять на себя его функции без потери данных;
- **высокая скорость работы и производительности приложений** за счет хранения часто используемых данных в памяти на нескольких серверах, расположенных близко к пользователям;
- **проще масштабирование** из-за того, что легко добавлять новые узлы кэша по мере увеличения нагрузки;
- **ниже затраты** за счет снижения нагрузки на основные базы данных и оптимизации использования ресурсов, так как базы данных в обслуживании и настройке сильно дороже кэширования.

Ограничения:
- **зависимость от сети**, так как для эффективной работы необходимо надежное и быстрое сетевое соединение между серверами кэша и клиентами - облаком и локальной инфраструктурой;
- **сложность настройки и управления**, так как необходимо умение настраивать балансировку нагрузки, репликацию данных и механизмы аварийного переключения;
- **меньшая безопасность данных** из-за того что все, что в облаке, в большей опасности, чем внутри локального контура. Данные, хранящиеся в кэше, могут быть уязвимы для атак, если не приняты надлежащие меры безопасности;
- **риск потери данных** в случае сбоя в работе одного из узлов кэша данные, хранящиеся на этом узле, могут быть потеряны. Репликация данных помогает снизить этот риск, но не устраняет его полностью;
- **необходимость обучения персонала**, чтобы эффективно управлять системой и минимизировать риски;
- **влияние на производительность** из-за дополнительной нагрузки на сеть и сервера;
- **сложности интеграции** с существующими системами, так как требует тщательного планирования и тестирования.

### Content Delivery Network

**Content Delivery Network** (CDN) - это распределенные узлы хранения и доставки информации. Сервис представляет собой систему, которая в ответ на запросы от клиента запрашивает, получает и кэширует данные от источника и отдает их клиенту. Использование CDN значительно снижает нагрузку на источники хранения информации в интернете и ускоряет ее доставку пользователю.

Когда пользователь заходит на сайт, запрос направляется к ближайшему CDN-серверу. Если запрашиваемая информация кэширована на нем, данные сразу отдаются пользователю. Если данные запрашиваются впервые или они устарели, CDN-сервер сначала загружает их с сервера-источника, а затем отдает клиенту.

Преимущества:
- **улучшает SEO**, поскольку сайты загружаются быстрее, что улучшает их видимость в поисковых системах;
- **позволяет избежать дополнительных расходов на инфраструктуру**, так как не требуется покупать новое оборудование или увеличивать мощность сервера-источника;
- **повышает доступность сайта** за счет резервирования серверов друг другом, что гарантирует непрерывность работы сайта;
- **открывает доступ к подробной статистике о трафике** в реальном времени;
- **делает сайт доступным из любой точки мира** благодаря глобальному покрытию CDN;
- **снижает нагрузку на сервер-источник**.

Ограничения:
- **проблемы с динамическим контентом** из-за того, что он должен обрабатываться на сервере источнике;
- **задержки при обновлении контента** после обновления контента на основном сервере прежде чем изменения отобразятся на серверах CDN, что временно 
замедлит доступ к новому контенту;
- **блокировка по IP-адресам** что может привести к недоступности множества сайтов;
- **зависимость от CDN-провайдера**, так как технические проблемы у него могут повлиять на доступность сайта.

#### Методы разделения данных на основе DNS

**GeoDNS** (solitary traffic directors, global traffic directors) - это метод географических доменных имен, который использует алгоритм определения геокоординат по IP-адресу пользователя. Клиент отправляет запрос, DNS-сервер определяет местоположение пользователя по IP-адресу и находит ближайшую **точку присутствия** (пограничный узел, Point of presence, PoP) - базовый компонент CDN, где находятся копии или кэшированные версии контента, полученного от основного источника. Их количество и географическое расположение влияет на эффективность использования CDN. Чем ближе они к пользователям интернет-ресурса, тем быстрее доставляется им контент. Чем больше их количество, тем меньше нагрузка на исходный сервер.

GeoDNS позволяет:
- оптимизировать трафик и обеспечить надежную балансировку нагрузки;
- блокировать посетителей веб-сайта по странам;
- выдавать контент адресно в зависимости от геоположения посетителя.

**Anycast** - это метод сетевой адресации и маршрутизации, при котором один IP-адрес присваивается нескольким серверам в сети, которые при этом находятся в разных точках присутствия. В зависимости от местоположения источника запросов данные отправляются на ближайший сервер, что позволяет уменьшить количество сетевых переходов и задержку в передаче данных. Запрос DNS-клиента будет отправляться от одной точки присутствия к другой, пока не достигнет первого авторитетного сервера имен.

Observability
=============

**Observability** (наблюдаемость) - это свойство системы, которое подразумевает, что можно получать информацию о внутренних процессах.

Основные источники информации:
- **мониторинг** - сбор бизнесовых и инфраструктурных метрик (metrics);
- **логирование** - сбор логов (logs);
- **трейсинг** - сбор трейсов внутренних вызовов (traces).

Основные преимущества:
- **улучшение видимости и повышение безопасности системы** для того, чтобы можно было получать полное представление о работе системы, так как чем выше видимость, тем проще обеспечить безопасность;
- **более быстрое решение проблем и повышение надежности системы** из-за инструментов наблюдения, которые могут помочь быстрее определить корень проблемы, чтобы его было проще устранить и предотвратить в будущем;
- **повышение быстродействия системы и распределение ресурсов** так как с помощью инструментов наблюдения можно выявлять узкие места, что помогает оптимизировать производительность и проанализировать, как система работает под разными нагрузками;
- **ускорение рабочего процесса и DevOps**, поскольку наблюдаемость способствует оптимизации процессов и сокращению количества ошибок, что в свою очередь, помогает ускорить рабочий процесс и улучшить взаимодействие между командами;
- **ценные бизнес-инсайты** из-за накопления данных благодаря наблюдаемости системы, которые могут привести к бизнес-инсайтам, что может помочь принимать стратегические решения более обоснованно;
- **повышение удовлетворенности пользователей** из-за своевременного решение проблем, которые связаны с производительностью и функциональностью приложения.

## Мониторинг

**Метрика** - это агрегированные или одиночные данные о том, как себя чувствуют сервисы, которые выражаются одним числом, которое отслеживают в динамике.

**Мониторинг** - это отслеживание метрик.

Основные метрики:
- **показатели системного уровня** - потребление ресурсов процессора, памяти и диска и т.п.;
- **показатели производительности** - время отклика системы, количество ошибок и т.п.;
- **бизнес-метрики** - количество уникальных пользователей за день, возвращаемость пользователей и т.п.

Этапы мониторинга:
1. **Определение данных для сбора** - подготовительный этап;
2. **Сбор данных** - настраивание агентов, фреймворков и стороннего ПО для отправки метрик;
3. **Отправка данных на хранение** в хранилище, которое будет агрегировать данные для мониторинга, по модели *push* или *pull*;
4. **Анализ данных**, чтобы обнаружить тенденции, закономерности и проблемы;
5. **Формирование отчетов, сводных таблиц или оповещений** для оценки производительности и поведения системы, чтобы выявить проблему до того, как она станет критической.

### Основные подходы к мониторингу

**Метод USE**, который состоит в том, чтобы для каждого ресурса проверять три ключевых показателя:
- **utilization** (утилизация) - это среднее время, которое ресурс занят работой. Измеряется в процентах;
- **saturation** (насыщенность) - объем работы, которую ресурс не может выполнить и вынужден откладывать (например, в очередь), чтобы сохранять работоспособность. Насыщенность можно измерить как длину очереди;
- **errors** (ошибки) - количество ошибок.

Метод USE лучше всего работает с ресурсами, производительность которых снижается при интенсивном использовании.

**Метод четырех золотых сигналов**, который состоит в проверке показателей:
- **задержка** - это время, которое уходит на доставку запроса по сети от отправителя к получателю;
- **трафик** - это показатель активности пользователей в приложении, который можно измерить с помощью любого высокоуровневого системного показателя (в веб-приложениях трафик обычно считают как количество HTTP-запросов в секунду);
- **ошибки** - это частота неудачных запросов, к которым относятся как явные ошибки (например, ошибки с кодом 500), так и неявные (например, статус запроса 200, но контент доставили неправильно);
- **насыщенность** - это показатель насколько "заполнена" система и напрямую связана с показателем использования системы.

Метод золотых сигналов в целом подойдет любой системе, которая связана с предоставлением API, так как он позволяет заметить аномалии в работе заранее и быстро среагировать на ситуацию.

**Метод RED**, который состоит в проверке показателей:
- **requests rate** (частота запросов) - это количество запросов, которые обслуживает сервис в секунду, что дает представление о пропускной способности сервиса;
- **errors** (ошибки) - это количество неудачных запросов в секунду;
- **duration** (длительность) - это количество времени, которое уходит на выполнение одного запроса.

Метод RED эффективен только для сервисов, которые управляются запросами.

### Модель "ключ - значение"

Используется для описания метрики. Имеет структуру: `<ключ_метрики>{<метка_1>="<значение>", ..., <метка_N>="<значение>"} <значение_метрики>`, Где:
- `<ключ_метрики>` - это сама метрика;
- `<метка_1>="<значение>"` - это дополнительные метки, которые добавляют детали метрике;
- `<значение_метрики>` - это число, которое отражает измеренную величину за определенный период времени.
> `up{instance="localhost:8000", job="sample"} 1`

Обычно добавляют дополнительные метки времени - `timestamp` в формате UNIX.

## Логирование

**Лог** - это запись в хранилище (например, в файле или в базе данных), которая содержит информацию о состоянии системы в конкретный момент времени.

**Логирование** - это ведение журнала логов, который фиксирует, как состояние системы изменяется с течением времени.

Уровни логов:
- **FATAL** - отказ сервиса или оборудования;
- **ERROR** - ошибочное состояние (например "пользователь заблокирован");
- **WARN** - состояние, которое близко к нестандартному поведению системы (например "пользователь неправильно ввел пароль");
- **INFO** - это штатное поведение, которое используют для записи обычных сообщений (например "данные загружены");
- **DEBUG** - это отладочное сообщение;
- **TRACE** - это отладочное сообщение в среде разработки и для отладки в тестовом окружении.

## Трейсинг

**Трейсинг** - это метод отслеживания запросов в приложении.

Трейсинг начинается с точки входа запроса в приложение: он запускается для запроса и имеет уникальный идентификатор, сгенерированный для этого запроса. По мере того как трафик переходит от сервиса к сервису, каждый сервис добавляет информацию (например, время поступления запроса в сервис и время, затраченное на его обработку).

По итогу получается список вызовов, представленных в виде дерева, по которым можно понять, где и чем оборвалась цепочка вызовов.

Облачные вычисления
===================

Виды облачных вычислений:
1. **По модели развертывания** (Deployment Model) - определяет, каким образом и где разворачивается решение:
    - **частное облако** (Private Cloud) - это среда, предназначенная исключительно для одной организации, где есть четкая грань между программным обеспечением и аппаратным, при этом может находиться как на территории самой организации, так и у стороннего провайдера. Имеет подтипы:
        - **локальное** - когда решения и приложения разворачиваются на инфраструктуре организации и управляется самой организацией;
        - **управляемое** - когда решения и приложения управляется сторонней компанией, которая специализируется на обслуживании программного и аппаратного обеспечения;
        - **виртуальное** - когда решения и приложения клиента развернуты на инфраструктуре облачного провайдера, который предоставляет изолированную среду для организации клиента.
    - **публичное облако** (Public Cloud) - это среда, в которой виртуальные ресурсы разворачиваются на инфраструктуре облачного провайдера и предоставляются организации клиента по требованию, при этом аппаратная инфраструктура провайдера может использоваться другими клиентами;
    - **гибридное облако** (Hybrid Cloud) - это среда, когда часть решений находится в публичном облаке, а часть в частном или на "железе".
2. **По модели услуги** (Service Model) - определяет, какие именно и на каком уровне сервисы предоставляются клиенту:
    - **SaaS** (Software as a Service, SaaS) - программное обеспечение как услуга - это способ предоставления услуги, когда приложения предоставляются клиенту по подписке, при этом клиент не имеет доступа ни к настройке инфраструктуры, ни к конфигурации платформы или окружения;
    - **PaaS** (Platform as a Service) - платформа как услуга - это способ предоставления услуги - платформенных ресурсов со своей средой исполнения, API-интерфейсами и окружением, при этом клиенту не нужно управлять инфраструктурой или поддерживать платформу, что позволяет ему сосредоточиться на разработке, тестировании и развертывании своих приложений;
    - **IaaS** (Infrastructure as a Service) - инфраструктура как услуга - это способ предоставления услуги - аппаратных вычислительных ресурсов, при этом клиент получает полный контроль над операционной системой и приложениями, а провайдер берет на себя управление сетью, хранилищем данных и виртуализацией.

**Динамическое масштабирование** - это процесс автоматического управления вычислительными ресурсами в облачной инфраструктуре, при котором количество ресурсов может автоматически увеличиваться или уменьшаться в ответ на изменения в нагрузке. Бывает:
- **вертикальным** - изменение мощности существующих ресурсов;
- **горизонтальным** - добавление или удаление ресурсов (например, серверов или контейнеров).

## Подходы к миграции в облако

**Концепция миграции 6R** (6R Migration Strategy) - состоит из подходов:
1. **Retain** - когда выделяются отдельные компоненты решения, которые остаются в текущем on-premise окружении, часто используется в контексте других подходов к миграции;
2. **Retire** - вывод решения или его компонента из эксплуатации после пропажи необходимости в его функционале, часто происходит в рамках другого подхода к миграции, когда используются иные методы для перехода на новые технологии, упрощения инфраструктуры и снижения затрат на поддержку;
3. **Rehost** (Lift and Shift) - наименее затратный подход к миграции решения, без изменений в окружении или в архитектуре (все переносится "как есть"). Состоит из таких ключевых аспектов:
    - **непрерывности**, который заключается в сохранение и поддержание текущего состояния виртуальной и системной среды при миграции;
    - **данных**, который заключается в переносе данных;
    - **управления пользовательским трафиком**, который заключается в переадресации трафика;
4. **Repurchase** (Drop and Shop) - подразумевает отказ использования существующего решения и полную замену на облачный сервис (например, SaaS), это становится релевантно, когда старое решение устарело и миграция экономически нецелесообразна;
5. **Replatform** (Lift and Reshape) - минимальное изменение в коде или архитектуре с подключением дополнительных сервисов провайдера, чтобы воспользоваться преимуществами облачной платформы;
6. **Refactor** (Re-architect) - самый ресурсоемкий и продолжительный подход с глубокой переработкой решения под облачную среду, когда меняется не только окружение, но и сама архитектура приложения.

Могут комбинироваться.

Проектирование
==============

## Методология Domain-Driven Design (DDD)

**Домен** - это область знаний или деятельности, которая представляет собой основную часть работы компании - охватывает все понятия, связанные с данной областью, и описывает ее поведение и правила.

**Поддомен** - это логически выделенная часть домена, которая выполняет определенную функцию или решает конкретную задачу. В домене может быть несколько поддоменов, каждый из которых важен для общей картины.

**Контекст** - это область, внутри которой определенные термины и правила имеют четкое значение - помогают избежать путаницы, определяя границы использования понятий.

### Уровни проектирования

**Стратегическое проектирование** позволяет определить высокоуровневую структуру системы, а **тактическое проектирование** - детализировать каждый контекст, обеспечивая реализацию бизнес-логики.

**Стратегическое проектирование** - это когда определяется общая структура системы и взаимодействие между различными частями домена, с основной задачей - разделить систему на поддомены и очертить границы контекстов. Основные элементы:
- **Bounded Context**: определяет границы, в пределах которых терминология и правила имеют четкое значение;
- **Context Map**: диаграмма, показывающая взаимодействие между различными контекстами.

**Тактическое проектирование** - это когда определяются детали реализации внутри каждого контекста, с основной задачей - создать модель, которая точно отражает бизнес-логику и поведение домена. Основные элементы:
- **Entities** (сущности): объекты, которые имеют уникальный идентификатор и состояние, изменяющееся со временем;
- **Value Objects** (объекты-значения): объекты, которые не имеют уникального идентификатора и полностью определяются своими атрибутами;
- **Aggregates** (агрегаты): группы связанных сущностей и объектов-значений, которые обрабатываются как единое целое;
- **Repositories** (репозитории): интерфейсы для доступа к агрегатам из хранилища данных;
- **Services** (сервисы): операции, которые не относятся к какой-либо сущности, но важны для домена.

### Процесс выделения доменов и контекстов

Состоит из шагов:
1. **Анализ бизнеса и требований**:
    - проведение интервью с ключевыми бизнес-экспертами;
    - сбор и анализ бизнес-требований и сценариев использования;
    - определение основных бизнес-целей и приоритетов.
2. **Выделение доменов**:
    - определение границ домена;
    - идентификация основных функций и процессов внутри домена;
    - документирование ключевых понятий и терминов, используемых в домене.
3. **Разделение на поддомены**:
    - идентификация поддоменов на основе функциональных требований;
    - определение взаимодействий между поддоменами;
    - документирование поддоменов и их границ.
4. **Определение контекстов**:
    - определение границ контекстов внутри поддоменов;
    - создание контекстных карт (Context Maps) для визуализации взаимодействий;
    - документирование терминов и правил внутри каждого контекста.
5. **Создание контекстных карт (Context Maps)**:
    - создание диаграмм, отображающих контексты и их взаимодействия;
    - определение типов взаимодействий (например, интеграция, антипаттерны);
    - документирование зависимостей и договоренностей между контекстами.
6. **Итеративное уточнение**:
    - регулярный пересмотр и обновление доменов и контекстов;
    - внедрение изменений на основе обратной связи от пользователей и команды;
    - обеспечение согласованности между всеми частями системы.

Документирование
================

## Модель C4

Это многоуровневая модель для описания архитектуры.

### Уровень 1. Диаграмма контекста - Context diagram

Показывает, как система выглядит в целом, предоставляет общий обзор системы и ее границ. Показывает систему в окружении, выделяя основные внешние системы и пользователей, которые взаимодействуют с ней.

Ее используют:
- **бизнес-аналитики** для демонстрации взаимодействия системы с внешними системами и пользователями;
- **проектные менеджеры** для определения основных стейкхолдеров и их взаимодействия с системой;
- **архитекторы** для общего представления системы и ее окружения.

Основные компоненты:
- **пользователь**;
- **система**;
- **границы системы**;
- **существующие системы (внешние)**;
- **взаимоотношение**.

### Уровень 2. Диаграмма контейнеров - Container diagram

Показывает высокоуровневые технические строительные блоки - приложения и хранилища данных. Показывает основные высокоуровневые контейнеры системы и взаимодействия между ними (например, веб-приложения, базы данных, микросервисы).

Ее используют:
- **архитекторы** для определения основных контейнеров системы и их взаимодействия;
- **разработчики** для понимания высокоуровневой структуры системы;
- **DevOps-инженеры** для планирования развертывания контейнеров и их взаимодействия.

Основные компоненты:
- **пользователь**;
- **контейнер**;
- **границы контейнера**;
- **существующие системы (внешние)**;
- **взаимоотношение**.

### Уровень 3. Диаграмма компонентов - Component diagram

Показывает уровень отдельного контейнера и показывают компоненты внутри него. Углубляется в один из контейнеров, показывая, из каких компонентов он состоит и как эти компоненты взаимодействуют друг с другом.

Ее используют:
- **разработчики** для детального понимания внутренних структур контейнеров и их взаимодействий;
- **архитекторы** для проектирования внутренней структуры контейнеров;
- **тестировщики** для планирования тестирования компонентов и их взаимодействий.

Основные компоненты:
- **компонент**;
- **контейнер**
- **границы компонента**;
- **существующие системы (внешние)**;
- **взаимоотношение**.

### Уровень 4. Диаграмма кода - Code/classes diagram

Показывает, как реализован отдельный компонент. Отображает структуру кода в рамках одного из компонентов. Показывая классы или файлы и их взаимодействие.

Ее используют:
- **разработчики** для детального проектирования и рефакторинга кода;
- **тестировщики** для понимания логики работы классов и планирования юнит-тестирования;
- **архитекторы** для верификации соответствия кода архитектурным требованиям.

### Дополнительные диаграммы

#### Диаграммы последовательностей - Dynamic diagrams

Показывает взаимодействие объектов в определенном временном порядке, акцентируя внимание на порядке сообщений между объектами.

Ее используют:
- **разработчики** для понимания последовательности взаимодействий между объектами при выполнении операций;
- **тестировщики** для планирования тестирования сценариев взаимодействий;
- **бизнес-аналитики** для демонстрации функциональных требований и сценариев использования.

#### Диаграммы развертывания - Deployment diagrams

Показывают физическое размещение программных артефактов на узлах развертывания.

Ее используют:
- **DevOps-инженеры** для планирования и управления развертыванием системы;
- **архитекторы** для проектирования архитектуры развертывания;
- **системные администраторы** для настройки и поддержки инфраструктуры развертывания.

### Шаги создания

Шаги:
1. **Сбор требования и определение границ системы**:
    - определение основных функций и компонентов системы;
    - определение внешних систем и пользователей, которые будут взаимодействовать с системой.
2. **Создание диаграммы контекста**:
    - описание системы и ее окружения;
    - указание внешних систем и пользователей, которые взаимодействуют с системой.
3. **Создание диаграммы контейнеров**:
    - определение основных контейнеров внутри системы - приложений и хранилищ данных;
    - указание взаимодействий между контейнерами и внешними системами.
4. **Создание диаграммы компонентов**:
    - детализация контейнеров и их внутренних структур;
    - определение основных компонентов внутри контейнеров и их взаимодействие.
5. **Создание диаграммы кода**:
    - детализация кода компонентов;
    - указание основных классов или файлов компонентов и их взаимодействие.

### Методы для анализа и интерпретации

Основные методы:
1. **Метод по проверки полноты и ясности**:
    - проверка, что все основные элементы системы и их взаимодействия отражены на диаграммах;
    - проверка, что диаграммы понятны всем стейкхолдерам, включая тех, кто не имеет технического образования.
2. **Метод по выявления узких мест и потенциальных проблем**:
    - определение компонентов, которые могут стать узкими местами (например, контейнеры с высокой нагрузкой);
    - оценка взаимодействия между компонентами на предмет потенциальных проблем (например, задержек или сбоев в коммуникации).
3. **Метод по анализу безопасности**:
    - проверка диаграммы на предмет потенциальных уязвимостей, связанных с доступом к данным и авторизацией пользователей;
    - проверка, что критически важные компоненты защищены соответствующими механизмами безопасности.
4. **Метод по оценки масштабируемости**:
    - определение, какие компоненты системы могут требовать масштабирования при увеличении нагрузки;
    - оценка возможности горизонтального и вертикального масштабирования компонентов.

### Методы для получения обратной связи

Основные методы:
1. **Метод по ревью команды** когда участники команды отмечают непонятные моменты, потенциальные проблемы и вносят предложения по улучшению;
2. **Метод по привелечению стейкхолдеров** когда проводят презентации диаграмм для бизнес-экспертов и стейкхолдеров для сбора их мнения о том, насколько диаграммы понятны и какие аспекты можно улучшить;
3. **Метод по использованию инструментов для комментариев** когда участники команды оставляют свои замечания и предложения прямо на диаграммах в онлайн-инструментах;
3. **Метод по анализу инцидентов и проблем**, чтобы выявить недостатки в архитектуре для обновления диаграмм, чтобы учитывать полученные уроки и улучшения.

## Документация как код

**Документация как код** (Documentation as Code) - это подход, при котором документация создается, обновляется и управляется так же, как и исходный код.

## OpenAPI

**OpenAPI** - это спецификация для описания RESTful API, которая позволяет документировать эндпоинты, методы, параметры и ответы API.

## AsyncAPI

**AsyncAPI** - это спецификация для документирования и проектирования асинхронных API, которая позволяет описывать структуры сообщений, каналы и взаимодействия между компонентами в асинхронной системе.

DevOps
======

**DevOps** - это культурная и профессиональная методология, которая направлена на интеграцию и взаимодействие разработчиков программного обеспечения (Dev) и специалистов по эксплуатации и обслуживанию (Ops).

Основная задача DevOps - ускорить разработку, повысить качество и надежность программного обеспечения за счет автоматизации и улучшения процессов.

## Pipeline as Code

**Pipeline as Code** (PaC) - это подход, при котором конвейеры CI/CD описываются с помощью кода и управляются ими тоже через код.

Этот подход обеспечивает:
- **повторяемость**, так как автоматизированные конвейеры гарантируют, что каждый процесс сборки, тестирования и развертывания выполняется одинаково, поэтому риск человеческих ошибок минимизирован;
- **гибкость**, так как определение конвейеров в виде кода позволяет легко изменять их и настраивать под нужды проекта, где требования могут часто меняться;
- **версионирование**, так как конвейеры хранятся в системе контроля версий, поэтому любые изменения при необходимости можно отследить и восстановить;
- **прозрачность**, так как кодовые конвейеры предоставляют четкую документацию процессов CI/CD, что позволяет понимать процессы и поддерживать их;
- **масштабируемость** благодаря тому, что сочетание CI/CD и PaC позволяет бизнесу быстрее адаптироваться к изменениям и легко масштабировать систему;
- **подверженность ошибкам**, так как автоматизация развертывания и тестирования снижает риск человеческих ошибок, что делает развертывания более предсказуемыми и безопасными.

## CI/CD

**CI/CD** - это набор практик и методологий, который направлен на автоматизацию процессов разработки, тестирования и развертывания программного обеспечения.

### Continuous Integration (CI)

**Continuous Integration** - это процесс непрерывной интеграции, который предполагает регулярное интегрирование изменений в общую кодовую базу и автоматические проверки нового кода на наличие ошибок и конфликтов.

Состоит из шагов:
1. **Работа с системой контроля версий** (Code) - фиксация изменений кода в системе контроля версий, что позволяет отслеживать изменения, управлять различными ветками разработки и координировать работу нескольких разработчиков;
2. **Сборка** (Build) - после внесения изменений в код, эти изменения автоматически интегрируются в центральный репозиторий, после интеграции система CI автоматически запускает процесс сборки проекта, что нужно для того, чтобы убедиться о том, что новый код компилируется и работает вместе с остальной кодовой базой;
3. **Автоматическое тестирование** (Automated Testing) - когда после сборки система CI запускает автоматические тесты, чтобы проверить корректность новых изменений (юнит-тесты, интеграционные тесты и другие виды тестирования), для того, чтобы помогают выявить ошибки и дефекты на ранних этапах разработки.

### Continuous Delivery (CD)

**Continuous Delivery** - это процесс непрерывной доставки, который предполагает автоматизацию развертывания и тестирования, что помогает добиться того, чтобы каждая версия программного обеспечения была готова к выпуску в любое время.

Состоит из шагов:
1. **Подготовка к развертыванию** (Release) - дополнительная проверка качества и создание сборки и пакетов, которые нужны для развертывания;
2. **Развертывание в тестовые среды** (Staging/Pre-production Deployment) - готовое приложение развертывается в тестовых средах, где выполняются дополнительные проверки и тесты, что помогает убедиться, что приложение работает корректно в условиях, близких к продакшн-среде.

### Continuous Deployment

**Continuous Deployment** - это процесс непрерывного развертывания, который предполагает что каждое успешное изменение автоматически развертывается в рабочую среду.

Состоит из шагов:
1. **Автоматическое развертывание** (Production Deployment) - после прохождения процессов CI и CD, система автоматически доставляет его конечным пользователям.

## Infrastructure as Code

**Infrastructure as Code** (IaC) - это подход управлением инфраструктурой, через код.

Основные подходы:
- **декларативный** (функциональный) - когда описывается конфигурация целевого состояния инфраструктуры или окружения, которое требуется, но при этом не указывается последовательность исполнения такой настройки IaC-инструментом;
- **императивный** (процедурный) - подразумевает детальное описание шагов развертывания или настройки инфраструктуры в конфигурационном файле.

## MLOps

**MLOps** (Machine Learning Operations) - это набор практик, который объединяет разработку моделей машинного обучения (ML) и DevOps-процессы.

Основная задача MLOps - автоматизация и управление всем жизненным циклом моделей машинного обучения, от их разработки и обучения до развертывания и эксплуатации в продакшн-среде.

**ModelOps** (Model Operations) - это практика, направленная на эксплуатацию моделей машинного обучения и других статистических моделей в продакшн-среде.

Искусственный интеллект
=======================

**Искусственный интеллект** - это технология, реализованная в информационных системах и имитирующая человеческий интеллект с помощью методов машинного обучения.

## NLP

**NLP** (Natural Language Processing) - обработка естественного языка - это класс задач по распознанию, генерации, обработке голоса и письменной речи человека, используемых при разработке информационных систем.

Состоит из аспектов:
1. **Токенизации** - декомпозиции текста на отдельные слова, фразы или предложения - **токены**;
2. **Стоп-слов** - часто встречающихся знаков и слов ("и", "в", "на", "этот"), которые обычно не несут полезной информации для анализа, которые часто удаляются, чтобы сократить объем данных и сосредоточиться на значимых словах;
3. **Лемматизации** - приводения слова к его базовой (лемматической) форме, то есть преобразование слова в их исходную форму;
4. **Стемминга** - нахождение основы слова, убирая приставки, окончания;
5. **Мешка слов** (bag of words) - сложенных в массив набор всех токенов, где каждый токен заносится в общий словарь, и каждому присваивается число, которое отражает, сколько раз каждое слово встречается в этом документе;
6. **TF-IDF** (term frequency-inverse document frequency) - числового показателя, который оценивает важность слов во всем тексте;
7. **Распознавания намерений** - определение цели или намерения пользователя на основе текста с использованием машинного обучения.

## Работа с данными

Состоит из шагов:
1. **Формирование бизнес-требований и технологического стека**, который заключается в определении критериев успеха, функциональных требований и согласование технологического стека, инструментов компетенций, которые будут использоваться;
2. **Сбор данных**, который заключается в определении данных с полезной информацией, обработки и интеграции данных из различных источников, создания пайплайнов данных, которые автоматизируют процесс извлечения данных и их загрузку в хранилища;
3. **Подготовка данных**, который заключается в очистке данных, преобразования их в нужный формат и подготовки их к использованию в моделях машинного обучения;
4. **Анализ данных**, который заключается в выявлении закономерностей, трендов и взаимосвязей в данных, которые могут быть полезны для дальнейшего моделирования и принятия решений;
5. **Моделирование**, который заключается в создании, обучении и тестировании моделей, которые будут использоваться для решения задач прогнозирования;
6. **Оценка модели и решения**, который заключается в оценке производительности обученной модели, используя различные метрики качества;
7. **Принятие решений**, который заключается в применении моделей в реальной среде;
8. **Мониторинг**, который заключается в наблюдении за производительностью и корректностью работы модели после ее развертывания в продакшн-среде.

**CRISP-DM** (CRoss-Industry Standart Process for Data Mining) - межотраслевой стандартный процесс исследования данных, который особенно используется в моделях исследования данных. Состоит из фаз:
1. **Определения бизнес-целей** (business understanding);
2. **Начального изучения данных** (data understanding);
3. **Подготовки данных** (data preparation);
4. **Моделирования** (modeling);
5. **Оценки** (evaluation);
6. **Внедрения** (deployment).

## ML-модели

**Модель** - это математическая функция, которая может принимать на вход новые данные и делать на их основе прогнозирование и многое другое. Модель включает в себя настройки (параметры), которые были получены в процессе обучения, и определяют, как модель интерпретирует входные данные. Модель - это то, что будет развернуто в продакшн-среде и с чем будут взаимодействовать другие компоненты будущего решения.

**Алгоритм машинного обучения** — это то, благодаря чему модель будет учиться выполнять более точное прогнозирование.

**Нормализация данных** - это преобразование входящих данных в рамках одного диапазона значений.

**Масштабирование данных** - это преобразование входящих данных к одному размеру для консистентности на входе модели.

**Тензор** - это многомерный массив чисел.

### Виды моделей машинного обучения

**Обучение с учителем** (Supervised Learning) - это метод, при котором модель обучается на размеченных данных. Каждому входному набору данных соответствует правильный выход или "метка" (целевой признак). Модель должна научиться предсказывать правильные метки для новых данных на основе того, что она выучила из обучающего набора.

Алгоритм работы:
1. Модель получает набор данных, где каждый элемент состоит из входных характеристик (например, признаки объекта) и известного результата (метки);
2. Модель анализирует эти данные и настраивает свои внутренние параметры так, чтобы минимизировать разницу между предсказанными и реальными результатами.

**Обучение без учителя** (Unsupervised Learning) - это метод, при котором модель обучается на неразмеченных данных. В этом случае у модели нет правильных ответов или меток для данных и задача модели - самостоятельно выявить скрытые структуры или паттерны в этих данных.

Алгоритм работы:
1. Модель получает только входные данные, без известных меток или результатов;
2. Модель анализирует данные и пытается найти в них закономерности - группы (кластеры), связи между признаками или важные характеристики данных.

**Обучение с подкреплением** (Reinforcement Learning, RL) - это метод машинного обучения, в котором агент взаимодействует с окружающей средой для выполнения определенной задачи, обучаясь на основе обратной связи в виде вознаграждений или наказаний.

Основные элементы:
- **Агент** (Agent) - это сервис или алгоритм, который принимает решения о том, какое действие предпринять в каждом состоянии среды, может быть программой, роботом или любым другим интеллектуальным объектом, который учится на основе взаимодействия с миром;
- **Среда** (Environment) - это внешний мир или ситуация, в которой действует агент, которая предоставляет агенту информацию о текущем состоянии и выдает вознаграждения на основе действий агента;
- **Состояние** (State) - текущее описание среды, в которой находится агент, которое включает всю доступную информацию о мире, с которой агент может работать для принятия решений;
- **Действие** (Action) - выбор действия агента, который влияет на состояние среды, который происходит на каждом шаге на основе своей стратегии;
- **Вознаграждение** (Reward) - обратная связь от среды после того, как агент совершает действие, которое может быть положительным (если действие привело к желаемому результату) или отрицательным (если действие оказалось неудачным). Цель агента - максимизировать совокупное вознаграждение;
- **Политика** (Policy) - (необязательный элемент) стратегия или правило, по которому агент выбирает действия на основе состояния среды, которая может быть статичной или динамически изменяющейся в зависимости от опыта агента;
- **Функция ценности** (Value Function) - (необязательный элемент) это оценка ожидаемого вознаграждения для каждого состояния, которая помогает агенту предсказывать, насколько выгодно попадание в определенное состояние.

## LLM

**LLM** (Large Language Models) - это общий термин, который охватывает целый класс больших языковых моделей, обладающих миллиардами параметров и выполняющих задачи, связанные с обработкой текста, которые могут генерировать связные тексты, переводить языки, анализировать текстовые данные и писать код.

## Модульные диалоговые системы

Модульные диалоговые системы взаимодействуют с пользователем на естественном языке в тексте или речи через различные интерфейсы на основе моделей машинного обучения.

Состоит из:
- **модуля NLU** (Natural Language Understanding), который отвечает за анализ и интерпретацию входящего текста в диалоговых системах, который принимает запрос через API от приложения, который послал пользователь. С главной задачей - извлечь из текста намерения пользователя и основные элементы;
- **модуля Dialog Management** (DM, Core), который отслеживает текущее состояние диалога, включая информацию о предыдущих намерениях и выполненных действиях, что позволяет системе сохранять контекст и делать правильные предсказания о следующем шаге на основе накопленной информации. И отвечает за выбор следующего шага в зависимости от контекста, намерений пользователя, сущностей и состояния диалога.
Состоит из:
    - **политик** - которые ответствены за принятия решений о том, как должна реагировать система. Имеет типы:
        - **rule-based** - реализуются на правилах, где требования к диалогу ограничены и предсказуемы и подходит для обработки часто задаваемых вопросов (FAQ), где ответы формируются на основе правил без необходимости сложной обработки естественного языка;
        - **data-driven** - реализация таких решений основана на управлении данными и имеет два механизма:
            - **retrieval-based** - когда используется заранее созданный набор данных для извлечения наиболее подходящего ответа и при запросе система сопоставляет введенный текст с существующими ответами и выбирает наилучший вариант на основе схожести. Используется в базах знаний, где нужен точный ответ из большого объема данных;
            - **generating** — когда используются нейронные сети, которые позволяют генерировать уникальные ответы на данных, на которых была обучена модель, что позволяет генерировать ответы даже для сильно нетипичных запросов, что делает это подходящим в сложных сценариях, но требует объема данных для обучения и мощных вычислительных ресурсов, а также могут выдавать слишком общие или непредсказуемые ответы, если не оптимизированы должным образом.
    - **слотов** (slot filling) - которые хранят важные данные из текстов пользователя, которые могут использоваться на следующих шагах диалога для предоставления более контекстно ориентированных ответов;
    - **действий** - которые могут быть вызваны по каким-то условиям.
- **модуля NLG** (Natural Language Generation), который отвечает за генерацию и формирование исходящего текста, который передается через API приложению для отображения пользователю. С главной задачей - последовательно сформировать текстовый ответ на основе внутренних данных системы и выявленных намерений пользователя, обеспечивая естественность и понятную коммуникацию.
