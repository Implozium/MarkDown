Основы JavaScript
=================

## Структура кода

**Команды**: как правило, каждая команда пишется на отдельной строке и после нее ставится точка с запятой `;`. Точку с запятой во многих случаях можно не ставить, если есть переход на новую строку.

**Комментарии** могут находиться в любом месте программы и никак не влияют на её выполнение. Интерпретатор JavaScript попросту игнорирует их. Однострочные комментарии начинаются с двойного слэша `//`. Текст считается комментарием до конца строки. Многострочные комментарии начинаются слешем-звездочкой `/*` и заканчиваются звездочкой-слэшем `*/`. Вложенные комментарии не поддерживаются.

## Директива use strict

Директива выглядит как строка `"use strict";` или `'use strict';` и ставится в начале скрипта, переводит код в режим полного соответствия современному стандарту.

## Переменные

Переменная состоит из имени и выделенной области памяти, которая ему соответствует. Для объявления или, другими словами, создания переменной используется ключевое слово `var`:  
`var <имя_переменной>;`

После объявления, можно записать в переменную данные:  
`<имя_переменной> = <значение_переменной>;`

Эти данные будут сохранены в соответствующей области памяти и в дальнейшем доступны при обращении по имени. Для краткости можно совместить объявление переменной и запись данных. Можно даже объявить несколько переменных сразу через запятую `,`.

JavaScript перемещает операторы `var` и определение `function` наверх ближайшей оборачивающей области видимости, переменные заданные через `var` до своего конкретного определения равны `undefined`.

На **имя переменной** в JavaScript наложены всего два ограничения:
- имя может состоять из: букв, цифр, символов `$` и `_`;
- первый символ не должен быть цифрой.

**Константа** - это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание `<ИМЯ_КОНСТАНТЫ>`.

### Переменные: `let` и `const` (ES6)

`let <имя_переменной>;`

У объявлений переменной через `let` есть три основных отличия от `var`:
- область видимости переменной `let` - блок `{...}` - переменная, объявленная через `let`, видна только в рамках блока `{...}`, в котором объявлена. Это, в частности, влияет на объявления внутри `if`, `while` или `for`;
- переменная `let` видна только после объявления;
- при использовании в цикле, для каждой итерации создаётся своя переменная - каждому повторению цикла соответствует своя независимая переменная `let`. Если внутри цикла есть вложенные объявления функций, то в замыкании каждой будет та переменная, которая была при соответствующей итерации.

`const <ИМЯ_КОНСТАНТЫ> = <значение>;`  
`const <имя_константы> = <объект>;`

Объявление `const` задаёт константу, то есть переменную, которую нельзя менять, в случае объекта не позволяет изменять переменную как ссылку на другое значение, а не сам объект. В циклах ведет себя подобно `let`.

### Правила именования

- **правило 1** - никакого транслита. Только английский;
- **правило 2** - использовать короткие имена только для переменных "местного значения". Название переменной должно быть понятным. Иногда для этого нужно использовать несколько слов;
- **правило 3** - переменные из нескольких слов пишутся - `вместеВотТак` - в формате `camelCase`;
- **правило последнее, главное** - имя переменной должно максимально чётко соответствовать хранимым в ней данным.

Если при поиске переменной с одним именем, находится - с другим, то зачастую самый лучший ход - это переименовать переменную, чтобы имя было тем, которое искали.

### Деструктуризация (ES6)

**Деструктуризация** (*destructuring assignment*) - это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.

#### Деструктуризация массива

`let [{<переменная1>[ = <значение_по_ум>] | }[, ...][, ...<переменная_все_остальное>]] = [<значение>[, ...]];` - при таком присвоении первое значение массива пойдёт в переменную `<переменная1>`, второе - в следующую, а последующие (если есть) - будут отброшены. Ненужные элементы массива также можно отбросить, поставив лишнюю запятую.

Если необходимо получить и последующие значения массива, но не уверены в их числе - можно добавить ещё один параметр, который получит "*всё остальное*", при помощи оператора `...` ("**spread**", троеточие). Значением этой переменной `<переменная_все_остальное>` будет массив из оставшихся элементов массива.

Если значений в массиве меньше, чем переменных - ошибки не будет, просто им присваивается `undefined`. В качестве значений по умолчанию можно использовать не только примитивы, но и выражения, даже включающие в себя вызовы функций. При этом вызов функции для генерации значения по умолчанию будет осуществлён только при необходимости, то есть если значения нет в массиве или оно равно `undefined`.

> `let [a, , c = 2, ...d] = [1, 2, 3, 4, 5];`

#### Деструктуризация объекта

Деструктуризацию можно использовать и с объектами. При этом указывают, какие свойства в какие переменные должны "*идти*". Базовый синтаксис:  
`let {<переменная_из_объекта1>[: <новое_имя>][ = <значение_по_ум>][, ...]} = <объект>`

Объект справа - уже существующий объект, который нужно разбить на переменные. А слева - список переменных, в которые нужно соответствующие свойства записать.

Если объект или массив содержат другие объекты или массивы, и их тоже хочется разбить на переменные - не проблема. Деструктуризации можно как угодно сочетать и вкладывать друг в друга. Можно использовать в аргументах функции.

Чтобы избежать интерпретации деструктуризации как блока (для существующих переменных), нужно обернуть всё присваивание в скобки `(...)`:  
`({<переменная_из_объекта_как_имя_существующей_переменной>[: <имя_переменной>][= <значение_по_ум>][, ...]} = <объект>)`

> `const {2: country, 4: state} = '1997,John Doe,US,john@doe.com,New York'.split(',');`

Для объекта (ES2018) можно использовать еще один параметр через оператор `...`: `...<остаток>`, который получит "*все остальные*" оставшиеся значения объекта.

> `let {a, ...rest} = {a: 1, b: 2, c: 3};`

#### Оператор spread

Оператор расширения (`...`) позволяет расширять выражения в тех местах, где предусмотрено использование нескольких аргументов (при вызовах функции) или ожидается несколько элементов (для массивов). Использование, может находиться в любом месте, это может быть массив, строка, генератор или любой перечисляемый объект:  
`...<перечисляемый_объект>`

> `[...[1, 2, 3], 4] // [1, 2, 3, 4]`  
> `Math.max(...[1, 3, 4, 5]) // Math.max(1, 3, 4, 5)`  
> `const copyArray = [...[1, 2, 3]] // копирует массив`

Для объекта (ES2018) можно использовать расширение объекта через оператор `...`: `...<объект>`, который запишет все ключи и значения из объекта в объект, при этом все последующие ключи после этого оператора перезапишут ключи из объекта.

> `{...{a: 0, b: 2, c: 3}, a: 1} // {a: 1, b: 2, c: 3}`

## Шесть типов данных

Примитивные типы:
- **Число "number"** - единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения `Infinity` (бесконечность) и `NaN` (ошибка вычислений). Бесконечность `Infinity` получается при делении на ноль. Ошибка вычислений `NaN` будет результатом некорректной математической операции;
- **Строка "string"** - для представления строк, заключается в кавычки, в JavaScript **одинарные** `'` и **двойные** `"` кавычки равноправны. Можно использовать или те или другие;
- **Булевый (логический) тип "boolean"** - у него всего два значения: `true` (истина) и `false` (ложь). Как правило, такой тип, используется для хранения значения типа да/нет;
- **Специальное значение "null"** - значение `null` не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного значения `null`. Это просто специальное значение, которое имеет смысл "**ничего**" или "**значение неизвестно**";
- **Специальное значение "undefined"** - значение `undefined`, как и `null`, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл "**значение не присвоено**". Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть `undefined`.

Объектный тип:
- **Объекты "object"** - он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок `{...}`.

## Основные операторы

**Операнд** - то, к чему применяется оператор.  
**Унарным** называется оператор, который применяется к одному выражению.  
**Бинарным** называется оператор, который применяется к двум операндам.

**Сложение строк, бинарный `+`** - обычно при помощи плюса `+` складывают числа. Но если бинарный оператор `+` применить к строкам, то он их объединяет в одну. Иначе говорят, что "*плюс производит конкатенацию (сложение) строк*". Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке. Это приведение к строке - особенность исключительно бинарного оператора `+`. Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

**Преобразование к числу, унарный плюс `+`** - унарный, то есть применённый к одному значению, плюс ничего не делает с числами. Тем не менее, он широко применяется, так как его "*побочный эффект**" - преобразование значения в число, для этого используется унарный плюс, чтобы преобразовать строку к числу.

**Присваивание** - возможно присваивание по цепочке, такое присваивание работает справа-налево. Оператор `=` возвращает значение, как и все операторы.

**Взятие остатка `%`** - результат `a % b` - это остаток от деления `a` на `b`.

**Возведение в степень `**`** - (ES2016) результат `a ** b` - это число `a` в степени `b`.

**Инкремент/декремент: `++`, `--`** - увеличивают/уменьшают значение переменной на `1`. Постфиксная форма `i++` отличается от префиксной `++i` тем, что возвращает старое значение, бывшее до увеличения. Инкремент/декремент можно использовать в любых выражениях.

### Побитовые операторы

Рассматривают аргументы как **32-разрядные целые числа** и работают на уровне их внутреннего двоичного представления. Поддерживаются следующие побитовые операторы:
- **побитовое И (AND) `a & b`** - ставит 1 на бит результата, для которого соответствующие биты операндов равны 1;
- **побитовое ИЛИ (OR) `a | b`** - ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1;
- **побитовое исключающее ИЛИ (XOR) `a ^ b`** - ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба);
- **побитовое НЕ (NOT) `~a`** - заменяет каждый бит операнда на противоположный;
- **левый сдвиг `a << b`** - сдвигает двоичное представление `a` на `b` битов влево, добавляя справа нули;
- **правый сдвиг, переносящий знак `a >> b`** - сдвигает двоичное представление `a` на `b` битов вправо, отбрасывая сдвигаемые биты;
- **правый сдвиг с заполнением нулями `a >>> b`** - сдвигает двоичное представление `a` на `b` битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.

В JavaScript побитовые операторы `^`, `&`, `|` выполняются после сравнений `==`. Битовые операции отбрасывают десятичную часть.

`-n = ~n + 1`  
`~n == 0 только если n == -1`

### Сокращённая арифметика с присваиванием

Имеет вид:
`<имя_переменной> <бинарный_оператор> = <второй операнд>;`

### Оператор запятая `,`

Оператор запятая `,` - обычно используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Каждое из них - вычисляется и отбрасывается, за исключением последнего, которое возвращается.

### Операторы сравнения и логические значения

Операторы сравнения:
- **больше/меньше**: `a > b`, `a < b`;
- **больше/меньше** или равно: `a >= b`, `a <= b`;
- **равно** `a == b`. Для сравнения используется два символа равенства `==`. Один символ `=` означал бы присваивание;
- **"не равно"**. В математике он пишется как `≠`, в JavaScript - знак равенства с восклицательным знаком перед ним `!=`.

Как и другие операторы, сравнение возвращает значение. Это значение имеет логический тип.

**Строки сравниваются** побуквенно, сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой, при этом любая буква больше отсутствия буквы.

При сравнении значений разных типов, используется **числовое преобразование**. Оно применяется к обоим значениям.

Для проверки равенства без преобразования типов используются операторы строгого равенства `===`(*тройное равно*) и `!==`. Если тип разный, то они всегда возвращают `false`.

Сравнение с `null` и `undefined`:
- значения `null` и `undefined` равны `==` друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка;
- при преобразовании в число `null` становится `0`, а `undefined` становится `NaN`. При этом получается некорректный результат сравнения `null` с `0`, и значение `undefined` вообще нельзя сравнивать.

### Логические операторы

`||` (**ИЛИ**) - логическое **ИЛИ** в классическом программировании работает следующим образом: "если хотя бы один из аргументов `true`, то возвращает `true`, иначе - `false`". Оператор **ИЛИ** вычисляет ровно столько значений, сколько необходимо - до первого `true`. При этом оператор **ИЛИ** возвращает то значение, на котором остановились вычисления. Причём, не преобразованное к логическому типу. Если все значения "ложные", то `||` возвратит последнее из них.

`&&` (**И**) - в классическом программировании **И** возвращает `true`, если оба аргумента истинны, а иначе - `false`. Если левый аргумент - `false`, оператор **И** возвращает его и заканчивает вычисления. Иначе - вычисляет и возвращает правый аргумент.

Приоритет у `&&` больше, чем у `||`.

`!` (**НЕ**) - оператор **НЕ** - самый простой. Он получает один аргумент. Действия `!`:
1. Сначала приводит аргумент к логическому типу `true`/`false`.
2. Затем возвращает противоположное значение.

В частности, двойное НЕ (`!!`) используют для преобразования значений к логическому типу.

### Оператор `typeof`

Оператор `typeof` возвращает тип аргумента в виде строки. У него есть два синтаксиса: со скобками и без:
- синтаксис оператора: `typeof <аргумент>`;
- синтаксис функции: `typeof(<аргумент>)`.

С помощью такой конструкции можно проверить существование переменной, ее объявление:  
`typeof <переменная> === "undefined"` - вернет `true`, если переменная не существует.

### Оператор `void`

Оператор `void` вычисляет переданное выражение и возвращает `undefined`. У него есть два синтаксиса: со скобками и без:
- синтаксис оператора: `void <выражение>`;
- синтаксис функции: `void(<выражение>)`.

С помощью такой конструкции можно вызвать анонимную функцию:  
`void function (...) {...}();`

## Преобразование типов для примитивов

**Строковое преобразование** - `String(<аргумент>)` - возвращает аргумент в виде строки, преобразование происходит наиболее очевидным способом, "как есть": `false` становится `"false"`, `null` - `"null"`, `undefined` - `"undefined"` и т.п. Также для явного преобразования применяется оператор `+`, у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент.

**Численное преобразование** - для преобразования к числу в явном виде можно вызвать `Number(<аргумент>)`, который возвращает аргумент в виде строки либо поставить перед выражением унарный плюс `+`, при этом: `undefined` - `NaN`; `null` - `0`; `true` - `1`; `false` - `0`; **Строка** - пробельные символы по краям обрезаются, далее, если остаётся пустая строка, то `0`, иначе из непустой строки "*считывается*" число, при ошибке результат `NaN`.

**Логическое преобразование** - для явного преобразования используется двойное логическое отрицание `!!<значение>` или вызов `Boolean(<аргумент>)`, который возвращает аргумент в виде логического значения, при этом `undefined`, `null` - `false`; **Числа** - все `true`, кроме `0`, `NaN` - `false`; **Строки** - все `true`, кроме пустой строки `""` - `false`; **Объекты** - всегда `true`.

### Вспомогательные функции `parseInt`, `toString`

`parseInt(<строка_с_числом>, <система_числа>)` - переводит строку в заданной системе в число.  
`<число>.toString(<система_числа>)` - получает для числа запись в заданной системе в виде строки.

## Условные операторы: `if`, `?:`

Оператор `if` ("если") - получает условие, он вычисляет его, и если результат - `true`, то выполняет команду. Если нужно выполнить более одной команды - они оформляются блоком кода в фигурных скобках `{<код>}`. Выполняет код только истиного условия, а если таких нет, то ложного. Вычисление условий происходит в порядке следования условий.

```javascript
if (<условие>) {
    <код_для_результата_условия_истины>
} [else if(<альтернативное_условие>) {
    <код_для_результата_альтернативного_условия_истины>
}] [...] [else {
    <код_для_результата_условия_лжи>
}]
```

Оператор `if (...)` вычисляет и преобразует выражение в скобках к логическому типу. В логическом контексте:
- число `0`, пустая строка `""`, `null` и `undefined`, а также `NaN` являются `false`;
- остальные значения - `true`.

### Тернарный оператор вопросительный знак `?:`

`<условие> ? <значение1> : <значение2>` - проверяется условие, затем если оно верно - возвращается `<значение1>`, если неверно - `<значение2>`.

### Опциональный оператор `?.` (ES2020)

`<значение>?.<ключ>` - если есть у заданого значения `<значение>` ключ `<ключ>`, то возвращается значение этого ключа, иначе возвращается `undefined`.

> `foo?.baz?.bar`

`<значение>?.()` - если заданое значения является функция, то возвращается значение вызова этой функции, иначе возвращается `undefined`.

> `foo.baz?.()`

### Оператор проверки на null `??` (ES2020)

`<значение1> ?? <значение2>` - проверяется условие если `<значение1>` равно `null` и `undefined`, то возвращается `<значение2>`, иначе `<значение1>`.

## Циклы

### Цикл `while`

```javascript
while (<условие>) {
    <код_тела_итерации_цикла>
}
```

Пока условие: `<условие>` верно - выполняется тело: `<код_тела_итерации_цикла>`.

### Цикл `do...while`

```javascript
do {
    <код_тела_итерации_цикла>
} while (<условие>);
```

Цикл, описанный, таким образом, сначала выполняет тело: `<код_тела_итерации_цикла>`, а затем проверяет условие: `<условие>`.

### Цикл `for`

```javascript
for (<начало>; <условие>; <шаг>) {
    <код_тела_итерации_цикла>
}
```

Поток выполнения: `<начало>` -> (если `<условие>` истинно -> тело: `<код_тела_итерации_цикла>` -> `<шаг>`) -> (если `<условие>` истинно -> тело: `<код_тела_итерации_цикла>` -> `<шаг>`) -> ... и так далее, пока верно условие. В цикле также можно определить переменную в `<начало>`. Любая часть `for` может быть пропущена.

### Прерывание цикла

`break` - прекращает выполнение текущей итерации цикла и выходит из его тела.

`continue` - прекращает выполнение текущей итерации цикла и переходит на следующую.

#### Метки для `break`/`continue`

Метка имеет вид `<имя_метки>:`, имя должно быть уникальным. Она ставится перед циклом. Вызов `break <имя_метки>` ищет ближайший внешний цикл с такой меткой и переходит в его конец. Директива `continue <имя_метки>` также может быть использована с меткой, в этом случае управление перепрыгнет на следующую итерацию цикла с меткой.

Также для меток можно использовать блок кода:  
`<имя_метки>: {...}` - тогда вызов `break <имя_метки>` переходит в конец блока.

#### Цикл `for..in`

Проходит через перечисляемые свойства объекта. Он пройдёт по каждому отдельному элементу:
```javascript
for (var <переменная> in <объект>) {
    <код_тела_итерации_цикла>
}
```

Где в `<переменная>` заносятся все перечисляемые свойства объекта.

## Конструкция `switch`

Конструкция `switch` заменяет собой сразу несколько `if`. Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами. Синтаксис:
```javascript
switch(<переменная>) {
    case <значение1>: {
        <код_при_равенстве_переменной_значению1>
        [break;]
    }
    case <значение2>: {
        <код_при_равенстве_переменной_значению2>
        [break;]
    }
    [...]
    default: {
        <код_по_умолчанию_при_неравенстве_переменной_ни_одному_из_значений>
        [break;]
    }
}
```

Переменная проверяется на строгое равенство первому значению, затем второму и так далее. Если соответствие установлено - `switch` начинает выполняться от соответствующей директивы `case` и далее, до ближайшего `break` (или до конца `switch`). Если ни один `case` не совпал - выполняется (если есть) вариант `default`. При этом `case` называют вариантами `switch`.

Если `break` нет в теле `case`, то выполнение пойдёт ниже по следующим `case` до ближайшего `break` (или до конца `switch`), при этом остальные проверки игнорируются.

Несколько значений `case` можно группировать, просто не записывая код.

## Функции

Главная цель создания функций: избавление от дублирования кода. Синтаксис **Function Declaration**:
```javascript
function <имя_функции>([<параметр1>[, ...]]) {
    <код_функции>
    [return [<возвращаемое_значение>];]
}
```
Использование:
`<имя_функции>([<аргумент1>[, ...]]);`

Функция может содержать локальные переменные, объявленные через `var`. Такие переменные видны только внутри функции. Блоки `if/else`, `switch`, `for`, `while`, `do..while` не влияют на область видимости переменных. При объявлении переменной в таких блоках, она всё равно будет видна во всей функции. Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию.

Функция может обратиться ко внешней переменной. Такие переменные, объявленные на уровне всего скрипта, называют "**глобальными переменными**".

Параметры копируются в локальные переменные функции. Функцию можно вызвать с любым количеством аргументов. Если параметр не передан при вызове - он считается равным `undefined`. При объявлении функции необязательные аргументы, как правило, располагают в конце списка.

Для указания значения "по умолчанию", то есть, такого, которое используется, если аргумент не указан, используется два способа:
- можно проверить, равен ли аргумент `undefined`, и если да - то записать в него значение по умолчанию;
- использовать оператор `||`: `<параметр1> = <параметр1> || <значение_по_умолчанию>;`.

"Псевдо-массив" `arguments` - содержит список аргументов по номерам переданных в функцию, а также свойство `length`. При этом `arguments` - это не массив `Array`. В действительности, это обычный объект, просто ключи числовые и есть `length`.

`Array.prototype.slice.call(arguments);` - возвращает массив из `arguments`.

В старом стандарте JavaScript объект `arguments` не только хранил список аргументов, но и содержал в свойстве `arguments.callee` ссылку на функцию, которая выполняется в данный момент, а свойство `arguments.callee.caller` хранит ссылку на функцию, которая вызвала данную.

Для возврата значения используется директива `return`. Она может находиться в любом месте функции. Как только до неё доходит управление - функция завершается и значение передается обратно. В случае, когда функция не вернула значение или `return` был без аргументов, считается что она вернула `undefined`.

Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие. Если оно сложное и подразумевает поддействия - имеет смысл выделить их в отдельные функции, чтобы лучше структурировать код. Но самое главное - в функции не должно быть ничего, кроме самого действия и поддействий, неразрывно связанных с ним.

В JavaScript функция является значением, таким же как строка или число. Функцию можно запустить через скобки `()`, а можно и скопировать в другую переменную или передать в функцию как переменную.

В JavaScript **нет "перегрузки" функций**.

(ES6) Объявление функции **Function Declaration**, сделанное в блоке, видно только в этом блоке.

### Параметры по умолчанию (ES6)

Можно указывать параметры по умолчанию через равенство `=` в сигнатуре функции: `<параметр1> = <значение_по_умолчанию>`. Параметр по умолчанию используется при отсутствующем аргументе или равном `undefined`. При передаче любого значения, кроме `undefined`, включая пустую строку `''`, `0` или `null`, параметр считается переданным, и значение по умолчанию не используется. Параметры по умолчанию могут быть не только значениями, но и выражениями, при этом значение выражения будет вычислено, и соответствующие функции вызваны - лишь в том случае, если это необходимо, то есть когда функция вызвана без параметра.

Значение по умолчанию может ссылаться на предыдущие аргументы функции.

### Оператор spread вместо `arguments` (ES6)

Чтобы получить массив аргументов, можно использовать оператор `...`, перед последней переменной в функцию. В который попадёт массив всех аргументов, начиная со второго. При этом это - настоящий массив, в отличие от arguments.

`...` оператор можно использовать и при вызове функции, для передачи массива параметров как списка параметров.

Если функция получает объект, то она может его тут же разбить в переменные с помощью деструктуризации.

### Объявление Function Expression

`var <имя_переменно_функции> = function [<имя_функции>]([<параметр1>[, ...]]) {...}` - возвращает функцию. Основное отличие между ними: функции, объявленные как **Function Declaration**, создаются интерпретатором до выполнения кода, и их можно вызвать до объявления.

Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.

### Функции через `=>` (ES6)

`<параметр> => <возвращаемый_результат>`  
`<параметр> => {... [return ...]}`  
`(<параметр1>, <параметр2>[, ...]) => <возвращаемый_результат>`  
`(<параметр1>, <параметр2>[, ...]) => {... [return ...]}`  
`() => <возвращаемый_результат>`
`() => {... [return ...]}`

> `a => a + 2`  
> `(a, b) => {a++; b--; return a*b}`

Основные особенности:
- стрелочные функции не имеют своего `this`. Внутри стрелочных функций - тот же `this`, что и снаружи. В стрелочных функциях `this` никогда не приобретает новое значение вне зависимости от того, как функция вызвана;
- стрелочные функции нельзя запускать с `new`, так как у стрелочных функций отсутствует "свой `this`";
- стрелочные функции не имеют своего `arguments`. В качестве `arguments` используются аргументы внешней "обычной" функции;
- стрелочные функции нельзя использовать для объявления методов объектов, т.к. в случае необходимости больше будет нельзя сослаться на объект через `this`.

Для возвращения объекта, объект оборачивается в скобки: `(<объект>)`.
> `() => ({a: 4, b: 3})`

## Создание функции из текста - `new Function`

`new Function('<список_аргументов>', '<код_тело_функции>');` - возвращает функцию созданную из аргументов.

### Рекурсия, стек

В коде функции могут вызывать другие функции для выполнения подзадач. Частный случай подвызова - когда функция вызывает сама себя. Это называется **рекурсией**. Рекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как некое действие в совокупности с решением той же задачи в более простом варианте.

Значение, на котором рекурсия заканчивается называют **базисом рекурсии**. Общее количество вложенных вызовов называют **глубиной рекурсии**. Максимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на **10000** вложенных вызовов, но некоторые интерпретаторы допускают и больше.

При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных - "**стеке контекстов**".

Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее. Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции, в зависимости от условий, используются различные рекурсивные подвызовы, когда ветвление более сложное.

Специально для работы с рекурсией в JavaScript существует особое расширение функциональных выражений, которое называется "*Named Function Expression*" (сокращённо NFE) - "**именованное функциональное выражение**", которое ставится после `function` в **Function Expression**. Имя функционального выражения имеет особый смысл. Оно доступно только изнутри самой функции. **NFE** используется в первую очередь в тех ситуациях, когда функцию нужно передавать в другое место кода или перемещать из одной переменной в другую. Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.

## Консоль

Используется при отладке, кроме просмотра переменных и передвижения по скрипту, позволяет запускать команды JavaScript.

`console.log(<аргументы>)` - пишет переданные ей аргументы в консоль.  
`console.log("<сообщение>"[, <аргумент>[, ...]])` - форматирует сообщение по указанным аргументам и пишет его в консоль. В сообщения могут встраиваться шаблоны для аргументов:
- `%o` или `%O` - выводит как JavaScript объект;
- `%d` или `%i` - выводит как целое число;
- `%s` - выводит как строку;
- `%f` - выводит как дробное число;
- `%c` - применяет к дальнейшему выводу в консоль CSS-стили из аргумента.

`console.info(<аргументы>)` - тоже что и лог, только как инфо.  
`console.info("<сообщение>"[, <аргумент>[, ...]])` - тоже что и лог, только как инфо.

`console.warn(<аргументы>)` - тоже что и лог, только как предупреждение.  
`console.warn("<сообщение>"[, <аргумент>[, ...]])` - тоже что и лог, только как предупреждение.

`console.error(<аргументы>)` - тоже что и лог, только как ошибка.  
`console.error("<сообщение>"[, <аргумент>[, ...]])` - тоже что и лог, только как ошибка.

`console.trace("<сообщение>"[, <аргумент>[, ...]])` - выводит сообщение как лог, плюс трейс вызова.

```javascript
console.dir(<объект>[, {
    showHidden: false, // если true, то будут отображать еще и не перечисляемые свойства и символы
    depth: <глубина_вложености>,
    colors: false // если true, то вывод будет стилизован под цвета ANSI
}])
```
Выводит элемент в виде JavaScript-объекта, для анализа его свойств.

`console.assert(<значение>[, "<сообщение>"[, <аргумент>[, ...]]])` - если значение не равно `true`, то выведется сообщение.

`console.time('<метка>')` - включить внутренний хронометр браузера с меткой.  
`console.timeEnd('<метка>')` - выключить внутренний хронометр браузера с меткой и вывести результат разницу в мс между конечной и начальной меткой.

`console.table({<массив> | <объект>}[, ["<отображаемое_свойство1>"[, ...]]])` - логгирует аргумент `<массив>` или `<объект>` в виде таблицы. Каждый элемент массива (или каждое свойство, если это объект) будет представлять строку таблицы. Если элементы массива, либо свойства объекта, в свою очередь сами являются массивами или объектами, тогда эти элементы или свойства перечисляются построчно, перечисляя вложенные элементы/свойства в колонках.

### Специальные методы (Chrome)

`monitor(<функция>);` - устанавливает мониторинг функции, при каждом вызове функции выводит в консоль список аргуметов с какими она была вызвана.  
`unmonitor(<функция>);` - убирает мониторинг функции.

`monitorEvents(<HTML_элемент>, { '<событие>' | ['<событие1>'[, ...]] });` - устанавливает мониторинг событий элемента, при каждом вызове события выводит в консоль сведения об этих событиях.  
`unmonitorEvents(<HTML_элемент>, { '<событие>' | ['<событие1>'[, ...]] });` - убирает мониторинг событий элемента.

`getEventListeners(<HTML_элемент>);` - возвращает объект, где ключи это имена событий, а его значения - это список слушателей события элемента.  

## Советы по стилю кода

```
function pow(x, n) {
            ^ ^ ^  ^
            | | |  +-- фигурная скобка { на той же строке через пробел
            | | +-- пробел между параметрами
            +-+-- между именем функции и скобкой ( и первым параметром нет пробела
    var result = 1;
^^^^          ^ ^ ^
||||          | | +-- точка с запятой ; обязательна
||||          +-+-- пробелы вокруг операторов
++++-- отступ 4/2 пробела для вложености
    for (var i = 0; i < n; i++) {
        ^
        +-- пробел после всех ключевых слов
        result *= x;
    }

    return result;
}

var x = prompt("x?", "");
var n = prompt("n?", "");
<-- пустая строка между логическими блоками

if (n < 0) {
    alert('Степень ', + n + <-- длина строки не больше 80 символов
        ' не поддерживается, введите целую степень, большую 0');
} else { <-- без перевода строки
    alert( pow(x, n) );
            ^         ^
            +---------+-- пробелы вокруг вложеного вызова
}
```

## Структуры данных

Все значения в JavaScript, за исключением `null` и `undefined`, содержат набор вспомогательных функций и значений, доступных "**через точку**". Такие функции называют "**методами**", а значения - "**свойствами**".

### Числа

Все числа в JavaScript, как целые так и дробные, имеют тип `Number` и хранятся в **64-битном формате IEEE-754**, также известном как "*double precision*".

Способы записи:
- `<число_в_десятичной_системе>`;
- `0b<число_в_двоичной_системе>`;
- `0x<число_в_шестнадцатеричной_системе>`;
- `0o<число_в_восьмеричной_системе>`;
- `<число_в_десятичной_системе>e<число_нулей>`.

`Infinity` - особенное численное значение, которое ведет себя в точности как математическая бесконечность `∞`. `Infinity` больше любого числа. Добавление к бесконечности не меняет её. Бесконечность можно присвоить и в явном виде: `var <переменная> = Infinity`. Бывает и минус бесконечность `-Infinity`. В качестве результата деления на 0 получается "бесконечность".

Если математическая операция не может быть совершена, то возвращается специальное значение `NaN` (*Not-A-Number*). Деление `0/0` в математическом смысле неопределенно, поэтому его результат `NaN`. Значение `NaN` используется для обозначения математической ошибки и обладает следующими свойствами:
- значение `NaN` - единственное, в своем роде, которое не равно ничему, включая себя;
- значение `NaN` "прилипчиво". Любая операция с `NaN` возвращает `NaN`.

`isNaN(<число>)` - преобразует аргумент к числу и возвращает `true`, если получилось `NaN`, и `false` - для любого другого значения.  
`isFinite(<число>)` - преобразует аргумент к числу и возвращает `true`, если это не `NaN`/`Infinity`/`-Infinity`.

`parseInt(<число>[, <система_счисления>])` и ее аналог:  
`parseFloat(<число>)` - преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось. Функция `parseInt` читает из строки целое число, а `parseFloat` - дробное. `parseInt` / `parseFloat` возвращают `NaN` при ошибке на первом же символе.

`<число>.toString(<система_числа>)` - возвращает запись числа в заданной системе в виде строки.  
`<число>.toLocaleString("<локаль>")` - возвращает запись числа в указаной локали.  
`<число>.toFixed(<точность>)` - округляет число до точности и возвращает результат в виде строки. Округление идёт до ближайшего значения, аналогично `Math.round`. Итоговая строка, при необходимости, дополняется нулями до нужной точности.  
`<число>.toPrecision(<количество>)` - возвращает число в виде строки в записи с фиксированной запятой или в экспоненциальной записи, округлённое до `<количество>` значащих цифр.  
`<число>.toExponential(<кол_цифр_после_запятой>)` - возвращает строку, представляющую объект в экспоненциальной записи.

`Number.isInteger(<значение>)` - проверяет, является ли переданное значение целым числом и возвращает `true` если является, иначе `false`.  
`Number.isSafeInteger(<значение>)` - проверяет, является ли переданное значение безопасным целым числом в диапазоне от `-(2**53 - 1)` до `2**53 - 1` и возвращает `true` если является, иначе `false`.

#### Округление

- `Math.ceil(<число>)` - округляет вверх и возвращает число;
- `Math.round(<число>)` - округляет до ближайшего целого и возвращает число;
- `Math.floor(<число>)` - округляет вниз и возвращает число;
- `Math.trunc(<число>)` - возвращает целую часть числа.

#### Встроенные функции для тригонометрических вычислений

- `Math.acos(<число>)` - возвращает арккосинус `<число>` (в радианах);
- `Math.asin(<число>)` - возвращает арксинус `<число>` (в радианах);
- `Math.atan(<число>)` - возвращает арктангенс `<число>` (в радианах);
- `Math.atan2(y, x)` - возвращает угол до точки` (y, x)`;
- `Math.sin(<число>)` - вычисляет синус `<число>` (в радианах);
- `Math.cos(<число>)` - вычисляет косинус `<число>` (в радианах);
- `Math.tan(<число>)` - возвращает тангенс `<число>` (в радианах).

#### Функции общего назначения

- `Math.sqrt(<число>)` - возвращает квадратный корень из `<число>`;
- `Math.cbrt(<число>)` - возвращает кубический корень из `<число>`;
- `Math.log(<число>)` - возвращает натуральный (по основанию e) логарифм `<число>`. Для получения логарифма по основанию `<основание>` используется выражение `Math.log(<число>) / Math.log(<основание>)`;
- `Math.pow(<число>, <степень>)` - возводит число в степень, возвращает `<число>^<степень>`. Работает в том числе с дробными и отрицательными степенями;
- `Math.abs(<число>)` - возвращает абсолютное значение числа;
- `Math.exp(<число>)` - возвращает `e^<число>`, где `e` - основание натуральных логарифмов;
- `Math.max(a, b, c[, ...])` - возвращает наибольший из списка аргументов;
- `Math.min(a, b, c[, ...])` - возвращает наименьший из списка аргументов;
- `Math.random()` - возвращает псевдо-случайное число в интервале `[0,1)` - то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализируется текущим временем;
- `Math.sign(<число>)` - возвращает 1 если число больше 0, -1 если меньше и 0 если равно 0;
- `Math.hypot(a, b, c[, ...])` - возвращает корень из суммы квадратов аргументов.

### Строки

В JavaScript любые текстовые данные являются строками. Внутренним форматом строк, вне зависимости от кодировки страницы, является **Юникод** (**Unicode**). Строки создаются при помощи двойных или одинарных кавычек. В JavaScript нет разницы между двойными и одинарными кавычками.

Строки могут содержать специальные символы:
- `\0` - нулевой символ (символ NUL);
- `\'` - одинарная кавычка;
- `\"` - двойная кавычка;
- `\\` - обратный слэш;
- `\n` - новая строка (New line);
- `\r` - возврат каретки (Carriage return);
- `\v` - вертикальная табуляция;
- `\t` - табуляция (Tab);
- `\b` - забой (Backspace);
- `\f` - подача страницы (Form feed);
- `\uXXXX` - кодовая точка **Юникода** с шестнадцатеричным кодом `XXXX`;
- `\xXX` - символ из кодировки **Latin-1** (**ISO 8859-1**) с шестнадцатеричным кодом `XX`;
- `\u{NNNNNNNN}`, где `NNNNNNNN` - (ES6) максимально восьмизначный (но можно и меньше цифр) код для суррогатных пар.

Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем `\'`. Экранирование служит исключительно для правильного восприятия строки JavaScript. В памяти строка будет содержать сам символ без `\`. Сам символ обратного слэша `\` является служебным, поэтому всегда экранируется, т.е пишется как `\\`. Заэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт.

#### Строки в `` ` `` (ES6)

Если строки создавать в виде: `` `...` ``, то они будут отличаться от двойных `"..."` и одинарных `'...'` кавычек:
- в них разрешёно использовать перевод строки;
- в них можно вставлять выражения при помощи `${...}` - значение переменной `${<переменная>}` или более сложные выражения, которые могут включать в себя операторы, вызовы функций и т.п. Такую вставку называют "интерполяцией".
    > ``const a = 4000, b = `a is ${a}`;``

#### Функции шаблонизации (ES6)

Можно использовать свою функцию шаблонизации для строк. Название этой функции ставится перед первой обратной кавычкой:  
``let <переменная> = <функция_шаблонизации>`<строка>`;``

Эта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров ${...} и сами эти параметры.

Строка разбивается по очереди на части: "кусок строки" - "параметр" - "кусок строки" - "параметр" и т.д.

`function <функция_шаблонизации>(strings, ...values) {... return <новая_строка>;}` - функция шаблонизации, где:
- участки строки идут в первый аргумент-массив `strings` без выражений в `${...}`;
- у этого массива есть дополнительное свойство `strings.raw`. В нём находятся строки в точности как в оригинале;
- дальнейший список аргументов функции шаблонизации `values` - это значения выражений в `${...}`.

Функция шаблонизации может как-то преобразовать строку и вернуть новый результат.

#### Свойства и методы

`<строка>.length` - возвращает длину строки.  
`<строка>.charAt(<позиция>)` - возвращает строку, состоящую из выбранного символа, если символа нет, то пустую строку. Первый символ имеет позицию 0.  
`<строка>[<позиция>]` - возвращает строку, состоящую из выбранного символа, если символа нет - `undefined`.

Содержимое строки в JavaScript нельзя изменять. Нельзя взять символ посередине и заменить его. Как только строка создана - она такая навсегда. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой.

`<строка>.toLowerCase()` - возвращает строку со всеми символами в нижнем регистре.  
`<строка>.toUpperCase()` - возвращает строку со всеми символами в верхнем регистре.

`<строка>.trim()` - возвращает строку с удаленными пробелами спереди и сзади.

`<строка>.indexOf(<подстрока>[, <начальная_позиция>])` - возвращает позицию, на которой находится подстрока или `-1`, если ничего не найдено [начиная с указанной позиции].  
`<строка>.lastIndexOf(<подстрока>[, <начальная_позиция>])` - ищет не с начала, а с конца строки.

`<строка>.substring(<начальная_позиция>[, <конечная_позиция>])` - возвращает подстроку с начальной позиции до конца [до конечной позиции, но не включая ее].  
`<строка>.substr(<начальная_позиция>[, <длина>])` - возвращает подстроку с начальной позиции до конца [заданной длины].  
`<строка>.slice(<начальная_позиция>[, <конечная_позиция>])` - возвращает подстроку с начальной позиции до конца [до конечной позиции, но не включая ее], при этом отрицательные значения отсчитываются от конца строки.

`String.fromCharCode(<код>)` - возвращает символ по коду Юникода.  
`<строка>.charCodeAt(<позиция>)` - возвращает код символа на позиции. Отсчет позиции начинается с нуля.

`<строка>.localeCompare(<сравниваемая_строка>)` - возвращает негативное число, если `<строка>` предшествует `<сравниваемая_строка>` при сортировке, позитивное если `<строка>` следует за `<сравниваемая_строка>`, иначе `0`.

`String.fromCodePoint(<код>)` и `<строка>.codePointAt(<позиция>)` - (ES6) аналоги `String.fromCharCode(<код>)` и `<строка>.charCodeAt(<позиция>)`, корректно работающие с суррогатными парами - когда одному символу языка соответствует два юникодных символа (итого 4 байта).  
`<строка>.normalize()` - (ES6) юникодная нормализация, при которой строки приводятся к единому, "нормальному", виду.  
`<строка>.includes(<включаемая_строка>[, <начальный_индекс>])` - (ES6) проверяет, включает ли одна строка в себя другую [, начиная с `<начальный_индекс>`], возвращает `true`/`false`.  
`<строка>.endsWith(<подстрока>)` - (ES6) возвращает `true`, если строка заканчивается подстрокой.  
`<строка>.startsWith(<подстрока>)` - (ES6) возвращает `true`, если строка начинается со подстрокой.  
`<строка>.repeat(<кол_повторений>)` - (ES6) повторяет строку указанное количество раз.

`<строка>.padStart(<длина>[, "<строка>"])` - (ES2017) заполняет текущую строку вначале (слева) символом пробела `" "` [строкой `<строка>`] (несколько раз, если нужно) так, что итоговая строка достигает заданной длины `<длина>`.  
`<строка>.padEnd(<длина>[, "<строка>"])` - (ES2017) заполняет текущую строку вконце (справа) символом пробела `" "` [строкой `<строка>`] (несколько раз, если нужно) так, что итоговая строка достигает заданной длины `<длина>`.

### Объекты как ассоциативные массивы

**Ассоциативный массив** - структура данных, в которой можно хранить любые данные в формате ключ-значение. Создание:
- `{}`;
- `new Object()`.

Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства ("по ключу"). Для обращения к свойствам используется:
`<объект>.<свойство>`  
`<объект>["<свойство>"]`

Можно обратиться к любому свойству объекта, даже если его нет, то вернется специальное значение `undefined`.

Оператор: `"<свойство>" in <объект>` - возвращает `true` если есть в объекте свойство с определенным ключом.

Удаление осуществляется оператором: `delete <объект>.<свойство>`.

Объект можно заполнить значениями при создании, указав их в фигурных скобках:
```javascript
{
    <ключ1>: <значение1>[,
    <ключ2>: <значение2>[,
    ... ]]
}
```

Если создаётся объект при помощи синтаксиса `{...}`, то задать свойства-функции можно прямо в его определении. Для этого используется особый синтаксис: `get <свойство>()` или `set <свойство>(newValue)`.

#### Короткое свойство (ES6)

При объявлении объекта достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем свойства уже ранее объявленной.
> `const day = 'mon', obj = {day}; // {day: 'mon'}`

#### Вычисляемые свойства (ES6)

В качестве имени свойства можно использовать выражение `[<выражение>]`.
> `const param = 'req-', obj = {[param + 'day']: 'mon', [param + 'next']: 'wed'}; // {req-day: "mon", req-next: "wed"}`

#### Цикл по свойствам

Он последовательно переберёт свойства объекта, имя каждого свойства будет записано в `<ключ>` и вызвано тело цикла:
```javascript
for ([var ]<ключ> in <объект>) {
    ... // доступ к значению <объект>[<ключ>]
}
```

В переменной, которой присвоен объект, хранится не сам объект, а "*адрес его места в памяти*", иными словами - "**ссылка**" на него. При копировании переменной с объектом - копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Так как объект всего один, то изменения через любую переменную видны в других переменных.

`Object.keys(<объект>)` - возвращает массив ключей всех свойств объекта.

## Массивы c числовыми индексами

**Массив** - разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией. Создание:
- `[[<элемент1>[, <элемент2>[, ...]]]]`;
- `new Array([<элемент1>[, <элемент2>[, ...]]])`;
- `new Array(<количество_элементов>)`;
- `Array.from(<псевдомассив>[, function (item, i, arr) {...}[, <this_контекст>]])` - (ES6) возвращает настоящий массив на основе псевдомассива или итерируемых объектов (у которых есть метод `[Symbol.iterator]`) [и к каждому элементу применяет функцию и результат этой функции заносит в массив]. Псевдомассив может быть такого вида: `{length: <количество>}`;
- `Array.of(<значение1>[, ...])` - (ES6) возвращает массив на основании переданных значений, аналогично `new Array(<значение1>[, ...])`, но без специального поведения при одном аргументе.

Элементы нумеруются, начиная с нуля `0`.

Для того чтобы получить нужный элемент из массива - указывается его номер в квадратных скобках `<массив>[<номер_индекс>]`, так же можно добавлять новые элементы.
Общее число элементов, хранимых в массиве, содержится в его свойстве, при этом - это не количество элементов массива, а **последний индекс + 1**:  
`<массив>.length`

При уменьшении `length` массив укорачивается, причем этот процесс необратимый, т.е. даже если потом вернуть `length` обратно - значения не восстановятся.

В массиве может храниться любое число элементов любого типа.

Массив - это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством `length`. Из этого следует следствие - можно присваивать в массив любые свойства.

`<массив>.fill(<значение>[, <нач_индекс> = 0[, <кон_индекс> = this.length]])` - (ES6) заполняет все элементы массива [от начального [до конечного] индекса] одним значением и возвращает его, если элемент это объект, то все элементы будут одним и тем объектом, т.е. иметь ссылки на один и тот же объект.

`<массив>.pop()` - удаляет последний элемент из массива и возвращает его.  
`<массив>.push(<элемент1>[, <элемент2>[, ...]])` - добавляет элементы в конец массива.  
`<массив>.shift()` - удаляет из массива первый элемент и возвращает его.  
`<массив>.unshift(<элемент1>[, <элемент2>[, ...]])` - добавляет элементы в начало массива.

`<массив>.splice(<номер_индекс>[, <кол_элементов>[, <элемент1>[, <элемент2>[, ...]]]])` - удаляет заданное количество элементов, начиная с номера `<номер_индекс>`, а затем вставляет элементы на их место. Возвращает массив из удалённых элементов. Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца.

`<массив>.copyWithin(<номер_индекс>[, <начальная_позиция>[, <конечная_позиция>]])` - (ES6) копирует участок массива в позицию начиная с номера `<номер_индекс>` в текущий массив, не больше длины самого массива [с начальной позиции и до конца [до конечной позиции, он не включая ее]] и возвращает текущий массив. Можно использовать отрицательные индексы, они отсчитываются с конца. Если вообще не указать аргументов - скопируется весь массив с начала в указаную позицию.

`<массив>.slice(<начальная_позиция>[, <конечная_позиция>])` - копирует участок массива с начальной позиции и до конца [до конечной позиции, он не включая ее] и возвращает его. Исходный массив при этом не меняется. Можно использовать отрицательные индексы, они отсчитываются с конца. Если вообще не указать аргументов - скопируется весь массив.

`<массив>.sort([function (a, b) {...}])` - сортирует массив на месте и возвращает его [с помощью функции сортировки, то элементы массива сортируются в соответствии с её возвращаемым значением:
- при положительном значение, сортировка поставит `b` по меньшему индексу, чем `a`;
- при отрицательном значение, сортировка поставит `a` по меньшему индексу, чем `b`, то есть, `a` идёт первым;
- при 0, но вообще - не важно, что возвращать, их взаимный порядок не имеет значения.]

`<массив>.reverse()` - меняет порядок элементов в массиве на обратный на месте и возвращает массив.

`<массив>.concat(<элемент1>[, <элемент2>[, ...]])` - создаёт новый массив и возвращает его, в который копируются элементы из массива, а также указанные элементы. Если аргумент `concat` - массив, то `concat` добавляет элементы из него.

`<строка>.split(<строка_разделитель>[, <макс_кол_элементов>])` - возвращает массив превращенный из строки по разделителю.  
`<массив>.join(<строка_разделитель>)` - склеивает массив в строку с помощью разделителя и возвращает его.

`<массив>.indexOf(<искомый_элемент>[, <начальная_позиция>])` - возвращает номер искомого элемента в массиве или `-1`, если его нет [, при этом поиск начинается с указаного номера, если он указан. Если нет - с начала массива.] Для поиска используется строгое сравнение `===`.  
`<массив>.lastIndexOf(<искомый_элемент>[, <начальная_позиция>])` - ищет справа-налево: с конца массива [с указанного номера].  
`<массив>.includes(<элемент>[, <начальный_индекс>])` - (ES2016) проверяет, включает ли массив в себя элемент [, начиная с `<начальный_индекс>`], возвращает в случае успеха `true` иначе `false`.

`<массив>.forEach(function (item, i, arr) {...}[, <this_контекст>])` - используется для перебора массива, он для каждого элемента массива вызывает переданую callback-функцию, где:
- `item` - текущий элемент массива, элементы перебираются по очереди слева-направо;
- `i` - номер текущего элемента;
- `arr` - обрабатываемый массив.

`<массив>.filter(function (item, i, arr) {...}[, <this_контекст>])` - используется для фильтрации массива через функцию. Он создаёт новый массив, в который войдут только те элементы массива, для которых вызов callback-функции возвратит `true`.

`<массив>.map(function (item, i, arr) {...}[, <this_контекст>])` - используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов возвращаемых значений вызова callback-функции для каждого элемента массива.

`<массив>.every(function (item, i, arr) {...}[, <this_контекст>])` - возвращает `true`, если вызов callback-функции вернёт `true` для каждого элемента массива, если для любого элемента массива callback-функции вернёт `false`, метод немедленно вернёт `false` и не будет посещать остальные элементы.

`<массив>.some(function (item, i, arr) {...}[, <this_контекст>])` - возвращает `true`, если вызов callback-функции вернёт `true` для какого-нибудь элемента массива, если такой элемент найден, метод немедленно вернёт `true` и не будет посещать остальные элементы.

`<массив>.reduce(function (accumulator, item, i, arr) {...}[, <начальное_значение>[, <this_контекст>]])` - используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата. Метод `reduce` используется для вычисления на основе массива какого-либо единого значения, иначе говорят "**для свёртки массива**". Он применяет callback-функцию по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат который должна возвращать callback-функция на каждой итерации, где:
- `accumulator` - последний результат вызова функции, он же "**промежуточный результат**";
- `item` - текущий элемент массива, элементы перебираются по очереди слева-направо;
- `i` - номер текущего элемента;
- `arr` - обрабатываемый массив.

Методу можно передать "начальное значение" `<начальное_значение>`. Если он есть, то на первом вызове значение `accumulator` будет равно начальному значению, а если у `reduce` нет второго аргумента, то оно равно **первому** элементу массива, а перебор начинается со **второго**. Если массив пустой и нет второго аргумента, то будет брошено исключение `TypeError`.

`<массив>.reduceRight(function (accumulator, item, i, arr) {...}[, <начальное_значение>[, <this_контекст>]])` - работает аналогично, но идёт по массиву справа-налево.

`<массив>.find(function (item, i, arr) {...}[, <this_контекст>])` - (ES6) возвращает ссылку на значение в массиве, если вызов callback-функции вернёт `true` для какого-нибудь элемента массива, в противном случае возвращается `undefined`.

`<массив>.findIndex(function (item, i, arr) {...}[, <this_контекст>])` - (ES6) возвращает индекс в массиве, если вызов callback-функции вернёт `true` для какого-нибудь элемента массива, в противном случае возвращается `-1`.

`<массив>.entries()` - (ES6) возвращает итерируемый объект для массива с элементами в виде `[<ключ>, <значение>]`, он используется по умолчанию в `for..of`.  
`<массив>.keys()` - (ES6) возвращает итерируемый объект для массива с элементами в виде ключей, т.е. по ключам, он используется по умолчанию в `for..of`.  
`<массив>.values()` - (ES6) возвращает итерируемый объект для массива с элементами в виде значений, т.е. по значениям, он используется по умолчанию в `for..of`.

`Array.isArray(<значение>)` - он возвращает `true` только если `<значение>` - массив.

### `ArrayBuffer` (ES6)

Представляет собой фиксированный сырой буфер с бинарными данными. Напрямую им нельзя манипулировать, из него можно создать типизированный массив или объект `DataView`, который представляет этот буфер в специфическом формате и используется для чтения или записи содержимого в буфер.

`let <arrayBuffer> = new ArrayBuffer(<размер_байт>)` - создает сырой буфер определенного размера в байтах.

`<arrayBuffer>.byteLength` - возвращает размер в байтах.

`<arrayBuffer>.slice(<начальная_позиция_байт>[, <конечная_позиция_байт>])` - возвращает новый `ArrayBuffer` в который копирует участок массива с начальной позиции и до конца [до конечной позиции, он не включая ее] и возвращает его. Исходный массив при этом не меняется. Можно использовать отрицательные индексы, они отсчитываются с конца. Если вообще не указать аргументов - скопируется весь массив.

`ArrayBuffer.isView(<объект>)` - он возвращает `true` только если `<объект>` - типизированный массив или `DataView`.

### `SharedArrayBuffer` (ES2017)

Используется для создания разделенного буфера фиксированной длины для хранения примитивных бинарных данных, подобно объекту `ArrayBuffer`, но в отличие от него экземпляры `SharedArrayBuffer` могут быть использованы для создания обзора на разделенную память. `SharedArrayBuffer` не может быть отсоединен. Используется для разделения памяти с помощью объекта `SharedArrayBuffer` между одним агентом в кластере и другим.

`let <sharedArrayBuffer> = new SharedArrayBuffer(<размер_байт>)` - создает сырой буфер определенного размера в байтах.

`<sharedArrayBuffer>.slice(<начальная_позиция_байт>[, <конечная_позиция_байт>])` - работает аналогично методу из `ArrayBuffer`, только возвращает новый `SharedArrayBuffer`.

Разделенная память может быть создана и изменена одновременно в `workers` или основном потоке. В зависимости от системы (ЦПУ, ОС, браузер) может уйти время пока изменения будут распространены по всем контекстам. Для синхронизации необходимы атомарные операции.

В случаях использования `postMessage` для передачи объекта, объект `SharedArrayBuffer` передается получателю, результируя в новый, приватный объект `SharedArrayBuffer` внутри агента-получателя, только однако имеет блок общих данных, на который ссылаются оба объекта `SharedArrayBuffer`, это один и тот же блок данных, и сторонние эффекты в блоке в одном из агентов в итоге станут заметны в другом агенте.

#### Глобальный объект `Atomics` (ES2017)

Предоставляет атомарные операции как статические методы. Используется вместе с объектом `SharedArrayBuffer`.

Атомарные операции гарантируют, что ожидаемые значения будут записаны и прочитаны, а операции завершены, прежде чем следующая операция начнет свою работу, и они не будут прерваны.

Методы по изменению массива:
- `Atomics.add(<typedArray>, <индекс>, <число>)` - добавляет значение к текущему по указанной позиции в массиве и возвращает предыдущее значение в этой позиции;
- `Atomics.and(<typedArray>, <индекс>, <число>)` - вычисляет побитовое **AND** в указанной позиции массива и возвращает предыдущее значение в этой позиции;
- `Atomics.compareExchange(<typedArray>, <индекс>, <число>)` - сохраняет представленное значение в указанную позицию массива, если оно эквивалентно представленному значению и возвращает предыдущее значение;
- `Atomics.exchange(<typedArray>, <индекс>, <число>)` - сохраняет представленное значение в указанную позицию массива и возвращает предыдущее значение;
- `Atomics.load(<typedArray>, <индекс>)` - возвращает значение из указаной позиции массива.
- `Atomics.or(<typedArray>, <индекс>, <число>)` - вычисляет побитовое **OR** в указанной позиции массива и возвращает предыдущее значение в этой позиции;
- `Atomics.store(<typedArray>, <индекс>, <число>)` - сохраняет представленное значение в указанную позицию массива и возвращает значение;
- `Atomics.sub(<typedArray>, <индекс>, <число>)` - вычитает представленное значение из текущего по указанной позиции в массиве и возвращает предыдущее значение в этой позиции;
- `Atomics.xor(<typedArray>, <индекс>, <число>)` - вычисляет побитовое **XOR** в указанной позиции массива и возвращает предыдущее значение в этой позиции.

Методы **futexes** ("*fast user-space mutex*" — быстрый mutex пользовательского пространства):
- `Atomics.wait(<typedArray>, <индекс>, <число>[, <таймаут_в_мс>])` - переходит в режим ожидания (спит) [максимум на указаное количество `<таймаут_в_мс>` мс] до тех пор пока все еще содержится в массиве `<typedArray>` на указанной позиции `<индекс>` представленное значение `<число>`. Возвращает `ok`, `"not-equal"` или `"timed-out"`.
- `Atomics.notify(<typedArray>, <индекс>[, <количество>])` — пробуждает всех [указаное количество `<количество>`] агентов, которые спят в очереди ожидания в указанной позиции массива и возвращает количество агентов, которые были разбужены.
- `Atomics.wake(<typedArray>, <индекс>[, <количество>])` - аналогично `Atomics.notify`.

### `DataView` (ES6)

Представляет отображение сырого буфера в специфическом формате и используется для чтения или записи содержимого в буфер.

`let <dataView> = new DataView(<arrayBuffer>[, <отступ_байт>[, <размер_байт>]])` - создает отображение на основании сырого массива [с определенного отступа в байтах [и определенного размера]].

`<dataView>.buffer` - возвращает исходный буфер.  
`<dataView>.byteLength` - возвращает размер в байтах отображения.  
`<dataView>.byteOffset` - возвращает отступ в байтах.  
`<dataView>.<метод_доступа>(<позиция_байт>)` - возвращает значение в определенном формате метода на указанной позиции в отображении.

Методы доступа:
- `getInt8` - возвращает значение типа `Int8`;
- `getUint8` - возвращает значение типа `Uint8`;
- `getInt16` - возвращает значение типа `Int16`;
- `getUint16` - возвращает значение типа `Uint16`;
- `getInt32` - возвращает значение типа `Int32`;
- `getUint32` - возвращает значение типа `Uint32`;
- `getFloat32` - возвращает значение типа `Float32`;
- `getFloat64` - возвращает значение типа `Float64`.

`<dataView>.<метод_установки>(<позиция_байт>, <позиция_байт>[, true])` - устанавливает значение в определенном формате метода на указанной позиции в отображении [в байтовом порядке `littleEndian`].

Методы установки:
- `setInt8` - устанавливает значение типа `Int8`;
- `setUint8` - устанавливает значение типа `Uint8`;
- `setInt16` - устанавливает значение типа `Int16`;
- `setUint16` - устанавливает значение типа `Uint16`;
- `setInt32` - устанавливает значение типа `Int32`;
- `setUint32` - устанавливает значение типа `Uint32`;
- `setFloat32` - устанавливает значение типа `Float32`;
- `setFloat64` - устанавливает значение типа `Float64`.

### TypedArray (ES6)

Объект **TypedArray** (типизированный массив) это массивоподобное представление нижележащего буфера с бинарными данными (`ArrayBuffer`). Нет ни глобального свойства TypedArray, ни открытого конструктора TypedArray. Но существует ряд глобальных элементов, которые являются конструкторами типизированных массивов для конкретно заданных типов данных.

Создание:
- `let <typedArray> = new <TypedArray>(<длина>)` - создает массив с указанным количеством элементов, т.е. в памяти создаётся буфер длины `<длина> * BYTES_PER_ELEMENT` байт, содержащий нули;
- `let <typedArray> = new <TypedArray>(<typedArray>)` - создает массив на основании входного массива одинаковой длины, при этом каждое значение из входного конвертируется в соответствующий конструктору тип прямо перед копированием;
- `let <typedArray> = new <TypedArray>(<объект>)` - создает массив на основании объекта;
- `let <typedArray> = new <TypedArray>(<arrayBuffer>[, <отступ_байт>[, <размер_байт>]])` - создает массив на основании сырого массива [с определенного отступа в байтах [и определенного размера]].
- `let <typedArray> = new <TypedArray>(<sharedArrayBuffer>[, <отступ_байт>[, <размер_байт>]])` - создает массив на основании распределенного сырого массива [с определенного отступа в байтах [и определенного размера]].

Где `<TypedArray>` это одно из следующих значений:

Тип (TypedArray)    | Размер (байты) | Тип Web IDL         | Тип языка C | Описание
 ------------------ | -------------- | ------------------- | ----------- | --------
`Int8Array`         | 1              | byte                | int8_t      | 8-битное целое со знаком с дополнением до двух
`Uint8Array`        | 1              | octet               | uint8_t     | 8-битное беззнаковое целое
`Uint8ClampedArray` | 1              | octet               | uint8_t     | 8-битное беззнаковое целое (фиксированное от 0 до 255)
`Int16Array`        | 2              | short               | int16_t     | 16-битное целое со знаком с дополнением до двух
`Uint16Array`       | 2              | unsigned short      | uint16_t    | 16-битное беззнаковое целое
`Int32Array`        | 4              | long                | int32_t     | 32-битное целое со знаком с дополнением до двух
`Uint32Array`       | 4              | unsigned long       | uint32_t    | 32-битное беззнаковое целое
`Float32Array`      | 4              | unrestricted float  | float       | 32-битное число с плавающей точкой IEEE-стандарта
`Float64Array`      | 8              | unrestricted double | double      | 64-битное число с плавающей точкой IEEE-стандарта

Получить доступ к элементам массива можно используя стандартный синтаксис по индексу (например, `arr[12]`). Однако, получение и установка индексируемых свойств по цепи прототипов не будет происходить даже в случае, когда будет попытка использовать индексы извне массива.

`<typedArray>.BYTES_PER_ELEMENT` - возвращает размер элемента для разных типизированных массивов.  
`<typedArray>.length` - возвращает количество элементов.  
`<typedArray>.set(<массив>[, <начальный_индекс>])` - копирует данные из массива в текущий массив начиная с позиции 0 текущего массива [на указаную позицию в текущем массиве].  
`<typedArray>.subarray(<начальная_позиция>[, <конечная_позиция>])` - копирует данные из массива в новый массив начиная с указаной позиции массива [и до указаной позиции] который основывается на том же `ArrayBuffer` что и текущий.

## Дата и Время

Для работы с датой и временем в JavaScript используются объекты `Date`. Создание:
- `new Date()` - создает объект `Date` с текущей датой и временем;
- `new Date(<кол_мс>)` - создает объект `Date`, значение которого равно количеству миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0;
- `new Date('<дата_в_строке>')` - если единственный аргумент - строка, используется вызов `Date.parse` для чтения даты из неё;
- `new Date(<год_из_4_цифр>, <месяц_с_0>[, <день>, <час>, <мин>, <сек>, <мс>])` - если значения, большие логического диапазона (например, 13 в качестве номера месяца или 70 для значения минут) "переметнутся" на соседние значения (`new Date(2013, 13, 1)` равен `new Date(2014, 1, 1)`).

`<дата>.getFullYear()` - возвращает год (из 4 цифр).  
`<дата>.getMonth()` - возвращает месяц, от 0 до 11.  
`<дата>.getDate()` - возвращает число месяца, от 1 до 31.  
`<дата>.getHours()`, `<дата>.getMinutes()`, `<дата>.getSeconds()`, `<дата>.getMilliseconds()` - возвращает соответствующие компоненты.  
`<дата>.getDay()` - возвращает номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0 (воскресенье) до 6 (суббота).

Все эти методы, возвращают результат для местной временной зоны.

Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): `getUTCFullYear()`, `getUTCMonth()`, `getUTCDay()`. То есть, сразу после `get` вставляется `UTC`.

`<дата>.getTime()` - возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0.  
`<дата>.getTimezoneOffset()` - возвращает разницу между местным и UTC-временем, в минутах.

Следующие методы позволяют устанавливать компоненты даты и времени:
`<дата>.setFullYear(<год>[, <месяц>[, <день>]])`  
`<дата>.setMonth(<месяц>[, <день>])`  
`<дата>.setDate(<день>)`  
`<дата>.setHours(<час>[, <мин>[, <сек>[, <мс>]]])`  
`<дата>.setMinutes(<мин>[, <сек>[, <мс>]])`  
`<дата>.setSeconds(<сек>[, <мс>])`  
`<дата>.setMilliseconds(<мс>)`  
`<дата>.setTime(<кол_мс>)` - устанавливает всю дату по миллисекундам с 01.01.1970 UTC

Все методы, кроме `<дата>.setTime()`, обладают также UTC-вариантом, например: `<дата>.setUTCHours()`.

**Неправильные компоненты даты автоматически распределяются по остальным**.

**Даты можно вычитать**, результат вычитания объектов `Date` - их временная разница, в миллисекундах.

Оператор `+` для `Date` использует именно `toString`, а не `valueOf`.

`performance.now()` возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее - с момента выгрузки предыдущей страницы из памяти. Так что это время включает в себя всё, включая начальное обращение к серверу.

`<дата>.toLocaleString("<локаль>", <опции>)` - выводит дату где указано, какие параметры даты нужно вывести, и ряд настроек вывода, после чего интерпретатор сам сформирует строку.

`<дата>.toString()`, `<дата>.toDateString()`, `<дата>.toTimeString()` - возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему - читаемость человеком.

`<дата>.toString()` - возвращает строковое представление даты на американском английском, `<дата>.toDateString()` и `<дата>.toTimeString()` - только дату и время соответственно.  
`<дата>.toUTCString()` - то же самое, что `<дата>.toString()`, но дата в зоне UTC.  
`<дата>.toISOString()` - возвращает дату в формате ISO. Этот формат выглядит так: `YYYY-MM-DDTHH:mm:ss.sssZ`, где:
- `YYYY-MM-DD` - дата в формате год-месяц-день;
- обычный символ `T` используется как разделитель;
- `HH:mm:ss.sss` - время: часы-минуты-секунды-миллисекунды;
- часть `Z` обозначает временную зону - в формате `{+ | -}hh:mm`, либо символ `Z`, обозначающий UTC. По стандарту её можно не указывать, тогда UTC.  
Также возможны укороченные варианты, например `YYYY-MM-DD` или `YYYY-MM` или даже только `YYYY`.

`Date.parse('<дата_в_строке>')` - разбирает строку в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, возвращает `NaN`. Должна выглядеть в формате ISO.

`Date.now()` - возвращает дату сразу в виде миллисекунд.

## Тип данных `Symbol` (ES6)

Новый примитивный тип данных `Symbol` служит для создания уникальных идентификаторов. Синтаксис:  
`let <символ> = Symbol("<имя>");`

У символов есть и соответствующий `typeof`.

Каждый символ - уникален. У функции `Symbol` есть необязательный аргумент "имя символа". Символы с одинаковым именем не равны друг другу. Его можно использовать для описания символа, в целях отладки.

Существует "**глобальный реестр**" символов, который позволяет, при необходимости, иметь общие "глобальные" символы, которые можно получить из реестра по имени. Для чтения (или создания, при отсутствии) "глобального" символа служит вызов:  
`Symbol.for("<имя>")`

Таким образом, можно из разных частей программы, обратившись к реестру, получить единый глобальный символ с именем `"<имя>"`.

`Symbol.keyFor(<символ>)` - возвращает по глобальному символу его имя, работает только для глобальных символов, для остальных будет возвращено `undefined`.

Символы можно использовать в качестве имён для свойств объекта, при этом если в объект записать свойство-символ, то оно не участвует в итерации, к примеру в `for..in`. Кроме того, свойство-символ недоступно, если обратиться к его названию: `<переменная_класса>.<символ>` не существует, а доступно: `<переменная_класса>[<символ>]`.

В спецификации для краткости символы принято обозначать как `@@<имя>`, но доступны они как свойства `Symbol`.

Символы можно использовать для задания свойств, так как они:
- уникальны;
- не участвуют в циклах;
- заведомо не сломают старый код, который о них не знает.

`Object.getOwnPropertySymbols(<объект>)` - возвращает все символы объекта.

## `Map` (ES6)

`Map` - коллекция для хранения записей вида *ключ: значение*. В отличие от объектов, в которых ключами могут быть только строки, в `Map` ключом может быть произвольное значение.

`let <map> = new Map([<итерируемый_объект>]);` - создание [можно сразу инициализовать списком значений, должен быть итерируемый объект (не обязательно именно массив), например: `[[<ключ1>, <значение>][, [<ключ2>, <значение>][, ...]]]`. Везде утиная типизация, что позволяет сделать максимальную гибкость.]

Ключи и значения сохраняются "как есть", без преобразований типов.

В качестве ключей `Map` можно использовать и объекты. Для проверки значений на эквивалентность используется алгоритм **SameValueZero**. Он аналогичен строгому равенству `===`, отличие - в том, что `NaN` считается равным `NaN`. Поэтому значение `NaN` также может быть использовано в качестве ключа.

`<map>.set(<ключ>, <значение>)` - установка значения ключа, возвращает `<map>`.  
`<map>.get(<ключ>)` - получение значения по ключу, если ключа нет то `undefined`.  
`<map>.delete(<ключ>)` - удаляет запись с ключом, возвращает `true`, если такая запись была, иначе `false`.  
`<map>.clear()` - удаляет все записи, очищает коллекцию.  
`<map>.has(<ключ>)` - возвращает `true`, если ключ есть, иначе `false`.  
`<map>.keys()` - возвращает итерируемый объект для ключей.  
`<map>.values()` - возвращает итерируемый объект для значений.  
`<map>.entries()` - возвращает итерируемый объект для записей `[<ключ>, <значение>]`, он используется по умолчанию в `for..of`.  
`<map>.size` - свойство, которое хранит общее количество записей в `<map>`.

Перебор осуществляется в порядке вставки. Объекты `Map` гарантируют это, в отличие от обычных объектов `Object`.

`<map>.forEach(function (value, key, map) {...});` - вызовет функцию для каждого ключа в коллекции. Где:
- `value` - текущее перебираемое значение элемента коллекции;
- `key` - ключ текущего элемента коллекции;
- `map` - текущий объект `<map>`.

## `Set` (ES6)

`Set` - коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.

`let <set> = new Set([<итерируемый_объект>]);` - создание [можно сразу инициализовать списком значений, должен быть итерируемый объект (не обязательно именно массив).]

`<set>.add(<значение>)` - добавляет в коллекцию `<значение>`, возвращает `<set>`.  
`<set>.delete(<значение>)` - удаляет `<значение>` из коллекции, возвращает `true`, если он там был, иначе `false`.  
`<set>.has(<значение>)` - возвращает `true`, если `<значение>` есть в коллекции, иначе `false`.
`<set>.clear()` - очищает `<set>`.  
`<set>.size` - свойство, которое хранит общее количество записей в `<set>`.

Перебор `Set` осуществляется через `forEach` или `for..of` аналогично как `Map`.

`<set>.forEach(function (value, valueAgain, set) {...});` - вызовет функцию для каждого ключа в коллекции. Где:
- `value` - текущее перебираемое значение элемента множества;
- `valueAgain` - также текущее перебираемое значение элемента множества, для совместимости со всеми перебираемыми функциями;
- `set` - текущий объект `<set>`.

## `WeakMap`, `WeakSet` (ES6)

`WeakSet` - особый вид `Set` не препятствующий сборщику мусора удалять свои элементы. То же самое - `WeakMap` для `Map`. То есть, если некий объект присутствует только в `WeakSet`/`WeakMap` - он удаляется из памяти.

Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь можно хранить для них "вспомогательные" данные, существующие лишь пока жив объект.

Если поместить данные в `WeakMap`, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Таким образом, `WeakMap` избавляет нас от необходимости вручную удалять вспомогательные данные, когда удалён основной объект. У `WeakMap` есть ряд ограничений:
- нет свойства `size`;
- нельзя перебрать элементы итератором или `forEach`;
- нет метода `clear()`.

Иными словами, `WeakMap` работает только на запись (`set`, `delete`) и чтение (`get`, `has`) элементов по конкретному ключу, а не как полноценная коллекция. Нельзя вывести всё содержимое `WeakMap`, нет соответствующих методов. Это связано с тем, что содержимое `WeakMap` может быть модифицировано сборщиком мусора в любой момент, независимо от программиста.

То же самое относится и к `WeakSet`: можно добавлять элементы, проверять их наличие, но нельзя получить их список и даже узнать количество.

## Обещания `Promise` (ES6)

`Promise` ("*промисы*") - предоставляют удобный способ организации асинхронного кода. `Promise` - это специальный объект, который содержит своё состояние. Вначале **pending** ("*ожидание*"), затем - одно из: **fulfilled** ("*выполнено успешно*") или **rejected** ("*выполнено с ошибкой*").

На *promise* можно навешивать колбэки двух типов:
- **onFulfilled** - срабатывают, когда промис в состоянии "*выполнен успешно*";
- **onRejected** - срабатывают, когда промис в состоянии "*выполнен с ошибкой*".

Способ использования, в общих чертах, такой:
1. Код, которому надо сделать что-то асинхронно, создаёт объект `Promise` и возвращает его.
2. Внешний код, получив промис, навешивает на него обработчики.
3. По завершении процесса асинхронный код переводит промис в состояние **fulfilled** (с результатом) или **rejected** (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис создания `Promise`:  
`let <promise> = new Promise(function (resolve, reject) {...});`

Функция в конструкторе будет вызвана автоматически, в ней можно делать любые асинхронные операции, а когда они завершатся - нужно вызвать одну из функций: `resolve(<результат>)` при успешном выполнении или `reject(<ошибка>)` при ошибке, они принимают только по одному параметру, последующие игнорируются и не передаются дальнейшим обрабатывающим методам.

`<promise>.then(<onFulfilled>[, <onRejected>])` - универсальный метод для навешивания обработчиков, где `<onFulfilled>` - функция вида `function (resolve) {...}`, которая будет вызвана с результатом при вызове`resolve` [, а `<onRejected>` - функция вида `function (reject) {...}`, которая будет вызвана с ошибкой при `reject`.] Возвращает новый промис.  
`<promise>.then(null, <onRejected>)` - только для ошибки.  
`<promise>.catch(<onRejected>)` - тоже самое, только для ошибки.  
`<promise>.finally(function () {...})` - (ES2018) всегда выполняет указанную функцию, в не зависимости от вызова `then` или `catch`. Если в `then` в `<onFulfilled>` вернул значение, то это значение пробросится через `finally` и попадет в следующий `then` в `<onFulfilled>`, даже если `finally` вернул `Promise` который завершился успешно с другим значением, но если он завершится с ошибкой, то ошибка попадет в следующий `catch`, при этом игнорируя предыдущую ошибку, если она была.

Если в момент прикрепления обработчика к промис уже "выполнено успешно" или "выполнено с ошибкой", он все равно будет выполнен, т.е. между выполнением обещания и прикреплением обработчика нет "состояния гонки".

Если в функции промиса происходит синхронный `throw` (или иная ошибка), то вызывается `reject` с этой ошибкой: `reject(<ошибка>)`.  
Промис после вызова одной из функций `resolve`/`reject` - неизменен, то есть когда промис переходит в состояние "выполнен" - с результатом (`resolve`) или ошибкой (`reject`) - это навсегда.

**Промисификация** - это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис. После промисификации использование функционала зачастую становится гораздо удобнее.

Возможно использование цепочки промисов, то есть "*чейнинг*" (*chaining*). При чейнинге, то есть последовательных вызовах `.then...then...then`, в каждый следующий `then` переходит результат от предыдущего, который он вернул через `return`.

Если очередной `then` вернул промис через `return`, то далее по цепочке будет передан не сам этот промис, а его результат. Если `then` возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать. Если внутри `then` стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, необходимо вернуть промис.

То есть, логика довольно проста:
- каждый `then` получает текущий результат работы;
- можно его обработать синхронно и вернуть результат (при этом результат будет обернут в конструкцию `Promise.resolve(<результат>)`). Или же, если нужна асинхронная обработка - инициировать её и вернуть промис.

При возникновении ошибки `throw <ошибка>` (при этом результат будет обернут в конструкцию `Promise.reject(<ошибка>)`) - она отправляется в ближайший обработчик `<onRejected>`. Такой обработчик нужно поставить через второй аргумент `.then` или через `.catch`. Обработчик `.catch` получает ошибку и должен обработать её. Есть два варианта развития событий:
- если ошибка не критичная, то возвращает значение через `return`, и управление переходит в ближайший `.then`;
- если продолжить выполнение с такой ошибкой нельзя, то он делает `throw`, и тогда ошибка переходит в следующий ближайший `.catch`.

Если в `.then`, один из обработчиков не указан, то добавляется его "от себя", следующим образом:
- для успешного выполнения - функция `Identity`, которая выглядит как `arg => return arg`, то есть возвращает аргумент без изменений;
- для ошибки - функция `Thrower`, которая выглядит как `arg => throw arg`, то есть генерирует ошибку.

Для того, чтобы результат обработчика передать следующей функции, `.then` создаёт новый промис и возвращает его.

`Promise.all(<итерируемый_объект>)` - получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние "выполнено" с массивом их результатов в порядке следования объявления промисов. Если какой-то из промисов завершился с ошибкой, то результатом `Promise.all` будет эта ошибка. При этом остальные промисы игнорируются.

`Promise.race(<итерируемый_объект>)` - как и `Promise.all`, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис. Но, в отличие от `Promise.all`, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.

`Promise.resolve(<результат>)` - создаёт успешно выполнившийся промис с результатом. Он аналогичен конструкции: `new Promise((resolve) => resolve(<результат>))`, если `<результат>` это промис, то возвращает этот промис и ждет завершения его.
`Promise.resolve` используют, когда хотят построить асинхронную цепочку, и начальный результат.
Подходит для разрешения промиса или результата, когда результат выполнения функции не известен.

`Promise.reject(<ошибка>)` - создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой.

Для последовательной асинхронной обработки массива, может использоваться такая конструкция:
```javascript
<массив>.reduce((promise, item) => {
    return promise.then(res => {
        return new Promise(function (resolve, reject) {...});
    });
}, Promise.resolve());
```

## Генераторы (ES6)

**Генераторы** - новый вид функций. Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени. Генератор это как "*замороженный вызов функции*".

Для объявления генератора используется новая синтаксическая конструкция: `function*`. Её называют "**функция-генератор**" (*generator function*).

```javascript
function* <функция_генератор>([<параметр1>[, ...]]) {
    yield <возвращаемое_значение1>;
    [yield <возвращаемое_значение2>;
    [...]]
    return <возвращаемое_значение>;
}
```

При запуске `<функция_генератор>([<аргумент1>[, ...]])` код такой функции не выполняется. Вместо этого она возвращает специальный объект, который называется "**генератором**":  
`let <генератор> = <функция_генератор>([<аргумент1>[, ...]]);`

Основным методом генератора является `<генератор>.next()`. При вызове он возобновляет выполнение кода до ближайшего ключевого слова `yield`. По достижении `yield` выполнение приостанавливается, а значение - `{value: <возвращаемое_значение1>, done: false}` возвращается во внешний код.

Повторный вызов `<генератор>.next()` возобновит выполнение и вернёт результат следующего `yield`, а последний вызов завершит выполнение функции и вернёт результат `return` - `{value: <возвращаемое_значение>, done: true}`. Новые вызовы `<генератор>.next()` больше не имеют смысла, они будут возвращать один и тот же объект: `{done: true}`.

"**Открутить назад***" завершившийся генератор нельзя, для этого создается новый.

Генератор является итерируемым объектом. Его можно перебирать и через `for..of`, при этом стандартный перебор итератора игнорирует `value` на последнем значении, при `done: true`. Так что результат `return` в цикле `for..of` не выводится, поэтому надо возвращать все значения через `yield`.

### Композиция

Один генератор может включать в себя другие. Это называется композицией.

Специальная форма `yield*`: `yield* <функция_вложеного_генератора>([<аргумент1>[, ...]])` - она применима только к другому генератору и делегирует ему выполнение. То есть, при `yield*` интерпретатор переходит внутрь генератора-аргумента, выполняет его, и все `yield`, которые он делает, выходят из внешнего генератора. Получается - как будто вставили код внутреннего генератора во внешний напрямую.

**Композиция** - это естественное встраивание одного генератора в поток другого. При композиции значения из вложенного генератора выдаются "по мере готовности". Поэтому она будет работать даже если поток данных из вложенного генератора оказался бесконечным или ожидает какого-либо условия для завершения.

### Передача данных в генератор

`yield` - дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор.

`let <переменная> = yield <значение>;` - делает следующее:
- возвращает `<значение>` во внешний код, приостанавливая выполнение генератора;
- внешний код может обработать значение, и затем вызвать `next` с аргументом: `<генератор>.next(<аргумент>)`;
- генератор продолжит выполнение, аргумент `<аргумент>` `next` будет возвращён как результат `yield` (и записан в `<переменная>`).

Для того, чтобы передать в `yield` ошибку, используется вызов:  
`<генератор>.throw(<ошибка>)`

При этом на строке с `yield` возникает исключение. Ошибка обрабатывается как обычно.

### Плоский асинхронный код

Одна из основных областей применения генераторов - написание "плоского" асинхронного кода. Общий принцип такой:
- генератор `yield`'ит не просто значения, а промисы;
- есть специальная "функция-чернорабочий" `execute(<generator>)` которая запускает генератор, последовательными вызовами `next` получает из него промисы - один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим `next`;
- последнее значение генератора (`done:true`) `execute` уже обрабатывает как окончательный результат - например, возвращает через промис куда-то ещё, во внешний код.

```javascript
function execute(generator, yieldValue) {
    let next = generator.next(yieldValue);

    if (!next.done) {
        next.value.then(
            result => execute(generator, result),
            err => generator.throw(err)
        );
    } else {
        <код_окончания_обработки_генератора>
    }
}
execute(<generator>());
```

### Асинхронное выполнение с генераторами

```javascript
function asyncFlow(generatorFunction) {
    function callback(err, ...results) {
        if (err) {
            return generator.throw(err);
        }
        generator.next(results.length> 1 ? results : results[0]);
    }

    const generator = generatorFunction(callback);
    generator.next();
}
```

Указаная функция принимает генератор, создает его экземпляр и сразу же запускает. Эта функция позаботится о возобновлении генератора после завершения асинхронной операции. Позволяет писать асинхронный код, применив линейный подход, который обычно используется для блокирующих функций. Функция обратного вызова, переданная в каждую асинхронную функцию, будет возобновлять работу генератора сразу после завершения асинхронной операции.

Генератор должен быть вида:
```javascript
function* (callback) {
    const <результат> = yield <асинхронная_функция>(<параметр>, callback);
    [...]
}
```

Для каждой асинхронной функции должен передаваться `callback` для обратного вызова, где в результат `<результат>` - запишется результат `callback`. В случае ошибки будет выброшено исключение.

Все последующие асинхронные функции нужно оформлять в виде представленой.

### Async / await (ES2017)

Цель функций `async` / `await` упросить использование промисов синхронно и воспроизвести некторое действие над группой Promises. Точно так же как Promises подобны структурированным callback-ам, `async` / `await` подобна комбинации генераторов и промисов.

`async function <функция>([<параметр1>[, ...]]) {...}` - определяет асинхронную функцию. Возвращает промис `Promise` в который будет обернута функция. Когда результат был получен через `return`, `Promise` завершается, возвращая полученное значение. Когда функция `async` выбрасывает исключение, `Promise` ответит отказом с выброшенным (`throws`) значением.

Функция `async` может содержать выражение внутри своего тела `await <promise>`, которое приостанавливает выполнение функции `async` и ожидает ответа от переданного `Promise`, затем возобновляя выполнение функции `async` и возвращая полученное значение в случае успешного разрешения промиса или выбрасывает исключение в случае не успешного. Все `await` происходят линейно в порядке следования.

## `Proxy` (ES6)

**Прокси** (proxy) - особый объект, смысл которого - перехватывать обращения к другому объекту и, при необходимости, модифицировать их. Синтаксис:  
`let <прокси> = new Proxy(<объект>, <объект_с_ловушками>)` - где:
- `<объект>` - объект, обращения к которому надо перехватывать;
- `<объект_с_ловушками>` - объект с "ловушками": функциями-перехватчиками для операций к `<объект>`.

Почти любая операция может быть перехвачена и обработана прокси до или даже вместо доступа к объекту `<объект>`, например: чтение и запись свойств, получение списка свойств, вызов функции (если `<объект>` - функция) и т.п.

Если для операции нет ловушки, то она выполняется напрямую над `<объект>`'ом.

### Ловушки

Объявляются в объекте: `{}` как свойства-методы.

Виды ловушек:
`get(target, property, receiver) {...}` - срабатывает при чтении свойства из прокси. Может возвращать значение свойства. Аргументы:
- `target` - целевой объект, тот же который был передан первым аргументом в `new Proxy`;
- `property` - имя свойства;
- `receiver` - объект, к которому было применено присваивание. Обычно сам прокси, либо прототипно наследующий от него. Этот аргумент используется редко.

`set(target, property, value, receiver) {...}` - срабатывает при записи свойства в прокси. Дополнительные аргументы:
- `value` - значение свойства.

Метод `set` должен вернуть `true`, если присвоение успешно обработано и `false` в случае ошибки (приведёт к генерации `TypeError`).

При каждой операции чтения и записи свойств прокси срабатывают методы `get`/`set`. Через них значение в конечном счёте попадает в объект (или считывается из него), если это необходимо.

`has(target, property, receiver) {...} `- срабатывает в операторе `in` и некоторых других случаях, когда проверяется наличие свойства. Возвращает `true`, если есть свойство.

`deleteProperty(target, property, receiver) {...}` - срабатывает при операции `delete`, должен вернуть `true`, если удаление было успешным.

`enumerate(target) {...}` - перехватывает операции `for..in` и `for..of` по объекту и может вернуть итератор для перебора свойств.

`apply(target, thisArgument, argumentsList) {...}` - срабатывает когда вызывается функция. Работает только с функциями. Получает:
- `thisArgument` - контекст `this` вызова;
- `argumentsList` - аргументы вызова в виде массива.

Она может обработать вызов сама и/или передать его функции через `target.apply(thisArgument, argumentsList)`.

`construct(target, argumentsList) `- перехватывает вызовы при помощи `new`.

Остальные ловушки:
- `getPrototypeOf` - перехватывает обращение к методу `getPrototypeOf`;
- `setPrototypeOf` - перехватывает обращение к методу `setPrototypeOf`;
- `isExtensible` - перехватывает обращение к методу `isExtensible`;
- `preventExtensions` - перехватывает обращение к методу `preventExtensions`;
- `getOwnPropertyDescriptor` - перехватывает обращение к методу `getOwnPropertyDescriptor`;
- `defineProperty` - перехватывает обращение к методу `defineProperty`;
- `ownKeys` - перехватывает обращения к методу `getOwnPropertyNames`.

Каждый перехватчик запускается с `<объект_с_ловушками>` в качестве `this`. Это означает, что `<объект_с_ловушками>` кроме ловушек может содержать и другие полезные свойства и методы. Каждый перехватчик получает в аргументах `target` и дополнительные параметры в зависимости от типа. Если перехватчик в `<объект_с_ловушками>` не указан, то операция совершается, как если бы была вызвана прямо на `target`.

### Отменяемый `Proxy`

`let <revocable> = Proxy.revocable(<объект>, <объект_с_ловушками>)` - все аналогично как и в `new Proxy`, только возвращает объект `<revocable>`, который содержит свойства `proxy` - сам прокси и `revoke` - функция выключения прокси, и после этого любой proxy-перехватчик событий объекта будет вызывать исключение `TypeError`.

## `Reflect` (ES6)

Используется для работы с объектами.

`Reflect.apply(<функция>, <объект_вызова>, <массив_аргументов>);` - вызывает функцию с указанным контекстом в виде объекта вызова и указанными аргументами.

`Reflect.construct(<функция_конструктор>, <массив_аргументов>[, <функция_прототип>]);` - вызывает конструктор без использования оператора `new` с указанными аргументами [и указаным прототипом] и возвращает созданный объект.

## Итераторы, цикл `for..of` (ES6)

Итерируемые или, иными словами, "перебираемые" объекты - это те, содержимое которых можно перебрать в цикле. Перебираемым объектом является массив, строка. Для перебора таких объектов добавлен новый синтаксис цикла `for..of`:
```javascript
for (let <переменная> of <объект>) {
    <код_тела_итерации_цикла>
}
```

Где в `<переменная>` заносятся все итерируемые значения объекта (элементы массива, буквы строки).

Везде, где нужен перебор, он осуществляется через итераторы. Это включает в себя не только строки, массивы, но и вызов функции с оператором `spread` `f(...args)`, и многое другое. В отличие от массивов, "перебираемые" объекты могут не иметь "длины" `length`. Итераторы дают возможность сделать "перебираемыми" любые объекты.

Для возможности использовать объект в `for..of` нужно создать в нём свойство с названием `Symbol.iterator` (системный символ). При вызове метода `Symbol.iterator` перебираемый объект должен возвращать другой объект ("итератор"), который умеет осуществлять перебор.

Здесь имеет место разделение сущностей:
- перебираемый объект сам не реализует методы для своего перебора;
- для этого создаётся другой объект, который хранит текущее состояние перебора и возвращает значение. Этот объект называется **итератором** и возвращается при вызове метода `<объект>[Symbol.iterator]`;
- у итератора (объекта `{...}`) должен быть метод `next()`, который при каждом вызове возвращает объект со свойствами:
    - `value` - очередное значение;
    - `done` - равно `false` если есть ещё значения, и `true` - в конце.

Конструкция `for..of` в начале своего выполнения автоматически вызывает `Symbol.iterator()`, получает итератор и далее вызывает метод `next()` до получения `done: true`. Такова внутренняя механика. Внешний код при переборе через `for..of` видит только значения.

Такое отделение функционала перебора от самого объекта даёт дополнительную гибкость. Например, объект может возвращать разные итераторы в зависимости от своего состояния.

Если функционал по перебору (метод `next`) предоставляется самим объектом, то можно вернуть `this` в качестве итератора. При таком подходе сам объект и хранит состояние итерации (текущий перебираемый элемент).

Для большей гибкости и понятности кода рекомендуется выделять итератор в отдельный объект со своим состоянием и кодом.

```javascript
{
    [Symbol.iterator]() {
        return {
            next() {
                return {
                    done: <завершен>, //false - если есть ещё значения, иначе true
                    value: <значение>
                }
            }
        }
    }
}
```

Встроенные в JavaScript итераторы можно получить и явным образом, без `for..of`, прямым вызовом `Symbol.iterator`:  
`let <итератор>= <объект>[Symbol.iterator]();`

## Замыкания, область видимости

### Глобальный объект

**Глобальными** называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции `function`, то они - "**глобальные**". В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется "**глобальный объект**" (global object). В браузере этот объект явно доступен под именем `window`.

### Лексическое окружение

Все переменные внутри функции - это свойства специального внутреннего объекта **LexicalEnvironment**, который создаётся при её запуске, это объект "**лексическое окружение**" или просто "**объект переменных**". При запуске функция создает объект **LexicalEnvironment**, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения. В отличие от `window`, объект **LexicalEnvironment** является внутренним, он скрыт от прямого доступа.

Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем **LexicalEnvironment**, а затем, если её нет - ищет во внешнем объекте переменных.

Такой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется `[[Scope]]`. Это свойство закрыто от прямого доступа. При создании функция получает скрытое свойство `[[Scope]]`, которое ссылается на лексическое окружение, в котором она была создана. Это свойство никогда не меняется. Оно всюду следует за функцией, привязывая её, таким образом, к месту своего рождения.

Переменную во внешней области видимости можно не только читать, но и изменять.

**Замыкание** - это функция вместе со всеми внешними переменными, которые ей доступны. По сути, замыкание - это способность функции во время создания запоминать ссылки на переменные, находящиеся в текущей области видимости.

Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней. Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это - использование функции "*как функции*". А свойство у функции - доступно отовсюду и всегда. Это - использование функции "*как объекта*". Если хочется привязать значение к функции, то можно им воспользоваться вместо внешних переменных. Принципиальная разница - во внутренней механике и в том, что свойство функции, в отличие от переменной из замыкания - общедоступно, к нему имеет доступ любой, у кого есть объект функции. Свойства, привязанные к функции, называют "статическими переменными".

При создании функции с использованием `new Function`, её свойство `[[Scope]]` ссылается не на текущий **LexicalEnvironment**, а на `window`.

### Модули через замыкания

Его цель - скрыть внутренние детали реализации скрипта. В том числе: временные переменные, константы, вспомогательные мини-функции и т.п. для этого нужно, чтобы у скрипта была своя собственная область видимости, чтобы его переменные не попали на страницу. Для этого оборачивают всё его содержимое в функцию, которую тут же запускают:
```javascript
(function () {
    <код_модуля>
})();
```

Внутри этой внешней функции: происходит что угодно, объявляются свои локальные переменные, функции, а в `window` выносится то, что нужно снаружи.

Можно оформить модуль и чуть по-другому, например передать значение через `return`.

### Устаревшая конструкция `with`

Конструкция `with(<объект>) {...}` использует `<объект>` как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в `<объект>`. Конструкция `with` устарела и не рекомендуется по ряду причин, её необходимо избегать.

## Методы объектов и контекст вызова

### Методы объектов, `this`

**Свойства-функции** называют "**методами**" объектов. Их можно добавлять и удалять в любой момент, в том числе и явным присваиванием.

Для полноценной работы метод должен иметь доступ к данным объекта. Для доступа к текущему объекту из метода используется ключевое слово `this`. Значением `this` является объект перед "точкой" `.`, в контексте которого вызван метод: `this.<свойство_метод>`.

При вызове `this` в методе объекта, оно ссылается на сам объект.

Через `this` метод может не только обратиться к любому свойству объекта, но и передать куда-то ссылку на сам объект целиком.

Любая функция может иметь в себе `this`. Совершенно неважно, объявлена ли она в объекте или отдельно от него. Значение `this` называется контекстом вызова и **будет определено в момент вызова функции**. Это выяснится при выполнении программы. Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный `this`, значение `this` не зависит от того, как функция была создана, оно определяется исключительно в момент вызова.

Контекст `this` никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы `this` передался, нужно вызвать функцию именно через точку `.` (или квадратные скобки `[]`).

Любой объект в логическом контексте - `true`, даже если это пустой массив `[]` или объект `{}`.

Если в объекте присутствует метод `toString`, который возвращает примитив, то он используется для строкового преобразования.

Для численного преобразования объекта используется метод `valueOf`, а если его нет - то `toString`. Метод `valueOf` обязан возвращать примитивное значение, иначе его результат будет проигнорирован. При этом - не обязательно числовое.

Если создаётся объект при помощи синтаксиса `{...}`, то задать свойства-функции можно прямо в его определении. Для этого используется особый синтаксис: `get <свойство>()` или `set <свойство>(newValue)`.

#### Методы объекта (ES6) `[[HomeObject]]`

Являются свойствами-функциями, привязанными к объекту. Их особенности:
- более короткий синтаксис объявления;
- наличие в методах специального внутреннего свойства `[[HomeObject]]` ("**домашний объект**"), ссылающегося на объект, которому метод принадлежит.

Для объявления метода вместо записи `<свойство>: function (<параметр1>[, ...]) {...}` нужно написать просто `<свойство>(<параметр1>[, ...]) {...}`.

Также методами станут объявления геттеров `get <свойство>()` и сеттеров `set <свойство>(newValue)`.

Можно задать и метод с вычисляемым названием.

Вызов `super.<родительское_свойство>` позволяет из метода объекта получить свойство его прототипа. При обращении через `super` используется `[[HomeObject]]` текущего метода, и от него берётся `__proto__`. Поэтому `super` работает только внутри методов.

Свойство `[[HomeObject]]` - не изменяемое. При создании метода - он привязан к своему объекту навсегда. Технически можно скопировать его и запустить отдельно, и `super` продолжит работать.

### Создание объектов через `new`

Конструктором становится любая функция, вызванная через `new`.

Функция, запущенная через `new`, делает следующее:
1. Создаётся новый пустой объект `{}`;
2. Ключевое слово `this` получает ссылку на этот объект;
3. Функция выполняется. Как правило, она модифицирует `this`, добавляет методы, свойства;
4. Возвращается `this`.

`new <FunctionConstructor>([<арг1>[, ...]])` - создание объекта через функцию конструктор.  
`new <FunctionConstructor>` - аналогично предыдущему варианту, с пустым конструктором.

Иногда функцию-конструктор объявляют и тут же используют:  
`new function () {...}`

Так делают, когда хотят создать единственный объект данного типа, когда обычный синтаксис `{...}` не подходит, когда при создании свойств объекта нужны более сложные вычисления. Их можно проделать в функции-конструкторе и записать результат в `this`.

Если явный вызов `return` всё же есть, то применяется простое правило: при вызове `return` с объектом, будет возвращён он, а не `this`, а при вызове `return` с примитивным значением, оно будет отброшено.

(ES6) Внутри функции свойство `new.target` - ссылается на функцию или конструктор, с помощью которой был создан объект.

### Дескриптор

`Object.defineProperty(<объект>, "<свойство_объекта>", <дескриптор>)` - позволяет объявить свойство для объекта `<объект>` и настроить его особые аспекты, которые никак иначе не изменить, возвращает переданный `<объект>`. Где `<дескриптор>` - это дескриптор, в виде объекта, который описывает поведение свойства. В нём могут быть следующие поля:
- `value` - значение свойства, по умолчанию `undefined`;
- `writable` - значение свойства можно менять, если `true`. По умолчанию `false`;
- `configurable` - если `true`, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов `defineProperty`. По умолчанию `false`;
- `enumerable` - если `true`, то свойство просматривается в цикле `for..in` и методе `Object.keys()`. По умолчанию `false`;
- `get` - функция, которая возвращает значение свойства. По умолчанию `undefined`;
- `set` - функция, которая записывает значение свойства. По умолчанию `undefined`.

Чтобы избежать конфликта, запрещено одновременно указывать значение `value` и функции `get`/`set`. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать `writable` при наличии `get`/`set`-функций.

`Object.defineProperties(<объект>, {<свойство1>: <дескриптор>[, ...]})` - позволяет объявить несколько свойств сразу, возвращает переданный `<объект>`.  
`Object.getOwnPropertyNames(<объект>)` - возвращает массив - список всех свойств объекта.  
`Object.getOwnPropertyDescriptor(<объект>, "<свойство_объекта>")` - возвращает дескриптор для свойства `<объект>["<свойство_объекта>"]`. Полученный дескриптор можно изменить и использовать `Object.defineProperty` для сохранения изменений.  
`Object.preventExtensions(<объект>)` - запрещает добавление свойств в объект.  
`Object.seal(<объект>)` - запрещает добавление и удаление свойств, все текущие свойства делает configurable: `false`, возвращает переданный `<объект>`.
`Object.freeze(<объект>)` - запрещает добавление, удаление и изменение свойств, все текущие свойства делает `configurable`: `false`, `writable`: `false`, возвращает переданный `<объект>`.  
`Object.isExtensible(<объект>)`, `Object.isSealed(<объект>)`, `Object.isFrozen(<объект>)` - возвращают `true`, если на объекте были вызваны методы `Object.preventExtensions`/`seal`/`freeze`.

`Object.keys(<объект>)` - возвращает массив - список свойств объекта, только `enumerable`-свойства.

`Object.assign(<целевой_объект>, <объект1>[, ...])` - (ES6) получает список объектов и копирует в первый `<целевой_объект>` свойства из остальных. При этом последующие свойства перезаписывают предыдущие.  
`Object.is(<значение1>, <значение2>)` - (ES6) возвращает `true`, если значения `<значение1>` и `<значение2>` равны, иначе `false`.

`Object.values(<объект>)` - (ES2017) возвращает массив - список значений свойств объекта, только `enumerable`-свойства.  
`Object.entries(<объект>)` - (ES2017) возвращает массив - список из массивов свойство-ключ объекта в виде `[<свойство>, <значение>]`, только `enumerable`-свойства.  
`Object.fromEntries(<итерируемый_объект>)` - (ES2018) создает и возвращает объект, инициализированный списком значений, должен быть итерируемый объект (не обязательно именно массив), например: `[[<ключ1>, <значение>][, [<ключ2>, <значение>][, ...]]]`.

### Статические и фабричные методы

Методы и свойства, которые не привязаны к конкретному экземпляру объекта, называют "статическими". Их записывают прямо в саму функцию-конструктор.

`<Функция>.<метод_свойство> = <значение>`

Статический метод также можно использовать для функций, которые вообще не требуют наличия объекта.
"**Фабричный статический метод**" - удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется "фабричным"). Преимущества использования фабричных методов:
- лучшая читаемость кода;
- лучший контроль ошибок;
- удобная расширяемость.

### Вызовы функций

`<функция>.call(<this_контекст>[, <аргумент_функции1>[, ...]])` - вызывается функция, при этом первый аргумент `call` `<this_контекст>` становится её `this`, а остальные передаются "как есть" для функции.  
При помощи `call` можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого. Это называется "**одалживание метода**" (на англ. method *borrowing*).

`<функция>.apply(<this_контекст>[, <массив_аргументов_функции>])` - работает аналогично `<функция>.call`, но принимает массив аргументов вместо списка.

`<функция>.bind(<this_контекст>[, <аргумент_функции1>[, ...]])` - вернет функцию-обёртку, которая фиксирует контекст и передает вызовы в `<функция>`, при этом если указаны аргументы - они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове.

`<функция>.name` - содержит имя функции, (ES6) а при создании анонимной функции с одновременной записью в переменную или свойство - её имя равно названию переменной (или свойства).  
`<функция>.length` - содержит количество аргументов, ожидаемых функцией.  
`<функция>.caller` - возвращает функцию, которая вызвала указанную функцию, будет равно `null` если функция была вызвана из кода самого верхнего уровня.

**Карринг** (*currying*) или **каррирование** - термин функционального программирования, который означает создание новой функции путём фиксирования аргументов существующей. Тогда новая функция является "**частичной функцией**" (*partial function*) от указаной.

**Декоратор** - приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение. Декоратор получает функцию и возвращает обертку, которая делает что-то своё "вокруг" вызова основной функции.

"**Форвардинг вызова**" (от англ. *forwarding*): текущий контекст и аргументы через `apply` передаются в указанную функцию, так что изнутри указанная функция всё выглядит так, как была вызвана она напрямую, а не декоратор.

Декораторы можно не только повторно использовать, но и комбинировать.

## Некоторые другие возможности, `instanceof`

Во всех встроенных объектах есть специальное свойство `[[Class]]`, в котором хранится информация о его типе или конструкторе, это свойство - внутреннее. Явно получить его нельзя, но можно прочитать его "в обход", воспользовавшись методом `toString` стандартного объекта `Object`. Для получения `[[Class]]` нужна именно внутренняя реализация `toString` стандартного объекта `Object`, другая не подойдёт.  
`{}.toString.call(<объект>)` - возвращает `"[object <тип_объекта>]"`.

Свойство `[[Class]]` есть и доступно для чтения указанным способом - у всех встроенных объектов. Но его нет у объектов, которые создают функции, точнее, оно есть, но равно всегда `"Object"`.

Оператор `instanceof` позволяет проверить, создан ли объект данной функцией, причём работает для любых функций - как встроенных, так и собственных.

`<объект> instanceof <Функция>` - возвращает `true` только если `<объект>` создан указанной функцией `<Функция>`, сравнивает конструкторы двух операндов.

### Формат JSON

Данные в формате JSON (RFC 4627) представляют собой:
- JavaScript-объекты `{...}`;
- массивы `[...]`;
- значения одного из типов:
    - строки в двойных кавычках;
    - число;
    - логическое значение `true`/`false`;
    - `null`.

`JSON.parse(<строка>[, function (key, value) {...}])` - превратит строку с данными в формате JSON в JavaScript-объект/массив/значение и возвратит его [, при этом в процессе чтения объекта из строки `JSON.parse` передаёт функции по очереди все создаваемые пары ключ-значение и может возвратить либо преобразованное значение, либо `undefined`, если его нужно пропустить].

`JSON.stringify(<значение>[, <массив_серриализуемых_свойств> | function (key, value) {...} | null [, <кол_пробелов_вложености>]])` - преобразует ("сериализует") значение в JSON-строку и возвращает ее [при этом указывается массив свойств, которые подлежат сериализации или функция, которая возвращает сериализованное `value` либо `undefined`, если его не нужно включать в результат (*функция вызывается рекурсивно для всех объектов и элементов массива, при этом у корневого элемента ключ равен`''`*) [, при этом уровни вложенности в JSON оформляются указанным количеством пробелов, если строкой - вставляется эта строка]].

При сериализации объекта вызывается его метод `toJSON`. Если такого метода нет - перечисляются его свойства, кроме функций.

### Внутренние таймеры-планировщики

`var <timerId> = setTimeout(<функция>, <задержка_мс>[, <аргумент_для_функции1>[, ...]])` - исполнение `<функция>` произойдёт спустя время, указанное в `<задержка_мс>`, возвращает числовой идентификатор таймера `<timerId>`, который можно использовать для отмены действия.

`clearTimeout(<timerId>)` - отменяет исполнение таймера.

`var <timer> = setInterval(<функция>, <задержка_мс>[, <аргумент_для_функции1>[, ...]])` - исполнение `<функция>` произойдёт спустя время, указанное в `<задержка_мс>`, а затем будет повторятся через каждые `<задержка_мс>`, возвращает числовой идентификатор таймера `<timerId>`, который можно использовать для отмены действия.

`clearInterval(<timerId>)` - отменяет исполнение интервала.

Важная альтернатива `setInterval` - рекурсивный `setTimeout`. Рекурсивный `setTimeout` гарантирует паузу между вызовами, `setInterval` - нет. Если функция и выполняется дольше, чем пауза `setInterval`, то вызовы будут происходить вообще без перерыва.

По стандарту, минимальная задержка составляет **4мс**, на частоту **4мс** стоит ориентироваться, но не стоит рассчитывать.

### Eval

`eval('<код>')` - позволяет выполнить код, переданный ей в виде строки, этот код будет выполнен в текущей области видимости, возвращает последнее вычисленное выражение. При вызове `eval` имеет полный доступ к локальным переменным.

### Base64

Используется там где необходимо кодировать двоичные данные для удобства включения в URL, скрытые поля форм.

`btoa('<строка>');` - возвращает строку в виде Base64, в которой закодирована указанная строка.  
`atob('<строка_в_формате_Base64>');` - возвращает строку, в которой указанная строка в виде Base64 раскодирована.

### Кодирование URI

Все символы для кодирования, кроме английских букв, цифр и `; , / ? : @ & = + $ - _ . ! ~ * ' ( ) #` заменяются на их цифровой код в `UTF-8` со знаком `%`.

`encodeURI('<строка>')` - возвращает указанную строку в виде URI кодировке.  
`decodeURI('<uri_строка>')` - возвращает раскодированную указанную строку в URI кодировке.

### Кодировка `urlencoded`

Все символы для кодировки `urlencoded`, кроме английских букв, цифр и `- _ . ! ~ * ' ( )` заменяются на их цифровой код в `UTF-8` со знаком `%`.

`encodeURIComponent('<строка>')` - возвращает указанную строку в виде `urlencoded` кодировке.  
`decodeURIComponent('<uri_строка>')` - возвращает раскодированную указанную строку в `urlencoded` кодировке.

## Перехват ошибок. `Error`

```javascript
try {
    <код>
} catch (err) {
    <код_для_обработки_ошибки>
}[ finally {
    <код_для_выполнения_всегда>
}]
```

Работает так:
1. Выполняется код внутри блока `try`;
2. Если в нём ошибок нет, то блок `catch(err)` игнорируется, то есть выполнение доходит до конца `try` и потом прыгает через `catch`.
3. Если в нём возникнет ошибка, то выполнение `try` на ней прерывается, и управление прыгает в начало блока `catch(err)`.
4. [Выполняется всегда секция `finally`.]

Таким образом, при ошибке в `try` скрипт не "падает", а получает возможность обработать ошибку внутри `catch`.  
`try..catch` подразумевает, что код синтаксически верен.  
`try..catch` работает только в синхронном коде.

### Объект ошибки

У него есть три основных свойства:
- `name` - тип ошибки;
- `message` - текстовое сообщение о деталях ошибки;
- `stack` - содержит строку с информацией о последовательности вызовов, которая привела к ошибке.

`throw <объект_ошибки>` - генерирует ошибку. В качестве конструктора ошибок можно использовать встроенный конструктор:
- `new Error('<сообщение>')` - для общей ошибки;
- `new RangeError('<сообщение>')` - для ошибки, возникающей, когда значение не входит в множество или выходит за диапазон допустимых значений;
- `new TypeError('<сообщение>')` - для ошибки, возникающей при недопустимом типе для переменной или параметра;
- `new ReferenceError('<сообщение>')` - для ошибки, возникающую при разыменовывании недопустимой ссылки;
и т.п.

Ошибку, о которой `catch` не знает, он не должен обрабатывать. Такая техника называется "**проброс исключения**": в `catch(err)` анализируется объект ошибки, и если он не подходит для обработки, то она пробрасывается с помощью `throw err` внутри блока `catch`.

Важнейший общий подход к проектированию - каждый участок функционала должен получать информацию на том уровне, который ему необходим. Этот подход называют "**оборачиванием**" исключения, поскольку берется ошибка "**более низкого уровня**" и "**заворачивается**" их в новую ошибку, которая соответствует текущей задаче.

Секцию `finally` используют, чтобы завершить начатые операции при любом варианте развития событий. Блок `finally` срабатывает при любом выходе из `try..catch`, в том числе и `return`. Возможно использование `try..finally` вообще без `catch`.

## ООП в функциональном стиле

### Классы

Классом в *объектно-ориентированной* разработке называют шаблон/программный код, предназначенный для создания объектов и методов.

Один из важнейших принципов ООП - отделение внутреннего интерфейса от внешнего.

**Внутренний интерфейс** - это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют "**приватными**". Внутренний интерфейс используется для обеспечения работоспособности объекта, его детали используют друг друга.

**Внешний интерфейс** - это свойства и методы, доступные снаружи объекта, их называют "**публичными**".

Локальные переменные, включая параметры конструктора, можно считать приватными свойствами. Свойства, записанные в `this`, можно считать публичными. Тоже самое относится а методам.

Сохранение `this` в замыкании - состоит в том, чтобы предварительно скопировать `this` во вспомогательную переменную например `self` и обращаться из внутренних функций уже к ней, чтобы это работало, не нужно изменять `self`, а все приватные методы, которым нужно иметь доступ к текущему объекту, должны использовать внутри себя `self` вместо `this`.

В терминологии ООП отделение и защита внутреннего интерфейса называется **инкапсуляция**.

### "Геттеры" и "сеттеры"

Для управляемого доступа к состоянию объекта используют специальные функции, так называемые "геттеры" и "сеттеры". Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод, который называют "**сеттер**" (*setter method*). А для того, чтобы дать возможность внешнему коду узнать его значение, создадим специальную функцию - "**геттер**" (*getter method*).

Для большего удобства иногда делают единый метод, который называется так же, как свойство и отвечает и за запись и за чтение. При вызове без параметров такой метод возвращает свойство, а при передаче параметра - назначает его.

### Наследование

**Наследование** - это создание новых "классов" на основе существующих.

Наследование реализовано вызовом `<Предок_Родитель>.call(this)` в начале конструктора `<Наследник>` или через `<Предок_Родитель>.apply(this)`. Наследник не имеет доступа к приватным свойствам родителя, чтобы наследник имел доступ к свойству, оно должно быть записано в `this`.

Подчёркивание в начале свойства `_` - общепринятый знак, что свойство является внутренним, предназначенным лишь для доступа из самого объекта и его наследников. Такие свойства называют защищёнными.

Общая схема переопределения метода:
1. Копируется доставшийся от родителя метод в переменную `<переменная_с_методом_родителя>`;
2. Заменяется `this.<метод_родителя>` на свою функцию;
3. Метод родителя по-прежнему реализует старый функционал и его можно использовать через вызов `<переменная_с_методом_родителя>.call(this)` или `apply`, или через `<переменная_с_методом_родителя>()` если метод не использует `this`.

## ООП в прототипном стиле

Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом.

### Специальное свойство `__proto__`

Если один объект имеет специальную ссылку `__proto__` на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте `__proto__`.

Объект, на который указывает ссылка `__proto__`, называется "**прототипом**". Тогда говорят что указанный объект "**прототипно наследует**" объект.

Прототип используется исключительно при чтении.

**Прототип** - если другими словами, это "**резервное хранилище свойств и методов**" объекта, автоматически используемое при поиске. У объекта, который является `__proto__`, может быть свой `__proto__`, у того - свой, и так далее. При этом свойства будут искаться по цепочке.

`<объект>.hasOwnProperty('<свойство>')` - возвращает `true`, если свойство принадлежит самому объекту, иначе `false`. Это единственная существующая в JavaScript возможность работать со свойствами, не затрагивая цепочку прототипов.  

`Object.create(null)` - возвращает объект, который не имеет прототипа, а значит в нём нет лишних свойств, удобен для коллекции.  
`Object.getPrototypeOf(<объект>)` - возвращает `<объект>.__proto__`.  
`Object.setPrototypeOf(<объект>, <прототип>)` - устанавливает `<объект>.__proto__ = <прототип>`.  
`Object.create(<прототип>[, <дескрипторы_свойств>])` - создаёт и возвращает пустой объект с `__proto__`, равным первому аргументу `<прототип>`, второй необязательный аргумент может содержать дескрипторы свойств. Если передать в качестве `<прототип>` произвольный объект, то он станет прототипом созданого объекта.

Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство `prototype`. При создании объекта через `new`, в его прототип `__proto__` записывается ссылка из `prototype` функции-конструктора. Свойство `prototype` имеет смысл только у конструктора. Значением `prototype` может быть только объект.

Свойство `prototype.constructor` содержит ссылку на конструктор объекта. JavaScript никак не использует свойство `constructor`, оно создаётся автоматически и указывает на функцию, которая приведет к созданию объекта.

Объект `Object.prototype` - вершина иерархии, единственный, у которого `__proto__` равно `null`. Поэтому говорят, что "**все объекты наследуют от Object**", а если более точно, то от `Object.prototype`.

### "Псевдокласс"

"**Псевдоклассом**" или, более коротко, "**классом**", называют функцию-конструктор вместе с её `prototype`. Такой способ объявления классов называют "**прототипным стилем ООП**".

Примитивы не являются объектами, но методы берут из соответствующих прототипов: `Number.prototype`, `Boolean.prototype`, `String.prototype`.

По стандарту, если обратиться к свойству числа, строки или логического значения, то будет создан объект соответствующего типа, например `new String` для строки, `new Number` для чисел, `new Boolean` - для логических выражений.

Значения `null` и `undefined` не имеют свойств.

Чтобы объявить свой класс на прототипах, нужно:
1. Объявить функцию-конструктор.
2. Записать методы и свойства, нужные всем объектам класса, в `prototype`.

Локальные переменные внутри методов доступны также через `this`.

**Достоинства** - функциональный стиль записывает в каждый объект и свойства и методы, а прототипный - только свойства. Поэтому прототипный стиль - быстрее и экономнее по памяти.

**Недостатки** - при создании методов через прототип, теряется возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором.

### Наследование

`<Наследник>.prototype = Object.create(<Родитель>.prototype)` - наследование через прототипы, наследник также должен быть объявлен как функция-конструктор.

Конструктор реализуется `<Предок_Родитель>.call(this[, <аргумент>[, ...]])` в начале конструктора `<Наследник>` или через `<Предок_Родитель>.apply(this[, arguments])`.

Методы переопределяются на уровне прототипов `<Наследник>.prototype.<метод>`.

Метод родителя по-прежнему реализует старый функционал и его можно использовать через вызов:
`<Предок_Родитель>.prototype.<метод_родителя>.call(this[, arguments])` или `apply`.

```javascript
function Auto(name) {
    this.name = name;
    this.countOfWheels = 10;
}
Auto.prototype.getName = function () {
    return this.name;
};
Auto.prototype.wheels = function () {
    return this.countOfWheels;
};

function Car() {
    Auto.call(this, 'Car');
    this.countOfWheels = 4;
}
Car.prototype = Object.create(Auto.prototype);
Car.prototype.getName = function () {
    return 'Super ' + Auto.prototype.getName.call(this);
};
```

Базовая реализация, но у этого подхода **важный недостаток** он создает родителя, а не только унаследует его методы:  
`<Наследник>.prototype = new <Родитель>();`  
`<Наследник>.prototype = <объект>;`

## Классы (ES6)

Реализует удобное ООП. В целом это обвертка над "ООП в прототипном стиле". Синтаксис для классов выглядит так:
```javascript
class <Класс>[extends <Родитель>] {
    <публичное_поле1>[ = <значение>]; // создание поля с публичным модификатором доступа, т.е. есть возможность изменять эту переменную вне методов класса
    /* ... */
    #<приватное_поле1>[ = <значение>]; // создание поля с приватным модификатором доступа, т.е. нет возможности изменять эту переменную вне методов класса
    /* ... */
    [constructor(...) {...}]
    <методы>
    /* ... */
}
```

Функция `constructor` запускается при создании `new <Класс>`, остальные методы записываются в `<Класс>.prototype`. В конструкторе объявляются поля класса (переменные) как `this.<поле>`, как и в функции.

Но при объявлении через `class` есть и ряд отличий:
- класс нельзя вызывать без `new`, будет ошибка;
- объявление класса с точки зрения области видимости ведёт себя как `let`. В частности, оно видно только в текущем блоке и только в коде, который находится ниже объявления (Function Declaration видно и до объявления).

Методы, объявленные внутри `class`, также имеют ряд особенностей:
- методы является именно методами, то есть имеет доступ к `super`;
- все методы класса работают в строгом режиме `use strict`, даже если он не указан;
- все методы класса не перечислимы. То есть в цикле `for..in` по объекту их не будет.

Метод может быть:
- простой функцией: `<метод>(...) {...}`;
- генератором: `* <метод>(...) {...}`;
- асинхронной функцией: `async <метод>(...) {...}`;
- функцией с вычисляемым именем: `['<имя>'](...) {...}` или  `[<символ>](...) {...}`.

Также, как и **Function Expression**, классы можно задавать "инлайн", в любом выражении и внутри вызова функции - это называется **Class Expression**. Имя такому классу можно дать, тогда оно, как и в **Named Function Expression**, будет доступно только внутри класса. Наиболее очевидная область применения этой возможности - создание вспомогательного класса прямо при вызове функции.

В классах, как и в обычных объектах, можно объявлять геттеры и сеттеры через `get`/`set`, а также использовать [...] для свойств с вычисляемыми именами.

`class` не позволяет задавать свойства-значения в описании класса, если это необходимо то можно воспользоваться после объявления класса:  
`<Класс>.prototype.<свойство> = <значение>;`

Если свойство-значение, всё же, необходимо, то можно создать геттер, который будет нужное значение возвращать.

Все свойства и методы класса технически доступны снаружи.

При этом `<Родитель>` может быть одним из стандартных типов: `Array`, `RegExp`, `Function`, `Promise`, `Boolean`, `Number`, `String`, `Error`, `Map`, `Set`.

### Приватные свойства

Реализуются с помощью замыкания на определенной `WeakMap` и записи в нее приватных свойств, тогда они будут доступны только внутри этого класса.

```javascript
const pr = new WeakMap(); // хранилище всех приватных свойств
class <Class> {
    constructor() {
        pr.set(this, {
            <key>: <value>[,
            ...]
        });
    }
    <method>() {
        pr.get(this).<key>;
    }
}
```

### Статические свойства

Класс, как и функция, является объектом. Статические свойства класса - это свойства непосредственно, то есть доступные из него "через точку".

Для их объявления используется ключевое слово `static` перед методами. Чтобы вызвать статический метод в другом статическом методе того же класса, можно использовать ключевое слово `this`. Вызов статических методов внутри методов класса:
- `<Класс>.<статический_метод>()`;
- `this.constructor.<статический_метод>()`.

Внутри статических методов `this` ссылается на класс `<Class>`.

Внутри переопределенных статических методов можно вызывать статические методы родителя с помощью конструкции: `super.<статический_метод>()`.

### Наследование

При наследовании через `extends` формируется стандартная цепочка прототипов: методы `<Наследник>` находятся в `<Наследник>.prototype`, методы `<Родитель>` - в `<Родитель>.prototype`, и они связаны через `__proto__`. И в `<Наследник>` доступны (через `super`) методы родителя.

Конструктор `constructor` родителя наследуется автоматически. То есть, если в потомке не указан свой `constructor`, то используется родительский. Если же у потомка свой `constructor`, то, чтобы в нём вызвать конструктор родителя - используется синтаксис `super()` с аргументами для родителя. Для такого вызова есть небольшие ограничения:
- вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, `super()` нельзя вызвать из произвольного метода;
- в конструкторе потомка обязано вызвать `super()` до обращения к `this`. До вызова `super()` не существует `this`, так как по спецификации в этом случае именно `super()` инициализирует `this`.

> `constructor(...) {super(...); ...}`

## Примесь

**Примесь** (англ. *mixin*) - класс или объект, реализующий какое-либо чётко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования.

Самый простой вариант примеси - это объект с полезными методами, которые просто копируется в нужный прототип.

Для добавления примеси в класс - её просто "подмешивают" в прототип:
```javascript
for (var key in <примесь>) {
  <объект>.prototype[key] = <примесь>[key];
}
```

"*Подмешать*" можно сколько угодно примесей, но если имена методов в разных примесях совпадают, то возможны конфликты.

## Модули (ES6)

Модули предоставляют удобные средства для разбития кода по функциональным блокам в разных файлах. Модулем считается файл с кодом.

В этом файле ключевым словом `export` помечаются переменные и функции, которые могут быть использованы снаружи.

Ключевое слово `export` можно ставить:
- перед объявлением переменных, функций и классов: `export <экспорт>`;
- отдельно, при этом в фигурных скобках указывается, что именно экспортируется: `export {<экспорт1>[ as <экспортируемое_имя>][, ...]}`.

Для экспорта обязательно нужно имя.

Когда один модуль экспортирует одно значение, предусмотрено особое ключевое сочетание `export default`. Если поставить после `export` слово `default`, то значение станет "экспортом по умолчанию". Такое значение можно импортировать без фигурных скобок.

Другие модули могут подключать экспортированные значения при помощи ключевого слова `import`:  
`import [<имя_экспорта_по_умолчанию>, ]{* as <импортируемое_имя> | {<импорт1>[ as <импортируемое_имя>][, ...]}} from "<путь_к_модулю>";`
> `import React, {Component} from 'react';`

`import("<путь_к_модулю>.js");` - динамический импорт, возвращает промис, который разрешиться когда загрузится модуль.

Регулярные выражения
====================

**Регулярные выражения** - мощное средство поиска и замены в строке. Регулярное выражение (оно же "регэксп", "регулярка" или просто "рег"), состоит из **паттерна** (он же "*шаблон*") и **необязательных флагов**. В JavaScript регулярные выражения реализованы отдельным объектом `RegExp` и интегрированы в методы строк.

## RegExp

Синтаксис создания регулярного выражения:  
`var <рег_выражение> = new RegExp("<шаблон>", "<флаги>");`  
`var <рег_выражение> = /<шаблон>/[g][m][i][s][y][u];`

Регулярные выражения могут иметь флаги, которые влияют на поиск, их всего три:
- `i` - если этот флаг есть, то регулярное выражение ищет независимо от регистра, то есть не различает между верхним и нижним регистром;
- `g` - если этот флаг есть, то регулярное выражение ищет все совпадения, иначе - только первое;
- `m` - если этот флаг есть, то включается многострочный режим;
- `s` - (ES2018) если этот флаг есть, то `.` обозначает все символы включая и переносы строк;
- `y` - (ES6) если этот флаг есть, то регулярное выражение сопоставляется с целевой строкой начиная с позиции, на которую указывает его свойство `lastIndex` (и не пытается сопоставиться по любому более старшему индексу). Такое поведение позволяет эффективно использовать символ `^` сопоставления-с-началом в любом месте строки путём смены значения свойства `lastIndex`;
- `u` - (ES6) если этот флаг есть, то любые escape-последовательности кода Unicode будут интерпретироваться как таковые `\u{NNNNNNNN}`.

## Методы String

`<строка>.search(<рег_выражение>)` - возвращает индекс, на котором найдено совпадение или `-1`, если ничего не найдено; он всегда ищет только первое совпадение.

`<строка>.match(<рег_выражение>)` - без флага `g` - находит только одно, первое совпадение, и возвращает массив, состоящий из этого совпадения по индексу `0`, с дополнительными свойствами `index` - позиция, на которой оно обнаружено и `input` - строка, в которой был поиск. Если часть шаблона обозначена скобками `()`, то она станет отдельным элементом массива. В случае, если совпадений не было, `match` возвращает `null`.

`<строка>.match(<рег_выражение>)` - с флагом `g` - возвращает обычный массив из всех совпадений. Никаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают. В случае, если совпадений не было, `match` возвращает `null`.

`<строка>.split({<рег_выражение> | <подстрока>}[, <макс_количество>])` - разбивает строку в массив по разделителю - регулярному выражению или подстроке и возвращает его.

`<строка>.replace(<рег_выражение>, {<строка_замены> | <функция_замены>})` - производит поиск и замену любого уровня сложности. При вызове со строкой замены `replace` всегда заменяет только первое совпадение, а чтобы заменить все совпадения, нужно использовать для поиска не строку, а регулярное выражение обязательно с флагом `g`. В строке для замены можно использовать специальные символы:
- `$$` - вставляет знак `$`;
- `$&` - вставляет всё найденное совпадение;
- `` $` `` - вставляет часть строки до совпадения;
- `$'` - вставляет часть строки после совпадения;
- `$<n>` - вставляет содержимое скобочной группы, где `<n>` - цифра или двузначное число, обозначает `n`-ю по счёту скобку, если считать слева-направо начиная с 1-го.

`<функция_замены>` - будет вызвана для каждого совпадения, и её результат будет вставлен как замена. Имеет вид:
```javascript
function (str[, p1[, p2[, ...]]], offset, s) {
    ...
    return <результат_замены>
}
```

Эта функция получает следующие аргументы:
- `str` - найденное совпадение;
- [`p1`, `p2`, ..., `pn` - содержимое скобок (если есть)];
- `offset` - позиция, на которой найдено совпадение;
- `s` - исходная строка.

Если скобок в регулярном выражении нет, то у функции всегда будет ровно 3 аргумента.

Функция - это самый мощный инструмент для замены, какой только может быть. Она владеет всей информацией о совпадении и имеет доступ к замыканию, поэтому может всё.

## Методы RegExp

`<рег_выражение>.test(<строка>)` - проверяет, есть ли хоть одно совпадение в строке. Возвращает `true`/`false`.  
`<рег_выражение>.exec(<строка>)` - позволяет искать и все совпадения и скобочные группы в них. Найденные результаты находятся там в том же формате, что и `match` - с учётом скобок, со свойствами `index` и `input`. Он ведёт себя по-разному, в зависимости от того, есть ли у регулярного выражения флаг `g`:
- если флага `g` нет, то ищет и возвращает первое совпадение, является полным аналогом вызова `<строка>.match(<рег_выражение>)`;
- если флаг `g` есть, то вызов возвращает первое совпадение и запоминает его позицию в свойстве `<рег_выражение>.lastIndex`. Последующий поиск он начнёт уже с этой позиции. Если совпадений не найдено, то сбрасывает `<рег_выражение>.lastIndex` в ноль. Можно заставить искать сразу с нужной позиции, если поставить `lastIndex` вручную.

## Свойства RegExp

Свойства доступны для чтения.

`<рег_выражение>.lastIndex` - индекс, с которого начнётся следующая попытка сопоставления. Если отсутствует флаг `g`, остаётся равным нулю. Является также записываемым.  
`<рег_выражение>.ignoreCase` - равен `true`, если в регулярном выражении используется флаг игнорирования регистра `i`, иначе `false`.  
`<рег_выражение>.global` - равен `true`, если в регулярном выражении используется флаг глобального сопоставления `g`, иначе `false`.  
`<рег_выражение>.multiline` - равен `true`, если в регулярном выражении используется флаг сопоставления по нескольким строкам `m`, иначе `false`.  
`<рег_выражение>.source` - содержит текст шаблона регулярного выражения.

## Классы и спецсимволы

**Класс символов** - это специальное обозначение, под которое подходит любой символ из определённого набора. Виды:
- `\d` (от английского "digit" - "цифра") - цифра, символ от 0 до 9;
- `\s` (от английского "space" - "пробел") - пробельный символ, включая табы, переводы строки и т.п;
- `\w` (от английского "word" - "слово") - символ "слова", а точнее - буква латинского алфавита или цифра или подчёркивание `_`. Не-английские буквы не являются `\w`, то есть русская буква не подходит;
- `\b` - это граница слова, особый класс - обозначает не символ, а границу между символами. Граница имеет "нулевую ширину" в том смысле, что обычно символам регулярного выражения соответствуют символы строки, но не в этом случае. Граница - это проверка;
- `\D` - не-цифра, то есть любой символ кроме `\d`;
- `\S` - не-пробел, то есть любой символ кроме `\s`;
- `\W` - любой символ, кроме `\w`, то есть не латиница, не подчёркивание, не цифра. В частности, русские буквы принадлежат этому классу;
- `\B` - проверка, обратная `\b`;
- `[\b]` - сопоставляется с символом забоя;
- `\0` - сопоставляется с нулевым символом;
- `\cX` - сопоставляется с управляющим символом в строке. Где `X` является буквой от `"A"` до `"Z"`. Сопоставляется с символом `control-X` в строке;
- точка `.` - обозначает любой символ, кроме перевода строки.

Чтобы использовать специальный символ `[` `\` `^` `$` `.` `|` `?` `*` `+` `(` `)` в качестве обычного, он должен быть экранирован, перед символом должен быть обратный слэш `\`. Сам символ слэш `/`, хотя и не является специальными символом в регулярных выражениях, но открывает-закрывает регулярное выражение в синтаксисе `/<шаблон>/`, поэтому его тоже нужно экранировать. Если нам нужно найти сам обратный слэш `\`, то его нужно просто задублировать.

## Наборы и диапазоны

`[[^]<символ1>[<символ2>[...]]]` - это набор, который означает один любой символ из указанных[ при `^` не указанных]. Квадратные скобки могут также содержать диапазоны символов:  
`[<символ_начала>-<символ_конца>[...]]`

> `[0129]`  
> `[^09]`  
> `[A-Z0-9]`

**Символьные классы** - всего лишь более короткие записи для диапазонов, в частности:
- `\d` - то же самое, что `[0-9]`;
- `\w` - то же самое, что `[a-zA-Z0-9_]`;
- `\s` - то же самое, что `[\t\n\v\f\r ]` плюс несколько юникодных пробельных символов.

В квадратных скобках можно использовать и диапазоны и символьные классы - вместе.

Квадратные скобки, начинающиеся со знака каретки `^`: `[^...]` находят любой символ, кроме указанных.

В квадратных скобках большинство специальных символов можно использовать без экранирования, если конечно они не имеют какой-то особый смысл именно внутри квадратных скобок. Без экранирования можно использовать символы: точка `.`; плюс `+`; круглые скобки `(` `)`; дефис `-`, если он находится в начале или конце квадратных скобок, то есть не выделяет диапазон; символ каретки `^`, если не находится в начале квадратных скобок; открывающая квадратная скобка `[`.

## Квантификаторы `+`, `*`, `?` и `{n}`

Количество повторений символа можно указать с помощью числа в фигурных скобках: `{<количество>}`, после символа. Такое указание называют **квантификатором** (от англ. quantifier). Виды:
- точное количество: `{<количество>}`;
- количество от-до: `{<количество_от>, [<количество_до>]}`.

Короткие обозначения:
- `+` - означает "один или более", то же что `{1,}`;
- `?` - означает "ноль или один", то же что и `{0,1}`. По сути, делает символ необязательным;
- `*` - означает "ноль или более", то же что `{0,}`. То есть, символ может повторяться много раз или вообще отсутствовать.

### Жадные и ленивые квантификаторы

В **жадном режиме** (по умолчанию) регулярное выражение повторяет квантификатор настолько много раз, насколько это возможно, чтобы найти соответствие.

**Ленивый режим** работы квантификаторов - противоположность жадному, он означает "*повторять минимальное количество раз*". Его можно включить, если поставить знак вопроса `?` после квантификатора, так что он станет таким: `*?` или `+?` или даже `??` для `?`. Чтобы не возникло путаницы - важно понимать: обычно `?` сам является квантификатором (ноль или один). Но если он стоит после другого квантификатора (или даже после себя), то обретает другой смысл - в этом случае он меняет режим его работы на ленивый. Ленивость распространяется только на тот квантификатор, после которого стоит `?`. Прочие квантификаторы остаются жадными. Ленивый режим без необходимости лишний раз квантификатор не повторит.

## Скобочные группы

Часть шаблона может быть заключена в скобки `(...)`. Такие выделенные части шаблона называют "**скобочными выражениями**" или "**скобочными группами**". У такого выделения есть два эффекта:
1. Он позволяет выделить часть совпадения в отдельный элемент массива при поиске через `String#match` или `RegExp#exec`;
2. Если поставить квантификатор после скобки, то он примениться ко всей скобке, а не всего лишь к одному символу.

Скобки нумеруются слева направо. Поисковой движок запоминает содержимое каждой скобки и позволяет обращаться к нему - в шаблоне и строке замены и в результатах.

Скобки могут быть и вложенными. В этом случае нумерация также идёт слева направо. На первом месте - всегда совпадение полностью, далее - группы. Нумерация всегда идёт слева направо, по открывающей скобке.

Даже если скобочная группа необязательна и не входит в совпадение, соответствующий элемент массива существует (и равен `undefined`).

### Именованые скобочные группы (ES2018)

Позоляет записывать значения скобочных групп в именованные переменные в объект результата, при этом они также будут писаться в массив в порядке следования в объявлении.

`(?<<имя>>...)` - запишет значение скобочной группы в `<результат>.groups[<имя>]`.

> `let result = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/.exec('2016-03-11');`

### Исключение из запоминания через `?:`

Если скобки нужны, чтобы квантификатор правильно применился, а запоминать её в массиве не нужно, то скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало `?:` - `(?:...)`.

### Обратные ссылки

Ссылки в строке замены имеют вид `$<n>`, где `<n>` - это номер скобочной группы. Вместо `$<n>` подставляется содержимое соответствующей скобки.

Ссылки в шаблоне регулярного выражения имеют вид `\<n>`, где `<n>` - это номер скобочной группы. Вместо `\<n>` подставляется содержимое соответствующей скобки.

Скобочные группы вида `(?:...)` не участвуют в нумерации.

## Альтернация (или) `|`

**Альтернация** - термин в регулярных выражениях, которому в русском языке соответствует слово "ИЛИ". Она обозначается символом вертикальной черты `|` и позволяет выбирать между вариантами. Для указания границ альтернации используют скобки `(...)`.

> `(red|blue|green)`

## Начало строки `^` и конец `$`

Знак каретки `^` и доллара `$` имеют в регулярном выражении особый смысл. Они называются "**якорями**" (anchor - англ.). Каретка `^` совпадает в начале текста, а доллар `$` - в конце, и ставятся вначале или в конце регулярного выражения соответственно. Якоря являются не символами, а проверками.

Оба якоря используют одновременно, если требуется, чтобы шаблон охватывал текст с начала и до конца. Обычно это требуется при валидации.

В многострочном режиме с флагом `m`, якоря сопоставляются в началом / концом каждой строки в многострочной строке, а не с началом / концом всей многострочной строки.

## Упреждение

`<символ>(?=<упреждение>)` - соответствует символу только если за ним следует набор символов упреждения, где может быть любая конструкция регулярных выражений. Это называется упреждение. Упреждение не являются частью результата сопоставления.

`<символ>(?!<упреждение>)` - соответствует символу только если за ним не следует набор символов упреждения, где может быть любая конструкция регулярных выражений. Это называется отрицательное упреждение. Упреждение не являются частью результата сопоставления.

Документирование API (JSDoc)
============================

## Основы

Документирование располагается сразу перед тем участком кода, который нужно задокументировать, и пишется в таком формате:
```javascript
/**
 * <описание>
 * @<тег> <значение>
 * ...
 */
```

## Основные теги

`@deprecated <описание>` - обозначение того что метод является устаревшим.  
`@description <описание>` - содержит описание.  
`@namespace <объект>` - глобальная ссылка на объект (имя переменной, которая на него указывает), если код относится к объекту или часть его.  
`@class <имя>` - имя, используемое для обозначения объекта или функции-конструктора или класса.  
`@augments <имя>` - имя, используемое для обозначения наследования от другого класса.  
`@extends <имя>` - аналогично.  
`@constructor` - указывает, что это в действительности является функцией-конструктором.  
`@method <имя>` - объявляет метод объекта и определяет его имя.  
`@override` - объявляет, что метод переопределяет метод родителя.  
`@param {<тип>} <имя_аргумента> <описание>` - перечисляет аргументы, принимаемые функцией. Может повторяться.  
`@returns {<тип>} <описание>` - описывает значение, возвращаемое методом, где <тип> может указывать на переменную.  
`@return {<тип>} <описание>` - аналогично.  
`@property {<тип>} <имя>` - имя свойства объекта. Может повторяться.  
`@type {<тип>}` - тип свойства объекта или свойства класса.  
`@typedef <имя>` - обозначает описание типа с указанным именем.  
`@callback <имя>` - описывает сигнатуру функции обратного вызова.  
`@throws {<тип>} <описание>` - описывает исключения которые может выбрасывать функция. Может повторяться.  
`@generator` - описывает что функция возвращает генератор.  
`@yield {<тип>}` - описывает тип возвращаемого значения генератора.

## Тип

Тип должен указывать все возможные типы, которые возможно принять.

Стандартные типы:
- `*` - любой тип;
- примитивные типы: `number`, `boolean`, `string`, `null`, `undefined`;
- массив:
    - `<тип>[]` - где `<тип>` означает тип элемента массива;
    - `Array.<<тип>>` - где `<тип>` означает тип элемента массива:
        > `Array.<number>`
- объект:
    - `object` - просто объект;
    - `{}` - просто объект;
    - `Object.<<тип_ключа>, <тип_значения>>` - специальная коллекция, где `<тип_ключа>` - тип всех ключей, `<тип_значения>` - тип всех значений:
        > `Object.<number, boolean>`
    - `{<имя_ключа1>: <тип_значения_ключа>[, <имя_ключа2>: <тип_значения_ключа>[, ...]]}` - объект с определенным строением;
        > `{stream: fs.WriteStream, chunks: string[], count: number}`  
        > `Object.<date: Date, price: number>`  
        > `Object.<string, {stream: fs.WriteStream, chunks: string[], count: number}>`
- конструктор:
    - `typeof <тип>`
        > `typeof Entry`
- промис:
    - `Promise.<<тип_разрешаемого_значения>>` - где `<тип_разрешаемого_значения>` означает тип, которым разрешиться промис.

Модификаторы типа:
- множественное значение типов: `<тип1>|...` или `(<тип1>|...)`;
- возможно принимать `null`: `?<тип>`;
- не возможно принимать `null`: `!<тип>`;
- опциональный параметр: `<тип>=`;
- оставшиеся параметры (для функции): `...<тип>`.

`{<тип>} [<имя_аргумента>] <описание>` - опциональное значение.

`{<тип>} [<имя_аргумента>=<значение_по_умолчанию>] <описание>` - значение по умолчанию.

## Описание структуры объекта типа

```javascript
/**
 * @param {object} <имя_аргумента> <описание>
 * @param {<тип>} <имя_аргумента>.<имя_свойства> <описание>
 * ...
 */
```

Если это массив объектов, то тогда описание свойств выглядит как:  
`@param {<тип>} <имя_аргумента>[].<имя_свойства> <описание>`

## Описание произвольного типа

```javascript
/**
 * @typedef <имя>
 * @type {<базовый_тип>}
 * @property {<тип>} <имя_свойства> <описание>
 * ...
 */
```

```javascript
/**
 * @typedef {<базовый_тип>} <имя>
 * @property {<тип>} <имя_свойства> <описание>
 * ...
 */
```

## Описание колбэка

```javascript
/**
 * @callback <имя_колбэка>
 * @param {<тип>} <имя_аргумента> <описание>
 * ...
 */
```

## Описание функции как параметра функции

`@param {function ([<тип_входящего_параметра>[, ...]])[:<тип_возвращаемого_значения>]} <имя_аргумента> <описание>`

> `@param {function (Event):boolean=} opt_allowDragStart`

> `@param {function (T, ...boolean)} type`

Тестирование
============

## Автоматические тесты при помощи chai и mocha

**Автоматизированное тестирование** - это когда тесты написаны отдельно от кода, и можно в любой момент запустить их и проверить все важные случаи использования.

**Тесты BDD** (*Behavior Driven Development*) - это три в одном: И тесты И документация И примеры использования одновременно.

**Спецификация** это то, что функция будет делать и можно это описать это по методике BDD:
```javascript
describe("<имя_тестируемой_сущности>", function () {
    it("<что_делает_функция>", function () {
        assert.equal(<тестируемая_функция>(...), <ожидаемый_результат>);
    });
});
```

У спецификации есть три основных строительных блока:
- `describe("<имя_тестируемой_сущности>", function () {...})` - задаёт, что именно описывается, используется для группировки "рабочих лошадок" - блоков `it`;
- `it("<что_делает_функция>", function () {...})` - в названии блока `it` человеческим языком описывается, что должна делать функция (с маленькой буквы), далее следует тест, который проверяет это;
- `assert.equal(<значение1>, <значение2>)` - код внутри `it`, если реализация верна, должен выполняться без ошибок.

```javascript
// <конкретная_сущность> должна ожидаемое действие / поведение [когда / при / если {<сценарий> | <контекст>}]
describe("<конкретная_сущность>", function () {
    [describe("когда / при / если {<сценарий> | <контекст>}", function () {]
        it("дожнен / должна {<ожидаемое_действие> | <поведение>} при / в случае / если {<название_сценария> | <краткое_описание_условия>}", function () {
            assert.equal(<тестируемая_функция>(...), <ожидаемый_результат>);
        });
    [});]
});
```

Различные функции вида `assert.*` используются, чтобы проверить, делает ли `<тестируемая_функция>` то, что задумано.

### Поток разработки

Как правило, поток разработки таков:
1. Пишется спецификация, которая описывает самый базовый функционал;
2. Делается начальная реализация;
3. Для проверки соответствия спецификации задействуется одновременно фреймворк (Mocha) вместе со спецификацией и реализацией. Фреймворк запускает все тесты `it` и выводит ошибки, если они возникнут. При ошибках вносятся исправления;
4. Спецификация расширяется, в неё добавляются возможности, которые пока, возможно, не поддерживаются реализацией;
5. Перходим на пункт 2, делаем реализацию, и так далее, до завершения спецификации и реализации.

Разработка ведётся итеративно, один проход за другим, пока спецификация и реализация не будут завершены.

Для запуска тестов нужны соответствующие JavaScript-библиотеки:
- **Mocha** - эта библиотека содержит общие функции для тестирования, включая `describe` и `it`;
- **Chai** - библиотека поддерживает разнообразные функции для проверок;
- **Sinon** - для эмуляции и хитрой подмены функций "заглушками".

**Один тест тестирует ровно одну вещь.**

В `describe` можно вкладывать `describe`, который объявит новую "подгруппу" тестов, блоки `it` которой запускаются так же, как и обычно, но выводятся с подзаголовком.

В каждом блоке `describe` можно также задать функции:
- `before(function ([done]) {...})` - выполнится до запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `after(function ([done]) {...})` - выполнится после запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `beforeEach(function ([done]) {...})` - выполнится до каждого `it` [где `done` - необходимо вызвать по завершению асинхронной работы];
- `afterEach(function ([done]) {...})` - выполнится после каждого `it` [где `done` - необходимо вызвать по завершению асинхронной работы].

### Дополнительные методы тестирования

- `.skip`:
    - после `it` позволяет пропустить тест;
    - после `describe` позволяет пропустить группу тестов, лучше использовать вместо комментирования самих тестов;
    > `it.skip("<что_делает_функция>", function () {...})`
- `.only`:
    - после `it` позволяет выполнить только этот тест;
    - после `describe` позволяет выполнить только эту группу тестов, и все другие с модификатором `.only`;
    > `describe.only("<имя_тестируемой_сущности>", function () {...})`

### Виды `chai.assert`

- `assert(<значение>[, '<сообщение>'])` - проверяет что `<значение>` является `true` в логическом контексте;
- `assert.equal(<значение1>, <значение2>[, '<сообщение>'])` - проверяет равенство `<значение1> == <значение2>`;
- `assert.strictEqual(<значение1>, <значение2>[, '<сообщение>'])` - проверяет строгое равенство `<значение1> === <значение2>`;
- `assert.notEqual(<значение1>, <значение2>[, '<сообщение>'])`, `assert.notStrictEqual(<значение1>, <значение2>[, '<сообщение>'])` - проверки, обратные двум предыдущим;
- `assert.deepEqual(<объект1>, <объект2>[, '<сообщение>'])` - производит глубокую проверку что один объект равен другому объекту по его свойствам;
- `assert.isTrue(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === true`;
- `assert.isFalse(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === false`;
- `assert.isOk(<значение>[, '<сообщение>'])` - проверяет, что `<значение>` есть;
- `assert.isNotOk(<значение>[, '<сообщение>'])` - проверяет, что `<значение>` нет;
- `assert.isNull(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === null`;
- `assert.isUndefined(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === undefined`;
- `assert.exists(<значение>[, '<сообщение>'])` - проверяет, что `<значение> !== null && <значение> !== undefined`;
- `assert.typeOf(<значение>, '<тип>'[, '<сообщение>'])` - проверяет что `<значение>` является указаным типом;
- `assert.instanceOf(<значение>, <функция_конструктор>[, '<сообщение>'])` - проверяет что `<значение>` является экземпляром `<функция_конструктор>`;

Все вызовы `assert` позволяют дополнительным последним аргументом указать строку с описанием ошибки, которое выводится, если `assert` не проходит.

Эту спецификацию можно использовать как:
- тесты, которые гарантируют правильность работы кода;
- документацию по функции, что она конкретно делает;
- примеры использования функции, которые демонстрируют её работу внутри `it`.

### Виды `chai.expect`

Используется для BDD (*Behavior-driven development*, *разработка через поведение*).  
Пишутся в стиле английского языка, через описание поведения.

`expect(<значение>)` - инициализация:
- `.to` - начало конструкции (чейнится):
    - `.be` - существование (есть) (чейнится):
        - `.true` - проверяет что значение `<значение> === true`;
        - `.false` - проверяет что значение `<значение> === false`;
        - `.null` - проверяет что значение `<значение> === null`;
        - `.an('<тип>'[, '<сообщение>'])` - проверяет что значение `<значение>` является указаным типом;
        - `.a('<тип>'[, '<сообщение>'])` - аналогично предыдущему;
        - `.instanceof('<функция_конструктор>'[, '<сообщение>'])` - проверяет что `<значение>` является экземпляром `<функция_конструктор>`;
    - `.exist` - значение `<значение>` существует;
    - `.not` - модификатор - отрицает последующие проверочные конструкции (чейнится):
        > `expect([1, 2, 3]).to.not.be.empty;`
    - `.deep` - модификатор - добавляет глубокие проверки для объектов по их свойствам (чейнится), для проверок `.equal`, `.include`, `.members`, `.keys`, `.property`;
    - `.nested` - модификатор - добавляет проверку по пути свойств для имен свойств (чейнится), для проверок `.include`, `.property`:
        > `expect(obj).to.have.nested.property('query.bool.filter[0].term.id');`
    - `.ordered` - модификатор - добавляет проверку порядка (чейнится), для проверок `.members`;
    - `.any` - модификатор - добавляет проверку что существует хотя бы один из (чейнится), для проверок `.keys`;
    - `.all` - модификатор - добавляет проверку что существуют все из (чейнится), для проверок `.keys`;
    - `.equal(<проверяемое_значение>[, '<сообщение>'])` - проверяет равенство значений `<значение>` и `<проверяемое_значение>`;
    - `.eql(<проверяемое_значение>[, '<сообщение>'])` - производит глубокую проверку что один объект равен другому объекту по его свойствам;
    - `.have` - имеет (чейнится):
        - `.members(<массив>[, '<сообщение>'])` - проверяет что входной массив `<значение>` строго содержит все значения из `<массив>` и **только их**;
        - `.property('<имя_свойства>'[, <значение_свойства>])` - проверяет что входной объект `<значение>` содержит свойство с указаным именем `<имя_свойства>` [и оно равно `<значение_свойства>`];
        - `.keys(['<имя_свойства1>'[, ...]])` - проверяет что входной объект `<значение>` содержит все свойства, которые заданы в массиве;
    - `.include`:
        - `.members(<массив>)` - проверяет что входной массив `<значение>` содержит все значения из `<массив>`;
    - `.include({<объект> | '<строка>' | <число>}[, '<сообщение>'])` - проверяет что одно из:
        - входной объект `<значение>` содержит все значения из `<объект>`;
        - входная строка `<значение>` содержит подстроку `<строка>`;
        - входной массив `<значение>` содержит строку `<строка>` или число `<число>`;
    - `.throw([<конструктор_ошибки>])` - проверяет что функция `<значение>` при вызове выбросит исключение экземпляра `<конструктор_ошибки>`;

### Асинхронные тесты

Для этого в функцию, которую принимает метод `it("<что_делает_функция>", function (done) {...})` передается дополнительный callback-параметр `done` - который необходимо вызвать по завершению асинхронной работы без параметров в случае успеха `done()`, или с ошибкой в случае не удачи `done(<error>)`.

```javascript
describe('#save()', function () {
    it('should save without error', function (done) {
        var user = new User('Luna');
        user.save(function () {
            done();
        });
    });
});
```

Или можно вернуть промис, который необходимо разрешить.

```javascript
describe('#find()', function () {
    it('respond with matching records', function () {
        return db.find({ type: 'User' }).should.eventually.have.length(3);
    });
});
```

### Размещение тестов

Глобальные тесты должны располагаться по путь `tests/` в корне проекта.

Тесты модулей должны именоваться `<имя_модуля>.spec.js`.

`mocha` - запуск всех тестов в `tests/`.  
`mocha <имя_модуля>.spec.js` - запуск теста модуля.  
`mocha --exclude node_modules ./**/*.spec.js` - запуск всех тестов модулей.

### Sinon

#### Шпион `spy`

`const <spy> = sinon.spy([{<функция> | <объект>, '<метод>'}]);` - возвращает новую функцию (шпиона), которая записывает аргументы, возвращаемое значение, исходное значение и выданные ошибки (если таковые были) для всех вызовов [поверх готовой функции `<функция>` или заменяет исходный метод `<метод>` объекта `<объект>`].

`<spy>.called` - содержит `true` если функция была вызвана, иначе `false`.  
`<spy>.calledOnce` - содержит `true` если функция была вызвана единожды, иначе `false`.  
`<spy>.callCount` - содержит количество вызовов функции.  
`<spy>.args` - содержит массив из массивов аргументов для вызовов функции.  
`<spy>.exceptions` - содержит массив из исключений для вызовов функции.  
`<spy>.returnValues` - содержит массив из возвращаемых значений для вызовов функции.  
`<spy>.getCall(<номер_вызова>)` - возвращает объект с запросами вызова функции, где `args` - массив аргументов для вызова функции.  
`<spy>.calledWith([<аргумент1>[, ...]])` - возвращает `true` если функция была вызвана с указанными аргументами, иначе `false`.  
`<spy>.threw()` - возвращает `true` если функция выбросила исключение, иначе `false`.  
`<spy>.calledBefore(<другой_spy>)` - возвращает `true` если функция была вызвана перед вызовом другого шпиона `<другой_spy>`, иначе `false`.  
`<spy>.calledAfter(<другой_spy>)` - возвращает `true` если функция была вызвана после вызова другого шпиона `<другой_spy>`, иначе `false`.

#### Заглушки `stub`

`const <stub> = sinon.stub([<объект>[, '<метод>']]);` - возвращает новую функцию (заглушку) с предварительно запрограммированным поведением, полностью поддерживает API шпионов в дополнение к методам, которые могут быть использованы для изменения поведения заглушек [для всех методов указаного объекта `<объект>`[, только указаного метода `<метод>`, тогда вызов `<stub>(...)` будет аналогичен вызову `<объект>.<метод>(...)`]].

`<stub>.returns(<значение>)` - возвращает указаное значение `<значение>` при вызове функции.  
`<stub>.returnsThis()` - возвращает `this` при вызове функции.  
`<stub>.resolves(<значение>)` - возвращает промис, который успешно разрешиться значением `<значение>` при вызове функции.  
`<stub>.resolvesArg(<номер>)` - возвращает промис, который успешно разрешиться значением переданным аргументом под номером `<номер>` при вызове функции.  
`<stub>.rejects(<значение>)` - возвращает промис, который неуспешно разрешиться значением `<значение>` при вызове функции.  
`<stub>.throws(['<Тип_Исключения>'])` - выбрасывает указаное исключение [с указаным типом `<Тип_Исключения>`] при вызове функции.  
`<stub>.withArgs([<аргумент1>[, ...]]).<метод_возврата_значения>` - `<метод_возврата_значения>` (к примеру как `returns` и `throws`) будут вызваны только при вызове функции с указанными аргументами, а иначе будут вызваны другие `<метод_возврата_значения>`, их объявляют до `<метод_возврата_значения>` без этого метода.  
`<stub>.onCall(<номер>).<метод_возврата_значения>` - `<метод_возврата_значения>` (к примеру как `returns` и `throws`) будут вызваны только при указаном `<номер>` вызове функции, а иначе будут вызваны другие `<метод_возврата_значения>`.  
`<stub>.callsArg(<номер>)` - вызывает указанный переданный аргумент под номером `<номер>` как функцию при вызове заглушки.  
`<stub>.callsArgWith(<номер>[, <аргумент1>[, ...]])` - вызывает указанный переданный аргумент под номером `<номер>` как функцию при вызове заглушки с указанными аргументами.  
`<stub>.restore()` - восстанавливает исходную функцию.

```javascript
const callback = sinon.stub();
callback.withArgs(42)
    .onFirstCall().returns(1)
    .onSecondCall().returns(2);
callback.returns(0);
```

#### Имитация `mock`

`const <mock> = sinon.mock(<объект>);` - возвращает имитацию для указанного объекта, с предварительно запрограммированным поведением (как заглушка), а также предварительно запрограммированным ожиданием, сам объект не изменяется, но обертывает mock-объект для установки ожиданий на методах объекта.

`<mock>.restore()` - восстанавливает все методы имитации.  
`<mock>.verify()` - возвращает `true` если все ожидания прошли проверку, иначе `false`.

`const <expectation> = <mock>.expects('<метод>');` - возвращает ожидание - функцией имитации, для указаного метода `<метод>`.

`<expectation>.atLeast(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное минимальное количество раз.  
`<expectation>.atMost(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное максимальное количество раз.  
`<expectation>.exactly(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное точное количество раз.  
`<expectation>.once()` - возвращает это ожидание и устанавливает, что метод будет вызван один раз.  
`<expectation>.never()` - возвращает это ожидание и устанавливает, что метод не будет вызван.  
`<expectation>.withArgs(<аргумент1>[, ...])` - возвращает это ожидание и устанавливает, что метод будет вызван с заданными аргументами (возможно подобными).  
`<expectation>.withExactArgs(<аргумент1>[, ...])` - возвращает это ожидание и устанавливает, что метод будет вызван с заданными аргументами и никакими другими.  
`<expectation>.verify()` - возвращает `true` если ожидание прошло проверку, иначе `false`.

## Автоматические тесты при помощи jest

`jest` - запуск всех тестов которые удолетворяют шаблону `*.test.js`.

Конструкции `test` можно вкладывать в блоки `describe` для групировки (по умолчанию считается что они уже вложены в блок `describe`):  
`describe('<описание_блока_тестов>', () => { /* */ }`

```javascript
test("<имя_теста>", () => {
    // ...
    expect(<значение>)[.not].<функция_проверки>(/* ... */);
    // ...
});
```

Асинхронный тест:
```javascript
test("<имя_теста>", (done) => {
    // ...
    expect(<значение>)[.not].<функция_проверки>(/* ... */);
    // ...
    done(); // при успешном завершении теста
    done(<ошибка>); // при неуспешном завершении теста
});
```

Или можно вернуть промис, вместо использования `done`, который необходимо разрешить.  
`test("<имя_теста>", () => new Promise((res, rej) => { ... }));`

Или использовать `async`.  
`test("<имя_теста>", async () => { ... }));`

В каждом блоке `describe` можно также задать функции:
- `beforeAll(([done]) => { ... })` - выполнится до запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `afterAll(([done]) => { ... })` - выполнится после запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `beforeEach(([done]) => { ... })` - выполнится до каждого `test` [где `done` - необходимо вызвать по завершению асинхронной работы];
- `afterEach(([done]) => { ... })` - выполнится после каждого `test` [где `done` - необходимо вызвать по завершению асинхронной работы].


### Имитация `mock`

`jest.spyOn(<объект>, "<свойство>").mockImplementation(() => { ... });` - включает мокирование для свойства `<свойство>` объекта (для свойст (как `fetch`) глобальных объектов используется `global` в качестве объекта).  
`<объект>.<свойство>.mockRestore();` - выключает мок для свойства `<свойство>` объекта.

### Проверки

#### Проверки значений

`expect(<значение>)`:
- `.toBe(<другое_значение>)` - проверяет на равенство значений;
- `.toEqual(<другое_значение>)` - проверяет на похожесть значений по структуре;
- `.toContain(<другое_значение>)` - проверяет на то что `<значение>` содержит другое значение.

#### Проверки вызова функций

`const <функция> = jest.fn();`

`expect(<функция>)`:
- `.toHaveBeenCalledWith([<аргум1>[, ...]])` - проверяет на то что функция была вызвана с указаными аргументами;
- `.toHaveBeenLastCalledWith([<аргум1>[, ...]])` - проверяет на то что функция была вызвана с указаными аргументами в последний раз.

Приемы
======

## Паттерн RORO

Основной смысл этого принципа заключается во фразе *receive an object, return an object* (получил объект, вернул объект) и применяется для функций:  

`function <имя>(<входящий_объект>) {... return <исходящий_объект>;}`

Этот паттерн позволяет избежать передачи параметров в функцию в заданом порядке и позволяет делать именованные параметры, все это упрощается благодаря декомпозиции. Также это позволяет задать обязательные поля с помощью функции, которая выбрасывает исключения:  
> `function func({key, key2 = requiredParam('key2'), key3 = 4}) {...}`

```javascript
function requiredParam(param) {
    const requiredParamError = new Error(`Required parameter, "${param}" is missing.`);
    if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(
            requiredParamError,
            requiredParam
        );
    }
    throw requiredParamError;
}
```

Благодаря тому что всегда получается и возвращается объект можно реализовать удобную композицию функций:
```javascript
function pipe(...fns) {
    return param => fns.reduce((result, fn) => fn(result), param);
}
```

Эта функция принимает список функций и возвращает одну функцию, которая может выполнить эти функции слева направо, передав первой из этих функций аргументы, переданные в `pipe`, второй - то, что вернёт первая функция, и так далее.

> `pipe(validate, normalize, persist)(userInfo)`

## Паттерн Ice Factory

Представляет собой функцию, которая возвращает "замороженный" (иммутабеленый) объект. Используется для построения фабрик по производству объектов, что позволяет скрывать их реализацию:
```javascript
function make<Имя>(<параметры>) { // <параметры> представляют собой объект
    // определение локальных переменных
    const <переменная>[ = <значение>];
    [...]

    //возврат иммутабельного объекта
    return Object.freeze({
        <переменная>[, ...],
        <метод>[, ...]
    });

    //определение методов
    function <метод>() {
        // код, который использует локальные переменные
    }
    [...]
}
```

В этом паттерне вместо наследования применяется композиция.

```javascript
const productList = makeProductList(<параметры>);
const cart = makeShoppingCart(productList);
```

## Паттерн BIF

Паттерн BIF (Backend In the Frontend) использует ту же логику, которая может применяться при использовании BFF (комбинирование нескольких API и очистка данных), но эта логика перемещается на сторону клиента.

```
    | Backend  |                        | Frontend                        |
    |          |                        |                                 |
    | +------+ | <-[ /auth          ]-> | +------+               +------+ |
    | | Data | | <-[ /profile       ]-> | | BIF  | <-[ /user ]-> | App  | |
    | +------+ | <-[ /notifications ]-> | +------+               +------+ |

```

Его использование не приводит к необходимости убирать какую-то логику из проекта. Он всего лишь отделяет логику одного типа (модификация структур данных) от логики другого типа (формирование пользовательского интерфейса).

Это приводит к комбинированию обращений к Backend через функции. То есть теперь все обращения к внешним данным будут проходить только через функции.

Эти функции также должны производить очистку и модификацию данных для приложения, то есть производить нормализацию данных.

## Паттерн Модуль

Заключается в использовании самовызывающийся функции (IIFE, Immediately-Invoked Function Expression, немедленно вызываемое функциональное выражение), которая возвращает модуль в переменную или объявляет какие-то данные глобально. Подобные функции удобно использовать для того, чтобы решить некую задачу, которую нужно решить лишь один раз, не оставляя при этом ничего лишнего в глобальной области видимости. Внутри этой функции создаётся приватная область видимости, недоступная извне.

```javascript
[var <Модуль> = ](function () {
    // приватные переменные и функции

    return {
        // публичные переменные
    };
})();
```

Существует одно соглашение, в соответствии с которым в начале имён приватных функций ставят знак подчёркивания.

TypeScript
==========

TypeScript представляет язык программирования на основе JavaScript. TypeScript - это строго типизированный и компилируемый язык. TypeScript реализует многие концепции, которые свойственны объектно-ориентированным языкам, как, например, наследование, полиморфизм, инкапсуляция и модификаторы доступа и так далее. TypeScript является надмножеством JavaScript, а это значит, что любая программа на JS является программой на TypeScript. В TS можно использовать все те конструкции, которые применяются в JS - те же операторы, условные, циклические конструкции. Более того код на TS компилируется в javascript.

`npm install -g typescript` - установка через NPM.

`tsc -v` - вывод версии.

Все файлы для TypeScript именуются с суффиксом `ts`.

`tsc <файл>.ts` - производит компиляцию файла `<файл>.ts` в `<файл>.js`.

## Структура

Проект по умолчанию имеет следующие файлы:
- `app.ts` - файл с кодом на TypeScript;
- `package.json` - файл с определением пакетов и прочей конфигурации для Node.js;
- `tsconfig.json` - файл конфигурации TypeScript.

## Настройки компиляции

Осуществляются в качестве ключей для `tsc`:
- `-w` - автоматически перекомпилирует файлы typescript, если в них были внесены какие-либо изменения;
- `-t <версия>` - позволяет указать версию стандарта, может принимать следующие значения: "ES3" (по умолчанию), "ES5", "ES6", "ES2015", "ES2016", "ES2017" или "ESNext";
- `--removeComments` - удаляет комментарии при компиляции;
- `--outDir <каталог>` - указывает папку для хранения скомпилированных файлов js;
- `--outFile <файл>[ ...]` - позволяет объединить файлы в один файл;
- `-m` - позволяет указать тип модуля, который будет использоваться для компиляции. Эта опция может принимать следующие значения: "none", "commonjs", "amd", "system" - универсальный, "umd", "es6", "es2015" и "esnext".

### Файл конфигурации tsconfig.json

С помощью файла `tsconfig.json` можно настроить проект TypeScript. В частности, этот файл выполняет следующие задачи:
- устанавливает корневой каталог проекта TypeScript;
- выполняет настройку параметров компиляции;
- устанавливает файлы проекта.

Строение файла:
```json
{
    "compileOnSave": true,
    "compilerOptions": {
        "target": "es5",
        "removeComments": true,
        "outDir": "js",
        "sourceMap": true,
        "outFile": "main.js",
        "module": "system",
    },
    ["files": [
        "<файл>"[, ...]
    ],]
    ["exclude": [
        "<каталог>"[, ...]
    ],]
}
```

Файл `tsconfig.json` используется при компиляции в том случае, если компилятору не передаются названия файлов, которые надо скомпилировать. В этом случае компилятор TypeScript просматривает текущий каталог, ищет в нем файл `tsconfig.json` и затем при компиляции использует те параметры, которые определены в этом файле.

## Типы данных

TypeScript является строго типизированным языком, и каждая переменная и константа в нем имеет определенный тип. При этом в отличие от javascript нельзя динамически изменить ранее указанный тип переменной.

Для установки типа применяется знак двоеточия `:`:  
`{let | const} <переменная>: <тип>[ = <значение>];`

В TypeScript имеются следующие базовые типы:
- `boolean` - логическое значение `true` или `false`;
- `number` - представляет числа, причем все числа в TypeScript, как и в JavaScript, являются числами с плавающей точкой. TS поддерживает двоичную (`0b`), восьмеричную (`0o`), десятичную и шестнадцатиричную (`0x`) записи чисел;
- `string` - строки;
- `array` - массивы - определяются с помощью выражения [] и также являются строго типизированными:
    - `let <переменная>: <тип_элементов_массива>[];`;
    - `let <переменная>: Array<<тип_элементов_массива>>;`;
    > `let names: Array<string> = ["Tom", "Bob", "Alice"];`

    Есть тип `ReadonlyArray<T>`, который, по сути, является типом `Array<T>`, из которого удалены все изменяющие его методы, так что такие массивы не будут изменяться после создания.
- `tuple` - кортежи - как и массивы, представляют набор элементов, для которых уже заранее известен тип:
    - `let <переменная>: [<тип_элемента>[, ...]];`;
    > `let userInfo: [string, number] = ["Tom", 28];`
- `enum` - перечисления - предназначен для описания набора числовых данных с помощью строковых констант (если элемент не имеет инициализатора, ему присваивается значение 0):
    - `enum <ИмяПеречисления> {<ИмяЭлемента>[ = {<значение> | <начальное_значение>}][, ...]};`;
    > `enum Season { Winter = 5, Spring, Summer, Autumn }; // 5, 6, 7, 8`  
    > `let a = Season.Winter`
- `any` - произвольный тип - описывает данные, тип которых может быть неизвестен на момент написания приложения;
- `null`, `undefined` - соответствуют значениям `null` и `undefined` в javascript, фактически можно присваивать значения `undefined` и `null` переменным других типов. В этом плане `null` и `undefined` выступают как подтипы других типов и полезны преимущественно в каких-то операциях, где неизвестен результат - то ли это будет число или строка, то ли это будет `null`;
- `void` - отсутствие конкретного значения, используется в основном в качестве возвращаемого типа функций;
- `never` - также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку;

Большинство из этих типов соотносятся с примитивными типами из JavaScript.

Для определения типа объекта используется структура, при этом необязательные параметры должны быть помечены вопросительным знаком `?`:  
`let <переменная>: {<ключ>: <тип_значения>[, ...]};`
> `let obj: {a: string, b?: number};`

Если тип не указан то компилятор выдаст ей тип присвоеного значения.  
Если же переменная определяется без значения, и только впоследствии при работе программы ей присваивается значение, тогда считается, что она имеет тип `any`.

### Псевдонимы типов

TypeScript позволяет определять псевдонимы типов с помощью ключевого слова `type`:  
`type <имяПсевдонима> = <тип1>[ | <тип2>[ | ...]];`

Теперь можно применять псевдоним аналогично типу данных.

> `type stringOrNumberType = number | string;`  
> `let sum: stringOrNumberType = 36.6;`

От псевдонима типа невозможно расшириться или реализоваться.

#### Тип строкового литерала

Тип строкового литерала позволяет указывать точное значение строки, которое она должна иметь.

> `type Page = 'home' | 'about' | 'contact';`

#### Объединения

Объединения (*union*) не являются собственно типом данных, но они позволяют определить переменную, которая может хранить значение двух или более типов:  
`type <тип> = <тип1> | <тип2>[ | ...];`  
`{let | const} <переменная>: <тип1> | <тип2>[ | ...][ = <значение>];`

> `let id: number | string;`

#### Пересечение

Пересечение (*intersection*) являются новым типом данных, который содержит в себе новый тип из значение двух или более типов:  
`type <тип> = <тип1> & <тип2>[ & ...];`  
`{let | const} <переменная>: <тип1> & <тип2>[ & ...][ = <значение>];`

> `type ExUser = { name: string } & { description: string };`

### Type assertion

Type assertion представляет модель преобразования значения переменной к определенному типу.

`<<тип>><переменная>`  
`<переменная> as <тип>`

> `let someAnyValue: any = "hello world!";`  
> `let strLength: number = (<string>someAnyValue).length;`

### Const assertion (Неизменяемые структуры)

Const assertion представляет модель преобразования объектов и масивов к константным неизменяемым значениям.

`<переменная> as const`

> `[ 1, 3, 5 ] as const;`  
> `{ value: 4 } as const;`

## Определение функции

`function <имя>(<аргумент>: [readonly] <тип>[ = <значение>][, ...]): <тип_результата> {...}`

Если функция ничего не возвращает, то указывается тип результата `void`.

`[readonly]` - обозначает что агрумент используется только для чтения.

Чтобы иметь возможность передавать различное число значений в функцию, в TS некоторые параметры можно объявить как необязательные. Необязательные параметры должны быть помечены вопросительным знаком `?`. Причем необязательные параметры должны идти после обязательных.

`<аргумент>?: <тип>`

Если же необходимо, чтобы функция принимала набор однотипных параметров, то используется знак многоточия, после которого идет массив. Причем этот параметр идет после обязательных.

`...<аргумент>: <тип>[]`

### Оператор утверждения `!`

`!` - после выражения утверждает компилятору, что значение не может быть `null` или `undefined`.

> `part.match(new RegExp(importRegExp))!.slice(1)`

### Параметр `this`

Так как `this` берется из функционального выражения внутри объектного литерала, то чтобы исправить это, можно явно указать `this` в качестве параметра. Параметр `this` - это "фальшивый" параметр, который идет первым в списке параметров функции:  
`function <имя>(this: <тип>, <аргумент>: <тип>[ = <значение>][, ...]): <тип_результата> {...}`

> `function (this: Deck) {...}`

### Перегрузка функций

TypeScript поддерживает возможность перегрузки функций, то есть можно определить несколько версий функции, которые будут иметь одно и то же имя, но разные типы параметров или разное количество параметров или разные возвращаемые типы результатов.  
Для перегрузки вначале определяются все версии функции, которые не будут иметь никакой логики. А потом определяем версию функции с общей сигнатурой, которая подходит под все ранее определенные варианты. И в этой общей версии уже определяем конкретную логику функции.  
То есть вначале аргументы идут с определенными типами, а потом в общей функции с типом `any`.

```typescript
function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: any, y: any): any {
    return x + y;
}
```

### Тип функции

Каждая функция имеет тип, как и обычные переменные. Тип функции фактически представляет комбинацию типов параметров и типа возвращаемого значения. Имеет вид:  
`(<аргумент>: <тип>[, ...]) => <тип_результата>`

> `let operationFunc: (x: number, y: number) => number;`

Тип функции используется также как и простые типы.

## Классы

TypeScript реализует объектно-ориентированный подход, в нем есть полноценная поддержка классов. Класс представляет шаблон для создания объектов и инкапсулирует функциональность, которую должен иметь объект. Класс определяет состояние и поведение, которыми обладает объект.

```typescript
class <Класс>[ extends <Родитель>][ implements <Интерфейс1>[, ...]] {
    [static] [{private | public | protected | readonly}] <свойство1>: <тип>[ = <начальное_значение>]; // Объявление свойства

    constructor([{private | public | protected | readonly}] <аргумент>: <тип>[, ...]): <тип> {
        [super(...);]
        ...
    }

    [static] [{private | public | protected | readonly}] <метод1>(<аргумент>: <тип>[, ...]): <тип> {...}
}
```

Если к свойствам и функциям классов не применяется модификатор, то такие свойства и функции расцениваются как будто они определены с модификатором `public`. То есть доступ к переменным есть из вне.

Если же к свойствам и методам применяется модификатор `private`, то к ним нельзя будет обратиться извне при создании объекта данного класса.

Модификатор `protected` во многом аналогичен `private` - свойства и методы с данным модификатором не видны из вне, но к ним можно обратиться из классов-наследников.

Ключевое слово `readonly` позволяет определить свойства, которые доступны только для чтения. Его значение можно установить только в конструкторе класса или при объявлении.

Также в описании класса можно описывать свойства с двумя методами `get`/`set`.

Имя класса используется также как и простые типы.

Если класс реализует интерфейс, то он обязан определить все те же свойства и функции, которые есть в интерфейсе. При этом объект класса является как объектом типа `<Класс>`, так и объектом `<Интерфейс>`.

`typeof <Класс>` - возвращает тип идентификатора, который является типом функции-конструктора. Этот тип будет содержать все статические члены `<Класс>`, вместе с конструктором, который создает экземпляры класса `<Класс>`.

Полиморфный тип `this` представляет тип, являющийся подтипом содержащегося класса или интерфейса.

### Абстрактные классы

Абстрактные классы представляют классы, определенные с ключевым словом `abstract`. Они во многом похожи на обычные классы за тем исключением, что мы не можем создать напрямую объект абстрактного класса, используя его конструктор.

```typescript
abstract class <Класс>[ extends <Родитель>] {
    [static] [{private | public | protected | readonly}] <свойство1>: <тип>;

    [static] [{private | public | protected | readonly}] <метод1>(<аргумент>: <тип>[, ...]): <тип> {...}

    abstract [{private | public | protected | readonly}] <метод1>(<аргумент>: <тип>[, ...]): <тип>; // абстрактный метод, который необходимо переопределить в наследнике
}
```

Ключевое слово `abstract` указывает что метод или свойство является не определенным в текущий момент и должно быть определено в наследниках в дальнейшем.

## Интерфейсы

### Интерфейсы классов

Интерфейс определяет свойства и методы, которые объект должен реализовать. Другими словами, интерфейс - это определение кастомного типа данных, но без реализации. Интерфейсы определяются с помощью ключевого слова `interface`.

```typescript
interface <Интерфейс>[ extends {<Интерфейс> | <Класс>}[, ...]] {
    [readonly] <свойство1>: <тип>; // Обязательное свойство

    [readonly] <свойство1>?: <тип>; // Необязательное свойство

    [propName: <тип_ключа>]: <тип_значения>; // Описание всех остальных свойств, которые не перечислены в описании интерфейса

    <метод1>(<аргумент>: <тип>[, ...]): <тип>;

    new(<аргумент>: <тип>[, ...]): <тип>; // Определение типа конструктора для класса
}
```

Также интерфейс может содержать свойства только для чтения, значение которых нельзя изменять. Такие свойства определяются с помощью ключевого слова `readonly`.

Имя интерфейса используется также как и простые типы.

Если объект, удовлетворяет перечисленным требованиям интерфейса для аргумента функции, то он считается подходящим для функции. Проверка типов не требует, чтобы свойства шли в определенном порядке: важно лишь, что необходимые свойства присутствуют и имеют подходящий тип.

```typescript
interface User {
    id: number;
    name: string;
}
let employee: User = {
    id: 1,
    name: "Alice"
};
```

### Интерфейсы функций

Интерфейсы функций содержат определение типа функции. Затем они должны быть реализованы объектом, который представляет функцию данного типа.

```typescript
interface <Интерфейс> {
    (<аргумент>: <тип>[, ...]): <тип>;
}
```

```typescript
interface FullNameBuilder {
    (name: string, surname: string): string;
}

let simpleBuilder: FullNameBuilder = function (name:string, surname: string): string {
    return "Mr. " + name + " " + surname;
}
```

### Интерфейсы объектов

Интерфейсы объектов содержат описание структуры ключа и структуры его значения. Затем они должны быть реализованы, тем кто представляет данный тип.

```typescript
interface <Интерфейс> {
    [readonly] [index: <тип_ключа>]: <тип_значения>;
}
```

```typescript
interface Dictionary {
    [index: string]: string;
}

var colors: Dictionary = {};
colors["red"] = "#ff0000";
colors["green"] = "#00ff00";
colors["blue"] = "#0000ff";
```

Сигнатуру индекса можно сделать доступной только для чтения, чтобы запретить присваивание индексам после объявления.

### Гибридные интерфейсы

Интерфейсы могут сочетать различные стили, могут применяться сразу как к определению объекта, так и к определению функции.

Преобразование к интерфейсам происходит по правилу утиной типизации или с помощью конструкций стандартного преобразования.

## Оператор `instanceof`

С помощью оператора `instanceof` можно проверить, принадлежит ли объект определенному классу.

## Обобщения

Для функций:  
`function <имя><T>(<аргумент>: T[, ...]): T {...}`

С помощью выражения `<T>` указывают, что функция типизирована определенным типом `T`. При выполнении функции вместо `Т` будет подставляться конкретный тип. Причем на этапе компиляции конкретный тип не известен. И возвращать функция будет объект этого типа. Таким образом, можно передать в функцию объекты различных типов, но при этом сохраняется строгая типизация, каждый вариант обобщенной функции может принимать объекты только определенного типа.

```typescript
function getId<T>(id: T): T {
    return id;
}
let result1 = getId<number>(5);
let result2 = getId<string>("abc");
```

Для классов и интерфейсов:  
`class <Класс><T> {...}`

`interface <Интерфейс><T> {...}`

Только нужно учитывать, что если типизировали объект определенным типом, то сменить данный тип уже не получится. То есть в следующем случае второе создание объекта не будет работать, так как объект уже типизирован типом изначальным типом.

```typescript
let tom = new User<number>(3);
console.log(tom.getId());
tom = new User<string>("vsf");
```

> `type Constructor<T> = new (...args: any[]) => T;`

### Ограничения обобщений

`<T extends {<Интерфейс> | <Класс>}>` - устанавливает что только можно передавать объекты, которые расширяют `{<Интерфейс> | <Класс>}`.

```typescript
class UserInfo<T extends User> {
    getUserInfo(user: T): void {
        user.getInfo();
    }
}
```

### Ключевое слово `new`

`<T>(type: { new (): T; }): T`

Чтобы создать новый объект в коде обобщений, нужно указать, что обобщенный тип `T` имеет конструктор. Это означает, что вместо параметра `type: T` нужно указать `type: {new (): T;}`.

```typescript
function userFactory<T>(type: { new (): T; }): T {
    return new type();
}

class User {
    constructor() {console.log("создан объект User");}
}

let user: User = userFactory(User);
```

### Защитники типа

**Защитник типа** - это некоторое выражение, выполняющее проверку во время выполнения, гарантирующий тип в некоторой области. 

#### Пользовательский защитник

Чтобы определить защитник типа, нужно определить функцию, чей тип возврата является **предикатом типа**, которая должна возвращать `true` - если `<аргумент>` является типом `<нужный_тип>`, иначе `false`:  
`function is<Имя>(<аргумент>: <тип1> | <тип2> [| ...]): <аргумент> is <нужный_тип> { return <boolean>; }`

Всякий раз, когда с некоторой переменной вызывается указаная функция, TypeScript ограничивает эту переменную в специфический тип, при условии, что оригинальный тип совместим.

```typescript
function isFish(pet: Fish | Bird): pet is Fish {
    return (<fish>pet).swim !== undefined;
}
if (isFish(pet)) {
    pet.swim();
}
```

#### Защитники типа `typeof`

`typeof <переменная> === <тип>` - определяет защитник типа только для типов `"number"`, `"string"`, `"boolean"`, или `"symbol"`.

```typescript
if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
}
```

#### Защитники типа `instanceof`

`<переменная> instanceof <тип>` - определяет защитник типа используя их функцию-конструктор.

```typescript
if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
}
```

### `keyof`

Оператор индексовского типа.

Кострукция `keyof <Интерфейс>` возвращает тип в котором присутствуют все свойства этого интерфейса в качестве объединения.

```typescript
interface User {
    name: string;
    description: string;
    age: number;
}

type UKeys = keyof User; // будет равно объединенному типу 'name' | 'description' | 'age'
```

Его можно использовать в обобщениях: `K extends keyof <Интерфейс>`

Если применять его для интерфейсов объектов, то вернет тип индекса.

### Утилитарные типы

`Partial<<Интерфейс>>` - возвращает новый тип в котором все свойства `<Интерфейс>` определены как опциональные.

```typescript
interface User {
    name: string;
    description: string;
}

type OptionalUser = Partial<User>;

const user: OptionalUser = { name: 'first' };
```

`Required<<Интерфейс>>` - возвращает новый тип в котором все свойства `<Интерфейс>` определены как обязательные.

`Readonly<<Интерфейс>>` - возвращает новый тип в котором все свойства `<Интерфейс>` определены как доступные только для чтения.

`Record<<ИнтерфейсСвойств>, <ИнтерфейсЗначений>>` - возвращает новый тип - запись, в котором свойства могут быть только типа `<ИнтерфейсСвойств>`, а его значения только `<ИнтерфейсЗначений>`.

```typescript
type Keys = 'name' | 'description' | 'age';

interface Value {
    value: string;
    created?: Date;
}

type UserRecord = Record<Keys, Value>;

const userRecord: UserRecord = {
    name: {
        value: 'second',
        created: new Date(12),
    },
    description: {
        value: 'description'
    },
    age: {
        value: 'second',
        created: new Date(123212),
    },
};
```

`Pick<<Интерфейс>, <ИнтерфейсВыбораЗначенийСвойств>>` - возвращает новый тип из типа `<Интерфейс>`, в котором оставляет только те свойства, которые могут быть только типа `<ИнтерфейсВыбораЗначенийСвойств>`.

```typescript
type Keys = 'name' | 'description' | 'age';

interface User {
    name: string;
    description: string;
    age: number;
    created: Date;
}

type UserInfo = Pick<User, Keys>;

const userInfo: UserInfo = {
    name: 'second',
    description: 'description',
    age: 27,
};
```

`Omit<<Интерфейс>, <ИнтерфейсВыбораЗначенийСвойств>>` - возвращает новый тип из типа `<Интерфейс>`, из которого исключает только те свойства, которые могут быть только типа `<ИнтерфейсВыбораЗначенийСвойств>`.

```typescript
interface User {
    name: string;
    description: string;
    age: number;
    created: Date;
}

type UserInfo = Omit<User, 'created' | 'age'>;

const userInfo: UserInfo = {
    name: 'second',
    description: 'description',
};
```

## Пространства имен

Пространства имен предназначены для организации больших программ. Пространства имен содержат группу классов, интерфейсов, функций, других пространств имен, которые могут использоваться в некотором общем контексте. Чтобы типы и объекты, определенные в пространстве имен, были видны извне, они определяются с ключевым словом `export`.

При этом пространства имен могут содержать и интерфейсы, и объекты, и функции.

```typescript
namespace <имя_пространства_имен> {
    // тело пространства имен, которое содержит группу классов, интерфейсов, функций, других пространств имен

    export <экспортируемый_тип>;
}
```

С помощью директивы `/// <reference path="<файл>.ts" />` подключается файл `<файл>.ts`, в котором содержатся данные.

`<имя_пространства_имен>.<экспортируемый_тип>` - доступ к элементам пространства имен.

Пространства имен могут быть вложенными. Причем вложенные пространства имен определяются со словом `export`. Соответственно при обращении к типам надо использовать все пространства имен.

### Псевдонимы

Псевдонимы задаются с помощью ключевого слова `import`.

`import <псевдоним> = <имя_пространства_имен>.<экспортируемый_тип>;`

> `import employee = Data.Personnel.Employee;`

## Модули

TypeScript поддерживает работу с модулями. Модули являются концепцией, привнесенной стандартом ES2015.

Модули в некотором смысле похожи на пространства имен: они могут заключать различные классы, интерфейсы, функции, объекты. Модули выделяются в отдельные файлы. При этом модули подключаются в приложение не посредством тега `<script>`, а с помощью загрузчика модулей.

Работают аналогично модулям ES2015.

## Заголовочные файлы

Для установки связи с внешними файлами скриптов javascript в TS служат декларативные или заголовочные файлы. Это файлы с расширением `.d.ts`, они описывают синтаксис и структуру функций и свойств, которые могут использоваться в программе, не предоставляя при этом конкретной реализации. Их действие во многом похоже на работу файлов с расширением `.h` в языках C/C++. Они выполняют своего рода роль оберток над библиотеками JavaScript.

С помощью ключевого слова `declare` в программу на TS подключается определение глобальной переменной.

```typescript
declare var globalVar: string;
declare function display(): void;
```

Подключение с помощью: `/// <reference path="globals.d.ts" />`.

## Декораторы

Декораторы являются инструментом декларативного программирования, они позволяют добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода.

Декораторы представляют функции, которые могут применяться к классам, методам, методом доступа (геттерам и сеттерам), свойствам, параметрам.

Включаются с помощью `"experimentalDecorators": true`.

### Декораторы классов

Декоратор класса представляет функцию, которая принимает один параметр:  
`function <декоратор>(constructor: Function) {...}`

В качестве параметра выступает конструктор класса.

Для применения декоратора используется знак `@`. Сам декоратор ставится перед названием класса: `@<декоратор>`.

Также декораторы могут изменять результат работы конструктора. В этом случае определение функции декоратора немного меняется, но она также в качестве параметра принимает конструктор класса:  
`function <декоратор><TFunction extends Function>(target: TFunction): TFunction {...}`

В самом декораторе передаваемый конструктор target никак не используется. Но создается новый конструктор который и возвращается `return <TFunction><новый_конструктор>;`.

```typescript
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

@sealed
class User {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    print(): void {
        console.log(this.name);
    }
}
```

### Декоратор метода

Декоратор метода также представляет функцию, которая принимает три параметра:  
`function <декоратор>(target: any, propertyName: string, descriptor: PropertyDescriptor) {...}`

Декоратор принимает следующие параметры:
- `target` - функция конструктора класса для статического метода, либо прототип класса для обычного метода;
- `propertyName` - название метода;
- `descriptor` - объект интерфейса `PropertyDescriptor`.

```typescript
interface PropertyDescriptor {
    configurable?: boolean;
    enumerable?: boolean;
    value?: any;
    writable?: boolean;
    get? (): any;
    set? (v: any): void;
}
```

Этот объект описывает изменение декорируемого метода. Его свойство `value` содержит определение функции. Свойство `writable` указывает, является ли функция модифицируемой (если значение `true`, то является).

Указывается перед описанием метода.

### Декораторы параметров методов

Декоратор параметра метода представляет функцию, которая принимает три параметра:  
`function <декоратор>(target: Object, propertyKey: string, parameterIndex: number) {...}`

Где `target` - представляет конструктор класса, если метод статический, либо прототип класса, если метод нестатический, `propertyKey` - представляет имя параметра, `parameterIndex` - представляет порядковый индекс параметра в списке параметров.

### Декораторы свойств

Декоратор свойства представляет функцию, которая принимает два параметра:  
`function <декоратор>(target: Object, propertyKey: string) {...}`

Где `target` - представляет конструктор класса, если свойство статическое, либо прототип класса, если свойство нестатическое, `propertyKey` - представляет имя свойства.

В функциях декораторов методов, свойств `this` - указывает на текущий экземпляр класса.

```typescript
class User {
    @format
    name: string;
    @logMethod
    setName(@logParameter name: string) {
        this.name = name;
    }
}
```

### Декоратор метода доступа

Декоратор метода доступа принимает три параметра:  
`function <декоратор>(target: Object, propertyName: string, descriptor: PropertyDescriptor) {...}`

Декоратор принимает следующие параметры:
- `target` - функция конструктора класса для статического метода, либо прототип класса для обычного метода;
- `propertyName` - название метода;
- `descriptor` - объект интерфейса `PropertyDescriptor`.

## Фабрики декораторов

Фабрика декоратора представляет функцию, которая в свою очерель возвращает функцию декоратора.

```typescript
function <фабрика_декораторов>(<параметры>) {
    ...
    return function <декоратор>(...) {}
}
```

```typescript
function regex(pattern: string) {
    const expression = new RegExp(pattern);
    return function regex(target: Object, propertyName: string) {
        let propertyValue = this[propertyName];
        const getter = function () {
            return propertyValue;
        };
        const setter = function (newVal) {
            let isValid: boolean = expression.test(newVal);
            if (isValid === false) {
                throw new Error(`Value ${newVal} does not match ${pattern}`);
            } else {
                console.log(`${newVal} is valid`);
            }
        };
        if (delete this[propertyName]) {
            Object.defineProperty(target, propertyName, {
                get: getter,
                set: setter
            });
        }
    }
}

class Account {
    @regex("^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$")
    email: string;

    @regex("^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$")
    phone: string;

    constructor(email: string, phone: string) {
        this.email = email;
        this.phone = phone;
    }
}
```

## TODO: delete

[^ \n]+  +(?!\n)

–|—

:\n\n

(\S) $|(\S) {3,}\n|^ +$

^\s*- .*[^;:]$

[^ ]( |   )$