Описание
========

**Vue** (произносится */vjuː/*, примерно как **view**) - это прогрессивный фреймворк для создания пользовательских интерфейсов. **Vue** создан пригодным для постепенного внедрения. Его ядро в первую очередь решает задачи уровня представления (view), что упрощает интеграцию с другими библиотеками и существующими проектами.

Установка
=========

## Подключение через `<script>`

`<script src="https://cdn.jsdelivr.net/npm/vue"></script>` - для прототипов.  
`<script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>` - для релиза.

Основы
======

## Экземпляр Vue

`const vm = new Vue(<опции>)` - создание экземпляра `Vue`. Переменную с экземпляром `Vue` традиционно именуют `vm` (сокращенно от **ViewModel**). Где `<опции>` представляют собой объект со свойствами:
- `data` - объект с данными, **Vue** добавляет все свойства, найденные в опции `data`, в систему реактивности **Vue**, это означает что если изменять свойство `data.<свойство>`, то изменится и свойство `vm.<свойство>` и наоборот. Чтобы свойсво было реактивным, оно должно существовать в объекте изначально;
- `el` - строка селектора куда будет отрисован экземпляр;

Свойства и методы экземпляра (их имена начинаются с префикса `$`, чтобы отличаться от пользовательских свойств):
- `$data` - ссылка на изначальный объект из опций `data`;
- `$el` - DOM-элемент селектора из опций `el`;

```javascript
const vm = new Vue({
    /**
     * Объект с данными, **Vue** добавляет все свойства, найденные в опции `data`,
     * в систему реактивности **Vue**, это означает что если изменять свойство
     * `data.<свойство>`, то изменится и свойство `vm.<свойство>` и наоборот.
     * Чтобы свойсво было реактивным, оно должно существовать в объекте изначально
     * @type {Object}
     */
    data: {},
    /**
     * Строка селектора куда будет отрисован экземпляр
     * @type {string=}
     */
    el: '',
    /**
     * Объект для определения вычисляемых свойств. При изменении свойств,
     * вычисляемые свойства вычислятся из функций. Могут быть изменяемыми.
     * При этом вычисляемые свойства кэшируются, основываясь на своих реактивных зависимостях
     * @type {Object.<string, function (): *|{get: function (): *, set: function (string)}>=}
     */
    computed: {
        property: function () {
            // `this` указывает на экземпляр vm
            return '<newValue>' || {};
        },
        property2: {
            get: function () {
                // `this` указывает на экземпляр vm
                return '<newValue>' || {};
            },
            set: function (newValue) {
                // `this` указывает на экземпляр vm
            }
        }
    },
    /**
     * Объект для слежения за свойствами.
     * Будут вызваны указаные функции при изменении указаного свойства.
     * @type {Object.<string, function ()>=}
     */
    watch: {
        property: function () {
            // `this` указывает на экземпляр vm
        }
    },
    /**
     * Объект для методов.
     * @type {Object.<string, function (Event)|function (*)>=}
     */
    methods: {
        name: function (event) {
            // `this` указывает на экземпляр vm
        }
    },
    /**
     * Объект для объявления локальных компонентов,
     * которые будут видны только внутри этого компонента, при этом
     * локально зарегистрированные компоненты не будут доступны в дочерних компонентах
     * @type {Object.<string, Object>=} 
     */
    components: {
        'component-1': {
            // опции компонента
        }
    },
    /**
     * Хук, который выполнится после создания экземпляра
     * @type {function ()=}
     */
    created: function () {
        // `this` указывает на экземпляр vm
    },
})
```

## Диаграмма жизненного цикла

![](../assets/Vue/lifecycle.png)

## Синтаксис шаблонов

Шаблоны могут как находится в DOM-дереве, так и в `<script type="text/x-template"><текст_шаблона></script>`.

### Интерполяции

`{{ <имя_свойства> }}` - выражение в фигурных скобках будет заменено значением свойства `<имя_свойства>` соответствующего объекта данных и оно будет обновлено при любом изменении этого свойства.  
Можно указывать любое выражение JavaScript, которое возвращает данные. Из глобальных объектов доступны только объекты `Math` и `Date`.

> `{{ message.split('').reverse().join('') }}`

### Директивы

**Директивы** - это специальные атрибуты с префиксом `v-`. В качестве значения они принимают одно выражение JavaScript (за исключением `v-for`). Директива реактивно применяет к DOM изменения при обновлении значения этого выражения. Значение директивы интерполируется и в глобальной видимости у него доступны все свойства объекта данных, т.е. `<имя_свойства>` - будет заменено на значение этого свойства.

При использовании директивы `v-once` у элемента, это свойство будет отрисовано **только раз** и не будет обновляться.

> `<span v-once>Это сообщение никогда не изменится: {{ msg }}</span>`

При использовании директивы `v-html="<имя_свойства>"` у элемента, это свойство будет **интерпретированно как обычный HTML** и вставленно внутрь этого элемента.

> `<p>Директива v-html: <span v-html="rawHtml"></span></p>`

Для указания **значений атрибутов** используется директива `v-bind:<имя_атрибута>="<имя_свойства>"` у элемента. Для логических атрибутов действеут такое правило, если значение будет `null`, `undefined` или `false`, то атрибут не добавится в элемент. Можно использовать динамические аргументы: `v-bind:[<имя_свойства>]="<имя_свойства>"`. Для сокращения используется вместо `v-bind:` - `:`. При этом значение атрибутов вычисляется динамически.

> `<button v-bind:disabled="isButtonDisabled">Кнопка</button>`  
> `<a v-bind:[attributeName]="url"> ... </a>`

Для передачи всех свойств из объекта используется конструкция: `v-bind="<имя_свойства>"`.

> `<blog-post v-bind="post"></blog-post>` для `post: {id: 1, title: 'My Journey with Vue'}`
> будет равно `<blog-post v-bind:id="post.id" v-bind:title="post.title"></blog-post>`

Для указания **классов** используется директива `v-bind:class="{<имя_класса>: <имя_свойства>}"` или `v-bind:class="<имя_свойства_объекта_классов>"` или `v-bind:class="[<имя_свойства1>[, ...]]"` у элемента. При истинном значении ключа `<имя_класса>` указанный `<имя_класса>` будет добавлен к элементу, при ложном удален.

> `<div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>`  
> `<div class="static" v-bind:class="classObject"></div>`  
> `<div v-bind:class="[activeClass, errorClass]"></div>`

Для указания **inline-стилей** используется директива `v-bind:style="{<имя_css_свойсва>: <имя_свойства>}"` или `v-bind:style="<имя_свойства_css_свойсв>"` у элемента.

> `<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>`  
> `<div v-bind:style="styleObject"></div>`

#### Условные директивы

При использовании директивы `v-if="<имя_свойства>"` у элемента, **Vue** удалит или вставит элемент в зависимости от истинности значения выражения `<имя_свойства>`.

> `<p v-if="seen">Сейчас меня видно</p>`

Для группировки используется псевдоэлемент `<template>`, который служит невидимой оберткой и сам в результатах отрисовки не появляется.

Для указания блока **else if** для `v-if` используется директива `v-else-if`. Элемент с директивой `v-else-if` должен следовать сразу за элементом с директивой `v-if` или `v-else-if`, иначе он не будет распознан.  
Для указания блока **иначе** для `v-if` используется директива `v-else`. Элемент с директивой `v-else` должен следовать сразу за элементом с директивой `v-if` или `v-else-if`, иначе он не будет распознан.

```html
<template v-if="ok">
    <h1>Заголовок</h1>
    <p>Абзац 1</p>
    <p>Абзац 2</p>
</template>
<div v-else-if="type === 'C'">
    <p>Абзац C</p>
</div>
<div v-else>
    <p>Абзац 2</p>
</div>
```

При использовании директивы `v-show="<имя_свойства>"` у элемента, **Vue** скроет или покажет элемент в зависимости от истинности значения выражения `<имя_свойства>`, при этом элемент будет всегда оставаться в DOM, а изменяться будет лишь свойство `display` в его параметрах CSS.

> `<h1 v-show="ok">Привет!</h1>`

#### Отображение перебираемых объектов с помощью директивы `v-for`

Для массивов используется директива `v-for="<имя_элемента_массива> in <имя_свойства>"` или `v-for="(<имя_элемента_массива>, <индекс>) in <имя_свойства>"` у элемента. Где `<имя_элемента_массива>` - ссылка на текущий элемент массива. Вместо `in` разделителем можно использовать `of`, как в итераторах JavaScript.

Рекомендуется всегда указывать атрибут `key` с `v-for`, через директиву `v-bind:key="<имя_элемента_массива>.<ключ>"`, кроме случаев когда итерируемый контент DOM прост, или используется стратегия обновления по умолчанию для улучшения производительности.

```html
<li v-for="(item, index) in items" v-bind:key="item.id">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
</li>
```

Для объектов аналогично используется директива `v-for="<имя_значения_ключа_объекта> in <имя_свойства>"` или `v-for="(<имя_значения_ключа_объекта>, <имя_ключа_объекта>) in <имя_свойства>"` или `v-for="(<имя_значения_ключа_объекта>, <имя_ключа_объекта>, <индекс>) in <имя_свойства>"` у элемента. Где `<имя_значения_ключа_объекта>` - ссылка на текущие значение объекта.

```html
<div v-for="(value, name, index) in object">
    {{ index }}. {{ name }}: {{ value }}
</div>
```

Для изменения значений элемента массива или ключей объекта используется `Vue.set(vm.<имя_свойства>, <индекс_ключ>, <значения>)` или для массива `vm.<имя_свойства>.splice(<индекс>, 1, <значения>)` вместо `vm.<имя_свойства>[<индекс_ключ>] = <значения>`.

Подобно использованию с `v-if`, также можно использовать тег `<template>` с директивой `v-for` для отображения блока из нескольких элементов.

Когда присутствуют вместе на одном элементе, `v-for` имеет больший приоритет, чем `v-if`. Поэтому `v-if` будет выполняться для каждой итерации цикла.

```html
<li v-for="todo in todos" v-if="!todo.isComplete">
    {{ todo }}
</li>
```

#### Директива обработки событий `v-on`

Для указания **функций обработки событий** используется директива `v-on:<имя-события>[<имя_модификатора>]="<имя_метода>"` у элемента, где `<имя-события>` может быть нативным событием или собственным. Можно использовать динамические аргументы: `v-on:[<имя_свойства>]="<имя_метода>"`. Для сокращения используется вместо `v-on:` - `@`. Специальная переменная `$event` передает в метод оригинальное событие DOM.

> `<a v-on:click.prevent="doSomething"> ... </a>`  
> `<a v-on:[eventName]="doSomething"> ... </a>`  
> `<button v-on:click="say('hi', $event)">Скажи hi</button>`  

Модификаторы событий:
- `.stop` - предотвращает всплытие события;
- `.prevent` - убирает действие по умолчанию;
- `.capture` - указывает перехватывать все события внутренних компонентов в этом методе;
- `.self` - только при наступлении события у указаного элемента;
- `.once` - вызов обработчика только единождый;
- `.passive` - предотвращает вызов `event.preventDefault()`;
- `.native` - для подписывания на нативное событие.

Для передачи всех обработчиков событий из объекта используется конструкция: `v-on="<имя_свойства>"`. Свойство `$listeners` содержит все слушатели событий.

> `<input v-bind="$attrs" v-bind:value="value" v-on="inputListeners">`

Когда `vm` уничтожается, все слушатели событий автоматически удаляются. Нет необходимости волноваться, что придется прибираться за собой.

## Работа с формами

Для двунаправленного связывания данных с элементами форм `input`, `textarea` и `select` используется директива `v-model="<имя_свойства>"`.  
`v-model` игнорирует начальное значение атрибутов `value`, `checked` или `selected` на любых элементах форм. Данные экземпляра **Vue** всегда считаются источником истины. Внутренне `v-model` использует разные свойства и генерирует разные события для различных элементов ввода:
- элементы для ввода текста и многострочного текста используют свойство `value` и событие `input`;
- чекбоксы и радиокнопки используют свойство `checked` и событие `change`;
- выпадающие списки используют свойство `value` и событие `change`.

Аналогично директивам: `v-bind:value="<имя_свойства>" v-on:input="<имя_свойства> = $event.target.value"`

```html
<input v-model="message" placeholder="отредактируй меня">
<p>Введенное сообщение: {{ message }}</p>
```

```html
<div>
    <input type="checkbox" id="jack" value="Джек" v-model="checkedNames">
    <label for="jack">Джек</label>
    <input type="checkbox" id="john" value="Джон" v-model="checkedNames">
    <label for="john">Джон</label>
    <br>
    <span>Отмеченные имена: {{ checkedNames }}</span>
</div>
```

Для радиокнопок и выпадающих списков в качестве `v-model` обычно используются статические строки, а для чекбоксов - булевые значения.

Для чекбокса можно указать атрибуты `true-value="<значение_при_выборе>"` и `false-value="<значение_при_сбросе>"`

> `<input type="checkbox" v-model="toggle" true-value="да" false-value="нет">`

Через директиву `v-bind:value="<имя_свойства>"` можно задать значение из свойства.

Модификаторы:
- `.lazy` - синхронизация будет только по событию `change`;
- `.number` - автоматически приводит значение к числу, если не получается, то возвращается оригинальная строка;
- `.trim` - автоматически обрезает пробелы в начале и в конце строки.

Основы компонентов
==================

**Компоненты** - это переиспользуемые экземпляры Vue со своим именем.

Компоненты принимают те же опции что и `new Vue`, такие как `data`, `computed`, `watch`, `methods`, хуки жизненного цикла.

Объявление:
```javascript
Vue.component('<имя-компонента>', {
    /**
     * Автоматически устанавливается при регистрации - имя компонента
     * @type {string=}
     */
    name: '<имя-компонента>',
    /**
     * Функция по созданию объекта изначальных данных
     * @type {function (): Object}
     */
    data: function () {
        // `this` указывает на экземпляр vm и содержит переданые входные параметры
        return {};
    },
    /**
     * Содержит массив входных параметров, которые будут переданы в компонент
     * оно становится свойством экземпляра компонента.
     * Если имя записано в параметре в виде *camelCase*,
     * то оно должно быть в HTML в kebab-case.
     * Может быть в виде объекта, где ключ - имя параметра, а значение - его тип
     * @type {string[]|Object.<string, Function|Function[]|Object>}
     */
    props: ['<параметр-1>'],
    props: {
        '<параметр-1>': Number,
        '<параметр-2>': [Number, Boolean],
        '<параметр-3>': {
            type: Boolean, // тип
            required: true, // обязательность параметра
            default: '<значение>', // значение по умолчанию
            default: function () {
                return {};
            }, // значение по умолчанию для объектов или массивов должно возвращать новый экземпляр
            validator: function (value) {
                return true; // должно возвращать `true`, если `value` проходит валидацию
            } // функция валидации переданого параметра
        },
    },
    /*
     * Отключает наследование атрибутов
     */
    inheritAttrs: false,
    /**
     * Используется для двунаправленного связывания события и изменяемого свойства
     * при использовании `v-model` для связывания
     * @type {{prop: string, event: string}=}
     */
    model: {
        prop: '<имя_параметра>',
        event: '<тип_события>',
    },
    /**
     * Функция по предоставлению данных или методов всем компонентам-потомкам
     * @type {function (): Object=}
     */
    provide: function () {
        // `this` указывает на экземпляр vm и содержит переданые входные параметры
        return {};
    },
    /**
     * Содержит массив входных свойств, которые будут предоставленны компонентом родителем
     * @type {string[]=>}
     */
    inject: ['<свойство-1>'],
    /**
     * Содержит текст шаблона для отрисовки. Должен содержать только один корневой элемент
     * `<slot><!--<значение_по_умолчанию>--></slot>` - содержит содержимое внутри компонетна
     * @type {string}
     */
    template: '<текст_шаблона>',
})
```

Все входные параметры образуют одностороннюю привязку между дочерним свойством и родительским: когда родительское свойство обновляется - оно будет передаваться дочернему, но не наоборот. Каждый раз, когда обновляется родительский компонент, все входные параметры дочернего компонента будут обновлены актуальными значениями. Это означает, что не надо изменять входной параметр внутри дочернего компонента.

Для большинства атрибутов значение, предоставляемое компоненту, будет заменять значение, заданное компонентом, но не для атрибутов `class` и `style`, так как оба значения будут объединены в итоговое.

Свойство `$attrs` - содержит имена атрибутов и значения, переданные компоненту в виде объекта.

Модификатор `.sync` для `v-bind` обеспечивает двустороннюю привязку входных параметров. Но это не работает с вычисляемыми выражениями.

**Все в родительском шаблоне компилируется в области видимости родительского компонента; все в дочернем шаблоне компилируется в области видимости дочернего компонента.**

Использование:
```html
<div id="components">
    <имя-компонента <параметр-1>="<значение>">содержимое1</имя-компонента>
    <имя-компонента <параметр-1>="<значение>">содержимое2</имя-компонента>
</div>
```

```javascript
new Vue({el: '#components'});
```

Для передачи параметра и директивы `v-for` используется директива `v-bind:<параметр>="<значение>"`.

> `<blog-post v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title"></blog-post>`

## Слоты

Слот - представляет собой содержимое тега, которое передали в него, задаются в виде:  
`<slot><значение_по_умолчанию></slot>`.

При отрисовке компонента `<slot></slot>` будет заменен на содержимое тега. Слоты могут содержать любой код шаблона, в том числе HTML.

Директива `v-slot:<имя_слота>` на `<template>` используется для указания содержимого для именованного слота:  
`<template v-slot:<имя_слота>>[<значение_по_умолчанию>]</template>`  
Это будет отрисовано в слот: `<slot name:<имя_слота>>[<значение_по_умолчанию>]</slot>`

Все внутри элементов `<template>` будет передаваться в соответствующие слоты. Любое содержимое, не обернутое в `<template>` с использованием `v-slot`, предназначается для слота по умолчанию `default`.

```html
<имя-компонента>
    <template v-slot:<имя_слота>>
        <!--<содержимое_слота>-->
    </template>
</имя-компонента>
```

### Входные параметры слота

Чтобы сделать параметр `<параметр>` доступным для содержимого слота в родительском компоненте, необходимо добавить привязку параметра `<параметр>` в качестве атрибута на элементе `<slot>` `v-bind:<параметр>="<имя_свойства>"` и тогда атрибуты, привязанные к элементу `<slot>`, можно использовать `v-slot:<имя_слота>="<имя_свойства>"` в `<template>` со значением, чтобы указать имя для предоставленных слоту входных параметров. Можно использовать динамические аргументы: `v-slot:[<имя_свойства>]="<имя_метода>"`. Для сокращения используется вместо `v-slot:` - `#`.

```html
<template v-slot:default="slotProps">
    <!--переопределение-->
    {{ slotProps.user.firstName }}
</template>
<!--...-->
<slot v-bind:user="user">
    <!--по умолчанию-->
    {{ user.lastName }}
</slot>
```

В случаях, когда только слоту по умолчанию предоставляется содержимое, тег компонента можно использовать в качестве шаблона слота вместо `<template>`. Это позволяет использовать `v-slot` непосредственно на компоненте.

```html
<имя-компонента v-slot="slotProps">
    <!--<содержимое_слота>-->
</имя-компонента>
```

Сокращенный синтаксис для слота по умолчанию нельзя смешивать с именованными слотами.

Можно также использовать деструктурирование во входных параметрах слота.

## События компонента

### Вызов событий компонента

Для этого используется `v-on:<имя-события>[<имя_модификатора>]="$emit('<имя-события>'[, <параметр1>[, ...]])"` - производит генерацию события `<имя-события>` с указаными параметрами, тогда значение этого параметра будет содержаться в переменной `$event` или быть первым параметром в функции обработчике. Также можно использовать в методах компонента `this.$emit('<имя-события>'[, <параметр1>[, ...]]`.

Рекомендуется всегда использовать **kebab-case** для имен событий.

При использовании на компоненте директивы `v-model` делает следующее:
```html
<имя-компонента
    v-bind:value="<имя_свойства>"
    v-on:input="<имя_свойства> = $event"
></имя-компонента>
```

### Прослушивание событий компонента

`this.$on(<имя-события>, function () {...})` - добавляет обработчик на прослушивание события `<имя-события>`.  
`this.$once(<имя-события>, function () {...})` - добавляет обработчик на прослушивание события `<имя-события>` только один раз.  
`this.$off(<имя-события>, function () {...})` - убирает обработчик на прослушивание события `<имя-события>`.

## Динамическое переключение компонентов

`<component v-bind:is="<имя_свойства_имени_компонента>"></component>` - будет отображен только указаный компонент в значении, может быть:
- именем зарегистрированного компонента;
- объектом с настройками компонента.

> `<component v-bind:is="currentTabComponent"></component>`

Элемент `<keep-alive>` позволяет кешировать компоненты, а не пересоздовать их с нуля при отображении.

## Алиас компонета

`<<тег> is="<имя_компонента>"></<тег>>` - указаный тег `<тег>` будет считаться компонетном `<имя_компонента>`.

> `<tr is="blog-post-row"></tr>`

## Доступы

`$root` - ссылка на корневой экземпляр.  
> `this.$root.map`

`$parent` - ссылка на родительский экземпляр текущего экземпляра.  
> `this.$parent.map`

`$refs` - объект ссылок на дочерние компоненты и элементы.  
`this.$refs.<ссылка>` будет равен дочернему компоненту которому с помощью атрибута `ref="<ссылка>"` назначена ссылка.  
`$refs` заполняются только после того, как компонент был отрисован, и они не реактивны.
> `<base-input ref="usernameInput"></base-input>`  
> `<input ref="input">`