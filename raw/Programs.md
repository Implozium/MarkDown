Docker
======

`service docker start` - запуск службы docker.  
`service docker stop` - остановка службы docker.

**Образы** - это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит.

## Файл **Dockerfile**

Файл **Dockerfile** (именно так должен он именоваться) содержит набор инструкций, следуя которым Docker будет собирать образ контейнера.

**Контейнеры** - состоят из слоёв. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. **Dockerfile** сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.  
Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** (родительский) - это то, что является исходным слоем (или слоями) создаваемого образа.

### Инструкции файла **Dockerfile**

Состоит из инструкций, после которых идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать: открыть какой-то порт или выполнить какую-то команду.

Инструкции:
- `# <коментарий>` - коментарий;
- `FROM <имя_родительского_образа>[:<версия>] [AS <алиас>]` - (обязательная) задаёт базовый (родительский) образ [если версия не указана, то возьмется последняя] [с указаным алиасом] - начинает новый шаг сборки:
    > `FROM ubuntu:18.04`

    Рекомендуется использовать базовые образы, основанные на Alpine Linux.
- `LABEL <ключ>=<значение>` - описывает метаданные. Например - сведения о том, кто создал и поддерживает образ - содержат в себе полезную информацию об образе Docker:
    > `LABEL maintainer="jeffmshale@gmail.com"`
- `ENV <ключ>=<значение>[ ...]` - устанавливает постоянные переменные среды:
    > `ENV ADMIN="jeff"`
- `RUN <команда1>[ && ...]`  
  `RUN ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов или выполнения вспомогательный действий. После её выполнения в образ добавляется новый слой, его состояние фиксируется:
    > `RUN apk update && apk upgrade && apk add bash && apk add --update git`  
    > `RUN ["mkdir", "/a_directory"]`
    
    В конце установки пакетов рекомендуется удалять их кеш: `&& rm -rf /var/lib/apt/lists/*`
- `COPY [--from=<алиас_образа>] <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует в контейнер файлы и папки [с указаного образа]:
    > `COPY . ./app`
- `ADD <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или добавлять файлы из сети:
    > `ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory`
- `CMD <команда1>[ && ...]`  
  `CMD ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней. Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в **Dockerfile**:
    > `CMD ["python", "./my_script.py"]`
- `WORKDIR <директория>` - задаёт рабочую директорию для следующей инструкции, автоматически создаёт директорию в том случае, если она не существует:
    > `WORKDIR /usr/src/my_app_directory`
- `ARG <имя_переменной>=<значение_по_умолчанию>` - позволяет задать переменную, значение которой можно передать из командной строки в образ, во время его сборки их можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа или в качестве аргументов для команд `RUN`, `CMD`, `ENTRYPOINT` в виде `"<имя_переменной>"` или `${<имя_переменной>}`:
    > `ARG bd=oracle`
- `ENTRYPOINT ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - предоставляет команду с аргументами для вызова во время выполнения контейнера, параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки, а дополняются к команде запуска:
    > `ENTRYPOINT ["python", "./app/my_script.py", "my_var"]`
- `EXPOSE <порт>[ ...]` - указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run -p <порт>`. Если использовать ключ в виде `-P`, то открыты будут все порты, указанные в инструкции `EXPOSED`:
    > `EXPOSE 8000`
- `VOLUME <том>[ ...]` - позволяет указать место - том, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами:
    > `VOLUME /my_volume`

```Dockerfile
FROM node:8 AS build
# Папки
RUN mkdir /app && mkdir /src
WORKDIR /src
# Установка зависимостей
COPY package*.json ./
RUN npm install
# Для использования в продакшне
# RUN npm install --production
# Копирование файлов проекта и сборка проекта
COPY . .
RUN npm run build:production
# В результате получается образ, состоящий из одного слоя
FROM node:alpine
# Копируем собранные файлы из папки build в папку app
COPY --from=build ./build/* /app
ENTRYPOINT ["/app"]
# Уведомление о порте, который будет прослушивать работающее приложение
EXPOSE 3000
# Запуск проекта
CMD ["npm", "run"]
```

Файл `.dockerignore` позволяет игнорировать файлы и папки, в которых нет необходимости при сборке образа, размещается там же, где находится файл **Dockerfile**, поддерживает шаблоны имён файлов (похож на файл `.gitignore`).

## Сборка

### Команды для управления образами

- `docker image build [--build-arg [<имя_переменной>=<значение>[ ...]]] -t <имя>[:<тег>] <путь>`  
    `docker build ...` - собирает образ Docker [с установлением значений переменных] с именем `<имя>` [и тегом `<тег>`] из **Dockerfile** по контексту сборки - из набора файлов, расположенных по определённому пути или URL;
- `docker image ls` - выводит в консоль размеры образов;
- `docker image history <имя_образа>[:<версия>]` - выводит в консоль размеры промежуточных образов, из которых собран некий образ;
- `docker image inspect <имя_образа>[:<версия>]` - выводит в консоль подробные сведения об образе, в том числе - размер каждого его слоя;
- `docker image rm <образ>`  
    `docker rmi <образ>` - удаляет образ.

## Работа с контейнирами

### Команды для управления контейнерами

- `docker container create [-p <порт>:<expose_порт>] [--name <имя>] <образ>` - создание контейнера [с именем `<имя>`], на основе указанного образа [с проброшеными портами внутрь];
- `docker container start <контейнер>[ ...]` - запуск существующего контейнера[-ов];
- `docker container run [-p <порт>:<expose_порт>] [--name <имя>] [--rm] [-d] [--mount type=volume,source=<том>,destination=<путь_монтирования>] <образ> [-it <команда>]`  
    `docker run ...` - запускает контейнер [с проброшеными портами внутрь] [с именем `<имя>`] [и удаляет его после завершения работы контейнера] [в фоновом режиме] [с монтирование тома с именем `<том>` по пути `<путь_монтирования>`], на основе указанного образа [, а в нем указаную команду];
- `docker container ls [-s] [-a]` - вывод списка работающих контейнеров [с их примерным размером] [всех контейнеров];
- `docker container inspect [-s] <контейнер>[ ...]` - вывод подробной информации о контейнере [с их общим размером];
- `docker container logs [-f] [--tail=<количество>] <контейнер>`  
    `docker logs ...` - вывод логов контейнера [в реальном времени] [только указаное количество последних строк];
- `docker container stop <контейнер>[ ...]`  
    `docker stop ...` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время, `SIGKILL`;
- `docker container kill <контейнер>[ ...]`  
    `docker kill ...` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`;
- `docker container rm <контейнер>[ ...]`  
    `docker rm ...` - удаление остановленного контейнера.

## Тома Docker

**Том** - это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker.

### Команды для работы с томами

`docker volume create --name <имя_тома>` - создает том.  
`docker volume ls` - выводит список томов.  
`docker volume inspect <имя_тома>` - вывод подробной информации о томе.  
`docker volume rm <имя_тома>` - удаляет том.  
`docker volume prune` - удаляет не используемые контейнерами тома.  

## Другие команды

`docker stats $(docker ps -q)` - непрерывно выводит в консоль статуса работающих контейнеров.

`docker ps {--all | -a}` - выводит в консоль статус контейнеров.  
`docker ps {--quiet | -q}` - выводит в консоль только id контейнеров.

`docker exec -it <контейнер> sh` - подключается к докеру для выполнения команд. `exit` - выход из докера.

`docker system prune [-a] [--volumes]` - удаляет неиспользуемые контейнеры, которым не назначено имя и тег [все] , сети и образы, [тома].

## `docker-compose`

`docker-compose down` - остановка всех контейнеров.  
`docker-compose up -d` - запуск всех остановленных контейнеров.  
`docker-compose restart`  - перезапускает все контейнеры.  
`docker-compose restart <контейнер>` - перезапускает указанный контейнер.

Redis
=====

`redis-cli <команда>[ <арг1>[ ...]]` - базовое выполнение команд.

`redis-cli DEL <ключ>` - удаляет ключ.

`redis-cli HGET <ключ> <поле>` - выводит в консоль значение поля указаного ключа (хеш-таблицы).  
`redis-cli HSET <ключ> <поле> "<значение>"` - устанавливает значение поля указаного ключа (хеш-таблицы).

`redis-cli --raw keys *<маска>*` - возвращает список ключей, которые соответствуют маске.  
`redis-cli --raw keys *<маска>* | xargs redis-cli DEL` - удаляет все ключи, которые соответствуют маске

`curl`
======

`curl -F '<имя_поля>=@<путь_к_файлу>'[ ...] <url>` - загружает файл на указанный адрес `<url>`.  
`curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <soap_метод_вызова>" --data-binary @<путь_к_файлу_xml> <url>` - отправляет soap запрос с указанным действием `<soap_метод_вызова>` на адрес `<url>` с телом запроса из файла.