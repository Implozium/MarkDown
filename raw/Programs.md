YAML
====

Формат для описания данных. Имеет расширение `.yml`.

## Типы данных

`# <комментарий>` - комментарий, все что идет после `#` считается комментарием и не влияет ни на что. Может располагаться где угодно.
> `key one: value one # this is temporary`

### Строки

`<строка>` - строка, если не содержит спец символов `@`, `_`.  
`'<строка>'` - строка.  
`"<строка>"` - строка.  
> `This is a string`  
> `"This is @ string"`


### Числа

Если число без точки - то оно имеет тип integer, иначе float.
> `200 # integer`  
> `20.1 # float`

### Массивы

`[<значение1>[, ...]]` - описание списка (массива) в одной строке. В виде синтаксиса дефиса:
```yaml
  - <значение1>
  ...
```

> `['Anne', 'John', 'Max']`
```yaml
  - Anne
  - John
  - Max
```

## Синтаксис

Вложеность задается пробелами (2). 0 пробелов обозначает корень.

`<ключ>: <значение>` - описание ключа и его значения. Все что до `:` идет за ключ, а после за значение. Значением может быть число, строка или массив. 
> `key: value`  
> `key one: value one`  
> `people: ['Anne', 'John', 'Max']`
```yaml
people:
  - Anne
  - John
  - Max
```

## Ссылки

`<ключ>: &<переменная>` - объявление переменной. Все что вложено в этот ключ будет в переменной.

`<<: *<переменная>` - вставляет все ключи из переменной в текущее место.

```yaml
base-config: &config
  os: ubuntu
  manager: yarn
  run:
    - NODE_ENV=${ENVIRONMENT} yarn build

development:
  <<: *config
  env:
    - ENVIRONMENT: development


production:
  <<: *config
  env:
    - ENVIRONMENT: production
```

Docker
======

`service docker start` - запуск службы docker.  
`service docker stop` - остановка службы docker.

**Образы** - это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит.

## Файл **Dockerfile**

Файл **Dockerfile** (именно так должен он именоваться) содержит набор инструкций, следуя которым Docker будет собирать образ контейнера.

**Контейнеры** - состоят из слоев. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. **Dockerfile** сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.  
Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** (родительский) - это то, что является исходным слоем (или слоями) создаваемого образа.

### Инструкции файла **Dockerfile**

Состоит из инструкций, после которых идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать: открыть какой-то порт или выполнить какую-то команду.

Инструкции:
- `# <коментарий>` - коментарий;
- `FROM <имя_родительского_образа>[:<версия>] [AS <алиас>]` - (обязательная) задает базовый (родительский) образ [если версия не указана, то возьмется последняя] [с указаным алиасом] - начинает новый шаг сборки:
    > `FROM ubuntu:18.04`

    Рекомендуется использовать базовые образы, основанные на Alpine Linux.
- `LABEL <ключ>=<значение>` - описывает метаданные. Например - сведения о том, кто создал и поддерживает образ - содержат в себе полезную информацию об образе Docker:
    > `LABEL maintainer="jeffmshale@gmail.com"`
- `ENV <ключ>=<значение>[ ...]` - устанавливает постоянные переменные среды:
    > `ENV ADMIN="jeff"`
- `RUN <команда1>[ && ...]`  
  `RUN ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - выполняет команду и создает слой образа. Используется для установки в контейнер пакетов или выполнения вспомогательный действий. После ее выполнения в образ добавляется новый слой, его состояние фиксируется:
    > `RUN apk update && apk upgrade && apk add bash && apk add --update git`  
    > `RUN ["mkdir", "/a_directory"]`

    В конце установки пакетов рекомендуется удалять их кеш: `&& rm -rf /var/lib/apt/lists/*`
- `COPY [--from=<алиас_образа>] <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует в контейнер файлы и папки [с указаного образа]:
    > `COPY . ./app`
- `ADD <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или добавлять файлы из сети:
    > `ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory`
- `CMD <команда1>[ && ...]`  
  `CMD ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней. Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в **Dockerfile**:
    > `CMD ["python", "./my_script.py"]`
- `WORKDIR <директория>` - задает рабочую директорию для следующей инструкции, автоматически создает директорию в том случае, если она не существует:
    > `WORKDIR /usr/src/my_app_directory`
- `ARG <имя_переменной>=<значение_по_умолчанию>` - позволяет задать переменную, значение которой можно передать из командной строки в образ, во время его сборки их можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа или в качестве аргументов для команд `RUN`, `CMD`, `ENTRYPOINT` в виде `"<имя_переменной>"` или `${<имя_переменной>}`:
    > `ARG bd=oracle`
- `ENTRYPOINT ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - предоставляет команду с аргументами для вызова во время выполнения контейнера, параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки, а дополняются к команде запуска:
    > `ENTRYPOINT ["python", "./app/my_script.py", "my_var"]`
- `EXPOSE <порт>[ ...]` - указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run -p <порт>`. Если использовать ключ в виде `-P`, то открыты будут все порты, указанные в инструкции `EXPOSED`:
    > `EXPOSE 8000`
- `VOLUME <том>[ ...]` - позволяет указать место - том, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами:
    > `VOLUME /my_volume`

```Dockerfile
FROM node:8 AS build
# Папки
RUN mkdir /app && mkdir /src
WORKDIR /src
# Установка зависимостей
COPY package*.json ./
RUN npm install
# Для использования в продакшне
# RUN npm install --production
# Копирование файлов проекта и сборка проекта
COPY . .
RUN npm run build:production
# В результате получается образ, состоящий из одного слоя
FROM node:alpine
# Копируем собранные файлы из папки build в папку app
COPY --from=build ./build/* /app
ENTRYPOINT ["/app"]
# Уведомление о порте, который будет прослушивать работающее приложение
EXPOSE 3000
# Запуск проекта
CMD ["npm", "run"]
```

Файл `.dockerignore` позволяет игнорировать файлы и папки, в которых нет необходимости при сборке образа, размещается там же, где находится файл **Dockerfile**, поддерживает шаблоны имен файлов (похож на файл `.gitignore`).

## Сборка

### Команды для управления образами

- `docker image build [--build-arg [<имя_переменной>=<значение>[ ...]]] -t <имя>[:<тег>] <путь>`  
    `docker build ...` - собирает образ Docker [с установлением значений переменных] с именем `<имя>` [и тегом `<тег>`] из **Dockerfile** по контексту сборки - из набора файлов, расположенных по определенному пути или URL;
- `docker image ls` - выводит в консоль размеры образов;
- `docker image history <имя_образа>[:<версия>]` - выводит в консоль размеры промежуточных образов, из которых собран некий образ;
- `docker image inspect <имя_образа>[:<версия>]` - выводит в консоль подробные сведения об образе, в том числе - размер каждого его слоя;
- `docker image rm <образ>`  
    `docker rmi <образ>` - удаляет образ.

## Работа с контейнерами

### Команды для управления контейнерами

- `docker container create [-p <порт>:<expose_порт>] [--name <имя>] <образ>` - создание контейнера [с именем `<имя>`], на основе указанного образа [с проброшеными портами внутрь];
- `docker container start <контейнер>[ ...]` - запуск существующего контейнера[-ов];
- `docker container run [-p <порт>:<expose_порт>] [--name <имя>] [--rm] [-d] [--mount type=volume,source=<том>,destination=<путь_монтирования>] <образ> [-it <команда>]`  
    `docker run ...` - запускает контейнер [с проброшеными портами внутрь] [с именем `<имя>`] [и удаляет его после завершения работы контейнера] [в фоновом режиме] [с монтирование тома с именем `<том>` по пути `<путь_монтирования>`], на основе указанного образа [, а в нем указаную команду];
- `docker container ls [-s] [-a]` - вывод списка работающих контейнеров [с их примерным размером] [всех контейнеров];
- `docker container inspect [-s] <контейнер>[ ...]` - вывод подробной информации о контейнере [с их общим размером];
- `docker container logs [-f] [--tail=<количество>] <контейнер>`  
    `docker logs ...` - вывод логов контейнера [в реальном времени] [только указаное количество последних строк];
- `docker container stop <контейнер>[ ...]`  
    `docker stop ...` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время, `SIGKILL`;
- `docker container kill <контейнер>[ ...]`  
    `docker kill ...` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`;
- `docker container rm <контейнер>[ ...]`  
    `docker rm ...` - удаление остановленного контейнера.

## Тома Docker

**Том** - это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker.

### Команды для работы с томами

`docker volume create --name <имя_тома>` - создает том.  
`docker volume ls` - выводит список томов.  
`docker volume inspect <имя_тома>` - вывод подробной информации о томе.  
`docker volume rm <имя_тома>` - удаляет том.  
`docker volume prune` - удаляет не используемые контейнерами тома.  

## Другие команды

`docker stats $(docker ps -q)` - непрерывно выводит в консоль статуса работающих контейнеров.

`docker ps {--all | -a}` - выводит в консоль статус контейнеров.  
`docker ps {--quiet | -q}` - выводит в консоль только id контейнеров.

`docker exec -it <контейнер> sh` - подключается к докеру для выполнения команд. `exit` - выход из докера.

`docker system prune [-a] [--volumes]` - удаляет неиспользуемые контейнеры, которым не назначено имя и тег [все] , сети и образы, [тома].

`docker restart <контейнер>` - перезапускает указанный контейнер.  
`docker restart $(docker ps -a -q)`  - перезапускает все контейнеры.

## `docker-compose`

Файл `docker-compose.yml` - это файл Docker Compose, который будет содержать инструкции, необходимые для запуска и настройки сервисов.

```yml
version: "3"

# 1 сервис = 1 контейнер.
# Сервисом может быть клиент, сервер, сервер баз данных...

services:
    <имя_сервиса>:
        # Ключевое слово "build" позволяет задать путь к файлу Dockerfile, который нужно использовать для создания образа, который позволит запустить сервис.
        # Здесь <путь> соответствует пути к папке сервера, которая содержит соответствующий Dockerfile.
        build: <путь>

        # Команда, которую нужно запустить после создания образа.
        command: <команда>

        # Для перенаправления портов применяется следующая конструкция: [порт компьютера]:[порт контейнера]
        ports:
            - <порт_компьютера>:<порт_контейнера]>

        # Ключевое слово 'network_mode' используется для описания типа сети, указывается то, что контейнер может обращаться к 'localhost' компьютера.
        network_mode: host

        # Ключевое слово 'depends_on' позволяет указывать, должен ли сервис, прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы <имя_сервиса>.

        depends_on:
            - <имя_сервиса>

        # имя контенера
        container_name: <имя_контенера>
```

Порты контейнеров, назначенные в файлах Dockerfile, будут открыты в сети, организуемой Docker Compose.

`docker-compose build` - выполняет команды `build` для всех сервисов.

`docker-compose up` - запуск всех контейнеров.  
`docker-compose up -d` - запуск всех остановленных контейнеров.
`docker-compose -f <файл_конфигурации1>[ ...] up -d` - запуск всех контейнеров из файла с настройками, которые сливаются вместе при совпадении полей или дополняются.

`docker-compose down` - остановка всех контейнеров.  
`docker-compose restart`  - перезапускает все контейнеры.  
`docker-compose restart <контейнер>` - перезапускает указанный контейнер.

`docker-compose logs -f <контейнер>` - выводит журналы сервиса.

`docker-compose ps` - выводит список контейнеров.

`docker-compose exec <контейнер> <команда>` - выполняет команду в выполняющемся контейнере.

## Примеры

### Файлы для сервера ноды

Dockerfile для создания статики и запуска nginx сервера:
```Dockerfile
# использование образа с алиасом build для создания статики
FROM node:12-alpine as build
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# копирование исходного кода
COPY . /app
# запуск сборки
RUN npm run build
# использования образа nginx для запуска и отдачи статики
FROM nginx:1.16.0-alpine
# копирование из образа build из каталога /app/build в каталог /usr/share/nginx/html текущего образа
COPY --from=build /app/build /usr/share/nginx/html
# открытие порта 80 наружу
EXPOSE 80
# запуск команды на выполнение
CMD ["nginx", "-g", "daemon off;"]
```

Dockerfile для компиляции и запуска сервера ноды:
```Dockerfile
# использование образа с алиасом builder для комплиляции кода
FROM node:12-alpine as builder
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install
# копирование исходного кода
COPY . /app
# запуск компиляции
RUN npm run build
# использования образа ноды
FROM node:12-alpine
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование из образа builder из каталога /app/dist в каталог /app текущего образа
COPY --from=builder /app/dist /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# открытие порта 8080 наружу
EXPOSE 8080
# установка пользователя
USER node
# запуск команды на выполнение
CMD ["node", "index.js"]
```

Файл `docker-compose.yml` для запуска образов:
```yml
version: "3"
services:
  api:
    build: ./services/api
    ports:
      - "8080:8080"
    depends_on:
      - db
    container_name: blog-api
  client:
    build: ./services/client
    ports:
      - "80:80"
    container_name: blog-client
  db:
    image: mongo
    ports:
      - "27017:27017"
    container_name: blog-db
```

Для общения между контейнерами используется имя контейнера вместо ip адреса localhost.
> `mongodb://localhost:27017/blog` -> `mongodb://blog-db:27017/blog`

Redis
=====

`redis-cli <команда>[ <арг1>[ ...]]` - базовое выполнение команд.

`redis-cli DEL <ключ>` - удаляет ключ.

`redis-cli HGET <ключ> <поле>` - выводит в консоль значение поля указаного ключа (хеш-таблицы).  
`redis-cli HSET <ключ> <поле> "<значение>"` - устанавливает значение поля указаного ключа (хеш-таблицы).

`redis-cli --raw keys *<маска>*` - возвращает список ключей, которые соответствуют маске.  
`redis-cli --raw keys *<маска>* | xargs redis-cli DEL` - удаляет все ключи, которые соответствуют маске

`curl`
======

`curl [<опции>] <url>` - базовый вызов адреса `<url>`, по умолчанию GET.

Опции:
- `-i` - выводит заголовки ответа;
- `-k` - обозначает что можно проводить небезопасный запрос, при невозможности подтверждения сертификата, при использовании протокола **https**;
- `-F '<имя_поля>=@<путь_к_файлу>'` - добавляет содержимое файла в указаное поле;
- `-X <тип_запроса>` - изменяет тип запроса на указанный (POST, GET, PUT, DELETE);
- `-H "<имя_заголовка>: <значение_заголовка>"` - добавляет заголовок в запрос;
- `-b "<имя_куки>=<значение_куки>"` - добавляет куку в запрос;
- `-d "<имя_поля>=<значение_поля>"` - добавляет значение ключа в POST-запрос;
- `--data "<тело>"` - добавляет тело в POST-запрос;
- `-o <путь_к_файлу>` - сохранит все в файл `<путь_к_файлу>`.

Для запросов типа POST по умолчанию используется заголовки: `Content-Type: application/x-www-form-urlencoded`. Для передачи JSON нужно дополнительно пропичывать зоголовок: `Content-Type: application/json`.

Примеры:
- `curl -F '<имя_поля>=@<путь_к_файлу>'[ ...] <url>` - загружает файл на указанный адрес `<url>`;
- `curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <soap_метод_вызова>" --data-binary @<путь_к_файлу_xml> <url>` - отправляет soap запрос с указанным действием `<soap_метод_вызова>` на адрес `<url>` с телом запроса из файла;
- `curl -OL <url>` - загружает файл с адреса `<url>` в файл с именем после последнего `/` в адресе `<url>`.

`nginx`
=======

`nginx -s <сигнал>` - посылает сигнал nginx, может быть:
- `stop` - быстрое завершение;
- `quit` - плавное завершение;
- `reload` - перезагрузка конфигурационного файла;
- `reopen` - переоткрытие лог-файлов.

Файл `nginx.conf` содержит конфигурацию, расположен по `/usr/local/nginx/conf`, `/etc/nginx`, `/usr/local/etc/nginx`.

Состоит из директив:
- **простая** - `<имя> <параметр_1>[ ...];`;
- **блочная** - `<имя> <параметр_1>[ ...] { ... }`.

`#` - обозначает коментарий.

Структура:
```nginx
http {
    server {
        listen <порт>; # порт прослушивания сервера

        server_name <имя_виртуального_сервера_1>[ ...]; # задает имя виртуального сервера

        root <путь_по_умолчанию_к_каталогу_с_файлами>; # будет использоваться, если в location не указана директива root

        location <префикс_пути_1> {
            root <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>/<префикс_пути_1>
        }

        location <префикс_пути_2> {
            proxy_pass <url>; # производит проксирование всех запросов по данному пути на указаный <url>
            proxy_set_header Host $host; # для передачи имени хоста
        }

        location <префикс_пути_3> {
            alias <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>
        }

        location = <путь> { # будет работать только для тех, которые точно равны указаному пути
            # ...
        }

        location ~ <регулярное_выражение> { # будет работать только для тех, которые совпадают с регулярным выражением, можно использовать выделения (), которые затем доступны в виде переменных $1..$9
            # ...
            # alias /usr/share/$1/$2
        }

        location ~* <регулярное_выражение> { # то же, только без учета регистра
            # ...
        }

        # ...
    }
    # ...
}
```

При этом выбирается самый больший префикс пути в директивах `location`.

Если не находится совпадение с директивами `location`, то возвращается заголовок **404**.

Если в регулярном выражении встречаются символы `}` или `;`, то все выражение следует заключить в одинарные или двойные кавычки.

При поиске виртуального сервера по имени, если имени соответствует несколько из указанных вариантов, например, одновременно подходят и имя с маской, и регулярное выражение, будет выбран первый подходящий вариант в следующем порядке приоритета:
- точное имя;
- самое длинное имя с маской в начале, например `*.example.com`;
- самое длинное имя с маской в конце, например `mail.*`;
- первое подходящее регулярное выражение (в порядке следования в конфигурационном файле).

## Подключение конфигурации

Для этого используется директива: `include <путь_к_файлу_конфигурации>;`, которая вставляет конфигурации из файла в указаное место, где путь `<путь_к_файлу_конфигурации>` может быть шаблоном.

## Переменные

`set $<имя_переменной> <значение>;` - устанавливает значение переменной. Значение `<значение>` может быть заключено в кавычки: `"<значение>"`. Также может содержать внутри себя переменные, которые заменятся на значение переменных.
> `set $USER release;`  
> `set $USER_FOLDER "/user/$USER/www";`

## Условия

```nginx
if (<условие>) {
    # ...
}
```

Где `<условие>` может быть вида:
- `<имя_переменной>` - при этом ложными значениями переменной являются пустая строка или `"0"`;
- `<имя_переменной> = <строка>`;
- `<имя_переменной> != <строка>`;
- `<имя_переменной> ~ <регулярное_выражение>` - можно использовать выделения `()`, которые затем доступны в виде переменных `$1`..`$9`;
- `<имя_переменной> !~ <регулярное_выражение>`;
- `<имя_переменной> ~* <регулярное_выражение>`;
- `<имя_переменной> !~* <регулярное_выражение>`.

## Переопределение

`rewrite <регулярное_выражение> <строка> [permanent];` - переопределяет путь, который совпадает с регулярным выражением `<регулярное_выражение>`, на указаную строку `<строка>`, в которой можно использовать выделения `()` в виде переменных `$1`..`$9` из регулярного выражения.

## Переменные

`$host` - содержит имя хоста из строки запроса, или имя хоста из поля `Host` заголовка запроса, или имя сервера, соответствующего запросу.