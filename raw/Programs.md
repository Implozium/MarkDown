Форматы
=======

## YAML

Формат для описания данных. Имеет расширение `.yml`.

### Типы данных

`# <комментарий>` - комментарий, все что идет после `#` считается комментарием и не влияет ни на что. Может располагаться где угодно.
> `key one: value one # this is temporary`

#### Строки

`<строка>` - строка, если не содержит спец символов `@`, `_`.  
`'<строка>'` - строка.  
`"<строка>"` - строка.  
> `This is a string`  
> `"This is @ string"`


#### Числа

Если число без точки - то оно имеет тип integer, иначе float.
> `200 # integer`  
> `20.1 # float`

#### Массивы

`[<значение1>[, ...]]` - описание списка (массива) в одной строке. В виде синтаксиса дефиса:
```yaml
  - <значение1>
  ...
```

> `['Anne', 'John', 'Max']`
```yaml
  - Anne
  - John
  - Max
```

## Синтаксис

Вложеность задается пробелами (2). 0 пробелов обозначает корень.

`<ключ>: <значение>` - описание ключа и его значения. Все что до `:` идет за ключ, а после за значение. Значением может быть число, строка или массив.
> `key: value`  
> `key one: value one`  
> `people: ['Anne', 'John', 'Max']`
```yaml
people:
  - Anne
  - John
  - Max
```

### Ссылки

`<ключ>: &<переменная>` - объявление переменной. Все что вложено в этот ключ будет в переменной.

`<<: *<переменная>` - вставляет все ключи из переменной в текущее место.

```yaml
base-config: &config
  os: ubuntu
  manager: yarn
  run:
    - NODE_ENV=${ENVIRONMENT} yarn build

development:
  <<: *config
  env:
    - ENVIRONMENT: development


production:
  <<: *config
  env:
    - ENVIRONMENT: production
```

## Расширенная форма Бэкуса - Наура

Это формальная система определения синтаксиса, в которой одни синтаксические категории последовательно определяются через другие. Используется для описания граматик.

**Терминальные символы** - это минимальные элементы грамматики, не имеющие собственной грамматической структуры - это предопределенные идентификаторы (имена, считающиеся заданными для данного описания грамматики), либо цепочки - последовательности символов в кавычках или апострофах.

**Нетерминальные символы** - это элементы грамматики, имеющие собственные имена и структуру. Каждый нетерминальный символ состоит из одного или более терминальных и / или нетерминальных символов, сочетание которых определяется правилами грамматики.

**Правила** - используются для определения нетерминальных символов:  
`<идентификатор> = <выражение>.` - правило, где `<идентификатор>` - это нетерминальный символ, а `<выражение>` - это комбинация терминальных и нетерминальных символов и специальных знаков, могут быть комбинацией конструкций:
- **конкатенация** - это перечисление терминальных и не терминальных символов через символ `,`, что обозначает что нетерминал состоит из последовательности символов. Правило вида `A = B,C.`, иногда символ `,` может опускаться:
    > `SELECT = 'select', COLUMN_LIST, 'from', TABLE.`
- **выбор** - это выбор одного из терминальных и не терминальных символов через символ `|`, что обозначает что нетерминал может состоять из одного из символов. Правило вида `A = B|C.`:
    > `COND = 'or' | 'and'.`
- **условное вхождение** - это необязательный элемент выражения, который может присутствовать, а может и отсутствовать и заключается между символами `[` и `]`. Правило вида `A = [B].`:
    > `COND = ['not'], COND.`
- **повторение** - это повторяющийся элемент выражения, который обозначают конкатенацию любого числа (включая нуль) записанных в ней элементов и заключается между символами `{` и `}`. Правило вида `A = {B}.`:
    > `LIST = ARG {',', ARG}.`
- **групировка** - это конструкция, которая применяется для группировки элементов при формировании сложных выражений и заключается между символами `(` и `)`. Правило вида `A = (B).`:
    > `COND = ARG, 'in', (ARG | LIST).`

Docker
======

`service docker start` - запуск службы docker.  
`service docker stop` - остановка службы docker.

**Образы** - это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит.

## Файл **Dockerfile**

Файл **Dockerfile** (именно так должен он именоваться) содержит набор инструкций, следуя которым Docker будет собирать образ контейнера.

**Контейнеры** - состоят из слоев. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. **Dockerfile** сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.  
Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** (родительский) - это то, что является исходным слоем (или слоями) создаваемого образа.

### Инструкции файла **Dockerfile**

Состоит из инструкций, после которых идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать: открыть какой-то порт или выполнить какую-то команду.

Инструкции:
- `# <коментарий>` - коментарий;
- `FROM <имя_родительского_образа>[:<версия>] [AS <алиас>]` - (обязательная) задает базовый (родительский) образ [если версия не указана, то возьмется последняя] [с указаным алиасом] - начинает новый шаг сборки:
    > `FROM ubuntu:18.04`

    Рекомендуется использовать базовые образы, основанные на Alpine Linux.

- `LABEL <ключ>=<значение>` - описывает метаданные. Например - сведения о том, кто создал и поддерживает образ - содержат в себе полезную информацию об образе Docker:
    > `LABEL maintainer="jeffmshale@gmail.com"`

- `ENV <ключ>=<значение>[ ...]` - устанавливает постоянные переменные среды:
    > `ENV ADMIN="jeff"`

- `RUN <команда1>[ && ...]`.

  `RUN ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - выполняет команду и создает слой образа. Используется для установки в контейнер пакетов или выполнения вспомогательный действий. После ее выполнения в образ добавляется новый слой, его состояние фиксируется:
    > `RUN apk update && apk upgrade && apk add bash && apk add --update git`  
    > `RUN ["mkdir", "/a_directory"]`

    В конце установки пакетов рекомендуется удалять их кэш: `&& rm -rf /var/lib/apt/lists/*`

- `COPY [--from=<алиас_образа>] <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует в контейнер файлы и папки [с указаного образа]:
    > `COPY . ./app`

- `ADD <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или добавлять файлы из сети:
    > `ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory`

- `CMD <команда1>[ && ...]`.

  `CMD ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней. Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в **Dockerfile**:
    > `CMD ["python", "./my_script.py"]`

- `WORKDIR <директория>` - задает рабочую директорию для следующей инструкции, автоматически создает директорию в том случае, если она не существует:
    > `WORKDIR /usr/src/my_app_directory`

- `ARG <имя_переменной>=<значение_по_умолчанию>` - позволяет задать переменную, значение которой можно передать из командной строки в образ, во время его сборки их можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа или в качестве аргументов для команд `RUN`, `CMD`, `ENTRYPOINT` в виде `"<имя_переменной>"` или `${<имя_переменной>}`:
    > `ARG bd=oracle`

- `ENTRYPOINT ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - предоставляет команду с аргументами для вызова во время выполнения контейнера, параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки, а дополняются к команде запуска:
    > `ENTRYPOINT ["python", "./app/my_script.py", "my_var"]`

- `EXPOSE <порт>[ ...]` - указывает на то, какие порты планируется открыть внутри контейнера для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run -p <порт>`. Если использовать ключ в виде `-P`, то открыты будут все порты, указанные в инструкции `EXPOSE`:
    > `EXPOSE 8000`

- `VOLUME <том>[ ...]` - позволяет указать место - том, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами:
    > `VOLUME /my_volume`

```Dockerfile
FROM node:8 AS build
# Папки
RUN mkdir /app && mkdir /src
WORKDIR /src
# Установка зависимостей
COPY package*.json ./
RUN npm install
# Для использования в продакшне
# RUN npm install --production
# Копирование файлов проекта и сборка проекта
COPY . .
RUN npm run build:production
# В результате получается образ, состоящий из одного слоя
FROM node:alpine
# Копируем собранные файлы из папки build в папку app
COPY --from=build ./build/* /app
ENTRYPOINT ["/app"]
# Уведомление о порте, который будет прослушивать работающее приложение
EXPOSE 3000
# Запуск проекта
CMD ["npm", "run"]
```

Файл `.dockerignore` позволяет игнорировать файлы и папки, в которых нет необходимости при сборке образа, размещается там же, где находится файл **Dockerfile**, поддерживает шаблоны имен файлов (похож на файл `.gitignore`).

## Сборка

### Команды для управления образами

- `docker image build [--build-arg [<имя_переменной>=<значение>[ ...]]] -t <имя>[:<тег>] <путь>` - собирает образ Docker [с установлением значений переменных] с именем `<имя>` [и тегом `<тег>`] из **Dockerfile** по контексту сборки - из набора файлов, расположенных по определенному пути или URL;
- `docker build [--build-arg [<имя_переменной>=<значение>[ ...]]] -t <имя>[:<тег>] <путь>` - аналогично предыдущей;
- `docker image ls` - выводит в консоль размеры образов;
- `docker image history <имя_образа>[:<версия>]` - выводит в консоль размеры промежуточных образов, из которых собран некий образ;
- `docker image inspect <имя_образа>[:<версия>]` - выводит в консоль подробные сведения об образе, в том числе - размер каждого его слоя;
- `docker image rm <образ>` - удаляет образ;
- `docker rmi <образ>` - аналогично предыдущей.

## Работа с контейнерами

### Команды для управления контейнерами

- `docker container create [-p <порт>:<expose_порт>] [--name <имя>] <образ>` - создание контейнера [с именем `<имя>`], на основе указанного образа [с проброшеными портами внутрь];
- `docker container start <контейнер>[ ...]` - запуск существующего контейнера[-ов];
- `docker container run [-p <порт>:<expose_порт>] [--name <имя>] [--rm] [-d] [--mount type=volume,source=<том>,destination=<путь_монтирования>] <образ> [-it <команда>]` - запускает контейнер [с проброшеными портами внутрь] [с именем `<имя>`] [и удаляет его после завершения работы контейнера] [в фоновом режиме] [с монтирование тома с именем `<том>` по пути `<путь_монтирования>`], на основе указанного образа `<образ>`[, а в нем указаную команду];
- `docker run [-p <порт>:<expose_порт>] [--name <имя>] [--rm] [-d] [--mount type=volume,source=<том>,destination=<путь_монтирования>] <образ> [-it <команда>]` - аналогично предыдущей;
- `docker container ls [-s] [-a]` - вывод списка работающих контейнеров [с их примерным размером] [всех контейнеров];
- `docker container inspect [-s] <контейнер>[ ...]` - вывод подробной информации о контейнере [с их общим размером];
- `docker container logs [-f] [--tail=<количество>] <контейнер>` - вывод логов контейнера [в реальном времени] [только указаное количество последних строк];
- `docker logs ...` - аналогично предыдущей;
- `docker container stop <контейнер>[ ...]` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время, `SIGKILL`;
- `docker stop ...` - аналогично предыдущей;
- `docker container kill <контейнер>[ ...]` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`;
- `docker kill ...` - аналогично предыдущей;
- `docker container rm <контейнер>[ ...]` - удаляет остановленный контейнер.
- `docker rm ...` - аналогично предыдущей;

## Тома Docker

**Том** - это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker.

### Команды для работы с томами

`docker volume create --name <имя_тома>` - создает том.  
`docker volume ls` - выводит список томов.  
`docker volume inspect <имя_тома>` - вывод подробной информации о томе.  
`docker volume rm <имя_тома>` - удаляет том.  
`docker volume prune` - удаляет не используемые контейнерами тома.  

## Другие команды

`docker stats $(docker ps -q)` - непрерывно выводит в консоль статуса работающих контейнеров.

`docker ps {--all | -a}` - выводит в консоль статус контейнеров.  
`docker ps {--quiet | -q}` - выводит в консоль только id контейнеров.

`docker exec -it <контейнер> sh` - подключается к докеру для выполнения команд. `exit` - выход из докера.

`docker system prune [-a] [--volumes]` - удаляет неиспользуемые контейнеры, которым не назначено имя и тег [все] , сети и образы, [тома].

`docker restart <контейнер>` - перезапускает указанный контейнер.  
`docker restart $(docker ps -a -q)`  - перезапускает все контейнеры.

## `docker-compose`

Файл `docker-compose.yml` - это файл Docker Compose, который будет содержать инструкции, необходимые для запуска и настройки сервисов.

```yml
version: "3"

# 1 сервис = 1 контейнер.
# Сервисом может быть клиент, сервер, сервер баз данных...

services:
    <имя_сервиса>:
        # Ключевое слово "build" позволяет задать путь к файлу Dockerfile, который нужно использовать для создания образа, который позволит запустить сервис.
        # Здесь <путь> соответствует пути к папке сервера, которая содержит соответствующий Dockerfile.
        build: <путь>

        # Команда, которую нужно запустить после создания образа.
        command: <команда>

        # Для перенаправления портов применяется следующая конструкция: [порт компьютера]:[порт контейнера]
        ports:
            - <порт_компьютера>:<порт_контейнера]>

        # Ключевое слово 'network_mode' используется для описания типа сети, указывается то, что контейнер может обращаться к 'localhost' компьютера.
        network_mode: host

        # Ключевое слово 'depends_on' позволяет указывать, должен ли сервис, прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы <имя_сервиса>.

        depends_on:
            - <имя_сервиса>

        # имя контенера
        container_name: <имя_контенера>
```

Порты контейнеров, назначенные в файлах Dockerfile, будут открыты в сети, организуемой Docker Compose.

`docker-compose build` - выполняет команды `build` для всех сервисов.

`docker-compose up` - запуск всех контейнеров.  
`docker-compose up -d` - запуск всех остановленных контейнеров.
`docker-compose -f <файл_конфигурации1>[ ...] up -d` - запуск всех контейнеров из файла с настройками, которые сливаются вместе при совпадении полей или дополняются.

`docker-compose down` - остановка всех контейнеров.  
`docker-compose restart`  - перезапускает все контейнеры.  
`docker-compose restart <контейнер>` - перезапускает указанный контейнер.

`docker-compose logs -f <контейнер>` - выводит журналы сервиса.

`docker-compose ps` - выводит список контейнеров.

`docker-compose exec <контейнер> <команда>` - выполняет команду в выполняющемся контейнере.

## Примеры

### Файлы для сервера ноды

Dockerfile для создания статики и запуска nginx сервера:
```Dockerfile
# использование образа с алиасом build для создания статики
FROM node:12-alpine as build
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# копирование исходного кода
COPY . /app
# запуск сборки
RUN npm run build
# использования образа nginx для запуска и отдачи статики
FROM nginx:1.16.0-alpine
# копирование из образа build из каталога /app/build в каталог /usr/share/nginx/html текущего образа
COPY --from=build /app/build /usr/share/nginx/html
# открытие порта 80 наружу
EXPOSE 80
# запуск команды на выполнение
CMD ["nginx", "-g", "daemon off;"]
```

Dockerfile для компиляции и запуска сервера ноды:
```Dockerfile
# использование образа с алиасом builder для комплиляции кода
FROM node:12-alpine as builder
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install
# копирование исходного кода
COPY . /app
# запуск компиляции
RUN npm run build
# использования образа ноды
FROM node:12-alpine
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование из образа builder из каталога /app/dist в каталог /app текущего образа
COPY --from=builder /app/dist /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# открытие порта 8080 наружу
EXPOSE 8080
# установка пользователя
USER node
# запуск команды на выполнение
CMD ["node", "index.js"]
```

Файл `docker-compose.yml` для запуска образов:
```yml
version: "3"
services:
  api:
    build: ./services/api
    ports:
      - "8080:8080"
    depends_on:
      - db
    container_name: blog-api
  client:
    build: ./services/client
    ports:
      - "80:80"
    container_name: blog-client
  db:
    image: mongo
    ports:
      - "27017:27017"
    container_name: blog-db
```

Для общения между контейнерами используется имя контейнера вместо ip адреса localhost.
> `mongodb://localhost:27017/blog` -> `mongodb://blog-db:27017/blog`

Kubernetes
==========

`minikube start --driver=hyperkit` - запускает эмуляцию кластера kubernetes с гипервизором для локальной разработки.

`kubectl cluster-info` - выводит информацию о кластерах.

`kubectl <action> <resource>` - базовая структура для большинства команд, где `<action>` - какое либо действие над ресурсом `<resource>`.

`kubectl get nodes` - выводит информацию о нодах.

`kubectl create deployment <имя_деплоя> --image=<docker_образ>` - создает размещение docker образа `<docker_образ>` приложения под именем `<имя_деплоя>`.  
`kubectl get deployments` - выводит информацию о размещениях.  
`kubectl describe deployment` - выводит информацию о размещении.  

`kubectl scale deployments/<имя_деплоя> --replicas=<количество>` - устанавливает количество реплик для размещения.

`kubectl set image deployments/<имя_деплоя> <имя_деплоя>=<docker_образ>` - обновляет образ размещения.

`kubectl rollout status deployments/<имя_деплоя>` - подтверждает обновления новым образом.  
`kubectl rollout undo deployments/<имя_деплоя>` - отклоняет обновления новым образом и возвращается на предыдущий.

**Узел** (node) - это отдельная физическая или виртуальная машина, на которой развернуты и выполняются контейнеры приложений. Каждый узел в кластере содержит сервисы для запуска приложений в контейнерах (например Docker), а также компоненты, предназначенные для централизованного управления узлом.

**Под** (pod) - базовая единица для запуска и управления приложениями: один или несколько контейнеров (Докер и подобные), которым гарантирован запуск на одном узле, обеспечивается разделение ресурсов и межпроцессное взаимодействие и предоставляется уникальный в пределах кластера IP-адрес, что позволяет приложениям, развернутым на поде, использовать фиксированные и предопределенные номера портов без риска конфликта. Поды могут напрямую управляться с использованием API Kubernetes или управление ими может быть передано контроллеру. Общие ресурсы: хранилище, сеть (один IP адрес и порт) и информация о запуске. Могут иметь метки. Поды находятся в приватной, изолированной сети и по умолчанию видны другим подам и сервисам в том же кластере. Сервер автоматически создает конечную точку для каждого пода основываясь на имени пода. Поды объединяются в `ReplicaSet`, который контролирует их количество и доступность и запускает новые, если старые умерли.

**Контроллер** (controller) - это процесс, который управляет состоянием кластера, пытаясь привести его от фактического состояния к желаемому; он делает это, оперируя набором подов, определяемых с помощью селекторов меток и являющихся частью определения контроллера.

`kubectl get rs` - выводит список подов в `ReplicaSet`.

`kubectl get pods [-l <метка>=<значение>] [-o wide]` - выводит список подов [отфильтрованых по метке и ее значению] [в расширенном формате].  
`kubectl describe pods` - выводит информацию о подах.

`kubectl logs <имя_пода>` - выводит логи пода, весь вывод в STDOUT.

`kubectl exec <имя_пода> -- <команда>` - выполняе команду на поде и возвращает весь ее вывод в STDOUT.  
`kubectl exec -ti <имя_пода> -- bash` - подключается к поду с терминалом.

`export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}{{.metadata.name}}{{"\n"}}{{end}}')` - получает имя текущего пода.  
`curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/` - возвращает информацию о поде.  
`curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/` - возвращает информацию о прокси пода.

`kubectl proxy` - создает прокси для соединения хостом и кластером.

**Сервис** - это совокупность логически связанных наборов подов и политик доступа к ним. Например, сервис может соответствовать одному из уровней программного обеспечения, разработанного в соответствии с принципами многоуровневой архитектуры программного обеспечения. Набор подов, соответствующий сервису, получается в результате выполнения селектора соответствующей метки. Сервисы позволяют приложениям получать внешний трафик с помощью меток - пары ключей и значений, и селекторов.

`kubectl get services [-l <метка>=<значение>]` - выводит список сервисов.  
`kubectl describe services/<имя_сервиса>` - выводит информацию о сервисе.  
`kubectl delete service -l <метка>=<значение>` - удаляет сервис с определенной меткой и ее значением.

`kubectl expose deployment/<имя_деплоя> --type="NodePort" --port <порт> service/<имя_сервиса> exposed` - создает сервис для открытия размещения по указанному порту.

`export NODE_PORT=$(kubectl get services/<имя_сервиса> -o go-template='{{(index .spec.ports 0).nodePort}}')` - получает порт сервиса.

`kubectl label pods <имя_пода> <метка>=<значение>` - устанавливает метку со значением поду.

Redis
=====

`redis-cli <команда>[ <арг1>[ ...]]` - базовое выполнение команд.

`redis-cli DEL <ключ>` - удаляет ключ.

`redis-cli HGET <ключ> <поле>` - выводит в консоль значение поля указаного ключа (хеш-таблицы).  
`redis-cli HSET <ключ> <поле> "<значение>"` - устанавливает значение поля указаного ключа (хеш-таблицы).

`redis-cli --raw keys *<маска>*` - возвращает список ключей, которые соответствуют маске.  
`redis-cli --raw keys *<маска>* | xargs redis-cli DEL` - удаляет все ключи, которые соответствуют маске

`curl`
======

`curl [<опции>] <url>` - базовый вызов адреса `<url>`, по умолчанию GET.

Опции:
- `-i` - выводит заголовки ответа;
- `-k` - обозначает что можно проводить небезопасный запрос, при невозможности подтверждения сертификата, при использовании протокола **https**;
- `-F '<имя_поля>=@<путь_к_файлу>'` - добавляет содержимое файла в указаное поле;
- `-X <тип_запроса>` - изменяет тип запроса на указанный (POST, GET, PUT, DELETE);
- `-H "<имя_заголовка>: <значение_заголовка>"` - добавляет заголовок в запрос;
- `-b "<имя_куки>=<значение_куки>"` - добавляет куку в запрос;
- `-d "<имя_поля>=<значение_поля>"` - добавляет значение ключа в POST-запрос;
- `--data "<тело>"` - добавляет тело в POST-запрос;
- `-o <путь_к_файлу>` - сохранит все в файл `<путь_к_файлу>`;
- `-w "\n\n%{time_connect}:%{time_starttransfer}:%{time_total}\n"` - выведет информацию о времени выполнения запроса.

Для запросов типа POST по умолчанию используется заголовки: `Content-Type: application/x-www-form-urlencoded`. Для передачи JSON нужно дополнительно пропичывать зоголовок: `Content-Type: application/json`.

Примеры:
- `curl -F '<имя_поля>=@<путь_к_файлу>'[ ...] <url>` - загружает файл на указанный адрес `<url>`;
- `curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <soap_метод_вызова>" --data-binary @<путь_к_файлу_xml> <url>` - отправляет soap запрос с указанным действием `<soap_метод_вызова>` на адрес `<url>` с телом запроса из файла;
- `curl -OL <url>` - загружает файл с адреса `<url>` в файл с именем после последнего `/` в адресе `<url>`.

`nmap`
======

`nmap <ip>` - производит сканирование портов. По итогу сканирования выводит информацию со статусами о портах:
-  `open` - приложение активно принимает соединения TCP, дейтаграммы UDP или ассоциации SCTP на этом порту;
- `closed` - закрытый порт доступен (он принимает и отвечает на зондовые пакеты nmap), но его не прослушивает ни одно приложение;
- `filtered` - нет возможности определить, открыт ли порт, потому что фильтрация пакетов не позволяет его зондам достичь порта. Фильтрация может осуществляться с помощью выделенного брандмауэра, правил маршрутизатора или программного обеспечения брандмауэра на хосте;
- `unfiltered` - нефильтрованное состояние означает, что порт доступен, но нет возможности определить, открыт он или закрыт;
- `open|filtered` - это те порты, для которых нет возможности определить, открыты или отфильтроваын. Это происходит для типов сканирования, при которых открытые порты не дают ответа. Отсутствие ответа может также означать, что пакетный фильтр отклонил зонд.
`closed|filtered` - это состояние используется, когда нет возможности определить, закрыт порт или фильтруется.

Основные ключи:
- `-p <порт_от>-<порт_до>` - устанавливает интервал портов для сканирования;
- `-p <порт_1>[,...]` - устанавливает порты для сканирования.

`nginx`
=======

`nginx -s <сигнал>` - посылает сигнал nginx, может быть:
- `stop` - быстрое завершение;
- `quit` - плавное завершение;
- `reload` - перезагрузка конфигурационного файла;
- `reopen` - переоткрытие лог-файлов.

Файл `nginx.conf` содержит конфигурацию, расположен по `/usr/local/nginx/conf`, `/etc/nginx`, `/usr/local/etc/nginx`.

`nginx -t` - проверяет конфигурацию на корректность.

Состоит из директив:
- **простая** - `<имя> <параметр_1>[ ...];`;
- **блочная** - `<имя> <параметр_1>[ ...] { ... }`.

`#` - обозначает коментарий.

Структура:
```nginx
http {
    server {
        listen <порт>; # порт прослушивания сервера

        server_name <имя_виртуального_сервера_1>[ ...]; # задает имя виртуального сервера

        root <путь_по_умолчанию_к_каталогу_с_файлами>; # будет использоваться, если в location не указана директива root

        # объявление секции потока
        upstream <upstream_name> {
            zone upstreams <количество>K; # указывает на количество общей памяти для рабочих процессов
            server <ip_адрес>:<порт> max_fails=<количество> fail_timeout=<количество_секунд>s; # указания одного сервера для перенаправления, могут повторяться с разными параметрами
            keepalive <количество>; # количество поддерживаемых соединений с вышестоящими серверами
        }

        location <префикс_пути_1> {
            root <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>/<префикс_пути_1>
        }

        location <префикс_пути_2> {
            proxy_pass <url>; # производит проксирование всех запросов по данному пути на указаный <url>
            # из исходного url вырезается все до <префикс_пути_2>, включая его и добавляется к <url>, поэтому нужно быть осторожным, чтобы не возникло два слеша //
            proxy_set_header Host $host; # для передачи имени хоста
        }

        location <префикс_пути_3> {
            alias <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>
        }

        location <префикс_пути_4> {
            proxy_set_header Host $host; # для передачи имени хоста
            proxy_http_version 1.1; # указывает использовать протокол версии 1.1
            proxy_set_header "Connection" ""; # указывает не завершать соединения
            proxy_pass http://<upstream_name>/; # перенаправляет все запросы на указанный upstream
            proxy_next_upstream error timeout http_500; # указывает передавать ошибки следующему серверу в вышестоящей группе
        }

        location = <путь> { # будет работать только для тех, которые точно равны указаному пути
            # ...
        }

        location ~ <регулярное_выражение> { # будет работать только для тех, которые совпадают с регулярным выражением, можно использовать выделения (), которые затем доступны в виде переменных $1..$9
            # ...
            # alias /usr/share/$1/$2
        }

        location ~* <регулярное_выражение> { # то же, только без учета регистра
            # ...
        }

        # ...
    }
    # ...
}
```

При этом выбирается самый больший префикс пути в директивах `location`.

Если не находится совпадение с директивами `location`, то возвращается заголовок **404**.

Если в регулярном выражении встречаются символы `}` или `;`, то все выражение следует заключить в одинарные или двойные кавычки.

При поиске виртуального сервера по имени, если имени соответствует несколько из указанных вариантов, например, одновременно подходят и имя с маской, и регулярное выражение, будет выбран первый подходящий вариант в следующем порядке приоритета:
- точное имя;
- самое длинное имя с маской в начале, например `*.example.com`;
- самое длинное имя с маской в конце, например `mail.*`;
- первое подходящее регулярное выражение (в порядке следования в конфигурационном файле).

## Подключение конфигурации

Для этого используется директива: `include <путь_к_файлу_конфигурации>;`, которая вставляет конфигурации из файла в указаное место, где путь `<путь_к_файлу_конфигурации>` может быть шаблоном.

## Переменные

`set $<имя_переменной> <значение>;` - устанавливает значение переменной. Значение `<значение>` может быть заключено в кавычки: `"<значение>"`. Также может содержать внутри себя переменные, которые заменятся на значение переменных.
> `set $USER release;`  
> `set $USER_FOLDER "/user/$USER/www";`

## Условия

```nginx
if (<условие>) {
    # ...
}
```

Где `<условие>` может быть вида:
- `<имя_переменной>` - при этом ложными значениями переменной являются пустая строка или `"0"`;
- `<имя_переменной> = <строка>`;
- `<имя_переменной> != <строка>`;
- `<имя_переменной> ~ <регулярное_выражение>` - можно использовать выделения `()`, которые затем доступны в виде переменных `$1`..`$9`;
- `<имя_переменной> !~ <регулярное_выражение>`;
- `<имя_переменной> ~* <регулярное_выражение>`;
- `<имя_переменной> !~* <регулярное_выражение>`.

## Глобвльные переменные

`$host` - содержит имя хоста из строки запроса, или имя хоста из поля `Host` заголовка запроса, или имя сервера, соответствующего запросу.

## Директивы

Директивы наследуются с предыдущего уровня конфигурации, или "сверху-вниз": дочерний контекст, будучи вложенным в другой контекст (родительский), наследует настройки директив, входящих в родительский уровень.

`add_header <заголовок> <значение>;` - добавляет заголовок со значением.

`return <код>[ "<содержимое>"];` - возвращает код ответа [и его содержимое].

`rewrite <регулярное_выражение> <строка> [permanent];` - переопределяет путь, который совпадает с регулярным выражением `<регулярное_выражение>`, на указаную строку `<строка>`, в которой можно использовать выделения `()` в виде переменных `$1`..`$9` из регулярного выражения.

`auth_basic "closed site";` - включает базовую HTTP-аутентификацию.  
`auth_basic_user_file <файл>;` - добавляет файл с логинами и паролями для прохождении аутентификации.

`allow {<ip_адрес> | <ip_подсеть>};` - разрешает доступ только из указанной ip подсети или ip адресов.  
`deny all;` - запрещает доступ отовюду, кроме разрешенных с помошью директив `allow`.

`vim`
=====

`vim <файл_1>[ ...]` - открывает файлы на редактирование в командном режиме.

`~/.vimrc` - файл с командами настроек, которые запускаются автоматически при открытии редактора. Команды пишутся без `:`.

`vim scp://<user>@<myserver>[:<port>]//<path_to_file>` - открывает файл на редактирование на сервере.
> `vim scp://user@myserver[:port]//path/to/file.txt`

## Обычный режим

Используется для редактирования файла путем ввода команд.

`:q` - выход из редактора.  
`:q!` - принудительный выход из редактора без сохранения файла.

`:w` - запись в файл.  
`:w <файл>` - запись в указанный файл, но при этом редактироваться продолжит исходный.  
`:wq` - запись в файл и выход из редактора.

`:e .` - выводит интерактивный текущий каталог с файлами и навигацией по ним.

`ZZ` - запись в файл и выход из редактора.

`i` - переход в режим вставки.

`v` - переход в визуальный режим.

`:` - переход в командный режим.

`u` - отмена предыдущей команды.

`a` - переход в конец файла и переход в режим вставки.  
`A` - переход в конец текущей строки и переход в режим вставки.

Команды перемешения:
- `l` - вправо на один символ;
- `h` - влево на один символ;
- `j` - вниз на один символ;
- `k` - вверх на один символ;
- `0` - в начало текущей строки;
- `^` - к первому не пробельному символу в текущей строке;
- `$` - в конец текущей строки;
- `w` - в начало следующего слова или знаку препинания;
- `W` - в начало следующего слова минуя знаки препинания;
- `b` - в начало предыдущего слова или знаку препинания;
- `B` - в начало предыдущего слова минуя знаки препинания;
- `CTRL + F` - вниз на одну страницу;
- `CTRL + B` - вверх на одну страницу;
- `<число>G` - к заданной строке в файле.
- `G` - к последней строке в файле.

Перед командой может указываться число, которое обычно обозначает количество повторений команды.
> `5j`  
> `5dd`

Команды вставки:
- `o` - добавляет строку ниже текущей;
- `O` - добавляет строку выше текущей.

Команды удаления:
- `x` - удаляет текущий символ;
- `dd` - вырезает текущую строку;
- `dW` - вырезает от текущего символа до начала следующего слова;
- `d$` - вырезает от текущего символа до конца текущей строки;
- `d0` - вырезает от текущего символа до начала строки;
- `d^` - вырезает от текущего символа до первого непробельного символа в строке;
- `dG` - вырезает от текущей строки до конца файла;
- `d<число>G` - вырезает от текущей строки до указанной строки.

Команды копирование:
- `yy` - копирует текущую строку;
- `yW` - копирует от текущего символа до начала следующего слова;
- `y$` - копирует от текущего символа до конца текущей строки;
- `y0` - копирует от текущего символа до начала строки;
- `y^` - копирует от текущего символа до первого непробельного символа в строке;
- `yG` - копирует от текущей строки до конца файла;
- `y<число>G` - копирует от текущей строки до указанной строки.

Команды вставки из буфера:
- `p` - вставка правее текушей позиции курсора;
- `P` - вставка левее текушей позиции курсора.

`J` - удаляет у текущей строки символ конца строки (объединяет две строки).

Команды поиска:
- `f<символ>` - переместит курсор к следующему вхождению символа в текущей строке, для повторения поиска используется `;`;
- `/<строка> + ENTER` - переносит курсор к следующему вхождению строки в файле, для повторения поиска используется `n`.

`:%s/<строка_поиска>/<строка_замены>/g + ENTER` - заменяет все строки на новые во всем файле.

Команды использования нескольких файлов:
- `:bn` - переключение на следующий файл;
- `:bp` - переключение на предыдущий файл;
- `:buffers [<номер_файла>]` - выводит список редактируемых файлов с возможностью выбора файла;
- `:e <файл>` - добавляет файл для редактирования.

`:r <файл>` - вставляет содержимое файла перед текущим курсором.

## Режим вставки

Используется для редактирования файла путем добавления текста.

`ESC` - переход в командный режим и окончание вставки текста.

## Визуальный режим

Используется для выделения текста в файле. В этом режиме клавиши перемещения будут выделять текст.

Выделенный текст можно скопировать `y` или удалить `d` с помощью команд обычного режима.

`ESC` - переход в командный режим.

## Командный режим

Используется для ввода команд.

`ESC` - переход в командный режим.

## Особые команды

`:syntax on` - включает подсветку синтаксиса.  
`:set syntax=<язык>` - устанавливает подсветку синтаксиса для определенного языка.
> `:set syntax=sh`

`:set hlsearch` - включает подсветку результатов поиска.

`:set tabstop=<количество>` - устанавливает длину символа tab.

`:set autoindent` - включает автоотступы для новых строк на основании предыдущей.
