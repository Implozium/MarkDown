jQuery
======

Добавление jQuery на страницы:

```html
<script type="text/javascript" src="jquery.min.js"></script>
```

## Команды jQuery

`$()` - это синоним для `jQuery()`.
`$('<селектор>')` - возвращает jQuery выборку элементов. Может принимать также стандартные элементы JS и `this`. Ее принято начинать именовать с `$`. Знак `$` сообщает, что символы идущие после него являются jQuery кодом;

Селектор позволяет выбрать элемент на странице, должен быть похожим на селектор CSS и позволяет указать дополнительные комманды:
- `:first` - первый элемент;
- `:last` - последний элемент;
- `:even` - все элементы списка с четными индексами;
- `:odd` - все элементы с нечетными индексами;
- `:eq(<номер>)` - элемент списка с указаным индексом, нумерация начинается с 0, если индекс меньше нуля, то с конца;
- `:gt(<номер>)` - все элементы списка, которые больше по индексу указанного, нумерация начинается с 0;
- `:lt(<номер>)` - все элементы списка, которые меньше по индексу указанного, нумерация начинается с 0;
- `:animated` - все анимированные элементы;
- `:contains('<строка>')` - все элементы содержащиеуказанную строку;
- `:empty` - все элементы не имеющие узлов потомков;
- `:hidden`- все скрытые элементы;
- `:visible` - все видимые элементы.

Стандартный синтаксис jQuery команд:  
`$('<селектор>').<метод>();`

Метод задает действие, которое необходимо совершить над выбранным элементом, подразделяются на следующие группы:
- методы для манипулирования DOM;
- методы для оформления элементов;
- методы для создания AJAX запросов;
- методы для создания эффектов;
- методы для привязки обработчиков событий.

### Загрузка кода после загрузки страницы

Для этого можно использовать один из вариантов:
- `$(document).ready(function () {<код>});`;
- `$().ready(function () {<код>});`;
- `$(function () {<код>});`.

### Цепочки команд

Можно соединять команды jQuery в цепочки, если они возвращают jQuery выборку элементов. Команды в цепочке будут выполняться поочередно слева направо.

`$('<селектор>').<метод_1>()[.<метод_2>()[....]];`

### Перебор выборки всех элементов

`<$_выборка>.each(function ([index[, element]]) {...})` - вызывает указанную функцию для каждого элемента в выборке, где `this` в контексте функции это элемент [`index` номер элемента в выборке [`element` сам элемент]], если функция возвратит `false`, то прервется цикл по элементам выборки.

## Методы навигации по DOM

`<$_выборка>.find('<селектор>')` - возвращает jQuery выборку элементов, которые выбраны по указанному селектору с указанной выборки.  
`<$_выборка>.closest('<селектор>')` - возвращает выборку из элементов для каждого текущего элемента обходя вверх по DOM дереву, до тех пор пок не найдет первое совпадение для заданного селектора.

`<$_выборка>.prev(['<селектор>'])` - возвращает выборку предыдущих элементов от текущих, [которые соответствуют указаному селектору].  
`<$_выборка>.next(['<селектор>'])` - возвращает выборку следующих элементов от текущих, [которые соответствуют указаному селектору].

`<$_выборка>.children(['<селектор>'])` - возвращает выборку всех детей текущих элементов, [которые соответствуют указаному селектору].  
`<$_выборка>.parent()` - возвращает выборку всех прямых родителей текущих элементов.  
`<$_выборка>.parents(['<селектор>']) `- возвращает выборку всех родителей текущих элементов, [которые соответствуют указаному селектору].

`<$_выборка>.filter('<селектор>')` - возвращает выборку из всех элементов, которые соответствуют указаному селектору.

`<$_выборка>.eq(<номер>)` - возвращает указанный `<номер>` элемента в выборке.  
`<$_выборка>.get(<номер>)` - возвращает указанный `<номер>` элемента в выборке в виде стандартного элемента.  
`<$_выборка>.get()` - возвращает все элементы выборки как массив в виде стандартных элементов.

`<$_выборка>.add({'<селектор>' | <$_выборка>})` - возвращает новую выборку с добавленными элементами.

`<$_выборка>.end()` - возвращает предыдущую выборку по стеку выборок.

## Атрибуты элементов и CSS

### CSS свойства

`<$_выборка>.css('<свойство>')` - получение значения CSS свойства, возвращает текущее значение, а не прописанное в CSS файле.  
`<$_выборка>.css('<свойство>', <значение>)` - установка значения CSS свойства.  
`<$_выборка>.css({'<свойство_1>': <значение>[, ...]})` - установка нескольких значений CSS свойств через структуру.  
`<$_выборка>.css('<свойство>', function (index, value) {return <новое_значение>})` - для установки значения используется функция обратного вызова,где `index` это порядковый номер элемента в выборке, `value` - старое значение свойства. Должна возвращать новое значение.

### CSS классы

`<$_выборка>.addClass('<имя_класса>')` - добавление класса элементу.  
`<$_выборка>.addClass(function (index, classList) {return '<имя_класса>'})` - добавление класса используя функцию обратного вызова, `classList` - список классов у элемента.  
`<$_выборка>.hasClass('<имя_класса>')` - проверка на причастность к определенному классу.  
`<$_выборка>.removeClass('<имя_класса>')` - удаление класса.  
`<$_выборка>.removeClass(function (index, classList) {return '<имя_класса>'})` - удаление класса используя функцию обратного вызова.  
`<$_выборка>.toggleClass('<имя_класса>')` - переключение класса.  
`<$_выборка>.toggleClass('<имя_класса>', <switch>)` - переключение класса по флагу `<switch>`, если равно `true`, то он добавиться, при `false` - удалиться.  
`<$_выборка>.toggleClass(function (index, classList, switch) {return '<имя_класса>'}, <switch>)` - переключение класса используя функцию обратного вызова.

В приведенных функциях в качестве `<имя_класса>` может быть строка содержащая список классов через пробел.

### Атрибуты

Атрибуты - это все то, что находится внутри самого тега.

`<$_выборка>.attr('<имя_атрибута>')` - получение значения атрибута.  
`<$_выборка>.attr('<имя_атрибута>', <значение_атрибута>)` - установка значения атрибута (также можно использовать объект, либо функцию обратного вызова, как у CSS свойств).  
`<$_выборка>.removeAttr('<имя_атрибута>')` - удаление атрибута.

### data-атрибуты

`<$_выборка>.data()` - возвращает объект со всеми ключами и значениями из реестра данных.  
`<$_выборка>.data('<ключ>')` - получение значения ключа из реестра данных, если его там нет то возвращается из атрибута тега `data-<ключ>`.  
`<$_выборка>.data('<ключ>', <значение>)` - установка значения ключа.  
`<$_выборка>.data({'<ключ_1>': <значение>[, ...]})` - установка нескольких значений ключей через структуру.  
`<$_выборка>.removeData('<ключ>')` - удаление ключа из реестра данных.

### Свойства элементов

К ним относится `selectedIndex`, `checked`, `selected`, `tagName`, `nodeName`, `nodeType`, `ownerDocument`, `defaultChecked` и `defaultSelected`.

`<$_выборка>.prop('<имя_свойства>')` - получение значения свойства.  
`<$_выборка>.prop('<имя_свойства>', <значение_свойства>)` - установка значения свойства (также можно использовать объект, либо функцию обратного вызова, как у CSS свойств).  
`<$_выборка>.removeProp('<имя_свойства>')` - удаление свойства.

## События

Основные события JavaScript:
- `change` - изменение значения элемента (значение, при потери фокуса, элемента отличается от изначального, при получении фокуса);
- `click` - клик по элементу (порядок событий: `mousedown`, `mouseup`, `click`);
- `dblclick` - двойной щелчок мышки;
- `resize` - изменение размеров элементов;
- `scroll` - скроллинг элемента;
- `select` - выбор текста (только для `input[type=text]` и `textarea`);
- `submit` - отправка формы;
- `focus` - фокус на элементе;
- `blur` - фокус ушел с элемента;
- `focusin` - фокус на элементе, данное событие срабатывает на предке элемента, для которого произошло событие `focus`;
- `focusout` - фокус ушел с элемента, данное событие срабатывает на предке элемента, для которого произошло событие `blur`;
- `keydown` - нажатие клавиши на клавиатуре;
- `keypress` - нажатие клавиши на клавиатуре (`keydown` -> `keypress` -> `keyup`);
- `keyup` - отжатие клавиши на клавиатуре;
- `load` - загрузка элемента;
- `unload` - выгрузка элемента;
- `mousedown` - нажатие клавиши мыши;
- `mouseup` - отжатие клавиши мыши;
- `mousemove` - движение курсора;
- `mouseenter` - наведение курсора на элемент, не срабатывает при переходе фокуса на дочерние элементы;
- `mouseleave` - вывод курсора из элемента, не срабатывает при переходе фокуса на дочерние элементы;
- `mouseover` - наведение курсора на элемент;
- `mouseout` - вывод курсора из элемента.

Методы для работы с событиями:  
`<$_выборка>.<событие>()` - вызов события на элементах выборки.

Установка обработчика события:

```javascript
<$_выборка>.<событие>(function (event) {
    ...
    event.stopImmediatePropagation() //останавливает цепочку вызова событий для последующих слушателей DOM элемента, то есть события оставшихся слушателей вызваны не будут
    event.preventDefault(); //отменяет стандартное действие
    event.stopPropagation(); //отменяет всплытие события
    return false; //совмещает две предыдущие инструкции
});
```

`<$_выборка>.on('<событие>'[, '<селектор>'][, <данные>], function (event) {...})` - установка обработчика события (`'<событие>'` - может быть списком событий разделенных пробелом: `'<событие_1>[ <событие_2>[ ...]]'`) для элементов (аналогично `addEventListener`) [динамически для указанных `<селектор>` внутри элементов выборки, при условии что к ним будет относиться событие] [где `<данные>` будут доступны в `event.data`, когда событие вызовется].  
`<$_выборка>.off('<событие>'[, '<селектор>'][, <функция_обработчика>])` - удаления обработчиков события на элементах.

`<$_выборка>.trigger('<событие>'[, <данные>])` - вызов указаного события [где `<данные>` должны быть массивом или объектом и они перададутся в функцию обработки как дополнительные параметры].

`<$_выборка>.bind('<событие>'[, <данные>], function (event) {...})` - привязывает функцию обработчик к событию.  
`<$_выборка>.unbind(['<событие>'])` - удаления обработчиков события на элементах.

Можно повесить обработчик событий практически на любой объект.

### Пространство имен

Задаются как дополнение к `'<событие>'` после точки `.`:  
`'<событие>.<пространство_имен>'`

Могут использоваться для вызова обработчиков:  
`'<событие>.<пространство_имен>[.<пространство_имен>[...]]'`

Можно удалить все обработчики с определенного пространства имен:  
`'.<пространство_имен>'`

## Анимация

`<$_выборка>.hide([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - скрывает элементы, оперирует лишь CSS атрибутом `display`, переключая его из текущего состояния в `none`[, оперирует `width`, `height`, `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`) [и вызывает указаную функцию после завершения анимации]].  
`<$_выборка>.show([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - показывает элементы.  
`<$_выборка>.toggle([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - работает как переключатель `hide` -> `show` или `show` -> `hide`.  
`<$_выборка>.toggle({true | false})` - отображает элемент при `true`, скрывает при `false`.

Функции анимации из семейства `slide` - оперирует `height`, `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`, по ум. = `200`):  
`<$_выборка>.slideUp([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - скрывает.  
`<$_выборка>.slideDown([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - показывает.  
`<$_выборка>.slideToggle([{'slow' | 'fast' | <количество_мс>}[, function () {..}]])` - скрывает или показывает в зависимости от состояния.

Функции анимации из семейства `fade` - оперирует `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`, по ум. = `200`):  
`<$_выборка>.fadeIn([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - изменяет `opacity` от `0` до предыдущего.  
`<$_выборка>.fadeOut([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - изменяет `opacity` от текущего до `0`.  
`<$_выборка>.fadeToggle([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - переключатель между `In` и `Out`.  
`<$_выборка>.fadeTo([{{'slow' | 'fast' | <количество_мс>}, <прозрачность>[, function () {...}]])` - изменяет значение `opacity` до требуемого значения.

### `animate`

Данная функция берет один или несколько CSS-свойств элемента и изменяет их от исходного до заданного за N-ое количество итераций (количество итераций зависит от указанного времени, но не реже одной итерации в 13мс).

```javascript
<$_выборка>.animate({
        '<свойство_1>': <значение>, //изменяет текущее значение до указаного
        '<свойство_2>': {'show' | 'hide' | 'toggle'}, //изменяет текущее значение по указаной схеме
        '<свойство_3>': {+=<значение> | -=<значение>} //изменяет на указаное значение
        [, ...]
    },
    {'slow' | 'fast' | <количество_мс>} //скоростью изменения
    [, {'linear' | 'swing'} //функция для изменения значений процесса анимации
    [, function () {...}]] //функция обратного вызова после завершения анимации
)
```

Второй вариант:  
`<$_выборка>.animate(<CSS_свойства>, <опции>)`, где у опции может быть:
- `duration` - скоростью изменения - `'slow'` | `'fast'` | `<количество_мс>`;
- `easing` - функция для изменения значений процесса анимации: `'linear'` | `'swing'`;
- `complete` - функция обратного вызова после завершения анимации: `function () {...}`;
- `step` - функция, которая будет вызвана на каждом шаге анимации: `function (now, obj) {...}`. Где у `obj` имеются свойства:
    - `elem` - объект анимации;
    - `prop` - параметр, который анимируется;
    - `start` - начальное значение;
    - `end` - конечное значение;
    - `pos` - коэффициент, изменяется от 0 до 1;
    - `options` - опции настроек анимации.
    `now` - текущее значение анимированного параметра, вычисляется как: `now = (obj.end - obj.start) * obj.pos`;
- `queue` - флаг/параметр очереди, при значении строки равной `<имя_очереди_анимации>`, то укажет имя очереди анимации и автоматомически при это не стартует, при значении `false` анимации будут выполняться параллельно;
- `specialEasing` - объект в котором можно описать какую именно `easing` функцию следует использовать для изменения определенных параметров.

Если `animate` указывать за `animate`, то будет выполняться последовательный вызов анимаций, сразу после завершения предыдущей.

`$('html').animate({scrollTop: $('.class').offset().top})`

`<$_выборка>.dequeue(<имя_очереди_анимации>)` - запускает указаную очередь анимации.

#### Остановка анимации

`<$_выборка>.stop([<имя_очереди_анимации>, ][<очистка_очереди>[, <применение_результата>]])` - останавливает анимацию [указанной очереди, по ум `'fx'`] [с очищением очереди всех последующих анимаций, если `true` [и применением результата анимации, если `true`]].

`jQuery.fx.off = true;` - отключает всю анимацию

## Манипуляции с DOM

### Создания элементов

`$('<<имя_тега>>'[, <объект_атрибутов_элемента>])` - создает jQuery элемент.

### Перемещение элементов

`<$_выборка>.after('<контент>')` - вставляет контент после каждого элемента из выборки.  
`<$_выборка>.insertAfter({'<селектор>' | <элементы>})` - вставляет элементы из выборки после каждого элемента переданного в качестве аргумента.  
`<$_выборка>.before('<контент>')` - вставляет контент перед каждым выбранным элементом.  
`<$_выборка>.insertBefore({'<селектор>' | <элементы>})` - вставляет элементы из выборки перед каждым элементом переданным в качестве аргумента.

`<$_выборка>.append('<контент>')` - вставляет контент в конец каждого элемента из выборки.  
`<$_выборка>.appendTo({'<селектор>' | <элементы>}) `- вставляет выбранный контент в конец каждого элемента переданного в качестве аргумента.  
`<$_выборка>.prepend('<контент>')` - вставляет контент в начало каждого элемента из выборки.  
`<$_выборка>.prependTo({'<селектор>' | <элементы>})` - вставляет выбранный контент в начало каждого элемента переданного в качестве аргумента.

`<$_выборка>.replaceWith('<контент>')` - заменяет найденные элементы новым контентом.  
`<$_выборка>.replaceAll({'<селектор>' | <элементы>})` - вставляет элементы в замен найденному.

`<$_выборка>.wrap({'<селектор>' | <элементы>})` - оборачиваем каждый найденный элемент новым элементом.  
`<$_выборка>.wrapAll({'<селектор>' | <элементы>})` - оборачивает все найденные элементы новым элементом.  
`<$_выборка>.wrapInner({'<селектор>' | <элементы>})` - оборачивает контент каждого найденного элемента новым элементом, оставляя при этом элементы на своих местах.  
`<$_выборка>.unwrap()` - удаляет родительский элемент у найденных элементов.

`<$_выборка>.clone([true])` - клонирует выбранные элементы, для дальнейшей вставки копий назад в DOM, позволяет так же копировать и обработчики событий.

`<$_выборка>.detach()` - удаляет элемент из DOM, но при этом сохраняет все данные о нем в jQuery, используется, если надо удалить элемент, а потом вернуть его обратно.  
`<$_выборка>.empty()` - удаляет текст и дочерние DOM элементы.  
`<$_выборка>.remove()` - удаляет элемент из DOM, насовсем.

`<$_выборка>.html()` - возвращает HTML заданного элемента.  
`<$_выборка>.html(<html>)` - заменяет HTML в заданном элементе.  
`<$_выборка>.text()` - возвращает текст заданного элемента, если внутри элемента будут другие HTML тэги, то вернется текст всех элементов.  
`<$_выборка>.text(<text>)` - заменяет текст внутри выбранных элементов, при попытке вставить таким образом HTML, будет получен текст, где тэги будут приведены к `HTML entities`.

### Размеры элементов

`<$_выборка>.offset()` - возвращает позицию DOM элемента относительно `document`'а, данные будут получены в виде объекта: `{top: <поз_сверху>, left: <поз_слева>}`.  
`<$_выборка>.offset({top: <поз_сверху>, left: <поз_слева>})` - устанавливает расположение DOM элемента по указанным координатам.

`<$_выборка>.position()` - возвращает позицию DOM элемента относительно родительского элемента.

`<$_выборка>.height([<высота>])` - возвращает высоту элемента за вычетом отступов и границ; если у нас несколько элементов в выборке, возвратит первое; значение, в отличии от метода `css('height')`, возвращается без указания единиц измерения [, устанавливает высоту всех элементов в выборке, если значение высоты передано без указания единиц измерения, то это будут "px"].  
`$(window).height()` - высота окна.  
`$(document).height()` - высота HTML документа.  
`<$_выборка>.width([<ширина>])` - возвращает ширину элемента [, устанавливает ширину всех элементов в выборке].  
Методы `height()` и `width()` не изменяют своего поведения в зависимости от выбранной блочной модели, т.е. они всегда возвращают параметры области внутри `margin`, `padding` и `border`'а элемента.

`<$_выборка>.innerHeight()` и `<$_выборка>.innerWidth()` - возвращают высоту и ширину элемента, включая `padding`.  
`<$_выборка>.outerHeight([true])` и `<$_выборка>.outerWidth([true])` - возвращают высоту и ширину элемента, включая `padding`, `border` [и `margin`].

### Прокрутка

`<$_выборка>.scrollLeft([<значение>])` - возвращает значение "проскроленности" по горизонтали первого элемента из выборки [, устанавливает значение горизонтального скрола для каждого элемента из выборки].  
`<$_выборка>.scrollTop([<значение>])` - возвращает значение "проскроленности" по вертикали первого элемента из выборки [, устанавливает значение вертикального скрола для каждого элемента из выборки]

Значение `"scrollTop"` и `"scrollLeft"` поддаются анимации и не работают для спрятанных элементов DOM.

## Работа с формами

`<$_выборка>.serialize()` - возвращает данные с формы в виде строки: `<name>=<value>[&...]`.  
`<$_выборка>.serializeArray()` - возвращает данные с формы в виде массива объектов.

## AJAX

`<$_выборка>.load("<url>"[, <данные>][, function (<строка_ответа>, <текст_статуса>, <jqXHR>) {...}])` - загружает данные с указанного адреса [, передавая дополнительные данные] в элемент [и вызывая после этого функцию обратного вызова].

`$.ajax(<опции>)` - где `<опции>` - объект со свойствами:
- `url` - в виде `"<url>"` - адрес запроса;
- `method` - метод запроса, один из `"POST"` | `"GET"` | `"PUT"`;
- `dataType` - тип загружаемых данных, один из `"html"` | `"xml"` | `"text"` | `"json"` | `"script"` | `"jsonp"`;
- `success` - функция вызова при удачном запросе: `function (data) {...}`, где `data` - пришедшие данные в указаном формате;
- `data` - данные для передачи, должны быть в виде массива, объекта или строки;
- `error` - возникает в случае ошибки: `function (error) {...}`, где `error` - ошибка.

События AJAX для элементов, для которых можно установить обработчики в объекте `<опции>`:
- `ajaxStart` - данное событие возникает в случае когда начался первый AJAX запрос, и при этом других активных AJAX запросов в данный момент нет;
- `beforeSend` - возникает до отправки запроса, позволяет редактировать `XMLHttpRequest`, локальное событие;
- `ajaxSend` - возникает до отправки запроса, аналогично `beforeSend`;
- `success` - возникает по возвращению ответа, когда нет ошибок ни сервера, ни вернувшихся данных, локальное событие;
- `ajaxSuccess` - возникает по возвращению ответа, аналогично `success`;
- `error` - возникает в случае ошибки, локальное событие;
- `ajaxError` - возникает в случае ошибки;
- `complete` - возникает по завершению текущего AJAX запроса (с ошибкой или без - срабатывает всегда), локальное событие;
- `ajaxComplete` - глобальное событие, аналогичное `complete`;
- `ajaxStop` - данное событие возникает в случае, когда больше нету активных запросов.

Эти имена событий могут использоваться в `$.ajax`, тогда они будут глобальными.

### Префильтры

**Префильтр** - это функция, которая будет вызвана до `ajaxStart`, в можно изменить как объект `jqXHR`, так и любые сопутствующие настройки.

`$.ajaxPrefilter(['<типы_возвращаемых_ajax_данных>',] function (options, originalOptions, jqXHR) {...});`. Где:
- `options` - настройки запроса (то что указывается при вызове "$.ajax()");
- `originalOptions` - "чистые" настройки, даже без учета изменений "по умолчанию";
- `jqXHR` - объект "jQuery XMLHttpRequest".

Их можно использовать для кэшрования результата или перенаправлении запросов на другой адрес.

### Конвертеры

**Конвертор** - функция обратного вызова, которая вызывается в том случае, когда полученный типа данных не совпадает с ожидаемым.

`$.ajaxSetup({converters: <конвертеры>})` - где `<конвертеры>` - объект, который должен содержать свойства в указаном формате:  
`"{<входящий_тип> | *} <тип_преобразования>": function (textValue) {... return <newValue>}` - должна возвращать значение в типе преобразования или бросать исключение.

### Транспорт

**Транспорт** - это объект, который предоставляет два метода - `send()` при отправке и `abort()` при отмене - они будут использоваться внутри метода `$.ajax()`.

`$.ajaxTransport(['<типы_возвращаемых_ajax_данных>',] function (options, originalOptions, jqXHR) {...})`, где тело функции может быть:

```javascript
if (<необходим_транспорт>) {
    return {
        send: function (headers //заголовки запроса в виде связки ключ-значение
            , function (status //HTTP статус ответа
                , statusText //текстовая интерпретация ответа
                , responses //объект содержащий ответы сервера во всех форматах, которые поддерживает транспорт
                , headers //строка содержащие заголовки ответа сервера, если конечно транспорт может их получить
            ) {...} /// функция обратного вызова, используется для оповещения о завершении запроса
        ) {...},
        abort: function () {...}
    };
}
```

## Объект `Deferred` и подобные

`Deferred` используется чтобы заставлять асинхронный JavaScript работать синхронно.

`var <Deferred> = $.Deferred()` - инициализация `Deferred` объекта со статусом "ожидает выполнение".

`<Deferred>.done(function (data) {...}[, ...])` - добавление одного обработчика для успеха, где `data` - данные, которые были переданы с помощью метода `<Deferred>.resolve(<данные>)`, возвращает самого себя - `<Deferred>`.  
`<Deferred>.fail(function (error) {...}[, ...])` - добавление одного обработчика для ошибки, где `error` - данные, которые были переданы с помощью метода `<Deferred>.reject(<данные>)`, возвращает самого себя - `<Deferred>`.  
`<Deferred>.always(function (data) {...}[, ...])` - добавление одного обработчика для любого исхода, возвращает самого себя - `<Deferred>`.  
`<Deferred>.then(function (data) {...}, function (error) {...})` - добавление одного обработчика для успеха и для ошибки, возвращает самого себя - `<Deferred>`.

`<Deferred>.resolve([<данные>])` - изменения статуса на "выполнен успешно" и вызов всех обработчиков для успеха в порядки очереди, но они будут выполняться параллелено.  
`<Deferred>.reject([<ошибка>])` - изменения статуса на "выполнен с ошибкой" и вызов всех обработчиков для ошибки.

Если будут подключены обработчики после вызова метода который меняет статус, то он сразу выполнится.

`<Deferred>.promise()` - возвращает искомый объект в режиме "read only".

`$.when(<Deferred>[, ...])` - реализует интерфейс `Deferred`, возвращает проекцию `Deferred` объекта, принимает в качестве параметров произвольное множество `Deferred` объектов, когда все из них отработают, объект `when` изменит свое состояние в "выполнено", с последующим вызовом всех подписавшихся.

Также методы `ajax()` и `animate()` реализуют интерфейс `Deferred`.

### Методы уведомлений

`<Deferred>.progress(function (data) {...}[, ...])` - регистрирует функцию для получения уведомлений.  
`<Deferred>.notify([<данные>])` - посылает уведомления во все зарегистрированные функции, т.е вызывает их [и передает в них указанные данные].

## `Callbacks`

`Callbacks` - позволяет составлять списки функций обратного вызова и вызывать их всех по надобности.

`var <Callbacks> = $.Callbacks([<флаги>])` - где `<флаги>` могут быть:
- `'once'` - все функции будут вызваны единожды (аналогично как в Deferred);
- `'memory'` - сохранять значение с последнего вызова `fire()`, и передача его в ново-зарегистрированные функции обратного вызова, и лишь потом обрабатывает новое значение (как в `Deferred`);
- `'unique'` - список функций обратного вызова фильтруется по уникальности;
- `'stopOnFalse'` - как только какая-нить функция вернет `false`, процесс запуска остановится.

`<Callbacks>.add(function (data) {...}[, ...])` - регистрирует функцию обратного вызова.  
`<Callbacks>.fire([<данные_для_функций>])` - вызывает все зарегистрированные функции обратного вызова в порядке их добавления.

## Дополнительные методы

`$.extend([true, ]{{} | <object_1>}[, <object_2>[, ...]])` - сливает содержимое двух и более объектов в первый и возвращает его [и включая вложенные объекты].

## jQuery плагин

`$.fn.<имя_плагина> = function (params) {...}` - объявление плагина, при этом `this` содержит jQuery объект с коллекцией всех элементов, а `params` - объект параметров инициализации, используется такая схема объявления плагина:

```javascript
(function ($) {
    var defaults = {'<параметр_1>': <значение>[, ...]}; //параметры по умолчанию
    var options; //актуальные настройки, глобальные
    $.fn.<имя_плагина> = function (params) {
        options = $.extend({}, defaults, options, params); //при многократном вызове настройки будут сохранятся и замещаться при необходимости
        ...
        return this;
    };
})(jQuery);
```

`<$_выборка>.<имя_плагина>([<объект_параметров_инициализации>])` - создание плагина.

### Публичные методы

Методы объявляются в отдельном объекте, где **ключ** - это названия метода, а его **значение** - это реализация метода.

Для использования метода необходимо изменить функцию инициализатор плагина, при таком подходе будет происходить вызов метода, если он есть, со всем списком аргументов, иначе будет выполняться инициализация:

```javascript
    var methods = {...}; //описание методов.
    $.fn.<имя_плагина> = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else {
            ...//метод инициализации
        }
        ...
    }
```

`<$_выборка>.<имя_плагина>([<имя_метода>][, <аргумент_1>[, ...]])` - вызов метода.

Если плагин вешает какой-либо обработчик, то лучше всего всегда данный обработчик повесить в своем собственном пространстве имен `namespace`.

Webpack
=======

`npm i -g webpack` - инсталляция.  
`npm i webpack` - инсталляция локальная, для установки всех дополнительных модулей.

## Включение зависимостей

Базовая конфигурация представляет собой импорт и экспорт как в NodeJs. Для включения файла в файл необходимо написать:  
`var <модуль> = require('<имя_файла>');`

### Сборка

`webpack <имя_входного_файла> <имя_выходного_файла>` - запуск, - эта команда скомпилирует модуль `<имя_входного_файла>` и соберет все необходимые зависимости в один файл `<имя_выходного_файла>`, готовый к использованию в браузере.

Параметр `--watch` позволяет Webpack наблюдать за файлами от которых зависит модуль и пересобирать модуль по мере изменения файлов.

## Конфигурация

В файле `webpack.config.js` помещается код, внутри можно использовать любой код из NodeJs или Js. Это - модуль, экспортирующий объект конфигурации, который читает Webpack при вызове его из командной строки без аргументов. Сам конфигурационный модуль должен экспортировать объект опций:  
`module.exports = <объект_опций>;`

`const NODE_ENV = process.env.NODE_ENV || 'developer';` - позволяет взять переменную окружения, для дальнейшего использования в конфигурирование.

`const webpack = require('webpack');` - используется для установки плагинов

`webpack` - запуск, с использованием файла `webpack.config.js`.

Пример использования библиотек:  
`npm install jquery` - установка.  
`const $ = require('jquery');` - подключение и использование.

## Свойства

Пример конфигурации:

```javascript
const path = require('path');

module.exports = {
    entry: path.join(__dirname, "src", "main.js"),
    output: {
        path: path.join(__dirname, "dist"),
        filename: "bundle.js"
    },
    module: {
        loaders: [
            {
                test: path.join(__dirname, "src"),
                loader: 'babel-loader',
                query: {
                    presets: ['es2015']
                }
            }
        ]
    },
    plugins: [definePlugin, uglifyJsPlugin]
};
```

Основные свойства:
- `entry` - отвечает за входной файл, точку входа, задается в виде `"<путь_к_модулю>"`;
- `context` - означает базовое нахождение модулей (для точки входа, `entry`), задается в виде `"<путь_к_модулям>"`;
- `output` - отвечает за выходной файл, задается в виде объекта со свойствами:
    - `filename` - имя выходного файла, задается в виде `"<имя_конечного_файла>"`;
    - `path` - путь к каталогу выходного файла, задается в виде `"<путь>"`;
    - `library` - в этот объект поместится все то что экспортируется из входного файла (для точки входа, `entry`): `exports.<имя> = <значение>`, и тогда онобудет доступно как `<имя_библиотеки>.<имя>`, задается в виде `"<имя_библиотеки>"`;
- `module` - отвечает за утилиты для сборки, задается в виде объекта со свойствами:
    - `loaders` - массив загрузчиков, каждый из которых выполняет конкретное преобразование, задается в виде массива, который содержит объекты определенной структуры:
        - `test` - маска соответствия загрузчику, задается в виде строки или регулярного выражения;
        - `include` - включает только файлы, которые соответствуют указанному пути, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
        - `exclude` - исключает файлы, которые соответствуют указанному пути, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
        - `loader` - имя загрузчика, задается в виде `"<имя_модуля>"`;
    - `noParse` - используется для исключения файлов из обработки, которые соответствуют указаным маскам, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
- `plugins` - отвечает за плагины, задается в виде массива, который содержит объекты плагинов;
- `watch` - указывает при значении `true` что нужно наблюдать за файлами и пересобирать их по их изменению (сохранению), после этого `webpack` будет запущен и наблюдать за файлами;
- `watchOptions` - отвечает за опции наблюдения, задается в виде объекта со свойствами:
    - `aggregateTimeout` - указывает время ожидания для пересборки в мс (по ум. 300), задается в виде числа `<время_мс>`;
- `devtool` - отвечает за "карту модулей" в файле `<имя_конечного_файла>.map` для удобной отладки по модулям, задается в виде одного из значений: `"source-map"`, `"cheap-source-map"`, `"cheap-module-eval-source-map"`;
- `resolve` - используется для поиска входных модулей, задается в виде объекта со свойствами:
    - `modules` - отвечает за каталоги поиска, задается в виде массива, должен включать `"node_modules"`;
    - `extensions` - отвечает за расширения файлов, задается в виде массива, должен включать `""`;
    - `root` - отвечает за дополнительный, корневой каталог поиска модулей;
    - `alias` - используется для указания алиасов путям подключения файлов, задается в виде объекта, где ключ - это алиас, а значение - это путь к модулю.

### Плагины

Плагины можно повторять.

#### Плагин `webpack.EnviromentPlugin`

Позволяет в скрипты передавать значения переменных окружения, и тогда их можно использовать как: `process.env.<имя_переменной_окружения>`.

`const EnviromentPlugin = new webpack.EnviromentPlugin('<имя_переменной_окружения>'[, ...]);`.

#### Плагин `webpack.DefinePlugin`

Позволяет заменить отдельные фрагменты исходного кода динамическим кодом или постоянными значениями.

`const definePlugin = new webpack.DefinePlugin(<объект_замен>);` - где `<объект_замен>` - представляет собой объект, где ключи - это то что нужно заменить, а значение - это то на что нужно заменить.

#### Плагин ` webpack.optimize.UglifyJsPlugin`

Применяется для обфускации и минификации JavaScript-кода в файле пакета с помощью `UglifyJs`.

`const uglifyJsPlugin = new webpack.optimize.UglifyJsPlugin(<объект_опций>);` - где `<объект_опций>` - представляет собой объект с опциями и свойствами:
- `beautify` - при значении `true` помогает избежать удаления всех отступов и пробельных символов, чтобы проще было читать получившийся файл пакета, по умолчанию `false`;
- `dead_code` - при значении `true`, удаляет все, что сочтет "мертвым кодом", поэтому текущий код чистится, по умолчанию `false`;
- `compress` - отвечает за сжатие, представляет собой объект с опциями и свойствами:
    - `warnings` - при значении `true` убирает предупреждения, по умолчанию `false`;
    - `drop_console` - при значении `true` убирает вывод в консоль, по умолчанию `false`;
    - `unsafe` - при значении `true` позволяет использовать не безопасные возможности во время сжатия, по умолчанию `false`.

#### Плагин `webpack.NormalModuleReplacementPlugin`

Позволяет заменять ресурсы, которые соответствуют регулярному выражению другим ресурсом.

`const NormalModuleReplacementPlugin = new webpack.NormalModuleReplacementPlugin(/<рег_выражение_поиска>/, "<путь_к_ресурсу>");` - если ресурс соответствует регулярному выражению `/<рег_выражение_поиска>/`, он заменяется ресурсом, указанным в `"<путь_к_ресурсу>"`.

#### Плагин `webpack.NoErrorsPlugin`

Позволяет не собирать сборку, если есть какая-то ошибка в сборке.

`const NoErrorsPlugin = new webpack.NoErrorsPlugin();`.

#### Плагин `webpack.CommonsChunkPlugin`

Позволяет вынести общую часть из всех модулей в один файл. Также можно объявить в `entry`: `"common": "<путь_к_общему_модулю>"`. Тогда в файл внесется и еще указанный модуль.

`const CommonsChunkPlugin = new webpack.CommonsChunkPlugin(<объект_опций>);` - где `<объект_опций>` - представляет собой объект с опциями и свойствами:
- `name` - имя общего файла;
- `minChunks` - минимальное количество файлов использования общей части, по умолчанию все, задается в виде числа.


Тестирование
============

## Автоматические тесты при помощи chai и mocha

**Автоматизированное тестирование** - это когда тесты написаны отдельно от кода, и можно в любой момент запустить их и проверить все важные случаи использования.

**Тесты BDD** (*Behavior Driven Development*) - это три в одном: И тесты И документация И примеры использования одновременно. Тесты в этом случае формируются по принципу:  
`as <someone> i want to do <something> so that <result>` - `как <кто-то> я хочу <что-то> так, чтобы <результат>`
> `Как пользователь Почты Yandex я хочу присоединить изображение к своей электронной почте так, чтобы его видели мои получатели`

**Спецификация** это то, что функция будет делать и можно это описать это по методике BDD:
```javascript
describe("<имя_тестируемой_сущности>", function () {
    it("<что_делает_функция>", function () {
        assert.equal(<тестируемая_функция>(...), <ожидаемый_результат>);
    });
});
```

У спецификации есть три основных строительных блока:
- `describe("<имя_тестируемой_сущности>", function () {...})` - задает, что именно описывается, используется для группировки "рабочих лошадок" - блоков `it`;
- `it("<что_делает_функция>", function () {...})` - в названии блока `it` человеческим языком описывается, что должна делать функция (с маленькой буквы), далее следует тест, который проверяет это;
- `assert.equal(<значение_1>, <значение_2>)` - код внутри `it`, если реализация верна, должен выполняться без ошибок.

Различные функции вида `assert.*` используются, чтобы проверить, делает ли `<тестируемая_функция>` то, что задумано.

### Основные правила по именованию

Описание теста должно описывать то, что он проверяет ожидаемое действие или поведение при наступлении определенного события / условия / сценария: `should {<expected_behavior> | <verb> <expected_outcome>} when <specific_condition>` (`дожнен / должна {<ожидаемое_действие> | <поведение>} при / в случае / если {<название_сценария> | <краткое_описание_условия>}`):
> `should display error message when validation fails`

Тесты должны групироваться в описательном контексте: `{<Component> | <Feature>} should <expected_behavior> when <specific_condition>` (`<конкретная_сущность> должна ожидаемое действие / поведение [когда / при / если {<сценарий> | <контекст>}]`):
```javascript
describe("{<Component> | <Feature>}", () => {
    describe("when <specific_condition>", () => {
        it("should <expected_behavior>", () => {});
    });
});
```

```javascript
describe("<конкретная_сущность>", () => {
    describe("когда / при / если {<сценарий> | <контекст>}", () => {
        it("дожнен / должна {<ожидаемое_действие> | <поведение>} при / в случае / если {<название_сценария> | <краткое_описание_условия>}", () => {});
    });
});
```

```javascript
describe("AuthForm", () => {
    describe("when form is empty", () => {
        it("should disable submit button", () => {});
        it("should not show any validation errors", () => {});
    });

    describe("when submitting invalid data", () => {
        it("should show validation errors", () => {});
        it("should keep submit button disabled", () => {});
    });
});
```

Описание теста должно описывать значения состояний до и после: `should change <attribute> from <initial_state> to <final_state>`:
> `should change status from pending to approved`  
> `should mark todo as completed when checkbox clicked`

Описание теста должно включать состояния загрузки и результирующее состояние для асинхронных операций: `should {<expected_behavior> | <verb> <expected_outcome>} {during | after } <async_operation>`:
> `should show skeleton while loading data`  
> `should render profile after user data loads`

Описание теста для ошибок должно включать тип ошибки и причину почему она произошла: `should show <specific_error_message> when <error_condition>`:
> `should show network error when API is unreachable`  
> `should display "Required" when password is empty`

Описание теста должно описываться бизнес языком, а не техническим: `should <business_action> <business_entity>`:
> `should save customer order`

Тесты для процессов должны описываться шаг за шагом в виде блоков:
```javascript
describe("<complex_process>", () => {
    it("should first <initial_step>", () => {});
    it("should then <next_step>", () => {});
    it("should finally <final_step>", () => {});

    describe("after <key_milestone>", () => {
        it("should <follow-up_action>", () => {});
    });
});
```

```javascript
describe("Checkout Process", () => {
    it("should first validate items are in stock", () => {});
    it("should then collect shipping address", () => {});
    it("should finally process payment", () => {});

    describe("after successful payment", () => {
        it("should display order confirmation", () => {});
        it("should send confirmation email", () => {});
    });
});
```

Пример теста:
```javascript
describe("ShoppingCart", () => {
    describe("when adding items", () => {
        it("should add item to cart when add button is clicked", () => {});
        it("should update total price immediately", () => {});
        it("should show item count badge", () => {});
    });

    describe("when cart is empty", () => {
        it("should display empty cart message", () => {});
        it("should disable checkout button", () => {});
    });

    describe("during checkout process", () => {
        it("should validate stock before proceeding", () => {});
        it("should show loading indicator while processing payment", () => {});
        it("should display success message after completion", () => {});
    });
});
```

### Поток разработки

Как правило, поток разработки таков:
1. Пишется спецификация, которая описывает самый базовый функционал;
2. Делается начальная реализация;
3. Для проверки соответствия спецификации задействуется одновременно фреймворк (Mocha) вместе со спецификацией и реализацией. Фреймворк запускает все тесты `it` и выводит ошибки, если они возникнут. При ошибках вносятся исправления;
4. Спецификация расширяется, в нее добавляются возможности, которые пока, возможно, не поддерживаются реализацией;
5. Перходим на пункт 2, делаем реализацию, и так далее, до завершения спецификации и реализации.

Разработка ведется итеративно, один проход за другим, пока спецификация и реализация не будут завершены.

Для запуска тестов нужны соответствующие JavaScript-библиотеки:
- **Mocha** - эта библиотека содержит общие функции для тестирования, включая `describe` и `it`;
- **Chai** - библиотека поддерживает разнообразные функции для проверок;
- **Sinon** - для эмуляции и хитрой подмены функций "заглушками".

**Один тест тестирует ровно одну вещь.**

В `describe` можно вкладывать `describe`, который объявит новую "подгруппу" тестов, блоки `it` которой запускаются так же, как и обычно, но выводятся с подзаголовком.

В каждом блоке `describe` можно также задать функции:
- `before(function ([done]) {...})` - выполнится до запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `after(function ([done]) {...})` - выполнится после запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `beforeEach(function ([done]) {...})` - выполнится до каждого `it` [где `done` - необходимо вызвать по завершению асинхронной работы];
- `afterEach(function ([done]) {...})` - выполнится после каждого `it` [где `done` - необходимо вызвать по завершению асинхронной работы].

### Дополнительные методы тестирования

- `.skip`:
    - после `it` позволяет пропустить тест;
    - после `describe` позволяет пропустить группу тестов, лучше использовать вместо комментирования самих тестов;
    > `it.skip("<что_делает_функция>", function () {...})`
- `.only`:
    - после `it` позволяет выполнить только этот тест;
    - после `describe` позволяет выполнить только эту группу тестов, и все другие с модификатором `.only`;
    > `describe.only("<имя_тестируемой_сущности>", function () {...})`

### Виды `chai.assert`

- `assert(<значение>[, '<сообщение>'])` - проверяет что `<значение>` является `true` в логическом контексте;
- `assert.equal(<значение_1>, <значение_2>[, '<сообщение>'])` - проверяет равенство `<значение_1> == <значение_2>`;
- `assert.strictEqual(<значение_1>, <значение_2>[, '<сообщение>'])` - проверяет строгое равенство `<значение_1> === <значение_2>`;
- `assert.notEqual(<значение_1>, <значение_2>[, '<сообщение>'])`, `assert.notStrictEqual(<значение_1>, <значение_2>[, '<сообщение>'])` - проверки, обратные двум предыдущим;
- `assert.deepEqual(<объект_1>, <объект_2>[, '<сообщение>'])` - производит глубокую проверку что один объект равен другому объекту по его свойствам;
- `assert.isTrue(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === true`;
- `assert.isFalse(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === false`;
- `assert.isOk(<значение>[, '<сообщение>'])` - проверяет, что `<значение>` есть;
- `assert.isNotOk(<значение>[, '<сообщение>'])` - проверяет, что `<значение>` нет;
- `assert.isNull(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === null`;
- `assert.isUndefined(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === undefined`;
- `assert.exists(<значение>[, '<сообщение>'])` - проверяет, что `<значение> !== null && <значение> !== undefined`;
- `assert.typeOf(<значение>, '<тип>'[, '<сообщение>'])` - проверяет что `<значение>` является указаным типом;
- `assert.instanceOf(<значение>, <функция_конструктор>[, '<сообщение>'])` - проверяет что `<значение>` является экземпляром `<функция_конструктор>`.

Все вызовы `assert` позволяют дополнительным последним аргументом указать строку с описанием ошибки, которое выводится, если `assert` не проходит.

Эту спецификацию можно использовать как:
- тесты, которые гарантируют правильность работы кода;
- документацию по функции, что она конкретно делает;
- примеры использования функции, которые демонстрируют ее работу внутри `it`.

### Виды `chai.expect`

Используется для BDD (*Behavior-driven development*, *разработка через поведение*).  
Пишутся в стиле английского языка, через описание поведения.

`expect(<значение>)` - инициализация:
- `.to` - начало конструкции (чейнится):
    - `.be` - существование (есть) (чейнится):
        - `.true` - проверяет что значение `<значение> === true`;
        - `.false` - проверяет что значение `<значение> === false`;
        - `.null` - проверяет что значение `<значение> === null`;
        - `.an('<тип>'[, '<сообщение>'])` - проверяет что значение `<значение>` является указаным типом;
        - `.a('<тип>'[, '<сообщение>'])` - аналогично предыдущему;
        - `.instanceof('<функция_конструктор>'[, '<сообщение>'])` - проверяет что `<значение>` является экземпляром `<функция_конструктор>`;
    - `.exist` - значение `<значение>` существует;
    - `.not` - модификатор - отрицает последующие проверочные конструкции (чейнится):
        > `expect([1, 2, 3]).to.not.be.empty;`
    - `.deep` - модификатор - добавляет глубокие проверки для объектов по их свойствам (чейнится), для проверок `.equal`, `.include`, `.members`, `.keys`, `.property`;
    - `.nested` - модификатор - добавляет проверку по пути свойств для имен свойств (чейнится), для проверок `.include`, `.property`:
        > `expect(obj).to.have.nested.property('query.bool.filter[0].term.id');`
    - `.ordered` - модификатор - добавляет проверку порядка (чейнится), для проверок `.members`;
    - `.any` - модификатор - добавляет проверку что существует хотя бы один из (чейнится), для проверок `.keys`;
    - `.all` - модификатор - добавляет проверку что существуют все из (чейнится), для проверок `.keys`;
    - `.equal(<проверяемое_значение>[, '<сообщение>'])` - проверяет равенство значений `<значение>` и `<проверяемое_значение>`;
    - `.eql(<проверяемое_значение>[, '<сообщение>'])` - производит глубокую проверку что один объект равен другому объекту по его свойствам;
    - `.have` - имеет (чейнится):
        - `.members(<массив>[, '<сообщение>'])` - проверяет что входной массив `<значение>` строго содержит все значения из `<массив>` и **только их**;
        - `.property('<имя_свойства>'[, <значение_свойства>])` - проверяет что входной объект `<значение>` содержит свойство с указаным именем `<имя_свойства>` [и оно равно `<значение_свойства>`];
        - `.keys(['<имя_свойства_1>'[, ...]])` - проверяет что входной объект `<значение>` содержит все свойства, которые заданы в массиве;
    - `.include`:
        - `.members(<массив>)` - проверяет что входной массив `<значение>` содержит все значения из `<массив>`;
    - `.include({<объект> | '<строка>' | <число>}[, '<сообщение>'])` - проверяет что одно из:
        - входной объект `<значение>` содержит все значения из `<объект>`;
        - входная строка `<значение>` содержит подстроку `<строка>`;
        - входной массив `<значение>` содержит строку `<строка>` или число `<число>`;
    - `.throw([<конструктор_ошибки>])` - проверяет что функция `<значение>` при вызове выбросит исключение экземпляра `<конструктор_ошибки>`.

### Асинхронные тесты

Для этого в функцию, которую принимает метод `it("<что_делает_функция>", function (done) {...})` передается дополнительный callback-параметр `done` - который необходимо вызвать по завершению асинхронной работы без параметров в случае успеха `done()`, или с ошибкой в случае не удачи `done(<error>)`.

```javascript
describe('#save()', function () {
    it('should save without error', function (done) {
        var user = new User('Luna');
        user.save(function () {
            done();
        });
    });
});
```

Или можно вернуть промис, который необходимо разрешить.

```javascript
describe('#find()', function () {
    it('respond with matching records', function () {
        return db.find({ type: 'User' }).should.eventually.have.length(3);
    });
});
```

### Размещение тестов

Глобальные тесты должны располагаться по путь `tests/` в корне проекта.

Тесты модулей должны именоваться `<имя_модуля>.spec.js`.

`mocha` - запуск всех тестов в `tests/`.  
`mocha <имя_модуля>.spec.js` - запуск теста модуля.  
`mocha --exclude node_modules ./**/*.spec.js` - запуск всех тестов модулей.

### Sinon

#### Шпион `spy`

Тестовый шпион как бы окутывает "реальный" объект, переопределяя некоторые его методы, а со всеми остальными методами объекта позволяя работать как ни в чем не бывало (режим полной прозрачности, как будто шпиона и нет вовсе). При этом действия шпиона при перекрытии чаще всего сводятся либо к возврату некоторых фиксированных значений в местах вызова определенных методов объекта (с определенными параметрами), либо просто к подсчету того, сколько раз был вызван тот или иной метод. Остальные методы, которые не прерываются шпионом, работают в обычном режиме. Шпионы отлично подходят для объектов, которые содержат как "тяжелые" операции, которые нужно имитировать, так и легковесные операции, с которыми можно справиться без имитации.

`const <spy> = sinon.spy([{<функция> | <объект>, '<метод>'}]);` - возвращает новую функцию (шпиона), которая записывает аргументы, возвращаемое значение, исходное значение и выданные ошибки (если таковые были) для всех вызовов [поверх готовой функции `<функция>` или заменяет исходный метод `<метод>` объекта `<объект>`].

`<spy>.called` - содержит `true` если функция была вызвана, иначе `false`.  
`<spy>.calledOnce` - содержит `true` если функция была вызвана единожды, иначе `false`.  
`<spy>.callCount` - содержит количество вызовов функции.  
`<spy>.args` - содержит массив из массивов аргументов для вызовов функции.  
`<spy>.exceptions` - содержит массив из исключений для вызовов функции.  
`<spy>.returnValues` - содержит массив из возвращаемых значений для вызовов функции.  
`<spy>.getCall(<номер_вызова>)` - возвращает объект с запросами вызова функции, где `args` - массив аргументов для вызова функции.  
`<spy>.calledWith([<аргумент_1>[, ...]])` - возвращает `true` если функция была вызвана с указанными аргументами, иначе `false`.  
`<spy>.threw()` - возвращает `true` если функция выбросила исключение, иначе `false`.  
`<spy>.calledBefore(<другой_spy>)` - возвращает `true` если функция была вызвана перед вызовом другого шпиона `<другой_spy>`, иначе `false`.  
`<spy>.calledAfter(<другой_spy>)` - возвращает `true` если функция была вызвана после вызова другого шпиона `<другой_spy>`, иначе `false`.

#### Заглушки `stub`

Заглушки (stub) используются для возврата фиксированных значений/объектов в тестируемую функцию в местах вызова внешних методов. Заглушку не интересует, как был вызван метод внешнего объекта, заглушка просто возвращает фиксированный объект, заданный заранее. Обычно в качестве такого объекта выступает какое-либо ожидаемое вызывающей стороной значение, если позитивное тестирование, или какое-то неожиданное/нетривиальное значение, негативное тестирование.  
Тестирование с заглушками подразумевает, что заменются реальные объекты заглушками, которые будут возвращать фиксированные значения, заданные при написании тестового сценария.

`const <stub> = sinon.stub([<объект>[, '<метод>']]);` - возвращает новую функцию (заглушку) с предварительно запрограммированным поведением, полностью поддерживает API шпионов в дополнение к методам, которые могут быть использованы для изменения поведения заглушек [для всех методов указаного объекта `<объект>`[, только указаного метода `<метод>`, тогда вызов `<stub>(...)` будет аналогичен вызову `<объект>.<метод>(...)`]].

`<stub>.returns(<значение>)` - возвращает указаное значение `<значение>` при вызове функции.  
`<stub>.returnsThis()` - возвращает `this` при вызове функции.  
`<stub>.resolves(<значение>)` - возвращает промис, который успешно разрешиться значением `<значение>` при вызове функции.  
`<stub>.resolvesArg(<номер>)` - возвращает промис, который успешно разрешиться значением переданным аргументом под номером `<номер>` при вызове функции.  
`<stub>.rejects(<значение>)` - возвращает промис, который неуспешно разрешиться значением `<значение>` при вызове функции.  
`<stub>.throws(['<Тип_Исключения>'])` - выбрасывает указаное исключение [с указаным типом `<Тип_Исключения>`] при вызове функции.  
`<stub>.withArgs([<аргумент_1>[, ...]]).<метод_возврата_значения>` - `<метод_возврата_значения>` (к примеру как `returns` и `throws`) будут вызваны только при вызове функции с указанными аргументами, а иначе будут вызваны другие `<метод_возврата_значения>`, их объявляют до `<метод_возврата_значения>` без этого метода.  
`<stub>.onCall(<номер>).<метод_возврата_значения>` - `<метод_возврата_значения>` (к примеру как `returns` и `throws`) будут вызваны только при указаном `<номер>` вызове функции, а иначе будут вызваны другие `<метод_возврата_значения>`.  
`<stub>.callsArg(<номер>)` - вызывает указанный переданный аргумент под номером `<номер>` как функцию при вызове заглушки.  
`<stub>.callsArgWith(<номер>[, <аргумент_1>[, ...]])` - вызывает указанный переданный аргумент под номером `<номер>` как функцию при вызове заглушки с указанными аргументами.  
`<stub>.restore()` - восстанавливает исходную функцию.

```javascript
const callback = sinon.stub();
callback.withArgs(42)
    .onFirstCall().returns(1)
    .onSecondCall().returns(2);
callback.returns(0);
```

#### Имитация `mock`

Mock-объекты (объекты-имитации) используются для проверки того, что функция корректно вызывает внешние API. Тесты с использованием имитаций (mock-объектов) позволяют проверить, что тестируемая функция передает корректные параметры (по типу или по значению) внешнему объекту. В случае консольных приложений (работающих в режиме командной строки), имитации тестируют команды. В мире событийно-ориентированных архитектур имитации позволяют тестировать генерируемые события.

`const <mock> = sinon.mock(<объект>);` - возвращает имитацию для указанного объекта, с предварительно запрограммированным поведением (как заглушка), а также предварительно запрограммированным ожиданием, сам объект не изменяется, но обертывает mock-объект для установки ожиданий на методах объекта.

`<mock>.restore()` - восстанавливает все методы имитации.  
`<mock>.verify()` - возвращает `true` если все ожидания прошли проверку, иначе `false`.

`const <expectation> = <mock>.expects('<метод>');` - возвращает ожидание - функцией имитации, для указаного метода `<метод>`.

`<expectation>.atLeast(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное минимальное количество раз.  
`<expectation>.atMost(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное максимальное количество раз.  
`<expectation>.exactly(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное точное количество раз.  
`<expectation>.once()` - возвращает это ожидание и устанавливает, что метод будет вызван один раз.  
`<expectation>.never()` - возвращает это ожидание и устанавливает, что метод не будет вызван.  
`<expectation>.withArgs(<аргумент_1>[, ...])` - возвращает это ожидание и устанавливает, что метод будет вызван с заданными аргументами (возможно подобными).  
`<expectation>.withExactArgs(<аргумент_1>[, ...])` - возвращает это ожидание и устанавливает, что метод будет вызван с заданными аргументами и никакими другими.  
`<expectation>.verify()` - возвращает `true` если ожидание прошло проверку, иначе `false`.

## Автоматические тесты при помощи jest

`jest` - запуск всех тестов которые удолетворяют шаблону `*.test.js`.

Конструкции `test` можно вкладывать в блоки `describe` для групировки (по умолчанию считается что они уже вложены в блок `describe`):  
`describe('<описание_блока_тестов>', () => { /* */ }`

```javascript
test("<имя_теста>", () => {
    // ...
    expect(<значение>)[.not].<функция_проверки>(/* ... */);
    // ...
});
```

Асинхронный тест:
```javascript
test("<имя_теста>", (done) => {
    // ...
    expect(<значение>)[.not].<функция_проверки>(/* ... */);
    // ...
    done(); // при успешном завершении теста
    done(<ошибка>); // при неуспешном завершении теста
});
```

Или можно вернуть промис, вместо использования `done`, который необходимо разрешить.  
`test("<имя_теста>", () => new Promise((res, rej) => { ... }));`

Или использовать `async`.  
`test("<имя_теста>", async () => { ... }));`

В каждом блоке `describe` можно также задать функции:
- `beforeAll(([done]) => { ... })` - выполнится до запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `afterAll(([done]) => { ... })` - выполнится после запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `beforeEach(([done]) => { ... })` - выполнится до каждого `test` [где `done` - необходимо вызвать по завершению асинхронной работы];
- `afterEach(([done]) => { ... })` - выполнится после каждого `test` [где `done` - необходимо вызвать по завершению асинхронной работы].

### Имитация `mock`

`jest.spyOn(<объект>, "<свойство>").mockImplementation(() => { ... });` - включает мокирование для свойства `<свойство>` объекта (для свойст (как `fetch`) глобальных объектов используется `global` в качестве объекта).  
`<объект>.<свойство>.mockRestore();` - выключает мок для свойства `<свойство>` объекта.

### Проверки

#### Проверки значений

`expect(<значение>)`:
- `.toBe(<другое_значение>)` - проверяет на равенство значений;
- `.toEqual(<другое_значение>)` - проверяет на похожесть значений по структуре;
- `.toContain(<другое_значение>)` - проверяет на то что массив или итерируемый объект `<значение>` содержит другое значение;
- `.toContainEqual(<другое_значение>)` - проверяет на то что массив или итерируемый объект `<значение>` содержит другое значение с ожидаемой структурой;
- `.toHaveLength(<другое_значение>)` - проверяет на то что свойство `length` у `<значение>` соответствует другому значению;
- `.toBeNull()` - проверяет на то что `<значение>` === `null`;
- `.toBeUndefined()` - проверяет на то что `<значение>` === `undefined`;
- `.toBeDefined()` - проверяет на то что `<значение>` !== `undefined`;
- `.toBeTruthy()` - проверяет на то что `<значение>` истино и не равно значениям `false`, `null`, `undefined`, `0`, `NaN` или пустой строке;
- `.toBeFalsy()` - проверяет на то что `<значение>` ложно и равно одному из значений `false`, `null`, `undefined`, `0`, `NaN` или пустой строке;
- `.toBeGreaterThan(<другое_значение>)` - проверяет на то что `<значение>` больше другово значения;
- `.toBeGreaterThanOrEqual(<другое_значение>)` - проверяет на то что `<значение>` больше или равно другово значения;
- `.toBeLessThan(<другое_значение>)` - проверяет на то что `<значение>` меньше другово значения;
- `.toBeLessThanOrEqual(<другое_значение>)` - проверяет на то что `<значение>` меньше или равно другово значения;
- `.toBeCloseTo(<другое_значение>)` - проверяет на то что `<значение>` близко к указаному другому значению;
- `.toMatch(<другое_значение>)` - проверяет на то что `<значение>` соответсвует решулярному выражению заданому другим значением;
- `.toThrow()` - проверяет на то что `<значение>` при вызове как функция выбросит исключение;
- `.not` - промежуточное звено, переводит дальнейшие проверки в неравенство.

#### Проверки вызова функций

`const <функция> = jest.fn();`

`expect(<функция>)`:
- `.toHaveBeenCalledWith([<аргумент_1>[, ...]])` - проверяет на то что функция была вызвана с указаными аргументами;
- `.toHaveBeenLastCalledWith([<аргумент_1>[, ...]])` - проверяет на то что функция была вызвана с указаными аргументами в последний раз.

## Цикломатическая сложность

**Цикломатическая сложность** - это мера числа линейно независимых путей в вашем исходном коде. Цикломатическая сложность равна увеличенному на единицу цикломатическому числу графа программы. Где граф программы - это как раз граф путей реализации вашей программы, а цикломатическое число - минимальное число ребер, которые надо удалить, чтобы граф стал ациклическим (то есть без циклов).

Начинает сильно влиять от 10 и очень сильно от 25.

Цикломатическая сложность | Вероятность "плохой правки" ("bad fix")
 ------------------------ | ---------------------------------------
**1-10**                  | 5%
**20-30**                 | 20%
**>50**                   | 40%
**Почти 100**             | 60%

## Покрытие кода

Покрытие кода показывает, выполняется или нет та или иная строка кода в ходе тестирования, а если выполняется, то сколько раз. Это полезно для измерения эффективности тестов. Теоретически, чем больше строк кода "покрыто", тем более полными являются тесты.

В случае с модульным тестированием значение покрытия кода может использоваться в ходе анализа корректности функционирования, полноты тестирования того или иного метода, тогда как в случае с интеграционным тестированием такие цели нереальны.

В случае с интеграционным тестированием более реальными целями является определение местонахождения той или иной этой функции в исходном коде и насколько часто она вызывается/используется.

## Приемы тестирования

Для тетсирования должна быть определена точно определена спецификация того что тестируется.

Классы:
- методы и свойства с доступом `private` не тестируются, так как они реализуют внутренний интерфейс, а не внешний;
- для тестирования методов и свойств с доступом `protected` используется наследование от этого класса и реализация в нем методов или свойств с доступом `public`, которые будут вызывать внутри себя методы и свойства с доступом `protected`.

## Пример тестирования в браузере

```html
Пример HTML-страницы для тестов:
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- подключаем стили Mocha, для отображения результатов -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">
    <!-- подключаем библиотеку Mocha -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"></script>
    <!-- настраиваем Mocha: предстоит BDD-тестирование -->
    <script>
        mocha.setup('bdd');
    </script>
    <!-- подключаем chai -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"></script>
    <!-- в chai есть много всего, выносим assert в глобальную область -->
    <script>
        var assert = chai.assert;
    </script>
</head>

<body>
    <script>
    function <тестируемая_функция>(...) {
        /* код функции, пока что пусто */
    }
    </script>

    <!-- в этом скрипте находятся специализации -->
    <script src="test.js"></script>

    <!-- в элементе с id="mocha" будут результаты тестов -->
    <div id="mocha"></div>

    <!-- запустить тесты! -->
    <script>
        mocha.run();
    </script>
</body>
</html>
```

Страницу можно условно разделить на четыре части:
- **блок `<head>`** - в нем подключаются библиотеки и стили для тестирования, кода там нет;
- **блок `<script>`** с реализацией спецификации, с кодом тестируемых функций;
- далее подключаются тесты, файл `test.js` содержит `describe("<имя_тестируемой_функции>", ...)`, для тестирования функций. Методы `describe` и `it` принадлежат библиотеке Mocha;
- элемент `<div id="mocha">` будет использоваться библиотекой Mocha для вывода результатов. Запуск тестов инициируется командой `mocha.run()`.
