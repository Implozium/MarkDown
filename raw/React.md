Описание
========

**React** - одна из библиотек, которая придерживаются строгих соглашений о том, как структурировать код и управлять данными вашего приложения. **JSX** является результатом одного из таких соглашений. **React** воплощает идею, что разметка и код, который генерирует ее по своей природе связаны друг с другом. В **React** компонентах это реализуется генерацией разметки прямо из **JavaScript**, используя всю мощь языка.

Установка
=========

## Create React App

```bash
npm install -g create-react-app
create-react-app my-app

cd my-app
npm start
```
Производит установку с помощью `create-react-app`.

```bash
npm run build
```
Это создаст production-сборку приложения в сборке / папке вашего проекта.

## Установка как пакетов

```bash
npm init
npm install --save react react-dom
```

JSX
===

Является синтаксическим расширением JavaScript. JSX производит React-элементы.

**JSX** нужен для JavaScript XML - разметки в стиле XML внутри компонентов React. React может работать и без JSX, но именно JSX делает компоненты более читаемыми.
- **JSX** это синтаксическая трансформация - каждая JSX ветвь соответствует JavaScript функции;
- не требует никаких библиотек для выполнения;
- **JSX** ничего не добавляет и не изменяет в JavaScript - он просто вызывает функции.

JSX трансформирует JavaScript код в семантическую осмысленную разметку.

React определяет все возможные HTML элементы в пространстве имен `React.dom`. Это к тому же позволяет использовать полностью произвольные компоненты внутри разметки.

Для того чтобы файл с JSX стал доступен для React, в начало файла нужно вставить такой заголовок: `/** @jsx React.DOM */`

Без этого JSX не поймет что файл нужно обработать для React.

React предопределяет все HTML теги которые только есть в пространстве имен `React.DOM`. JSX трансформирует их в глобальные переменные, которые позволят использовать просто `<div>...</div>` вместо того, чтобы каждый раз указывать `var div = React.dom.div` в каждом JSX файле.

После компиляции JSX-выражения становятся регулярными JavaScript-объектами. Что значит внутри можно использовать все преимущества при создании структуры компонента в HTML подобном синтаксис, который трансформируется в простые JavaScript функции.

## Создание компонента

Концептуально, компоненты подобны JavaScript-функциям. Они принимают произвольные данные (называемые `props`) и возвращают React-элементы, описывающие что должно появиться на экране.

```JSX
class <Компонент> extends React.Component {
    render() {
        return (
            <html_код_компонента>
        );
    }
};
```

```JSX
const <Компонент> = (
    <html_код_компонента>
);
```

```JSX
function <Компонент>(props) {
    return <html_код_компонента>;
}
```
Это создаст компонент. Внутри `return` всегда должен возвращаться DOM-узел (то есть, что угодно, обернутое в один, единый, родительский тэг) или `null` для того чтобы не отображать компонент. **Компонент всегда должен называться с большой буквы**.

Компоненты могут ссылаться на другие компоненты в своем выводе (результате отрисовки). Это позволяет использовать абстракцию компонента для любого уровня детализации. Внутри компонентов можно также использовать другие компоненты в `<html_код_компонента>`:  
`<<Компонент>> <контент> </<Компонент>>`

Запись `<<Компонент>/>` эквивалентна: `<<Компонент>></<Компонент>>`.

React DOM использует соглашение об именовании свойств в camelCase нотации, вместо имен HTML-атрибутов. Т.е. для того чтобы указать CSS-классы тега необходимо использовать атрибут `className` вместо стандартного `class`.
Также можно напрямую использовать js-код, для этого его необходимо заключить в:
`{<код>}`

### Комментарии внутри JSX

`{/* <комментарий> */}`

### Отрисовка (отображение) компонента

```JSX
ReactDOM.render(
    <<Компонент>> <контент> </<Компонент>>,
    document.getElementById('<id>'),
    [<callback>]
);
```
Это вставляет компонент внутрь указанного элемента в html.

## Отрисовка группы (массива) компонентов

Каждый элемент в массиве должен обладать свойством `key`, для того чтобы идентифицировать, какой элемент был изменен, добавлен или удален. Ключи должны быть предоставлены элементам внутри массива, чтобы дать элементам стабильную идентифицируемость. Ключи имеют смысл только в контексте окружающего массива, т.е. **элементы внутри вызова `map()` требуют ключей**.

```JSX
const items = <массив>.map((<элемент>) => {
    return <<Компонент> key={<ключ>}>...</<Компонент>>;
});
```

Отрисовка массива будет: `<div>{items}</div>`.

Свойства
========

В свойство компонента можно передать любой javascript примитив, объект, переменную и даже выражение. Они передаются в компонент как html атрибуты:  
`<<Компонент> <свойство>={<значение>}[ ...]> <контент> </<Компонент>>`

Значения свойств доступны внутри компонента как: `this.props.<свойство>`.

Если свойству значение не присвоено, но свойство написано, то оно равно по умолчанию `true`.

Для записи свойства HTML, которое использует `-` в своем название, используется **camelCase** именование.

В `this.props.children` - хранится `<контент>`, который был передан в компонент, который может быть любым значением понятным для реакта, а именно объект, строка или функция, а значения `false`, `null`, `undefined`, и `true` игнорируются.
> `<UserList users={users}>{(user) => <li key={user.id}>Пользователь: {user.name}</li>}</UserList>`

JSX удаляет пустые строки и пробелы в начале и конце строки. Новые строки, примыкающие к тегу будут удалены. Новые строки между строковых литералов сжимаются в один пробел.

`this.props` - иммутабельная структура, используется только для чтения.

Для вывода (отображения) значения переменной внутри JSX, нужно использовать указанный синтаксис, при этом все преобразуется в строку, перед тем как будет отрисовано:  
`{<переменная>}`

`<<Компонент> {...<объект_свойств>}> <контент> </<Компонент>>` - передача всех свойств компоненту, через объект, с помощью оператора расширения.

## Хранение элементов в переменной

`const <переменная> = <Компонент>;`  
Отрисовка компонента из переменной: `{<переменная>}`.

## Использование компонентов через переменные

`const <Компонент> = <компонент>;` - всегда должен быть с большой буквы.  
`<<Компонент> .../>`

Таким способом можно передавать компоненты через свойства.

## If - else внутри JSX

Оно доступно внутри JSX как `{<условие> ? <код_истины> : <код_лжи>}`.  
Только if без else `{<условие> && <код_истины>}`

```JSX
<div className="solid" tabIndex="0" customProperty="value">
    {valid && <div className="valid">Profile is valided</div>}
</div>
```

## HTML-код

`<<тег> dangerouslySetInnerHTML={{__html: '<html_код>'}}/>` - производит прямую вставку HTML-кода в элемент.

Локальное состояние
===================

Это состояние подобно свойствам `props`, но является приватным и полностью контролируется компонентом. Локальное состояние является возможностью, доступной только для классов. Используется для динамических свойств, оно хранится в `this.state`.

Для его использования необходимо:
```JSX
class <Компонент> extends React.Component {
    /**
     * @param {Object} props свойства переданные при создании
     */
    constructor(props) {
        super(props);
        this.state = {};// инициализация начального состояния, можно делать только в конструкторе
    }

    /**
     * срабатывает после того, как компонент был отрисован в DOM
     * тут есть возможность использовать refs (к примеру для установки фокуса или задействования других компонентов), таймауты, ajax-запросы и взаимодействие с другими библиотеками
     * можно сразу вызвать setState()
     */
    componentDidMount() {}

    /**
     * вызывается сразу перед тем, как компонент будет удален из DOM
     */
    componentWillUnmount() {}

    /**
     * компонент будет примонтирован. В данный момент нет возможности посмотреть DOM элементы
     * @deprecated
     */
    componentWillMount() {}

    /**
     * компонент получает новые props
     * этот метод не вызывается в момент первого render'a. В этот момент, старые props доступны как this.props, а новые props доступны в виде nextProps. Если вызывать setState внутри этого метода - не будет вызван дополнительный render
     * @deprecated
     * @param {Object} nextProps новые свойства
     */
    componentWillReceiveProps(nextProps) {}

    /**
     * вызывается прямо перед render, когда новые props и state получены
     в этом методе нельзя вызывать setState
     * @deprecated
     */
    componentWillUpdate() {}

    /**
     * вызывается перед каждым вызовом render
     * должен возвращать объект для обновления state или null для, чтобы показать что обновлять нечего
     * @param {Object} props текущие свойства компонента
     * @param {Object} state текущий state компонента
     * @return {?Object} объект для обновления state
     */
    static getDerivedStateFromProps(props, state) {}

    /**
     * вызывается сразу после render, когда изменение еще не принято в DOM, позволяет захватить некоторую информацию из DOM
     * то что будет возвращено передается в componentDidUpdate
     * @param {Object} prevProps предыдущие свойства компонента
     * @param {Object} prevState предыдущие state компонента
     * @return {*} значение для передачи в componentDidUpdate
     */
    getSnapshotBeforeUpdate(prevProps, prevState) {}

    /**
     * вызывается сразу после render. Не вызывается в момент первого render'а компонента
     * @param {Object} prevProps предыдущие свойства компонента
     * @param {Object} prevState предыдущие state компонента
     * @param {*} snapshot результат функции getSnapshotBeforeUpdate
     */
    componentDidUpdate(prevProps, prevState, snapshot) {}

    /**
     * вызывается после того как была схвачена ошибка в компоненте
     * @param {Object} error выброшенная ошибка
     * @param {{componentStack: *}} info объект со свойством componentStack в котором содержится информация о том компоненте, который выбросил ошибку
     */
    componentDidCatch(error, info) {}

    /**
     * вызывается перед вызовом render при возникновении ошибки
     * должен возвращать объект для обновления state или null для, чтобы показать что обновлять нечего
     * @param {Object} error выброшенная ошибка
     * @return {?Object} объект для обновления state
     */
    static getDerivedStateFromError(error) {}

    /**
     * вызывается до начала процесса повторной отрисовки
     * если вернет true, то React выполнит обновление (перерисовку) компонента, при false не будет
     * @param {Object} nextProps новые свойства компонента
     * @param {Object} nextState новые state компонента
     * @return {boolean}
     */
    shouldComponentUpdate(nextProps, nextState) {}

    render() {
        return (<html_код_компонента>);
    }
};

<Компонент>.defaultProps = <объект_свойств_по_умолчанию>;
<Компонент>.displayName = '<отображаемое_имя>';
```

Чтобы получить значение свойства из состояния в JSX используется: `{this.state.<свойство>}`.

`this.state` нельзя модифицировать вручную, для этого необходимо использовать функции готового компонента:  
`this.setState({<свойство>: <значение>[, ...]}[, () => {...}])` - изменяет (обновляет) состояние компонента, при этом объединяя новое состояние с предыдущим, и перерисовывает его, каждый раз должно передаваться новый экземпляр состояния с теми свойствами, которые поменялись (а не всеми) [и вызовет callback функцию после того, как новое состояние "установится"].

`this.setState((prevState, props) => {...}[, () => {...}])` - аналогично предыдущему варианту, где функция должна возвращать новое состояние (его обновляемую часть), а `prevState` - предыдущее состояние, `props` - свойства в момент отображения [и вызовет callback функцию после того, как новое состояние "установится"].

`this.setState()` - не изменяет `this.state` немедленно, а создает очередь изменений состояния. Доступ к `this.state` после вызова метода, потенциально может вернуть имеющееся (бывшее) значение.

Нельзя вызывать `setState` в `render`: так как реакт, видит изменилось состояние - начинает перерисовывать компонент - видит что изменилось состояние - начинает перерисовывать компонент и т.д.

Вызов `setState` родителя - перерисует дочерние компоненты.

## Чистый компонент `React.PureComponent`

`React.PureComponent` похож на `React.Component`. Отличие заключается в том, что `React.Component` не реализует `shouldComponentUpdate()`, а `React.PureComponent` реализует его поверхностным сравнением пропсов и состояния.  
В нем лучше использовать "чистые" дочерние компоненты.

Цикл жизни компонента
=====================

```
    Монтирование          :               Обновление             :        Демонтирование
        |                 :                                      :              |
        v                 :                                      :              |
    ---------------       :                                      :              |
    | constructor |       :  New props set­State() force­Update()  :              |
    ---------------       :     |          |            |        :              |
        |                 :     |          |            |        :              |
        v                 :     v          v            v        :              |
    ------------------------------------------------------------ :              |
    |                getDerivedStateFromProps                  | :              |
    ------------------------------------------------------------ :              |
        |                 :     |          |            |        :              |
        |                 :     v          v            |        :              |
        |                 : -------------------------   |        :              |
        |                 : | shouldComponentUpdate |   |        :              |
        |                 : -------------------------   |        :              |
        |                 :     |          |            |        :              |
        v                 :     v          x            v        :              |
    ------------------------------------------------------------ :              |
    |                           render                         | :              |     1
    ------------------------------------------------------------ :              |
        |                 :                |                     :              |
    +++ | +++++++++++++++ : ++++++++++++++ v +++++++++++++++++++ : ++++++++++++ | +++++++++
        |                 : ------------------------------------ :              |
        |                 : | getSnapshotBeforeUpdate          | :              |     2
        |                 : ------------------------------------ :              |
    +++ | +++++++++++++++ : ++++++++++++++ | +++++++++++++++++++ : ++++++++++++ | +++++++++
        v                 :                v                     :              |
    ------------------------------------------------------------ :              |
    |        React обновляет ­D­O­M и ссылки (refs)               | :              |     3
    ------------------------------------------------------------ :              |
        |                 :                |                     :              |
        v                 :                v                     :              v
    --------------------- : ------------------------------------ : ------------------------
    | componentDidMount | : |        componentDidUpdate        | : | componentWillUnmount |
    --------------------- : ------------------------------------ : ------------------------
```

Фазы:
1. Фаза **Render** - чистая и не имеет побочных эффектов. Может быть приостановлена, прервана и перезапущена самим React'ом;
2. Фаза **Pre-commit** - можно производить чтение DOM'a;
3. Фаза **Commit** - можно работать с DOM'ом, пускать побочные эффекты, намечать обновления.

Обработка событий
=================

Для использовании функций для обработки стандартных событий в `<html_код_компонента>` используется в нужном теге компонента, как значение необходимого свойства:  
`<<тег> on<Событие> = {<функция_обработки_события>}>` - это привязывает функцию к указанному событию элемента, в эту функцию передается событие `e` - это синтетическое событие (`SyntheticEvent`).

> `<div onClick = {(e) => {console.log(e);}}>...</div>`

На основе этого делаются произвольные события и callback функции:  
`<<тег> on<ПроизвольноеСобытие> = {<функция_обработки_события>}>`

Когда определяетcя компонент, используя ES6 класс, то общий паттерн таков: **обработчик события должен быть методом класса**. Для привязывания контекста `this` используется указаная конструкция в конструкторе класса:  
`this.<функция_обработки_события> = this.<функция_обработки_события>.bind(this);`

Теперь в свойствах компонента будет `this.props.<функция_события>` - которое будет содержать функцию для обратного вызова, которую необходимо будет вызвать в компоненте при указанном событии.

Используется кроссбраузерную обертка `SyntheticEvents`, представляющая синтетические события и предназначенную для унификации работы с событиями DOM. Их особености:
- унифицируют особенности различных платформ, связанные с обработкой событий;
- автоматически решают задачи по управлению памятью, так как синтетические события автоматически делегируются корневому узлу, что приводит к тому, что React-разработчикам не приходится решать задачи по управлению памятью;
- в их работе используются пулы объектов, объекты синтетических событий создаются заранее и помещаются в пул объектов. Когда надобности в событии нет, оно возвращается обратно в пул.

Контролируемые компоненты
=========================

Элемент ввода формы (например, `input`), значение которого контролируется React, называется "**контролируемый компонент**".

Если установлено свойство `value` для `input`, `textarea` и `select`, у которого нет `onChange` обработчика, то будет отрисовано поле только для чтения.

Если поле должно быть изменяемое, то нужно использовать `defaultValue`. А для `<input type="checkbox">` и `<input type="radio">` нужно использовать `defaultChecked`.

Для `select` выбранный `option` указывается по свойству `value` в `select`, которое должно быть равное `value` выбраного `option`. Если необходим множественный выбор, то `value` в `select` должно быть равно массиву, который состоит из значений `value` выбранных `option`.

В контролируемом компоненте, любая модификация состояния будет иметь ассоциированную функцию-обработчик. Это делает его простым для изменения или проверки данных, вводимых пользователем.

Для множественной обработки подобных полей можно воспользоваться связыванием:  
`<<тег> on<Событие>={<функция_обработки_события>.bind(this, <арг>[, ...])}>`

И тогда функция обработки будет выглядеть:  
`function <функция_обработки_события>(<арг>[, ...], e) {...}`

## Атрибут обратного вызова `ref`

Это специальный атрибут, который может быть присвоен любому компоненту. Атрибут `ref` принимает функцию обратного вызова, и вызывает ее после того, как компонент монтируется в DOM или удаляется из него. Используется для:
- анимации;
- управления фокусом, выделения текста или медиа функции;
- интеграция с другими библиотеками.

Когда атрибут `ref` используется в элементе HTML, функция обратного вызова принимает базовый элемент DOM в качестве аргумента.

Когда атрибут `ref` используется в кастомном компоненте React, функция обратного вызова принимает смонтированный экземпляр компонента в качестве аргумента.

`<<тег> ref={(input) => {this.<имя_переменной_в_классе> = input;}}>` - в переменную `<имя_переменной_в_классе> `- запишется ссылка на текущий элемент DOM или компонент.

Для прокидывания через компоненты используется, как правило, такое имя свойства: `inputRef`.

Если колбэк атрибута `ref` определен как встроенная функция, она будет вызываться дважды во время перерисовок: сперва с `null`, а затем снова с DOM-элементом.

### Создание ссылок (>= 16.3)

`this.<имя_переменной_ссылки> = React.createRef();` - создание ссылки, как правило, они назначаются свойствам экземпляра компонента, в то время как компонент сконструирован таким образом, чтобы ссылки были доступны из любого места этого компонента.

`<<тег> ref={this.<имя_переменной_ссылки>}>` - присвоение ссылки на компонент.

`this.<имя_переменной_ссылки>.current;` - присвоит свойству `current` элемент DOM или компонента, когда компонент будет монтирован, и значение `null`, когда компонент будет демонтирован. Обновления `ref` происходят перед срабатыванием методов жизненого Цикла `componentDidMount` или `componentDidUpdate`.

`ReactDOM.findDomNode(<компонент>)` - возвращает нативный DOM-элемент к которому относится компонент.

## Контекст

Контекст обеспечивает способ передачи данных через дерево компонентов без необходимости передавать свойства вручную на каждом уровне.

`const { Provider, Consumer } = React.createContext(<значение_по_умолчанию>);` - создает пару потребитель `Provider` и поставщик (провайдер) `Consumer`.

`<Provider[ value={<значение>}]>...</Provider>` - компонент, который позволяет потребителям подписываться на изменения контекста [принимает свойство `value`, которое должно быть передано потребителям, которые являются потомками данного провайдера]. Один провайдер может быть связан со многими потребителями. Провайдеры могут быть вложенными, чтобы переопределять значения глубже в дереве.

`<Consumer>{value => ...}</Consumer>` - компонент, который подписывается на изменения контекста. Требует функцию в качестве дочернего элемента. Функция получает текущее значение контекста и возвращает узел `React`. Аргумент `value`, переданный функции, будет равен свойству `value` ближайшего поставщика для этого контекста выше в дереве. Если для данного контекста нет провайдера, аргумент `value` будет равен значению `defaultValue`, которое было передано в `createContext()`. Все потребители перерисовываются всякий раз при изменении значения поставщика.

> `<Consumer>{theme => <Button theme={theme}/>}</Consumer>`

В свойство класса `contextType` может быть назначен объект контекста, созданный с помощью `React.createContext()`. Это позволяет использовать ближайшее и актуальное значение указанного контекста при помощи `this.context`.

```javascript
class MyClass extends React.Component {
    render() {
        let value = this.context;
        /* ... */
    }
}
MyClass.contextType = MyContext;
```

## Порталы

Порталы предоставляют способ отображения дочерних элементов в узел DOM, который существует вне иерархии DOM родительского компонента.

`ReactDOM.createPortal(<потомок_React>, <элемент_DOM>)` - создает портал, где `<потомок_React>` - любой отображаемый потомок React, такой как элемент, строка или фрагмент, а `<элемент_DOM>` - валидный DOM-узел в который необходимо отрисовать потомок. Используется в методе `render()` компонента.

```javascript
render() {
    return ReactDOM.createPortal(this.props.children, domNode);
}
```

Несмотря на то, что портал может быть где угодно в дереве DOM, он ведет себя как обычный дочерний элемент React во всех отношениях. Такие функции, как контекст, работают как и ранее, независимо от того, является ли дочерний элемент порталом, поскольку портал все еще существует в дереве React независимо от его положения в дереве DOM.

Это же касается и всплытия события. Событие, созданное внутри портала, будет распространяться к предкам в объемлющем дереве React, даже если они не являются предками в дереве DOM.

## Фрагменты `React.Fragment`

Используются для объединения DOM узлов. Для объединения множественных элементов.

```javascript
<React.Fragment>
    <Элемент />
    <Элемент />
    {/* ... */}
</React.Fragment>
```

Сокращенный синтаксис:
```javascript
<>
    <Элемент />
    <Элемент />
    {/* ... */}
</>
```

Сам `React.Fragment` не будет присутствовать в DOM.

## Ленивые компоненты `React.Lazy`

Используются для того чтобы рендерить динамический импорт как обычный компонент.

`const <Компонент> = React.lazy(() => import('./<Компонент>'));` - автоматически загрузит бандл, содержащий `<Компонент>`, когда этот компонент будет впервые отрендерен.

Используется только внутри компонента `Suspense`, который рендерит компонент или текст из свойства `fallback` пока подгружается код компонента `<Компонент>`:
```javascript
<Suspense fallback={<компонет_при_подгрузке_компонента>}>
    <Компонент />
<Suspense/>
```

## Мемоизированный компонент `React.memo`

Используются для того чтобы всегда рендерить одинаковый результат для одних и тех же пропсов для функциональных компонентов.

`const <МемоизированныйКомпонент> = React.memo(<Компонент>[, (props, nextProps) => { ... }]);` - автоматически поверхностно сравнивает вложенные объекты в объекте `props` [с помощью указаной функции, которая должна возвращать `true`, если `nextProps` рендерит тот же результат что и `props`, иначе возвращает `false`] и если один из них изменился, то перерендеривает компонент.

## Перенаправление рефов `React.forwardRef`

`React.forwardRef((props, ref) => {})` - позволяет взять `ref` из атрибутов компонента, и передать ("перенаправить") его одному из дочерних компонентов.

## Хуки

**Хуки** - это функции, с помощью которых можно "подцепиться" к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов - они дают вам возможность использовать React без классов.

**Хуки** - это функции JavaScript, которые налагают два дополнительных правила:
- **Хуки** следует вызывать только на верхнем уровне. Нельзя вызывать хуки внутри циклов, условий или вложенных функций;
- **Хуки** следует вызывать только из функциональных компонентов React. Нельзя вызывать хуки из обычных JavaScript-функций. Есть только одно исключение, откуда можно вызывать хуки - это пользовательские хуки.

**Хуки** - это способ использовать повторно логику состояния, а не само состояние, каждое обращение к хуку обеспечивает совершенно изолированное состояние.

### Стандартные хуки

#### Хук состояния `React.useState`

Используется для хранения состояния одного значения.

`const [<переменная>, set<Переменная>] = useState([<начальное_значение>]);` - где:
- `<переменная>` - содержит значение;
- `set<Переменная>` - функция для изменения значения: `set<Переменная>(<новое_значение>)`, может принимать функцию в качестве аргумента: `state => { return <новое_состояние>; }`, где `state` - текущее состояние, а функция должна возвращать новое значение состояния, которое полностью перепишет текущее значение на момент вызова, чтобы не потерять значения используется: `{ ...state, <обновляемые_значения>}`;
- `<начальное_значение>` - начальное значение состояния, если это функция `() => { return <начальное_состояние>; }`, то она вызовится один раз только при создании и должна вернуть начальное состояние.

> `const [count, setCount] = useState(0);`

#### Хук эффекта `React.useEffect`

Хук эффекта дает возможность выполнять побочные эффекты в функциональном компоненте, выполняется асинхронно.

Он выполняет ту же роль, что и `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` в React-классах, объединив их в единый API.

По умолчанию, React запускает эффекты после каждого рендера, включая первый рендер.

```javascript
useEffect(() => { // функция обновления - установки эффекта (componentDidMount, componentDidUpdate)
    ...
    [return () => { // функция сброса эффекта (componentWillUnmount)
        ...
    };]
}[, <массив_значений_зависимостей>]);
```

Каждый раз при повторном рендере, React ставит в очередь новый эффект, который заменяет предыдущий [только если изменится любое из значений в переданном массиве значений, если передавать пустой массив, то будет эффект запустится и сбросится только один раз].

Пример:
```javascript
useEffect(() => {
    function handleStatusChange(status) {
        setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
});
```

#### Хук эффекта `React.useLayoutEffect`

Хук эффекта дает возможность выполнять побочные эффекты в функциональном компоненте, выполняется синхронно после всех изменений DOM. Обновления, запланированные внутри `useLayoutEffect`, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.

Он выполняет ту же роль, что и `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` в React-классах, объединив их в единый API.

По умолчанию, React запускает эффекты после каждого рендера, включая первый рендер.

```javascript
useLayoutEffect(() => { // функция обновления - установки эффекта (componentDidMount, componentDidUpdate)
    ...
    [return () => { // функция сброса эффекта (componentWillUnmount)
        ...
    };]
}[, <массив_значений_зависимостей>]);
```

Каждый раз при повторном рендере, React ставит в очередь новый эффект, который заменяет предыдущий [только если изменится любое из значений в переданном массиве значений, если передавать пустой массив, то будет эффект запустится и сбросится только один раз].

#### Хук контекста `React.useContext`

Используется для возвращения контекста.

`const <значение> = useContext(<контекст>);` - где:
- `<контекст>` - сам объект контекста;
- `<значение>` - значение контекста.

> `const value = useContext(MyContext);`

Компонент, вызывающий `useContext`, всегда будет перерендериваться при изменении значения контекста.

#### Хук редюсера `React.useReducer`

Альтернатива для `useState`, когда используется сложная логика состояния, которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего.

`const [state, dispatch] = useReducer(<reducer>, <начальное_состояние>[, <функция_инициализации>]);` - где:
- `<reducer>` - редюсер - представляет собой функцию вида:
    `function reducer(state, action) {...; return <новое_состояние>;}` - где:
    - `state` - текущее значение состояния;
    - `action` - объект действия;
- `<начальное_состояние>` - начальное значение состояния;
- `<функция_инициализации>` - функция инициализации, будет вызвана со значениями `<функция_инициализации>(<начальное_состояние>)` и должна вернуть начальное значение состояния;
- `state` - текущее значение состояния;
- `dispatch` - функция отправки действий, вызывается как: `dispatch(<действие>)`.

Пример:
```javascript
function init(initialCount) {
    return {count: initialCount};
}

function reducer(state, action) {
    switch (action.type) {
        case 'increment':
            return {count: state.count + 1};
        case 'decrement':
            return {count: state.count - 1};
        case 'reset':
            return init(action.payload);
        default:
            throw new Error();
    }
}

function Counter({initialCount}) {
    const [state, dispatch] = useReducer(reducer, initialCount, init);
    return (
        <>
            Count: {state.count}
            <button onClick={() => dispatch({type: 'reset', payload: initialCount})}>Reset</button>
            <button onClick={() => dispatch({type: 'increment'})}>+</button>
            <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        </>
    );
}
```

#### Хук колбэк `React.useCallback`

Используется для возвращения мемоизированного колбэка. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров.

```javascript
const <memoizedCallback> = useCallback(() => {
    // тело функции
}[, <массив_значений_зависимостей>]);
```

Каждый раз при повторном рендере, React создаст новый колбэк [только если изменится любое из значений в переданном массиве значений, если передавать пустой массив, то будет эффект запустится и сбросится только один раз].

`useCallback(fn, deps)` - это эквивалент `useMemo(() => fn, deps)`.

#### Хук мемоизации `React.useMemo`

Используется для возвращения мемоизированного значения.

```javascript
const <memoizedCallback> = useMemo(() => {
    // тело функции
    return <вычисленное_значение>;
}[, <массив_значений_зависимостей>]);
```

React будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.  
Если массив не был передан, новое значение будет вычисляться при каждом рендере.

#### Хук ссылок `React.useRef`

`const refContainer = useRef(<начальное_значение>);` - возвращает изменяемый ref-объект, свойство `.current` которого инициализируется переданным аргументом (`<начальное_значение>`). Возвращенный объект будет сохраняться в течение всего времени жизни компонента.

Также он удобен для сохранения любого мутируемого значения, по аналогии с тем, как используются поля экземпляра в классах (переменные экземпляра). Мутирование свойства `.current` не вызывает повторный рендер.

Благодаря тому что может хранить любые значения, то его можно использовать в связке с `useEffect` для хранения ссылочных значений, которые передаются как параметры в пользовательский хук.

В примере не будет происходить перерасчет внутренних хуков, так как зависимости от параметра `callback` не будет у них, и они все будут ссылаться только на `savedCallback`.
```jsx
function useInterval(callback) {
    const savedCallback = useRef();
    useEffect(() => {
        savedCallback.current = callback;
    });
    // ...
}
```

### Пользовательские хуки

Имя функции хука должно начинается с `use`. Это JavaScript-функция которая может вызывать другие хуки. Эта функция может принимать что угодно в виде параметров и возвращать тоже что-либо.

Поскольку хуки являются функциями, можно передавать информацию между ними.

Хуки внутри функций не должны использоваться внутри циклов, условных операторов или вложенных функций.

Хуки должны вызываться только из React-функций.

## `React.Children`

Представляет утилитарные функции для работы с `this.props.children`.

`React.Children.map(this.props.children, (child) => {... return ...;})` - работает аналогично функции `map` для массивов и возвращает новый массив, с исключениями, если `this.props.children` был единичный элемент, то вернется массив, если `null` или `undefined`, то `null`.

`React.Children.forEach(this.props.children, (child) => {...})` - работает аналогично функции `forEach` для массивов.

`React.Children.toArray(this.props.children)` - возвращает массив преобразованный из `this.props.children`.

`React.Children.count(this.props.children)` - возвращает количество элементов в `this.props.children`.

`React.Children.only(this.props.children)` - возвращает один элемент из `this.props.children` если он только один, иначе выдает ошибку.

## `React.createElement`

`React.createElement(<имя_тега>[, props][, ...children])` - возвращает созданый элемент с тегом `<имя_тега>` с добавленными свойствами и дочерними компонентами.

## `React.cloneElement`

`React.cloneElement(<react_element>[, props][, ...children])` - возвращает клон элемента с добавленными свойствами, работает аналогично: `<element.type {...element.props} {...props}>{children}</element.type>`.

## `React.isValidElement`

`React.isValidElement(<объект>)` - возвращает `true`, если `<объект>` является валидным React-элементом.

## Компоненты высшего порядка (higher order component, HOC)

Компонент высшего порядка - это функция, которая принимает входной компонент и возвращает расширенную или измененную версию этого компонента - декоратор. Обычно реализуется функцией, которая принимает компонент и использует каррирование.

```javascript
const <декоратор> = ([<аргумент>[, ...]]) => (<Компонент>) => {
    const <НовыйКомпонент> = (props) => ( // модифицированная версия компонента
        ...
        return (...);
    );

    return <НовыйКомпонент>;
};
```

К именам компонентов высшего порядка обычно добавляют префикс `with`.

Компонент авторизации:
```javascript
function withAuthentication(WrappedComponent) {
    const ModifiedComponent = (props) => {
        if (!props.isAuthenticated) {
            return <Redirect to="/login" />;
        }

        return (<WrappedComponent { ...props } />);
    };

    const mapStateToProps = (state) => ({
        isAuthenticated: state.session.isAuthenticated
    });

    return connect(mapStateToProps)(ModifiedComponent);
}
```

## Шаблон "render props"

**Шаблон "render props"**, или, как его еще называют, "**функция как потомок**", позволяет достичь того же самого, что достижимо с помощью компонентов высшего порядка.

Идея использования **шаблона render props** заключается в передаче управления вашей функцией рендеринга другому компоненту, который затем возвращает управление через свойство, являющееся функцией.

Может быть использован в ситуациях, где нужна некая подходящая для повторного использования логика внутри компонента, при этом данный компонент не планируется оборачивать в компонент высшего порядка.

```javascript
class <Компонент> extends React.Component {
  constructor() {
    super();
  }
  render() {
    return this.props.children([<аргумент>[, ...]])
  }
}

const App = () => (
  <div>
    <Компонент>
      {([<аргумент>[, ...]]) => (...)}
    </Компонент>
  </div>
);
```

React Router
============

Используется для роутинга.

`const browserHistory = ReactRouter.browserHistory;` - определяет стратегию отслеживания истории. Объект `browserHistory` это синглтон.

`browserHistory.push('<путь>');` - переносит пользователя на другой URL.

```javascript
ReactDOM.render((
    <Router history={browserHistory}>
        <Route [path="<путь>"] component={<Компонент>}/> - маршрут
        [...]
        <Route [path="<путь>"] component={<Компонент>}>
            <IndexRoute component={<Компонент>} /> - корневой роутер, текущего роутера
            <вложенные_маршруты>
        </Route>
    </Router>
), document.getElementById('root'));
```
Должен помещаться в главный (корневой) элемент.

Каждый `<Route>` при совпадении URL будет выводить соответствующий компонент.

Одновременно в `'root'` будет выводиться лишь один из компонентов. Роутер переключает маршруты без запросов на сервер, при этом каждый компонент может быть самостоятельной новой страницей.

Маршруты можно вкладывать друг в друга, при этом их пути комбинируются (объединяются через `/`) по вложенности.

## Сопоставление маршрутов

Пути в роутах можно писать в таком виде:  
`<путь>/:<переменная>[/...]`

Роутер React передаст значение `:<переменная>` в качестве свойства компоненту, внутри компонента оно будет доступно как `this.props.params.<переменная>`.

## Ссылки на роуты

Ссылки на роуты должны оформляться в виде:
```javascript
<Link to="<путь>" [className="<класс>"] [activeClassName="<класс_активности>"]>
    <текст>
</Link>
```

Redux
=====

Redux-приложение это:
- состояние (state) приложения в одном месте;
- однонаправленный поток данных.

Хранилище можно рассматривать как посредника для всех изменений состояния в приложении. При использовании Redux компоненты не общаются между собой, все изменения состояния передаются через единственное хранилище.

В Redux только один объект `Store`, который "объединяет" редюсер (`reducer`) и действия (`actions`).

## Actions

`Actions` описывают действия - описывает факт, что что-то произошло, но не указывает, как состояние приложения должно измениться в ответ. Тип действия, описывают как константу:  
`const <ТИП_ДЕЙСТВИЯ> = '<ТИП_ДЕЙСТВИЯ>';`

`Actions` - это простой объект со свойствами:
- `type` - обозначает тип действия, задается в виде константы: `<ТИП_ДЕЙСТВИЯ>` или в виде `<домен>/<событие>`;
- `payload` - данные, которые передаются вместе с действием;
- другие свойства.

Чтобы вызвать `actions`, необходимо написать функцию, которая в рамках `Flux`/`Redux` называется - `ActionsCreator` (создатель действия), которая вернет действие.

## Reducer

`Reducer` - редуктор, изменяет состояние приложения в ответ на указанные `Actions`.

Основной смысл в том чтобы разбить глобальное состояние на кусочки, за каждый кусочек отвечает свой `reducer`. Кусочки объединяются в Корневом Редюсере (`rootReducer`).

```javascript
function <reducer>(state, action) {
    // ...
    return <новое_состояние>;
}
```
Где `state` - исходное состояние, а `action` - действие.

Очень важно чтобы `state` не мутировали, а создавали каждый раз новый `state`, если он изменился.

## Точка входа

### Store

`const store = createStore(<главный_reducer>, <начальное_состояние>);` - создает хранилище из `'redux'`, с начальным `reducer` и начальным состоянием (по ум. `{}`). `Store` хранит состояние приложения. Единственный путь изменить `store` - это отправить действие (dispatch action). `Store` - это не класс. После создания хранилища Redux немедленно вызывает редукторы и использует возвращенные ими значения в качестве исходного состояния. Главный компонент тогда должен оборачивать компонент и выглядеть как:
```javascript
import { Provider } from "react-redux";
<Provider store={store}>
    ...
</Provider>
```

`store` - это обычный объект с несколькими методами, а именно:
- `getState();` - позволяет получить состояние приложения;
- `dispatch(<action>);`  - позволяет обновлять состояния, путем вызова (отправки) действия, возвращает то что было передано, то есть `<action>`;
- `subscribe(listener)` - регистрирует слушателей в виде функции, которые вызываются в момент изменения `store`, возвращает функцию, которую необходимо вызвать для отписки;
- `replaceReducer(nextReducer)`.

```javascript
const <Обернутый_компонент> = connect(
    [<функция_соответствия_состояния>, ]
    [<функция_соответствия_действий>, ]
    [<функция_слияния>, ]
    [<опции>]
)(<Компонент>)
```

Подключает React компонент к Redux `store`. Возвращает новый присоединенный компонент, который оборачивает переданный компонент - `<Connected(<Компонент>)>` и добавляет свойство, которое указывает на метод redux `store` - `dispatch`.

`<функция_соответствия_состояния>` (`mapStateToProps`) - будет вызываться каждый раз, когда состояние хранилища изменяется, преобразует состояние - текущее состояние хранилища Redux, к свойствам для компонента, т.е. соответствие `state` (глобального хранилища) к `props`. Если будет возвращен обычный объект, то возвращенный объект объединяется со свойствами компонента. Где:
- `state` - глобальное хранилище Redux;
- `ownProps` - исходные свойства, полученные компонентом.

Должна выглядеть как:
```javascript
function <функция_соответствия_состояния>(state, ownProps) {
    ...
    return {<свойство>: <значение> [, ...]};
}
```

`<функция_соответствия_действий>` (`mapDispatchToProps`) - преобразует действия к свойствам для компонента, т.е. соответствие `actions` к `props`. Где:
- `dispatch` - `dispatch` Redux;
- `ownProps` - исходные свойства, полученные компонентом.

Должна выглядеть как:
```javascript
function <функция_соответствия_действий>(dispatch, ownProps) {
    ...
    return {
        <dispatchedAction>: () => {...}
    };
}
```

```javascript
function <функция_соответствия_действий>(dispatch) {
    ...
    return {
        pageActions: bindActionCreators(<объект_ActionsCreator>, dispatch)
    };
}
```

или

```javascript
function <функция_соответствия_действий>(dispatch) {
    ...
    return {
        <метод>: () => {
            ...
            dispatch(<действие>);
            ...
        }
        [, ...]
    };
}
```

Функция из redux - `bindActionCreators` - позволяет связать функции создания действий с текущим хранилищем, и позволит вызывать во внутренних компонентах создателей действий `this.props.<ActionsCreator>(...)`, без предоставления `dispatch` объекта.

`<функция_слияния>` (`mergeProps`) - представляет собой функцию, которая принимает следующие три параметра:
- `stateProps` - объект свойств, возвращенный из вызова `<функция_соответствия_состояния>`(`mapStateToProps()`);
- `dispatchProps` - объект свойств с генераторами действий из `<функция_соответствия_действий>`(`mapDispatchToProps()`);
- `ownProps` - исходные свойства, полученные компонентом.

Эта функция возвращает простой объект со свойствами, который будет передан заключенному в обертку компоненту. Должна выглядеть как:
```javascript
function <функция_слияния>(stateProps, dispatchProps, ownProps) {
    ...
    return {<свойство>: <значение> [, ...]};
}
```

### Комбинирование редюсеров

Используется для назначения редюсера по ответственности за секцию состояния хранилища:
```javascript
{
    <имя_секции>: <значение>
    [, ...]
}
```

```javascript
const <новый_reducer> = combineReducers({
    <имя_секции>: <reducer>
    [, ...]
});
```

`combineReducers` - возвращает новый `reducer`, который объединяет указанные `reducer`.

Теперь, каждый редюсер возвращает исходное состояние, это состояние отправляется в соответствующий раздел (секцию) хранилища. И теперь в него каждый раз передается его секция, соответствующий раздел общего состояния.

Во время действия, вызываются все редюсеры.

## Контейнеры и компоненты

.                         | Компонент (глупый, презентационный) `component` | Контейнер (умный) `container`
------------------------- | ----------------------------------------------- | ---
**Цель**                  | Как это выглядит (разметка, стили) | Как это работает (получение данных, обновление состояния)
**Осведомлен о Redux**    | Нет | Да
**Для считывания данных** | Читает данные из `props` | Подписан на Redux `state` (состояние)
**Для изменения данных**  | Вызывает `callback` из `props` | Отправляет (`dispatch`) Redux действие (actions)
**Пишутся**               | Вручную | Обычно, генерируются Redux

**Презентационные компоненты** "глупые" в том смысле, что они не имеют понятия о том, откуда взялись свойства, которыми они оперируют.

Презентационные компоненты никогда не должны менять данные в свойствах самостоятельно. Фактически, любой компонент, принимающий свойства должен считать, что данные неизменны и принадлежат его родителю.

**Компоненты-контейнеры** (именуются с суффиксом Container) практически всегда являются родительскими для презентационных компонентов. В определенной степени они служат посредниками между презентационными компонентами и остальным приложением.

Компоненты-контейнеры могут создаваться точно также, как и любой другой компонент React. У них также, как у остальных компонентов, есть метод `render`, но они ничего не создают для своего рендеринга, а вместо этого возвращают результат в виде презентационного компонента.  
Умные компоненты должны обращаться к состоянию только с помощью селекторов.

### Селектор

**Селектор** - это чистая функция, принимающая в качестве аргумента глобальный стейт и возвращающая его в преобразованном виде:
```javascript
function <селектор>(store) {
    ...
    return <часть_store>;
}
```

Селекторы тесно связаны с редюсерами и расположены внутри редюсеров, экспортируемых по умолчанию. Селекторы позволяют провести некоторые расчеты по данным, прежде чем данные попадут в представление. Каждый раз, когда необходимо получить часть стейта (например в `mapStateToProps`), то должны использовать селекторы.

Главная идея состоит в том, чтобы инкапсулировать внутренний стейт приложения и скрыть его от представления. Использование селекторов позволит проводить рефакторинг, изменяя только редюсер и не вносить изменения в каждый компонент представления, который от него зависит.

По возможности селекторы должны возвращать данные из глобального стейта, а не новые данные. При возвращании новых данных лучше иметь оригинальные данные для их сверки, если они не равны, то затем использовать новые данные из селектора.

Вся бизнес-логика должна находиться внутри обработчиков событий (санков), селекторов и редюсеров.

### Создание actions

Практически любое действие пользователя в интерфейсе = отправка действия (dispatch actions).

Основной алгоритм работы:
1. Приложение получило изначальное состояние (initial state);
2. Пользователь что-то сделал, отправил действие (dispatch action);
3. Соответствующий редюсер обновил часть приложения, в согласии с тем, что узнал от действия;
4. Приложение изменилось и теперь отражает новое состояние;
5. ... (все повторяется по кругу, с пункта 2)

Это и есть однонаправленный поток данных.

`store.dispatch(<action>);` - отправляет действие.

### Усилители

Усилители - это middleware функции. Суть middleware функций, взять входные данные, добавить что-то и передать дальше. Middleware - это всегда функция, которая обычно возвращают функцию, если только целью middleware не является прервать цепочку вызовов.
Они добавляются при создании хранилища:
```javascript
import { createStore, applyMiddleware } from 'redux';

const store = createStore(
    <главный_reducer>,
    <начальное_состояние>,
    applyMiddleware(<middleware> [, ...])
);
```

Где `<middleware>` должно выглядеть как:
```javascript
function <middleware>(store) {
    return function (next) {
        return function (action) {
            <действия>
            return next(action);
        };
    };
};
```

Где:
- `store` - redux-store приложения;
- `next` - функция-обертка, которая позволяет продолжить выполнение цепочки;
- `action` - действие, которое было вызвано (`store.dispatch`).

### Асинхронные actions

Асинхронность построена на том что на каждое асинхронное действие вызывается свое действия, все построено на комбинации действий.

#### Усилитель: redux-thunk

Используется для того чтобы можно возвращать действия как функции для асинхронных запросов.

Подключение:
```javascript
import thunk from 'redux-thunk';

const store = createStore(
    rootReducer,
    applyMiddleware(thunk)
);
```

Если **action creator** (создатель действия) возвращает не простой объект, а функцию - то он выполняет его, иначе если это простой объект, то передает его дальше. И благодаря этому усилителю внутрь функции передаются как параметры функции `dispatch`, `getState` и то что вернет функция вернет вызвавший ее `dispatch`. Использование:
```javascript
function <actionCreator>() {
    return (dispatch, getState) => {...};
}

dispatch(<actionCreator>());
```

#### Усилитель: redux-saga

Это библиотека нацеленная делать сайд-эффекты проще и лучше путем работы с сагами.

Саги это дизайн паттерн из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.

Подключение:
```javascript
import createSagaMiddleware from 'redux-saga';
const sagaMiddleware = createSagaMiddleware();

const store = createStore(
    rootReducer,
    applyMiddleware(sagaMiddleware)
);
```

Базируются на генераторах. Использование:
```javascript
function* <saga>() {
    yield <saga_effect>()
    ...
}

sagaMiddleware.run(<saga>); // выполняет указаную сагу
```

##### Эффекты

Это простые объекты, которые содержат инструкции для выполнения в middleware функциях.

```javascript
import { delay } from 'redux-saga';
import { put, takeEvery, call } from 'redux-saga/effects';

function* <action_saga>() {
    yield takeEvery('<action>', <saga>); // производит связывание саги-генератора с действием, которая вызовется по определенному действию
    yield delay(<задержка_мс>); // возвращает промис, который разрешится через определенное время
    yield put(<action>); // отправляет действие
    yield call({<функция> | <генератор>}[, <арг1>[, ...]]); // выполняет функцию, которая возвращает промис или генератор
}

sagaMiddleware.run(<action_saga>);
```

Связывание действий с сагами должно использоваться в корневой саге, которая используется в `sagaMiddleware.run`, к которой подвязываются "саго-выполнители" для действий:
```javascript
import { all } from 'redux-saga/effects';

function* <root_saga>() {
    yield all([ // запускает параллельно саги на выполнение
        <saga>()
        [, ...]
    ]);
}

sagaMiddleware.run(<root_saga>);
```

## `reselect`

Для мемоизации при возвращении новых данных используется эта библиотека:
```javascript
import { createSelector } from 'reselect';

const <selector1> = createSelector(
    (state[, <арг1>[, ...]]) => <часть_state_или_новое_отображение>, // должна быть чистой функцией, которая фозвращает часть state или новое отображение части state [, каждая функция принимает все переданные аргументы]
    /* ... */
    (<результат_1_функции>[, ...]) => <суммарное_отображение> // на основании результатов вызова всех предыдущих функций, должно возвращать суммарное отображение
);

// альтернативное использование
const <selector2> = createSelector(
    [
        (state[, <арг1>[, ...]]) => <часть_state_или_новое_отображение>,
        /* ... */
    ]
    (<результат_1_функции>[, ...]) => <суммарное_отображение>
);

const result = <selector1>(state[, <арг1>[, ...]]); // использование
```

## Хуки

`const result = useSelector(state => <часть_state>);` - возвращает часть хранилища. Для удобства может принимать селектор из библиотеки `reselect`.

`const dispatch = useDispatch();` - возвращает `dispatch`.

`const store = useStore();` - возвращает `store` со всеми его методами.

Redux-Form
==========

Используется для управления состоянием форм в в приложении React.

## Инициализация

В корневом файле для всех редюсеров.
```jsx
...
import { reducer as formReducer } from 'redux-form';
...
const reducers = {
    ...
    form: formReducer,
};
const reducer = combineReducers(reducers);
export reducer;
```

## Форма

Базовая конструкция:
```jsx
import React, { Component } from 'react';
import {
    Field,
    reduxForm,
} from 'redux-form';

class <КлассФормы> extends Component {
    render() {
        const {
            handleSubmit, // функция обработчик формы - запускает валидации (синхронные и асинхронные) и если форма валидная, то вызывает this.props.onSubmit(values), может принимать в качестве первого параметра функцию обработки формы (values) => {}, вместо использования this.props.onSubmit
            initialValues, // объект с начальными значениями формы, где ключ - name элемента, а значение - его value
            reset, // функция, которая сбрасывает значения формы до начальных значений
            // функции создатели действий - отправляются через <actionCreator>()
            resetSection, // функция, которая сбрасывает значения секции формы до начальных значений, вызывается resetSection(<имя_секции>)
            // функции создатели действий - отправляются через <actionCreator>()
            blur, // функция, которая уводит фокус с элемента и изменяет его значение, вызывается blur(<имя_элемента>, <значение>)
            change, // функция, которая изменяет значение элемента, вызывается change(<имя_элемента>, <значение>)
            touch, // функция, которая помечает элемент, как "тронутый" для показа его ошибок, вызывается touch(<имя_элемента>)
            untouch, // функция, которая помечает элемент, как не "тронутый" для скрытия его ошибок, вызывается untouch(<имя_элемента>)
            pristine, // равно true, если форма не изменялась
            valid, // равно true, если форма проходит успешно все валидации
        } = this.props;

        return (
            <form onSubmit={handleSubmit}>
                <Field
                    name="<имя_элемента>"
                    component={<Компонент> | "input"}
                    <свойство1>={<значение>}
                />
                {*...*}
                <button type="submit" label="submit">Submit</button>
            </form>
        );
    }
}

// используется для украшения компонента <КлассФормы>
<КлассФормы> = reduxForm({
    form: '<имя_формы>', // имя формы в хранилище state (state.form.<имя_формы>)
    /**
     * Вызовется при сабмите формы, общеформенный валидатор
     * @param {Object.<string, string|Object>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @return {Object.<string, string|Object>} объект со значениями ошибок для полей формы, где ключ - name элемента, а значение - его ошибка
     */
    validate: (values) => {
        const errors = {};
        return errors;
    },
    /**
     * Вызовется при сабмите формы, общеформенный валидатор для предупреждений
     * @param {Object.<string, string|Object>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @return {Object.<string, string|Object>} объект со значениями предупреждений для полей формы, где ключ - name элемента, а значение - его предупреждение
     */
    warn: (values) => {
        const warnings = {};
        return warnings;
    },
    /**
     * Вызовется при сабмите формы, общеформенный асинхронный валидатор
     * @param {Object.<string, string>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @param {function(*): *} dispatch redux dispatch
     * @return {Promise} объект со значениями ошибок для полей формы, где ключ - name элемента, а значение - его ошибка
     */
    asyncValidate: (values, dispatch) => {
        return new Promise((res, rej) => {
            const errors = {};
            throw errors;
        });
    },
})(<КлассФормы>);

export default <КлассФормы>;
```

Если используется одинаковое имя `form` у форм, то используется общая для них форма.

Использование формы:
```jsx
import React, { Component } from 'react';
import { SubmissionError } from 'redux-form';
import <КлассФормы> from '<путь_к_форме>';

class App extends Component {
    /**
     * Вызовется при сабмите формы
     * @param {Object.<string, string>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     */
    submit(values) {
        // внутри можно сделать асинхронные проверки и выбросить исключения с ошибками
        return new Promise((res, rej) => {
            throw new SubmissionError({
                <имя> : "<текст_ошибки>",
            });
        });
    }
    render() {
        return (
            <<КлассФормы>
                onSubmit={this.submit}
                initialValues={<объект_с_начальными_значениями>}
            />
        );
    }
}
```

## Многоразовые компоненты

Для обвертки полей используется `Field` из `redux-form`. Его структура:
```jsx
/**
 * Функция по валидированию
 * @param {string} value значение поля
 * @param {Object.<string, string>} allValues объект со значениями формы, где ключ - name элемента, а значение - его value
 * @param {Object.<string, string>} props объект со свойствами элемента, где ключ - имя свойства, а значение - его значение
 * @param {string} name имя поля
 * @return {string?} текст ошибки или ничего в случае ее отсутствия
 */
function <функция_проверки1>(value, allValues, props, name) {
    return '<текст_ошибки>';
}

/**
 * Функция по нормализации
 * @param {string} value значение поля
 * @param {string} previousValue предыдущее значение поля
 * @param {Object.<string, string>} allValues объект со значениями формы, где ключ - name элемента, а значение - его value
 * @param {Object.<string, string>} previousAllValues объект с предыдущими значениями формы, где ключ - name элемента, а значение - его value
 * @param {string} name имя поля
 * @return {string} новое нормализированое значение
 */
function <функция_нормализации>(value, previousValue, allValues, previousAllValues, name) {
    return '<нормализированое_значение>';
}

/**
 * Функция по парсингу значения для хранилища
 * @param {string} value значение поля
 * @param {string} name имя поля
 * @return {string} новое значение
 */
function <функция_парсинга>(value, name) {
    return '<значение>';
}

/**
 * Функция по форматированию изначального значения из хранилища
 * @param {string} value значение поля
 * @param {string} name имя поля
 * @return {string} новое значение
 */
function <функция_форматирования>(value, name) {
    return '<значение>';
}

<Field
    name="<имя_элемента>"
    component={<Компонент> | "input"}
    validate={[<функция_проверки1>]}
    normalize={<функция_нормализации>}
    parse={<функция_парсинга>}
    format={<функция_форматирования>}
    <свойство1>={<значение>}
/>
```

Все свойства, которые передаются в компонент `Field` передаются в компонент, который указан в атрибуте `component`, как `props`.

Структура компонента:
```jsx
/**
 * @param {Object} props объект со свойствами
 *
 * @param {Object} props.meta объект с метасвойствами
 * @param {boolean} props.meta.touched true, если значение изменилось
 * @param {string} props.meta.error текст ошибки
 * @param {string} props.meta.warning текст предупреждения
 * @param {boolean} props.meta.active true, если это поле имеет фокус
 * @param {string} props.meta.form имя формы элемента
 * @param {function} props.meta.dispatch dispatch
 * @param {string} props.meta.initial начальное значение элемента
 * @param {boolean} props.meta.invalid true, если это поле не прошло валидацию
 *
 * @param {Object} props.input объект со свойствами для деструктуризации для input
 * @param {boolean} props.input.checked true, если значение есть
 * @param {string} props.input.name имя поля
 * @param {function (Event, string=, string=, string=): void} props.input.onChange функция вызываемая при изменении поля
 * @param {*} props.input.value значение поля
 */
export const <Компонент> = ({
    meta: {
        touched,
        error,
        warning,
        active,
        form,
        dispatch,
        initial,
        invalid,
    },
    input: {
        checked,
        name,
        onChange,
        value,
    },
    ...other,
}) => {
    return ();
};
```

### Сложные компоненты

Сложный компонент состоит из `Field`, которые используются в компоненте `FormSection`.

Структура сложного компонента:
```jsx
class <СложныйКомпонент> extends React.Component {
    render() {
        return <div>
                <Field
                    name="<имя_элемента>"
                    component={<Компонент> | "input"}
                    <свойство1>={<значение>}
                />
                {/*...*/}
        </div>
    }
}
```

Использование:
```jsx
import { FormSection } from 'redux-form';
class <КлассФормы> extends React.Component {
    render() {
        return <form onSubmit={...}>
            <FormSection name="<имя_секции1>">
                <СложныйКомпонент/>
            </FormSection>
            <FormSection name="<имя_секции2>">
                <СложныйКомпонент/>
            </FormSection>
        </form>
    }
}
```

Тогда при сабмите формы, список полей `values` будет в виде:
```js
{
    <имя_элемента1>: <значение>,
    <имя_элемента2>: <значение>,
    <имя_секции1>: {
        <имя_элемента1>: <значение>,
        <имя_элемента2>: <значение>
    },
    <имя_секции2>: {
        <имя_элемента1>: <значение>,
        <имя_элемента2>: <значение>
    },
}
```

### Множественные компоненты

Реализуются с помощью `FieldArray`. Он используется для объединения блоков в массив.

Структура сложного компонента:
```jsx
class <СложныйКомпонент> extends React.Component {
    render() {
        const {
            fields, // список для управления элементами массива
        } = this.props;
        return <div>
            {fields.map((elemName, i, fields) => ( // elemName - сформированое вложеное имя элемента, i - номер по порядку, fields - ссылка на fields из props
                <div key={i}>
                    <Field
                        name={`${elemName}.<имя_элемента1>`}
                        component={<Компонент> | "input"}
                        <свойство1>={<значение>}
                    />
                    <Field
                        name={`${elemName}.<имя_элемента1>`}
                        component={<Компонент> | "input"}
                        <свойство1>={<значение>}
                    />
                    {/*производит удаление элемента из массив*/}
                    <button type="button" onClick={() => fields.remove(i)}>
                    Remove
                    </button>

                    <hr/>
                </div>
            ))}
            <div>
                {/*производит добавление элемента в массив*/}
                <button type="button" onClick={() => fields.push({})}>
                Add
                </button>
            </div>
        </div>
    }
}
```

Использование:
```jsx
import { FieldArray } from 'redux-form';
class <КлассФормы> extends React.Component {
    render() {
        return <form onSubmit={...}>
            <FieldArray
                name={'<имя_массива>'}
                component={<СложныйКомпонент>}
            />
        </form>
    }
}
```


## Создатели действий

```js
import {
    // функции создатели действий - отправляются через dispatch(<actionCreator>())
    blur, // функция, которая уводит фокус с элемента и изменяет его значение, вызывается blur(<имя_формы>, <имя_элемента>, <значение>)
    change, // функция, которая изменяет значение элемента, вызывается change(<имя_формы>, <имя_элемента>, <значение>)
    touch, // функция, которая помечает элемент, как "тронутый" для показа его ошибок, вызывается touch(<имя_формы>, <имя_элемента>)
    untouch, // функция, которая помечает элемент, как не "тронутый" для скрытия его ошибок, вызывается untouch(<имя_формы>, <имя_элемента>)
} from 'redux-form';
```

Тестирование
============

Используется библиотека Jest для запуска тестов.

## Блок тестирования

Файлы с тестами именуются по такому формату: `<имя_файла>.test.js`.

```javascript
import React from "react";
import { render, unmountComponentAtNode } from "react-dom";
import { act } from "react-dom/test-utils";

import <Компонент> from "./<имя_файла>";

let container = null;
beforeEach(() => {
    // подготавливается DOM-элемент, куда будем происходить рендер
    container = document.createElement("div");
    document.body.appendChild(container);
});

afterEach(() => {
    // удаляется DOM-элемент при завершении теста, для очистки
    unmountComponentAtNode(container);
    container.remove();
    container = null;
});

it("<имя_теста>", () => {
    // рендер компонента
    // вспомогательная функция, которая проверяет, что все обновления,
    // связанные с этими "блоками", выполнены и применены к DOM
    // до проверки предполагаемого вывода
    act(() => {
        render(<<Компонент> />, container);
    });
    // проверки компонета
    expect(container.textContent).toBe("<значение>");
});
```

Пример тестов:
```javascript
it("renders with or without a name", () => {
    act(() => {
        render(<Hello />, container);
    });
    expect(container.textContent).toBe("Hey, stranger");

    act(() => {
        render(<Hello name="Jenny" />, container);
    });
    expect(container.textContent).toBe("Hello, Jenny!");

    act(() => {
        render(<Hello name="Margaret" />, container);
    });
    expect(container.textContent).toBe("Hello, Margaret!");
});
```

Паттерны
========

## Структура проекта

```
project
|-- src // распологает исходный код
    |-- API // содержит методы для взаимодействия с внешним API, парсеры для данных и адаптеры к ним, а также моки
        |-- index.ts
    |-- components // содержит базовые компоненты
        |-- Component1.tsx
        |-- Component2
            |-- index.tsx // все внутреннии компоненты доступны наружу через этот файл
            |-- Part1OfComponent2.tsx
        |-- ...
    |-- hocs // содержит компоненты высшего порядка (HOC)
        |-- withHOC1.tsx
        |-- ...
    |-- hooks // содержит общие хуки по проекту
        |-- useHook1.tsx
        |-- ...
    |-- pages // содержит страницы приложения
        |-- Page1.tsx
        |-- ...
    |-- store // содержит хранилище с данными для приложения, должно работать вне зависимости от самого приложения реакта, содержит функции для взаимодействия с API
        |-- index.ts
        |-- ...
    |-- utils // содержит вспомогательные функции, структуры, классы для работы приложения
        |-- util1.ts
    |-- App.tsx // главный компонент, в котором подключается и используется все что нужно для проекта
    |-- types.ts // содержит описание всех общих типов в приложении
|-- index.tsx // входная точка в проект
|-- package.json
```