Описание
========

**React** - одна из библиотек, которая придерживаются строгих соглашений о том, как структурировать код и управлять данными вашего приложения. **JSX** является результатом одного из таких соглашений. **React** воплощает идею, что разметка и код, который генерирует ее по своей природе связаны друг с другом. В **React** компонентах это реализуется генерацией разметки прямо из **JavaScript**, используя всю мощь языка.

Установка
=========

## Create React App

```bash
npm install -g create-react-app
create-react-app my-app

cd my-app
npm start
```
Производит установку с помощью `create-react-app`.

```bash
npm run build
```
Это создаст production-сборку приложения в сборке / папке вашего проекта.

## Установка как пакетов

```bash
npm init
npm install --save react react-dom
```

JSX
===

Является синтаксическим расширением JavaScript. JSX производит React-элементы.

**JSX** нужен для JavaScript XML - разметки в стиле XML внутри компонентов React. React может работать и без JSX, но именно JSX делает компоненты более читаемыми.
- **JSX** это синтаксическая трансформация - каждая JSX ветвь соответствует JavaScript функции;
- не требует никаких библиотек для выполнения;
- **JSX** ничего не добавляет и не изменяет в JavaScript - он просто вызывает функции.

JSX трансформирует JavaScript код в семантическую осмысленную разметку.

React определяет все возможные HTML элементы в пространстве имен `React.dom`. Это к тому же позволяет использовать полностью произвольные компоненты внутри разметки.

Для того чтобы файл с JSX стал доступен для React, в начало файла нужно вставить такой заголовок: `/** @jsx React.DOM */`

Без этого JSX не поймет что файл нужно обработать для React.

React предопределяет все HTML теги которые только есть в пространстве имен `React.DOM`. JSX трансформирует их в глобальные переменные, которые позволят использовать просто `<div>...</div>` вместо того, чтобы каждый раз указывать `var div = React.dom.div` в каждом JSX файле.

После компиляции JSX-выражения становятся регулярными JavaScript-объектами. Что значит внутри можно использовать все преимущества при создании структуры компонента в HTML подобном синтаксис, который трансформируется в простые JavaScript функции.

## Создание компонента

Концептуально, компоненты подобны JavaScript-функциям. Они принимают произвольные данные (называемые props) и возвращают React-элементы, описывающие что должно появиться на экране.

```JSX
class <Компонент> extends React.Component {
    render() {
        return (
            <html_код_компонента>
        );
    }
};
```

```JSX
const <Компонент> = (
    <html_код_компонента>
);
```

```JSX
function <Компонент>(props) {
    return <html_код_компонента>;
}
```
Это создаст компонент. Внутри `return` всегда должен возвращаться DOM-узел (то есть, что угодно, обернутое в один, единый, родительский тэг) или `null` для того чтобы не отображать компонент. **Компонент всегда должен называться с большой буквы**.

Компоненты могут ссылаться на другие компоненты в своём выводе (результате отрисовки). Это позволяет использовать абстракцию компонента для любого уровня детализации. Внутри компонентов можно также использовать другие компоненты в `<html_код_компонента>`:  
`<<Компонент>> <контент> </<Компонент>>`

Запись `<<Компонент>/>` эквивалентна: `<<Компонент>></<Компонент>>`.

React DOM использует соглашение об именовании свойств в camelCase нотации, вместо имен HTML-атрибутов. Т.е. для того чтобы указать CSS-классы тега необходимо использовать атрибут `className` вместо стандартного `class`.
Также можно напрямую использовать js-код, для этого его необходимо заключить в:
`{<код>}`

### Комментарии внутри JSX

`{/* <комментарий> */}`

### Отрисовка (отображение) компонента

```JSX
ReactDOM.render(
    <<Компонент>> <контент> </<Компонент>>,
    document.getElementById('<id>')
);
```
Это вставляет компонент внутрь указанного элемента в html.

## Отрисовка группы (массива) компонентов

Каждый элемент в массиве должен обладать свойством `key`, для того чтобы идентифицировать, какой элемент был изменен, добавлен или удален. Ключи должны быть предоставлены элементам внутри массива, чтобы дать элементам стабильную идентифицируемость. Ключи имеют смысл только в контексте окружающего массива, т.е. **элементы внутри вызова `map()` требуют ключей**.

```JSX
const items = <массив>.map((<элемент>) => {
    return <<Компонент> key={<ключ>}>...</<Компонент>>;
});
```

Отрисовка массива будет: `<div>{items}</div>`.

Свойства
========

В свойство компонента можно передать любой javascript примитив, объект, переменную и даже выражение. Они передаются в компонент как html атрибуты:

`<<Компонент> <свойство>={<значение>}[ ...]> <контент> </<Компонент>>`

Значения свойств доступны внутри компонента как: `this.props.<свойство>`.

Если свойству значение не присвоено, но свойство написано, то оно равно по умолчанию `true`.

Для записи свойства HTML, которое использует `-` в своем название, используется camelCase именование.

В `{this.props.children}` – хранится `<контент>`, который был передан в компонент, который может быть любым значением понятным для реакта, а именно объект, строка или функция, а значения `false`, `null`, `undefined`, и `true` игнорируются.
> `<UserList users={users}>{(user) => <li key={user.id}>Пользователь: {user.name}</li>}</UserList>`

`this.props` – иммутабельная структура, используется только для чтения.

Для вывода (отображения) значения переменной внутри JSX, нужно использовать указанный синтаксис, при этом все преобразуется в строку, перед тем как будет отрисовано:  
`{<переменная>}`

`<<Компонент> {...<объект_свойств>}> <контент> </<Компонент>>` - передача всех свойств компоненту, через объект, с помощью оператора расширения.

## Хранение элементов в переменной

`const <переменная> = <Компонент>;`  
Отрисовка компонента из переменной: `{<переменная>}`.

## Использование компонентов через переменные

`const <Компонент> = <компонент>;` - всегда должен быть с большой буквы.  
`<<Компонент> .../>`

Таким способом можно передавать компоненты через свойства.

## If - else внутри JSX

Оно доступно внутри JSX как `{<условие> ? <код_истины> : <код_лжи>}`.  
Только if без else `{<условие> && <код_истины>}`

```JSX
<div className="solid" tabIndex="0" customProperty="value">
    {valid && <div className="valid">Profile is valided</div>}
</div>
```

## HTML-код

`<<тег> dangerouslySetInnerHTML={{__html: '<html_код>'}}/>` - производит прямую вставку HTML-кода в элемент.

Локальное состояние
===================

Это состояние подобно свойствам `props`, но является приватным и полностью контролируется компонентом. Локальное состояние является возможностью, доступной только для классов. Используется для динамических свойств, оно хранится в `this.state`.

Для его использования необходимо:

```JSX
class <Компонент> extends React.Component {
    /**
     * @param {Object} props свойства переданные при создании
     */
    constructor(props) {
        super(props);
        this.state = {};// инициализация начального состояния, можно делать только в конструкторе
    }

    /**
     * срабатывает после того, как компонент был отрисован в DOM
     * тут есть возможность использовать refs (к примеру для установки фокуса или задействования других компонентов), таймауты, ajax-запросы и взаимодействие с другими библиотеками
     */
    componentDidMount() {}

    /**
     * вызывается сразу перед тем, как компонент будет удален из DOM
     */
    componentWillUnmount() {}

    /**
     * компонент будет примонтирован. В данный момент нет возможности посмотреть DOM элементы
     * @deprecated
     */
    componentWillMount() {}

    /**
     * компонент получает новые props
     * этот метод не вызывается в момент первого render'a. В этот момент, старые props доступны как this.props, а новые props доступны в виде nextProps. Если вызывать setState внутри этого метода - не будет вызван дополнительный render
     * @deprecated
     * @param {Object} nextProps новые свойства
     */
    componentWillReceiveProps(nextProps) {}

    /**
     * вызывается прямо перед render, когда новые props и state получены
     в этом методе нельзя вызывать setState
     * @deprecated
     */
    componentWillUpdate() {}

    /**
     * вызывается перед каждым вызовом render
     * должен возвращать объект для обновления state или null для, чтобы показать что обновлять нечего
     * @param {Object} props текущие свойства компонента
     * @param {Object} state текущий state компонента
     * @return {?Object} объект для обновления state
     */
    static getDerivedStateFromProps(props, state) {}

    /**
     * вызывается сразу после render, когда изменение еще не принято в DOM, позволяет захватить некоторую информацию из DOM
     * то что будет возвращено передается в componentDidUpdate
     * @param {Object} prevProps предыдущие свойства компонента
     * @param {Object} prevState предыдущие state компонента
     * @return {*} значение для передачи в componentDidUpdate
     */
    getSnapshotBeforeUpdate(prevProps, prevState) {}

    /**
     * вызывается сразу после render. Не вызывается в момент первого render'а компонента
     * @param {Object} prevProps предыдущие свойства компонента
     * @param {Object} prevState предыдущие state компонента
     * @param {*} snapshot результат функции getSnapshotBeforeUpdate
     */
    componentDidUpdate(prevProps, prevState, snapshot) {}

    /**
     * вызывается после того как была схвачена ошибка в компоненте
     * @param {Object} error выброшенная ошибка
     * @param {{componentStack: *}} info объект со свойством componentStack в котором содержится информация о том компоненте, который выбросил ошибку
     */
    componentDidCatch(error, info) {}

    /**
     * вызывается перед вызовом render при возникновении ошибки
     * должен возвращать объект для обновления state или null для, чтобы показать что обновлять нечего
     * @param {Object} error выброшенная ошибка
     * @return {?Object} объект для обновления state
     */
    static getDerivedStateFromError(error) {}

    /**
     * вызывается до начала процесса повторной отрисовки
     * если вернет true, то React выполнит обновление (перерисовку) компонента, при false не будет
     * @param {Object} nextProps новые свойства компонента
     * @param {Object} nextState новые state компонента
     * @return {boolean}
     */
    shouldComponentUpdate(nextProps, nextState) {}

    render() {
        return (<html_код_компонента>);
    }
};

<Компонент>.defaultProps = <объект_свойств_по_умолчанию>;
```

Чтобы получить значение свойства из состояния в JSX используется: `{this.state.<свойство>}`.

`this.state` нельзя модифицировать вручную, для этого необходимо использовать функции готового компонента:

`this.setState({<свойство>:<значение>[, ...]}[, () => {...}])` - изменяет (обновляет) состояние компонента, при этом объединяя новое состояние с предыдущим, и перерисовывает его, каждый раз должно передаваться новый экземпляр состояния с теми свойствами, которые поменялись (а не всеми) [и вызовет callback функцию после того, как новое состояние "установится"].

`this.setState((prevState, props) => {...}[, () => {...}])` - аналогично предыдущему варианту, где функция должна возвращать новое состояние (его обновляемую часть), а `prevState` - предыдущее состояние, `props` - свойства в момент отображения [и вызовет callback функцию после того, как новое состояние "установится"].

`this.setState()` - не изменяет `this.state` немедленно, а создает очередь изменений состояния. Доступ к `this.state` после вызова метода, потенциально может вернуть имеющееся (бывшее) значение.

Нельзя вызывать `setState` в `render`: так как реакт, видит изменилось состояние - начинает перерисовывать компонент - видит что изменилось состояние - начинает перерисовывать компонент и т.д.

Вызов `setState` родителя - перерисует дочерние компоненты.

Цикл жизни компонента
=====================

```
    Монтирование          :               Обновление             :        Демонтирование
        |                 :                                      :              |
        v                 :                                      :              |
    ---------------       :                                      :              |
    | constructor |       :  New props set­State() force­Update()  :              |
    ---------------       :     |          |            |        :              |
        |                 :     |          |            |        :              |
        v                 :     v          v            v        :              |
    ------------------------------------------------------------ :              |
    |                getDerivedStateFromProps                  | :              |
    ------------------------------------------------------------ :              |
        |                 :     |          |            |        :              |
        |                 :     v          v            |        :              |
        |                 : -------------------------   |        :              |
        |                 : | shouldComponentUpdate |   |        :              |
        |                 : -------------------------   |        :              |
        |                 :     |          |            |        :              |
        v                 :     v          x            v        :              |
    ------------------------------------------------------------ :              |
    |                           render                         | :              |     1
    ------------------------------------------------------------ :              |
        |                 :                |                     :              |
    +++ | +++++++++++++++ : ++++++++++++++ v +++++++++++++++++++ : ++++++++++++ | +++++++++
        |                 : ------------------------------------ :              |
        |                 : | getSnapshotBeforeUpdate          | :              |     2
        |                 : ------------------------------------ :              |
    +++ | +++++++++++++++ : ++++++++++++++ | +++++++++++++++++++ : ++++++++++++ | +++++++++
        v                 :                v                     :              |
    ------------------------------------------------------------ :              |
    |        React обновляет ­D­O­M и ссылки (refs)               | :              |     3
    ------------------------------------------------------------ :              |
        |                 :                |                     :              |
        v                 :                v                     :              v
    --------------------- : ------------------------------------ : ------------------------
    | componentDidMount | : |        componentDidUpdate        | : | componentWillUnmount |
    --------------------- : ------------------------------------ : ------------------------
```

Фазы:
1. Фаза **Render** - чистая и не имеет побочных эффектов. Может быть приостановлена, прервана и перезапущена самим React'ом;
2. Фаза **Pre-commit** - можно производить чтение DOM'a;
3. Фаза **Commit** - можно работать с DOM'ом, пускать побочные эффекты, намечать обновления.

Обработка событий
=================

Для использовании функций для обработки стандартных событий в `<html_код_компонента>` используется в нужном теге компонента, как значение необходимого свойства:

`<<тег> on<Событие> = {<функция_обработки_события>}>` - это привязывает функцию к указанному событию элемента, в эту функцию передается событие `e` -  это синтетическое событие (`SyntheticEvent`).

> `<div onClick = {(e) => {console.log(e);}}>...</div>`

На основе этого делаются произвольные события и Callback функции:

`<<тег> on<ПроизвольноеСобытие> = {<функция_обработки_события>}>`

Когда определяетcя компонент, используя ES6 класс, то общий паттерн таков: **обработчик события должен быть методом класса**. Для привязывания контекста `this` используется указаная конструкция в конструкторе класса:  
`this.<функция_обработки_события> = this.<функция_обработки_события>.bind(this);`

Теперь в свойствах компонента будет this.props.<функция_события> - которое будет содержать функцию для обратного вызова, которую необходимо будет вызвать в компоненте при указанном событии.

Контролируемые компоненты
=========================

Элемент ввода формы (например, `input`), значение которого контролируется React, называется "**контролируемый компонент**".

Если установлено свойство `value` для `input`, `textarea` и `select`, у которого нет `onChange` обработчика, то будет отрисовано поле только для чтения.

Если поле должно быть изменяемое, то нужно использовать `defaultValue`. А для `<input type="checkbox">` и `<input type="radio">` нужно использовать `defaultChecked`.

Для `select` выбранный `option` указывается по свойству `value` в `select`, которое должно быть равное `value` выбраного `option`. Если необходим множественный выбор, то `value` в `select` должно быть равно массиву, который состоит из значений `value` выбранных `option`.

В контролируемом компоненте, любая модификация состояния будет иметь ассоциированную функцию-обработчик. Это делает его простым для изменения или проверки данных, вводимых пользователем.

Для множественной обработки подобных полей можно воспользоваться связыванием:  
`<<тег> on<Событие>={<функция_обработки_события>.bind(this, <арг>[, ...])}>`

И тогда функция обработки будет выглядеть:  
`function <функция_обработки_события>(<арг>[, ...], e) {...}`

## Атрибут обратного вызова `ref`

Это специальный атрибут, который может быть присвоен любому компоненту. Атрибут `ref` принимает функцию обратного вызова, и вызывает ее после того, как компонент монтируется в DOM или удаляется из него. Используется для:
- анимации;
- управления фокусом, выделения текста или медиа функции;
- интеграция с другими библиотеками.

Когда атрибут `ref` используется в элементе HTML, функция обратного вызова принимает базовый элемент DOM в качестве аргумента.

Когда атрибут `ref` используется в кастомном компоненте React, функция обратного вызова принимает смонтированный экземпляр компонента в качестве аргумента.

`<<тег> ref={(input) => {this.<имя_переменной_в_классе> = input;}}>` - в переменную `<имя_переменной_в_классе> `- запишется ссылка на текущий элемент DOM или компонент.

Для прокидывания через компоненты используется, как правило, такое имя свойства: `inputRef`.

Если коллбэк атрибута `ref` определен как встроенная функция, она будет вызываться дважды во время перерисовок: сперва с `null`, а затем снова с DOM-элементом.

### Создание ссылок (>= 16.3)

`this.<имя_переменной_ссылки> = React.createRef();` - создание ссылки, как правило, они назначаются свойствам экземпляра компонента, в то время как компонент сконструирован таким образом, чтобы ссылки были доступны из любого места этого компонента.

`<<тег> ref={this.<имя_переменной_ссылки>}>` - присвоение ссылки на компонент.

`this.<имя_переменной_ссылки>.current;` - присвоит свойству `current` элемент DOM или компонента, когда компонент будет монтирован, и значение `null`, когда компонент будет демонтирован. Обновления `ref` происходят перед срабатыванием методов Жизненого Цикла `componentDidMount` или `componentDidUpdate`.

`ReactDOM.findDomNode(<компонент>)` - возвращает нативный DOM-элемент к которому относится компонент.

## Контекст

Контекст обеспечивает способ передачи данных через дерево компонентов без необходимости передавать свойства вручную на каждом уровне.

`const {Provider, Consumer} = React.createContext(<значение_по_умолчанию>);` - создает пару потребитель `Provider` и поставщик (провайдер) `Consumer`.

`<Provider[ value={<значение>}]>...</Provider>` - компонент, который позволяет потребителям подписываться на изменения контекста [принимает свойство `value`, которое должно быть передано потребителям, которые являются потомками данного провайдера]. Один провайдер может быть связан со многими потребителями. Провайдеры могут быть вложенными, чтобы переопределять значения глубже в дереве.

`<Consumer>{value => ...}</Consumer>` - компонент, который подписывается на изменения контекста. Требует функцию в качестве дочернего элемента. Функция получает текущее значение контекста и возвращает узел `React`. Аргумент `value`, переданный функции, будет равен свойству `value` ближайшего поставщика для этого контекста выше в дереве. Если для данного контекста нет провайдера, аргумент `value` будет равен значению `defaultValue`, которое было передано в `createContext()`. Все потребители перерисовываются всякий раз при изменении значения поставщика.

> `<Consumer>{theme => <Button theme={theme}/>}</Consumer>`

## Порталы

Порталы предоставляют способ отображения дочерних элементов в узел DOM, который существует вне иерархии DOM родительского компонента.

`ReactDOM.createPortal(<потомок_React>, <элемент_DOM>)` - создает портал, где `<потомок_React>` - любой отображаемый потомок React, такой как элемент, строка или фрагмент, а `<элемент_DOM>` - валидный DOM-узел в который необходимо отрисовать потомок. Используется в методе `render()` компонента.

```javascript
render() {
    return ReactDOM.createPortal(this.props.children, domNode);
}
```

Несмотря на то, что портал может быть где угодно в дереве DOM, он ведет себя как обычный дочерний элемент React во всех отношениях. Такие функции, как контекст, работают как и ранее, независимо от того, является ли дочерний элемент порталом, поскольку портал все еще существует в дереве React независимо от его положения в дереве DOM.

Это же касается и всплытия события. Событие, созданное внутри портала, будет распространяться к предкам в объемлющем дереве React, даже если они не являются предками в дереве DOM.

## Фрагменты `React.Fragment`

Используются для объединения DOM узлов. Для объединения множественных элементов.

```javascript
<React.Fragment>
    <Элемент />
    <Элемент />
    ...
</React.Fragment>
```

Сокращенный синтаксис:

```javascript
<>
    <Элемент />
    <Элемент />
    ...
</>
```

## `React.Children`

Представляет утилитарные функции для работы с `this.props.children`.

`React.Children.map(this.props.children, (child) => {... return ...;})` - работает аналогично функции `map` для массивов и возвращает новый массив, с исключениями, если `this.props.children` был единичный элемент, то вернется массив, если `null` или `undefined`, то `null`.

`React.Children.forEach(this.props.children, (child) => {...})` - работает аналогично функции `forEach` для массивов.

`React.Children.toArray(this.props.children)` - возвращает массив преобразованный из `this.props.children`.

## `React.cloneElement`

`React.cloneElement(<react_element>[, props][, ...children])` - возвращает клон элемента с добавленными свойствами, работает аналогично: `<element.type {...element.props} {...props}>{children}</element.type>`

## Компоненты высшего порядка

Компонент высшего порядка - это функция, которая принимает входной компонент и возвращает расширенную или изменённую версию этого компонента - декоратор. Обычно реализуется функцией, которая принимает компонент и использует каррирование.

```javascript
const <декоратор> = ([<аргумент>[, ...]]) => (<Компонент>) => {
    const <НовыйКомпонент> = (props) => ( // модифицированная версия компонента
        ...
        return (...);
    );

    return <НовыйКомпонент>;
};
```

Компонент авторизации:

```javascript
function withAuthentication(WrappedComponent) {
    const ModifiedComponent = (props) => {
        if (!props.isAuthenticated) {
            return <Redirect to="/login" />;
        }

        return (<WrappedComponent { ...props } />);
    };

    const mapStateToProps = (state) => ({
        isAuthenticated: state.session.isAuthenticated
    });

    return connect(mapStateToProps)(ModifiedComponent);
}
```

## Шаблон "render props"

**Шаблон "render props"**, или, как его ещё называют, "**функция как потомок**", позволяет достичь того же самого, что достижимо с помощью компонентов высшего порядка.

Идея использования **шаблона render props** заключается в передаче управления вашей функцией рендеринга другому компоненту, который затем возвращает управление через свойство, являющееся функцией.

Может быть использован в ситуациях, где нужна некая подходящая для повторного использования логика внутри компонента, при этом данный компонент не планируется оборачивать в компонент высшего порядка.

```javascript
class <Компонент> extends React.Component {
  constructor() {
    super();
  }
  render() {
    return this.props.children([<аргумент>[, ...]])
  }
}

const App = () => (
  <div>
    <Компонент>
      {([<аргумент>[, ...]]) => (...)}
    </Компонент>
  </div>
);
```

React Router
============

Используется для роутинга.

`const browserHistory = ReactRouter.browserHistory;` - определяет стратегию отслеживания истории. Объект `browserHistory` это синглтон.

`browserHistory.push('<путь>');` - переносит пользователя на другой URL.

```javascript
ReactDOM.render((
    <Router history={browserHistory}>
        <Route [path="<путь>"] component={<Компонент>}/> - маршрут
        [...]
        <Route [path="<путь>"] component={<Компонент>}>
            <IndexRoute component={<Компонент>} /> - корневой роутер, текущего роутера
            <вложенные_маршруты>
        </Route>
    </Router>
), document.getElementById('root'));
```
Должен помещаться в главный (корневой) элемент.

Каждый `<Route>` при совпадении URL будет выводить соответствующий компонент.

Одновременно в `'root'` будет выводиться лишь один из компонентов. Роутер переключает маршруты без запросов на сервер, при этом каждый компонент может быть самостоятельной новой страницей.

Маршруты можно вкладывать друг в друга, при этом их пути комбинируются (объединяются через `/`) по вложенности.

## Сопоставление маршрутов

Пути в роутах можно писать в таком виде:  
`<путь>/:<переменная>[/...]`

Роутер React передаст значение `:<переменная>` в качестве свойства компоненту, внутри компонента оно будет доступно как `this.props.params.<переменная>`.

## Ссылки на роуты

Ссылки на роуты должны оформляться в виде:

```javascript
<Link to="<путь>" [className="<класс>"] [activeClassName="<класс_активности>"]>
    <текст>
</Link>
```

Redux
=====

Redux-приложение это:
- состояние (state) приложения в одном месте;
- однонаправленный поток данных.

Хранилище можно рассматривать как посредника для всех изменений состояния в приложении. При использовании Redux компоненты не общаются между собой, все изменения состояния передаются через единственное хранилище.

В Redux только один объект `Store`, который "объединяет" редюсер (`reducer`) и действия (`actions`).

## Actions

`Actions` описывают действия - описывает факт, что что-то произошло, но не указывает, как состояние приложения должно измениться в ответ. Тип действия, описывают как константу:  
`const <ТИП_ДЕЙСТВИЯ> = '<ТИП_ДЕЙСТВИЯ>';`

`Actions` - это простой объект со свойствами:
- `type` - обозначает тип действия, задается в виде константы: `<ТИП_ДЕЙСТВИЯ>`;
- `payload` - данные, которые передаются вместе с действием;
- другие свойства.

Чтобы вызвать `actions`, необходимо написать функцию, которая в рамках `Flux`/`Redux` называется - `ActionsCreator` (создатель действия), которая вернет действие.

## Reducer

`Reducer` - редуктор, изменяет состояние приложения в ответ на указанные `Actions`.

Основной смысл в том чтобы разбить глобальное состояние на кусочки, за каждый кусочек отвечает свой `reducer`. Кусочки объединяются в Корневом Редюсере (`rootReducer`).

```javascript
function <reducer>(state, action) {
	...
    return <новое_состояние>;
}
```
Где `state` - исходное состояние, а `action` - действие.

Очень важно чтобы `state` не мутировали, а создавали каждый раз новый `state`, если он изменился.

## Точка входа

### Store

`const store = createStore(<главный_reducer>, <начальное_состояние>);` - создает хранилище из `'redux'`, с начальным `reducer` и начальным состоянием (по ум. `{}`). `Store` хранит состояние приложения. Единственный путь изменить `store` - это отправить действие (dispatch action). `Store` - это не класс. После создания хранилища Redux немедленно вызывает редукторы и использует возвращенные ими значения в качестве исходного состояния. Главный компонент тогда должен оборачивать компонент и выглядеть как:

```javascript
<Provider store={store}>
    ...
</Provider>
```

`store` - это обычный объект с несколькими методами, а именно:
- `getState();` - позволяет получить состояние приложения;
- `dispatch(<action>);`  - позволяет обновлять состояния, путем вызова (отправки) действия, возвращает то что было передано, то есть `<action>`;
- `subscribe(listener)` - регистрирует слушателей в виде функции, которые вызываются в момент изменения `store`, возвращает функцию, которую необходимо вызвать для отписки;
- `replaceReducer(nextReducer)`

```javascript
const <Обернутый_компонент> = connect(
    [<функция_соответствия_состояния>, ]
    [<функция_соответствия_действий>, ]
    [<функция_слияния>, ]
    [<опции>]
)(<Компонент>)
```

Подключает React компонент к Redux `store`. Возвращает новый присоединенный компонент, который оборачивает переданный компонент - `<Connected(<Компонент>)>` и добавляет свойство, которое указывает на метод redux `store` - `dispatch`.

`<функция_соответствия_состояния>` (`mapStateToProps`) - будет вызываться каждый раз, когда состояние хранилища изменяется, преобразует состояние - текущее состояние хранилища Redux, к свойствам для компонента, т.е. соответствие `state` (глобального хранилища) к `props`. Если будет возвращён обычный объект, то возвращённый объект объединяется со свойствами компонента. Где:
- `state` - глобальное хранилище Redux;
- `ownProps` - исходные свойства, полученные компонентом.

Должна выглядеть как:

```javascript
function <функция_соответствия_состояния>(state, ownProps) {
    ...
    return {<свойство>: <значение> [, ...]};
}
```

`<функция_соответствия_действий>` (`mapDispatchToProps`) - преобразует действия к свойствам для компонента, т.е. соответствие `actions` к `props`. Где:
- `dispatch` - `dispatch` Redux;
- `ownProps` - исходные свойства, полученные компонентом.

Должна выглядеть как:

```javascript
function <функция_соответствия_действий>(dispatch, ownProps) {
    ...
    return {
        <dispatchedAction>: () => {...}
    };
}
```

```javascript
function <функция_соответствия_действий>(dispatch) {
    ...
    return {
        pageActions: bindActionCreators(<объект_ActionsCreator>, dispatch)
    };
}
```

или

```javascript
function <функция_соответствия_действий>(dispatch) {
    ...
    return {
        <метод>: () => {
            ...
            dispatch(<действие>);
            ...
        }
        [, ...]
    };
}
```

Функция из redux - `bindActionCreators` - позволяет связать функции создания действий с текущим хранилищем, и позволит вызывать во внутренних компонентах создателей действий `this.props.<ActionsCreator>(...)`, без предоставления `dispatch` объекта.

`<функция_слияния>` (`mergeProps`) - представляет собой функцию, которая принимает следующие три параметра:
- `stateProps` - объект свойств, возвращённый из вызова `<функция_соответствия_состояния>`(`mapStateToProps()`);
- `dispatchProps` - объект свойств с генераторами действий из `<функция_соответствия_действий>`(`mapDispatchToProps()`);
- `ownProps` - исходные свойства, полученные компонентом.

Эта функция возвращает простой объект со свойствами, который будет передан заключённому в обёртку компоненту. Должна выглядеть как:

```javascript
function <функция_слияния>(stateProps, dispatchProps, ownProps) {
    ...
    return {<свойство>: <значение> [, ...]};
}
```

### Комбинирование редюсеров

Используется для назначения редюсера по ответственности за секцию состояния хранилища:

```javascript
{
    <имя_секции>: <значение>
    [, ...]
}
```

```javascript
const <новый_reducer> = combineReducers({
    <имя_секции>: <reducer>
    [, ...]
});
```

`combineReducers` - возвращает новый `reducer`, который объединяет указанные `reducer`.

Теперь, каждый редюсер возвращает исходное состояние, это состояние отправляется в соответствующий раздел (секцию) хранилища. И теперь в него каждый раз передается его секция, соответствующий раздел общего состояния.

Во время действия, вызываются все редюсеры.

## Контейнеры и компоненты

.                         | Компонент (глупый, презентационный) `component` | Контейнер (умный) `container`
------------------------- | ----------------------------------------------- | ---
**Цель**                  | Как это выглядит (разметка, стили) | Как это работает (получение данных, обновление состояния)
**Осведомлен о Redux**    | Нет | Да
**Для считывания данных** | Читает данные из `props` | Подписан на Redux `state` (состояние)
**Для изменения данных**  | Вызывает `callback` из `props` | Отправляет (`dispatch`) Redux действие (actions)
**Пишутся**               | Вручную | Обычно, генерируются Redux

**Презентационные компоненты** "глупые" в том смысле, что они не имеют понятия о том, откуда взялись свойства, которыми они оперируют.

Презентационные компоненты никогда не должны менять данные в свойствах самостоятельно. Фактически, любой компонент, принимающий свойства должен считать, что данные неизменны и принадлежат его родителю.

**Компоненты-контейнеры** (именуются с суффиксом Container) практически всегда являются родительскими для презентационных компонентов. В определенной степени они служат посредниками между презентационными компонентами и остальным приложением.

Компоненты-контейнеры могут создаваться точно также, как и любой другой компонент React. У них также, как у остальных компонентов, есть метод `render`, но они ничего не создают для своего рендеринга, а вместо этого возвращают результат в виде презентационного компонента.  
Умные компоненты должны обращаться к состоянию только с помощью селекторов.

### Селектор

**Селектор** - это чистая функция, принимающая в качестве аргумента глобальный стейт и возвращающая его в преобразованном виде:

```javascript
function <селектор>(store) {
    ...
    return <часть_store>;
}
```

Селекторы тесно связаны с редюсерами и расположены внутри редюсеров, экспортируемых по умолчанию. Селекторы позволяют провести некоторые расчеты по данным, прежде чем данные попадут в представление. Каждый раз, когда необходимо получить часть стейта (например в `mapStateToProps`), то должны использовать селекторы.

Главная идея состоит в том, чтобы инкапсулировать внутренний стейт приложения и скрыть его от представления. Использование селекторов позволит проводить рефакторинг, изменяя только редюсер и не вносить изменения в каждый компонент представления, который от него зависит.

Вся бизнес-логика должна находиться внутри обработчиков событий (санков), селекторов и редюсеров.

### Создание actions

Практически любое действие пользователя в интерфейсе = отправка действия (dispatch actions).

Основной алгоритм работы:
1. Приложение получило изначальное состояние (initial state);
2. Пользователь что-то сделал, отправил действие (dispatch action);
3. Соответствующий редюсер обновил часть приложения, в согласии с тем, что узнал от действия;
4. Приложение изменилось и теперь отражает новое состояние;
5. ... (все повторяется по кругу, с пункта 2)

Это и есть однонаправленный поток данных.

`store.dispatch(<action>);` - отправляет действие.

### Усилители

Усилители - это middleware функции. Суть middleware функций, взять входные данные, добавить что-то и передать дальше. Middleware - это всегда функция, которая обычно возвращают функцию, если только целью middleware не является прервать цепочку вызовов.
Они добавляются при создании хранилища:

```javascript
import { createStore, applyMiddleware } from 'redux';

const store = createStore(
    <главный_reducer>,
    <начальное_состояние>,
    applyMiddleware(<middleware> [, ...])
);
```

Где `<middleware>` должно выглядеть как:

```javascript
function <middleware>(store) {
    return function (next) {
        return function (action) {
            <действия>
            return next(action);
        };
    };
};
```

Где:
- `store` - redux-store приложения;
- `next` - функция-обертка, которая позволяет продолжить выполнение цепочки;
- `action` - действие, которое было вызвано (`store.dispatch`).

### Асинхронные actions

Асинхронность построена на том что на каждое асинхронное действие вызывается свое действия, все построено на комбинации действий.

#### Усилитель: redux-thunk

Используется для того чтобы можно возвращать действия как функции для асинхронных запросов.

Подключение:

```javascript
import thunk from 'redux-thunk';

const store = createStore(
    rootReducer,
    applyMiddleware(thunk)
);
```

Если **action creator** (создатель действия) возвращает не простой объект, а функцию - то он выполняет его, иначе если это простой объект, то передает его дальше. И благодаря этому усилителю внутрь функции передаются как параметры функции `dispatch`, `getState` и то что вернет функция вернет вызвавший ее `dispatch`. Использование:

```javascript
function <actionCreator>() {
    return (dispatch, getState) => {...};
}

dispatch(<actionCreator>());
```

#### Усилитель: redux-saga

Это библиотека нацеленная делать сайд-эффекты проще и лучше путем работы с сагами.

Саги это дизайн паттерн из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.

Подключение:

```javascript
import createSagaMiddleware from 'redux-saga';
const sagaMiddleware = createSagaMiddleware();

const store = createStore(
    rootReducer,
    applyMiddleware(sagaMiddleware)
);
```

Базируются на генераторах. Использование:

```javascript
function* <saga>() {
    yield <saga_effect>()
    ...
}

sagaMiddleware.run(<saga>); // выполняет указаную сагу
```

##### Эффекты

Это простые объекты, которые содержат инструкции для выполнения в middleware функциях.

```javascript
import { delay } from 'redux-saga';
import { put, takeEvery, call } from 'redux-saga/effects';

function* <action_saga>() {
    yield takeEvery('<action>', <saga>); // производит связывание саги-генератора с действием, которая вызовется по определенному действию
    yield delay(<задержка_мс>); // возвращает промис, который разрешится через определенное время
    yield put(<action>); // отправляет действие
    yield call({<функция> | <генератор>}[, <арг1>[, ...]]); // выполняет функцию, которая возвращает промис или генератор
}

sagaMiddleware.run(<action_saga>);
```

Связывание действий с сагами должно использоваться в корневой саге, которая используется в `sagaMiddleware.run`, к которой подвязываются "саго-выполнители" для действий:

```javascript
import { all } from 'redux-saga/effects';

function* <root_saga>() {
    yield all([ // запускает параллельно саги на выполнение
        <saga>()
        [, ...]
    ]);
}

sagaMiddleware.run(<root_saga>);
```

Redux-Form
==========

Используется для управления состоянием форм в в приложении React.

## Инициализация

В корневом файле для всех редюсеров.
```jsx
...
import { reducer as formReducer } from 'redux-form';
...
const reducers = {
    ...
    form: formReducer,
};
const reducer = combineReducers(reducers);
export reducer;
```

## Форма

Базовая конструкция:
```jsx
import React, { Component } from 'react';
import {
    Field,
    reduxForm,
} from 'redux-form';

class <КлассФормы> extends Component {
    render() {
        const {
            handleSubmit, // функция обработчик формы - запускает валидации (синхронные и асинхронные) и если форма валидная, то вызывает this.props.onSubmit(values), может принимать в качестве первого параметра функцию обработки формы (values) => {}, вместо использования this.props.onSubmit
            initialValues, // объект с начальными значениями формы, где ключ - name элемента, а значение - его value
            reset, // функция, которая сбрасывает значения формы до начальных значений
            // функции создатели действий - отправляются через <actionCreator>()
            resetSection, // функция, которая сбрасывает значения секции формы до начальных значений, вызывается resetSection(<имя_секции>)
            // функции создатели действий - отправляются через <actionCreator>()
            blur, // функция, которая уводит фокус с элемента и изменяет его значение, вызывается blur(<имя_элемента>, <значение>)
            change, // функция, которая изменяет значение элемента, вызывается change(<имя_элемента>, <значение>)
            touch, // функция, которая помечает элемент, как "тронутый" для показа его ошибок, вызывается touch(<имя_элемента>)
            untouch, // функция, которая помечает элемент, как не "тронутый" для скрытия его ошибок, вызывается untouch(<имя_элемента>)
            pristine, // равно true, если форма не изменялась
            valid, // равно true, если форма проходит успешно все валидации
        } = this.props;

        return (
            <form onSubmit={handleSubmit}>
                <Field
                    name="<имя_элемента>"
                    component={<Компонент> | "input"}
                    <свойство1>={<значение>}
                />
                {*...*}
                <button type="submit" label="submit">Submit</button>
            </form>
        );
    }
}

// используется для украшения компонента <КлассФормы>
<КлассФормы> = reduxForm({
    form: '<имя_формы>', // имя формы в хранилище state (state.form.<имя_формы>)
    /**
     * Вызовется при сабмите формы, общеформенный валидатор
     * @param {Object.<string, string|Object>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @return {Object.<string, string|Object>} объект со значениями ошибок для полей формы, где ключ - name элемента, а значение - его ошибка
     */
    validate: (values) => {
        const errors = {};
        return errors;
    },
    /**
     * Вызовется при сабмите формы, общеформенный валидатор для предупреждений
     * @param {Object.<string, string|Object>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @return {Object.<string, string|Object>} объект со значениями предупреждений для полей формы, где ключ - name элемента, а значение - его предупреждение
     */
    warn: (values) => {
        const warnings = {};
        return warnings;
    },
    /**
     * Вызовется при сабмите формы, общеформенный асинхронный валидатор
     * @param {Object.<string, string>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @param {function(*): *} dispatch redux dispatch
     * @return {Promise} объект со значениями ошибок для полей формы, где ключ - name элемента, а значение - его ошибка
     */
    asyncValidate: (values, dispatch) => {
        return new Promise((res, rej) => {
            const errors = {};
            throw errors;
        });
    },
})(<КлассФормы>);

export default <КлассФормы>;
```

Если используется одинаковое имя `form` у форм, то используется общая для них форма.

Использование формы:
```jsx
import React, { Component } from 'react';
import { SubmissionError } from 'redux-form';
import <КлассФормы> from '<путь_к_форме>';

class App extends Component {
    /**
     * Вызовется при сабмите формы
     * @param {Object.<string, string>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     */
    submit(values) {
        // внутри можно сделать асинхронные проверки и выбросить исключения с ошибками
        return new Promise((res, rej) => {
            throw new SubmissionError({
                <имя> : "<текст_ошибки>",
            });
        });
    }
    render() {
        return (
            <<КлассФормы>
                onSubmit={this.submit}
                initialValues={<объект_с_начальными_значениями>}
            />
        );
    }
}
```

## Многоразовые компоненты

Для обвертки полей используется `Field` из `redux-form`. Его структура:
```jsx
/**
 * Функция по валидированию
 * @param {string} value значение поля
 * @param {Object.<string, string>} allValues объект со значениями формы, где ключ - name элемента, а значение - его value
 * @param {Object.<string, string>} props объект со свойствами элемента, где ключ - имя свойства, а значение - его значение
 * @param {string} name имя поля
 * @return {string?} текст ошибки или ничего в случае ее отсутствия
 */
function <функция_проверки1>(value, allValues, props, name) {
    return '<текст_ошибки>';
}

/**
 * Функция по нормализации
 * @param {string} value значение поля
 * @param {string} previousValue предыдущее значение поля
 * @param {Object.<string, string>} allValues объект со значениями формы, где ключ - name элемента, а значение - его value
 * @param {Object.<string, string>} previousAllValues объект с предыдущими значениями формы, где ключ - name элемента, а значение - его value
 * @param {string} name имя поля
 * @return {string} новое нормализированое значение
 */
function <функция_нормализации>(value, previousValue, allValues, previousAllValues, name) {
    return <нормализированое_значение>;
}

<Field
    name="<имя_элемента>"
    component={<Компонент> | "input"}
    validate={[<функция_проверки1>]}
    normalize={<функция_нормализации>}
    <свойство1>={<значение>}
/>
```

Все свойства, которые передаются в компонент `Field` передаются в компонент, который указан в атрибуте `component`, как `props`.

Структура компонента:
```jsx
/**
 * @param {Object} props объект со свойствами
 *
 * @param {Object} props.meta объект с метасвойствами
 * @param {boolean} props.meta.touched true, если значение изменилось
 * @param {string} props.meta.error текст ошибки
 * @param {string} props.meta.warning текст предупреждения
 * @param {boolean} props.meta.active true, если это поле имеет фокус
 * @param {boolean} props.meta.form имя формы элемента
 *
 * @param {Object} props.input объект со свойствами для деструктуризации для input
 * @param {boolean} props.input.checked true, если значение есть
 * @param {string} props.input.name имя поля
 * @param {function (*|Event): void} props.input.onChange функция вызываемая при изменении поля
 * @param {*} props.input.value значение поля
 */
export const <Компонент> = ({
    meta: {
        touched,
        error,
        warning,
        active,
        form,
    },
    input: {
        checked,
        name,
        onChange,
        value,
    },
    ...other,
}) => {
    return ();
};
```

### Сложные компоненты

Сложный компонент состоит из `Field`, которые используются в компоненте `FormSection`.

Структура сложного компонента:
```jsx
class <СложныйКомпонент> extends React.Component {
    render() {
        return <div>
                <Field
                    name="<имя_элемента>"
                    component={<Компонент> | "input"}
                    <свойство1>={<значение>}
                />
                {*...*}
        </div>
    }
}
```

Использование:
```jsx
import { FormSection } from 'redux-form';
class <КлассФормы> extends React.Component {
    render() {
        return <form onSubmit={...}>
            <FormSection name="<имя_секции1>">
                <СложныйКомпонент/>
            </FormSection>
            <FormSection name="<имя_секции2>">
                <СложныйКомпонент/>
            </FormSection>
        </form>
    }
}
```

Тогда при сабмите формы, список полей `values` будет в виде:
```js
{
    <имя_элемента1>: <значение>,
    <имя_элемента2>: <значение>,
    <имя_секции1>: {
        <имя_элемента1>: <значение>,
        <имя_элемента2>: <значение>
    },
    <имя_секции2>: {
        <имя_элемента1>: <значение>,
        <имя_элемента2>: <значение>
    },
}
```

## Создатели действий

```js
import {
    // функции создатели действий - отправляются через dispatch(<actionCreator>())
    blur, // функция, которая уводит фокус с элемента и изменяет его значение, вызывается blur(<имя_формы>, <имя_элемента>, <значение>)
    change, // функция, которая изменяет значение элемента, вызывается change(<имя_формы>, <имя_элемента>, <значение>)
    touch, // функция, которая помечает элемент, как "тронутый" для показа его ошибок, вызывается touch(<имя_формы>, <имя_элемента>)
    untouch, // функция, которая помечает элемент, как не "тронутый" для скрытия его ошибок, вызывается untouch(<имя_формы>, <имя_элемента>)
} from 'redux-form';
```