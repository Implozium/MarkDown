[Содержание](#Содержание)
==========

- [x86](#x86)
    - [Синтаксис AT&T](#Синтаксис-ATT)
        - [Регистры](#Регистры)
            - [64](#64)
            - [Специальный регистр `eflags`](#Специальный-регистр-eflags)
        - [Инструкции](#Инструкции)
        - [Работа с оперативной памятью](#Работа-с-оперативной-памятью)
        - [Метки](#Метки)
        - [Стек](#Стек)
            - [Соглашение о вызовах](#Соглашение-о-вызовах)

<a id="x86" href="#x86">x86</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===

## <a id="Синтаксис-ATT" href="#Синтаксис-ATT">Синтаксис AT&T</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Регистры" href="#Регистры">Регистры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Существует **8** 32-битных регистров:
- `eax`;
- `ecx`;
- `edx`;
- `ebx`;
- `esp`;
- `ebp`;
- `esi`;
- `edi`.

Префикс `e` обозначает "расширенный".

Каждый регистр делится:
```
| eax                                     |
| 00000000 00000000   00000000   00000000 |
|                   | ax                  |
|                   | 00000000   00000000 |
|                   | ah       | al       |
|                   | 00000000 | 00000000 |
```

Все регисторы можно поделить и использовать:
- `eax` - 32-бита;
- `ax` - 16 младших бит регистра `eax`;
- `ah` - 8 старших бит регистра `ax`;
- `al` - 8 младших бит регистра `ax`.

#### <a id="64" href="#64">64</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Каждый регистр расширен до 64 бит:
- `rax`;
- `rcx`;
- `rdx`;
- `rbx`;
- `rsp`;
- `rbp`;
- `rsi`;
- `rdi`.

Который может делиться до `e` регистра.

Нижний байт регистров `rsp`, `rbp`, `rsi`, `rdi` теперь адресуется как `spl`, `bpl`, `sil`, `dil`.

Плюс добавлены новые регистры:
- `r8`;
- `r9`;
- `r10`;
- `r11`;
- `r12`;
- `r13`;
- `r14`;
- `r15`.

Каждый новый регистр делится:
- `r8d` - 32 бит;
- `r8w` - 16 бит;
- `r8l` - 8 бит.

#### <a id="Специальный-регистр-eflags" href="#Специальный-регистр-eflags">Специальный регистр `eflags`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется неявно для простановки флагов.

Основные флаги:
Бит | Флаг | Значение
--- | ---- | --------
0   | `CF` | переноса
2   | `PF` | четности
4   | `AF` | 
6   | `ZF` | нуля
7   | `SF` | знаковый
11  | `OF` | переполнения

### <a id="Инструкции" href="#Инструкции">Инструкции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Инструкции строятся по принципу: `<инструкция> [<операнд_источник>,] <операнд_источник_и_назначения>`.
> `addl %ecx, %eax`

Регистр с перфиксом `%` указывается в виде: `%<регистр>`. Регистры могут быть как источником, так и назначение.
> `%eax`

Значение с перфиксом `$` указывается в виде: `$0x<16-чное_значение>`, `$<10-чное_значение>`. Значения могут быть только источником.
> `$0xFF`, `$-2`

Арифметические инструкции:
Инструкция          | C-код                        | Пример             | Примечание
------------------- | ---------------------------- | ------------------ | ----------
`addl <op1>, <op2>` | `<op2> = <op2> + <op1>`      | `addl %ecx, %eax`  | 
`xorl <op1>, <op2>` | `<op2> = <op2> ^ <op1>`      | `xorl %esi, %ebp`  | 
`subl <op1>, <op2>` | `<op2> = <op2> - <op1>`      | `subl %edx, %ebx`  | 
`andl <op1>, <op2>` | `<op2> = <op2> & <op1>`      | `andl %esp, %eax`  | 
`notl <op1>`        | `<op1> = ~<op1>`             | `notl %eax`        | 
`incl <op1>`        | `<op1> = <op1> + 1`          | `incl %ecx`        | 
`shll %cl, <op2>`   | `<op2> = <op2> << cl`        | `shll %cl, %ebx`   | сдвиг может быть в только регистре `cl` или значением
`shrl %cl, <op2>`   | `<op2> = <op2> >> cl`        | `shrl $3, %edx`    | сдвиг может быть в только регистре `cl` или значением
`movl <op1>, <op2>` | `<op2> = <op1>`              | `movl $0xFF, %esi` | производит копирование
`addl <op1>, <op2>` | `<op2> = <op2> + <op1>`      | `addl $-2, %edi`   | 
`adсl <op1>, <op2>` | `<op2> = <op2> + <op1> + cf` | `adcl %ebx, %eax`  | 

### <a id="Работа-с-оперативной-памятью" href="#Работа-с-оперативной-памятью">Работа с оперативной памятью</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При сохранении значения больше одного байта в память, оно кодируется в прямом порядке байт и также сохраняется в ней.

Пример:
```
Число             : `OxDEADBEEF`
Значение в памяти : | EF | BE | AD | DE |
Адрес             : | 10 | 11 | 12 | 13 |
```

Операнд памяти: `<смещение> (<основа>, <индекс>, <масштаб>)`, где:
- `<смещение>` - это целочисленная константа (может быть положительной, отрицательной или нулевой);
- `<основа>` - это 32-битный регистр;
- `<индекс>` - это 32-битный регистр;
- `<масштаб>` - это одно из значений `{1,2,4,8}`.
> `-10(%eax,%ecx,4)` = `*(eax + (ecx * 4) - 10)`

Операнд памяти может быть источником и назначением. Арифметические инструкции могут получать один операнд памяти (никогда два).

Инструкции для работы с памятью:
Инструкция          | C-код                        | Пример             | Примечание
------------------- | ---------------------------- | ------------------ | ----------
`movb <op1>, <op2>` | `<op2> = *<op1>`             | `movb (%ecx), %al`    | считывает байты по адресу `<op1>` памяти в регистр `<op2>`
`movb <op1>, <op2>` | `*<op2> = <op1>`             | `movb %bl, (%edx)`       | записывает байты по адресу `<op2>` памяти из регистра `<op1>`
`leal <op1>, <op2>` | `<op2> = <op1>`              | `leal 5(%eax,%ebx,8), %ecx` | вычисляет адрес смещения

### <a id="Метки" href="#Метки">Метки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Метка: `<метка>:` - указывается перед инструкциями.
> `foo:`

Адреса меток фиксируются в коде при его компиляции.

Инструкции для работы с метками:
Инструкция          | Пример             | Примечание
------------------- | ------------------ | ----------
`jmp <lb>`          | `jmp top`          | переходит к указанной метке, а не следующей инструкции
`jmp *<op>`         | `jmp *%ecx`        | переходит к значению регистра, по сути, означает "скопировать значение из регистра в `eip`"
`je <lb>`           | `je top`           | переходит к указанной метке, а не следующей инструкции, если равно
`ja <lb>`           | `ja top`           | переходит к указанной метке, а не следующей инструкции, если не больше
`jle <lb>`          | `jle top`          | переходит к указанной метке, а не следующей инструкции, если меньше либо равно
`jnbe <lb>`         | `jnbe top`         | переходит к указанной метке, а не следующей инструкции, если не меньше или равно
`jo <lb>`           | `jo top`           | переходит к указанной метке, а не следующей инструкции, если переполнение
`jc <lb>`           | `jc top`           | переходит к указанной метке, а не следующей инструкции, если перенос

Регистр `eip` - 32-битный регистр который во время выполнения программы хранит адрес памяти текущей обрабатываемой инструкции.

### <a id="Стек" href="#Стек">Стек</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Стек - это область памяти, адресуемая регистром `esp`.

Стек растет вниз, от больших адресов памяти в направлении меньших. К примеру, добавление 32-битного значения в стек подразумевает уменьшение `esp` на 4 с последующим помещением этого 4-байтового значения в область памяти, начиная с адреса `esp`. Извлечение значения подразумевает обратные операции - загрузку 4 байтов, начинающихся с адреса `esp` (либо в заданный регистр, либо отбрасывание), и увеличение `esp` на 4.

Инструкции для работы с метками:
Инструкция          | Пример             | Примечание
------------------- | ------------------ | ----------
`call <lb>`         | `call func`        | переходит к указанной метке, но перед этим помещает в стек адрес следующей инструкции `eip`
`retl`              | `retl`             | извлекает из стека адрес инструкции и помещает ее в регистр `eip`
`pushl <op1>`       | `pushl %ecx`       | добавляет в стек значение из регистра и уменьшает `esp`
`popl <op1>`        | `popl %ecx`        | помещает значение из стека в регистр и увеличивает `esp`

#### <a id="Соглашение-о-вызовах" href="#Соглашение-о-вызовах">Соглашение о вызовах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В 32-битной системе x86 под Linux соглашение о вызовах называется `cdecl`. Вызывающий функцию компонент справа налево помещает аргументы в стек, вызывает целевую функцию, получает возвращаемое значение в `eax` и извлекает аргументы из стека.

Вызов функции осуществляется:
```
pushl <последний_аргумент>
...
pushl <первый_аргумент>
call <функция>
popl %ecx // извлечение первого аргумента функции из стека
...
popl %ecx // извлечение последнего аргумента функции из стека
```

Внутри функции значение стека:
```
0(%esp) содержит адрес инструкции вызывающего.
4(%esp) содержит значение первого аргумента.
8(%esp) содержит значение второго аргумента.
...
```