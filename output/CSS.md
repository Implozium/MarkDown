[Содержание](#Содержание)
==========

- [CSS. Правила построения](#user-content-CSS-Правила-построения)
    - [Группировка селекторов](#user-content-Группировка-селекторов)
    - [Вложенность](#user-content-Вложенность)
    - [Псевдоклассы](#user-content-Псевдоклассы)
    - [Псевдоэлементы](#user-content-Псевдоэлементы)
    - [Комментарии](#user-content-Комментарии)
- [Специфичность](#user-content-Специфичность)
    - [Разнообразные селекторы](#user-content-Разнообразные-селекторы)
- [Правила форматирования CSS](#user-content-Правила-форматирования-CSS)
- [Включение таблиц стилей в HTML-документ](#user-content-Включение-таблиц-стилей-в-HTML-документ)
- [Правила задания свойств](#user-content-Правила-задания-свойств)
    - [Значения стилевых свойств](#user-content-Значения-стилевых-свойств)
    - [Размеры](#user-content-Размеры)
        - [Вычисления значений](#user-content-Вычисления-значений)
            - [`calc`](#user-content-calc)
            - [`min`](#user-content-min)
            - [`max`](#user-content-max)
            - [`minmax`](#user-content-minmax)
            - [`clamp`](#user-content-clamp)
            - [`repeat`](#user-content-repeat)
                - [Особые случаи](#user-content-Особые-случаи)
            - [`auto`](#user-content-auto)
        - [Изначальное значение `initial`](#user-content-Изначальное-значение-initial)
        - [Наследование `inherit`](#user-content-Наследование-inherit)
        - [Сброс `unset`](#user-content-Сброс-unset)
        - [Сброс `revert`](#user-content-Сброс-revert)
    - [Цвет](#user-content-Цвет)
        - [Задание цвета с помощью HSL](#user-content-Задание-цвета-с-помощью-HSL)
        - [Задание цвета с помощью RGBA, HSLA](#user-content-Задание-цвета-с-помощью-RGBA-HSLA)
    - [Адреса](#user-content-Адреса)
    - [Ключевые слова](#user-content-Ключевые-слова)
- [Основные свойства](#user-content-Основные-свойства)
    - [Свойство `all`](#user-content-Свойство-all)
    - [Свойства для работы с текстом](#user-content-Свойства-для-работы-с-текстом)
        - [Семейство шрифтов: свойство `font-family`](#user-content-Семейство-шрифтов-свойство-font-family)
        - [Размер шрифтов: свойство `font-size`](#user-content-Размер-шрифтов-свойство-font-size)
        - [Насыщенность шрифтов: свойство `font-weight`](#user-content-Насыщенность-шрифтов-свойство-font-weight)
        - [Стиль шрифта: свойство `font-style`](#user-content-Стиль-шрифта-свойство-font-style)
        - [Капитель: свойство `font-variant`](#user-content-Капитель-свойство-font-variant)
        - [Свойство `font`](#user-content-Свойство-font)
        - [Свойство `@font-face`](#user-content-Свойство-font-face)
        - [Преобразование текста: свойство `text-transform`](#user-content-Преобразование-текста-свойство-text-transform)
        - [Украшение текста: свойство `text-decoration`](#user-content-Украшение-текста-свойство-text-decoration)
        - [Добавление теней к тексту: свойство `text-shadow`](#user-content-Добавление-теней-к-тексту-свойство-text-shadow)
        - [Свойство `text-overflow`](#user-content-Свойство-text-overflow)
            - [Свойство `line-clamp`](#user-content-Свойство-line-clamp)
        - [Интервал между словами: свойство `word-spacing`](#user-content-Интервал-между-словами-свойство-word-spacing)
        - [Свойство `word-wrap`](#user-content-Свойство-word-wrap)
        - [Свойство `hyphens`](#user-content-Свойство-hyphens)
        - [Свойство `overflow-wrap`](#user-content-Свойство-overflow-wrap)
        - [Пробелы между словами: свойство `white-space`](#user-content-Пробелы-между-словами-свойство-white-space)
        - [Выравнивание текста: свойство `text-align`](#user-content-Выравнивание-текста-свойство-text-align)
        - [Интерлиньяж: свойство `line-height`](#user-content-Интерлиньяж-свойство-line-height)
        - [Интервал между буквами: свойство `letter-spacing`](#user-content-Интервал-между-буквами-свойство-letter-spacing)
        - [Управление цветом переднего плана: свойство `color`](#user-content-Управление-цветом-переднего-плана-свойство-color)
    - [Свойства для работы с фоном](#user-content-Свойства-для-работы-с-фоном)
        - [Управление цветом фона: свойство `background-color`](#user-content-Управление-цветом-фона-свойство-background-color)
        - [Повторение фонового изображения: свойство `background-repeat`](#user-content-Повторение-фонового-изображения-свойство-background-repeat)
        - [Присоединение: свойство `background-attachment`](#user-content-Присоединение-свойство-background-attachment)
        - [Положение фонового изображения: свойство `background-position`](#user-content-Положение-фонового-изображения-свойство-background-position)
        - [Свойство `background`](#user-content-Свойство-background)
        - [Размер фонового изображения: свойство `background-size`](#user-content-Размер-фонового-изображения-свойство-background-size)
        - [Несколько фоновых изображений](#user-content-Несколько-фоновых-изображений)
        - [Свойство `background-origin`](#user-content-Свойство-background-origin)
    - [Маски](#user-content-Маски)
    - [Свойства для компоновки CSS](#user-content-Свойства-для-компоновки-CSS)
        - [Положение эелемента: свойство `inset`](#user-content-Положение-эелемента-свойство-inset)
        - [Поля элемента: свойство `margin`](#user-content-Поля-элемента-свойство-margin)
        - [Добавление границы: свойство `border`](#user-content-Добавление-границы-свойство-border)
        - [Толщина границы: свойство `border-width`](#user-content-Толщина-границы-свойство-border-width)
        - [Стиль границы: свойство `border-style`](#user-content-Стиль-границы-свойство-border-style)
        - [Цвет границы: свойства `border-color`](#user-content-Цвет-границы-свойства-border-color)
        - [Создание элементов со сглаженными углами: свойство `border-radius`](#user-content-Создание-элементов-со-сглаженными-углами-свойство-border-radius)
        - [Заполнение элемента: свойство `padding`](#user-content-Заполнение-элемента-свойство-padding)
        - [Размеры элемента](#user-content-Размеры-элемента)
        - [Область вырезки: свойство `clip`](#user-content-Область-вырезки-свойство-clip)
        - [Свойство `clip-path`](#user-content-Свойство-clip-path)
        - [Свойство `box-sizing`](#user-content-Свойство-box-sizing)
        - [Добавление к элементам тени: свойство `box-shadow`](#user-content-Добавление-к-элементам-тени-свойство-box-shadow)
        - [Создание прозрачных элементов и картинок: свойство `opacity`](#user-content-Создание-прозрачных-элементов-и-картинок-свойство-opacity)
        - [Свойство `object-fit`](#user-content-Свойство-object-fit)
    - [Работа с потоком элементов](#user-content-Работа-с-потоком-элементов)
        - [Типы блоков: свойство `display`](#user-content-Типы-блоков-свойство-display)
            - [`display: contents`](#user-content-display-contents)
        - ["Всплывающие" элементы: свойства `float` и `clear`](#user-content-Всплывающие-элементы-свойства-float-и-clear)
        - [Свойство `position`](#user-content-Свойство-position)
        - [Третье измерение веб-страницы: свойство `z-index`](#user-content-Третье-измерение-веб-страницы-свойство-z-index)
        - [Переполнение контейнеров: свойство `overflow`](#user-content-Переполнение-контейнеров-свойство-overflow)
        - [Прокрутка](#user-content-Прокрутка)
            - [Свойство `scroll-behavior`](#user-content-Свойство-scroll-behavior)
            - [Свойство `overscroll-behavior`](#user-content-Свойство-overscroll-behavior)
            - [Свойство `scrollbar-gutter`](#user-content-Свойство-scrollbar-gutter)
            - [Scroll snap](#user-content-Scroll-snap)
                - [Свойства контейнера](#user-content-Свойства-контейнера)
                - [Свойства дочерних элементов:](#user-content-Свойства-дочерних-элементов)
        - [Видимость элемента: свойство `visibility`](#user-content-Видимость-элемента-свойство-visibility)
    - [Счетчики](#user-content-Счетчики)
    - [Курсор](#user-content-Курсор)
        - [Свойство `pointer-events`](#user-content-Свойство-pointer-events)
        - [Свойство `user-select`](#user-content-Свойство-user-select)
    - [Трансформирование элементов](#user-content-Трансформирование-элементов)
        - [Свойство `transform`](#user-content-Свойство-transform)
        - [Свойство `translate`](#user-content-Свойство-translate)
        - [Свойство `scale`](#user-content-Свойство-scale)
        - [Свойство `rotate`](#user-content-Свойство-rotate)
    - [Градиенты](#user-content-Градиенты)
        - [Линейные градиенты](#user-content-Линейные-градиенты)
        - [Сферические градиенты](#user-content-Сферические-градиенты)
        - [Повторяющиеся градиенты](#user-content-Повторяющиеся-градиенты)
    - [Анимация](#user-content-Анимация)
        - [Переходы: свойство `transition`](#user-content-Переходы-свойство-transition)
            - [Шаги: steps](#user-content-Шаги-steps)
        - [Функции смягчения](#user-content-Функции-смягчения)
            - [Свойство `will-change`](#user-content-Свойство-will-change)
        - [Анимация: свойство `@keyframes`, свойство `animation`](#user-content-Анимация-свойство-keyframes-свойство-animation)
            - [Ход выполнения анимации](#user-content-Ход-выполнения-анимации)
        - [Правила анимациии](#user-content-Правила-анимациии)
        - [Разбиение текста на столбцы](#user-content-Разбиение-текста-на-столбцы)
    - [Произвольные свойства и переменные CSS](#user-content-Произвольные-свойства-и-переменные-CSS)
            - [Использование переключение переменных](#user-content-Использование-переключение-переменных)
            - [Использование переменных в JS](#user-content-Использование-переменных-в-JS)
        - [Свойства (property)](#user-content-Свойства-property)
    - [Атрибуты данных](#user-content-Атрибуты-данных)
- [Flexbox](#user-content-Flexbox)
    - [Основные свойства flex-контейнера](#user-content-Основные-свойства-flex-контейнера)
        - [Главная и поперечная ось: свойство `flex-direction`](#user-content-Главная-и-поперечная-ось-свойство-flex-direction)
        - [Выравнивание по главной оси: свойство `justify-content`](#user-content-Выравнивание-по-главной-оси-свойство-justify-content)
        - [Выравнивание по поперечной оси: свойство `align-items`](#user-content-Выравнивание-по-поперечной-оси-свойство-align-items)
        - [Многострочная организация блоков](#user-content-Многострочная-организация-блоков)
        - [Свойство `align-content`](#user-content-Свойство-align-content)
        - [Свойство `place-content`](#user-content-Свойство-place-content)
    - [CSS правила для дочерних элементов (flex-блоков)](#user-content-CSS-правила-для-дочерних-элементов-flex-блоков)
        - [Базовый размер отдельно взятого flex-блока: свойство `flex-basis`](#user-content-Базовый-размер-отдельно-взятого-flex-блока-свойство-flex-basis)
        - ["Жадность" отдельно взятого flex-блока: свойство `flex-grow`](#user-content-Жадность-отдельно-взятого-flex-блока-свойство-flex-grow)
        - [Фактор "сжимаемости" отдельно взятого flex-блока: свойство `flex-shrink`](#user-content-Фактор-сжимаемости-отдельно-взятого-flex-блока-свойство-flex-shrink)
        - [Свойство `flex`](#user-content-Свойство-flex)
        - [Выравнивание отдельно взятого flex-блока по поперечной оси: свойство `align-self`](#user-content-Выравнивание-отдельно-взятого-flex-блока-по-поперечной-оси-свойство-align-self)
        - [Порядок следования отдельно взятого flex-блока внутри flex-контейнера: свойство `order`](#user-content-Порядок-следования-отдельно-взятого-flex-блока-внутри-flex-контейнера-свойство-order)
- [Grid](#user-content-Grid)
    - [Главный контейнер](#user-content-Главный-контейнер)
        - [Шаблон сетки](#user-content-Шаблон-сетки)
        - [Названия линий](#user-content-Названия-линий)
    - [Дочерние контейнеры](#user-content-Дочерние-контейнеры)
        - [Расположение на шаблоне сетки](#user-content-Расположение-на-шаблоне-сетки)
        - [Выравнивание](#user-content-Выравнивание)
        - [Свойство `justify-items`](#user-content-Свойство-justify-items)
        - [Свойство `align-items`](#user-content-Свойство-align-items)
        - [Свойство `place-items`](#user-content-Свойство-place-items)
        - [Свойство `justify-content`](#user-content-Свойство-justify-content)
        - [Свойство `align-content`](#user-content-Свойство-align-content)
        - [Свойство `place-content`](#user-content-Свойство-place-content)
    - [Отличие Grid от Flexbox](#user-content-Отличие-Grid-от-Flexbox)
- [Адаптивность](#user-content-Адаптивность)
    - [CSS viewport в HTML](#user-content-CSS-viewport-в-HTML)
    - [Media Queries в CSS](#user-content-Media-Queries-в-CSS)
    - [Директива `@supports`](#user-content-Директива-supports)
    - [Директива `@container`](#user-content-Директива-container)
- [Приемы](#user-content-Приемы)
    - [Эффект длинных теней для текста](#user-content-Эффект-длинных-теней-для-текста)
    - [Эффект контурного текста](#user-content-Эффект-контурного-текста)
    - [Размытие текста](#user-content-Размытие-текста)
- [БЭМ](#user-content-БЭМ)
    - [Блок](#user-content-Блок)
    - [Элемент](#user-content-Элемент)
    - [Модификатор](#user-content-Модификатор)
        - [Типы модификаторов](#user-content-Типы-модификаторов)
        - [Принципы работы с модификаторами](#user-content-Принципы-работы-с-модификаторами)
    - [Микс](#user-content-Микс)

<a id="CSS-Правила-построения" href="#CSS-Правила-построения">CSS. Правила построения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======================

**Таблица стилей** документа представляет собой набор правил, ассоциированных с документом HTML и определяющих его отображение. Каждое правило в таблице стилей состоит из **селектора** и **блока объявлений**. **Блок объявлений** всегда отделяется от селектора пробелом и заключается в фигурные скобки. **Селектор** определяет область применения стилевого правила, а блок объявлений содержит одно или несколько объявлений, которые отделяются друг от друга точкой с запятой.

Каждое **объявление** включает в себя свойство и соответствующее этому свойству значение. Любое свойство является обобщенным параметром оформления и должно отделяться от значения двоеточием. **Свойства** могут быть достаточно разнообразны: они могут определять цвет элемента и фона, поля, заполнение, тип и размер шрифта и т.п. Набор допустимых значений для каждого конкретного свойства должен быть определен индивидуально.

```css
<селектор> {
    <свойство>: <значение>;
    ...
}
```

**Универсальные селекторы** - позволяют применить стилевое оформление сразу ко всем элементам на странице:  
`* {...}`

**Селекторы элементов** - для определения информации о представлении элементов HTML используют в качестве селекторов имена этих элементов:  
`<имя_тега> {...}`

**Селекторы классов** - для всех элементов со специальным атрибутом `class`, который позволяет особым образом отметить некоторые структурные элементы в документе. Подобные стилевые правила будут применяться ко всем элементам, которые имеют атрибут `class` с указанным значением:  
`.<имя_класса> {...}`

**Селекторы идентификаторов** - для всех элементов со специальным атрибутом `id`, с помощью которого любому элементу можно назначить уникальный идентификатор, значение атрибута `id` должно быть уникальным:  
`#<имя_идентификатора> {...}`

Можно соединять несколько селекторов, чтобы определить еще более конкретные правила:  
`[<имя_тега>][#<имя_идентификатора>][.<имя_класса>] {...}`

**Селекторы атрибутов** - позволяют выбирать элементы на основе содержащихся в них атрибутов:  
`<селектор>[<имя_атрибута>[[^$*~|]=<значение>]] {...}`
> `div[data-role*="submit"] {...}`

Виды соответствий селекторов атрибутов:
- `=` - точное полное соответствие значению;
- `~=` - одно из слов заданных в атрибуте разделенных через пробел соответствует значению;
- `|=` - соответствует точному полному совпадению со значением или может начинаться с `<значение>-`;
- `^=` - начинается со значения;
- `$=` - заканчивается со значения;
- `*=` - содержит как минимум одно вхождение значения как подстроки.

`i` - через пробел после значения обозначает регистронезависимость значения.

**Селекторы потомков** - используются для выбора только определенных элементов, которые являются потомками других определенных элементов, только для потомка родителя, а не для потомка потомков.  
`<селектор_1> > <селектор_2> {...}`

**Селекторы нижележащих элементов** - выбирают все подходящие элементы в любом месте иерархии элементов.  
`<селектор_1> <селектор_2> {...}`

**Селекторы смежных одноуровневых элементов** - позволяют выбирать определенный элемент, который следует непосредственно после другого определенного элемента на том же уровне в иерархии элементов.  
`<селектор_1> + <селектор_2> {...}`

**Селекторы одноуровневых элементов** - позволяют выбирать определенный элемент, который следует после другого определенного элемента на том же уровне в иерархии элементов.  
`<селектор_1> ~ <селектор_2> {...}`

## <a id="Группировка-селекторов" href="#Группировка-селекторов">Группировка селекторов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Если нескольким разным селекторам необходимо сопоставить одинаковые объявления, такие селекторы можно сгруппировать в список. Имена селекторов в данном случае должны разделяться запятыми:  
`<селектор_1>[, <селектор_2>[, ...]]] {...}`

## <a id="Вложенность" href="#Вложенность">Вложенность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Селекторы можно вкладывать внутрь других селекторов в `{}`, что позволяет избавиться от дублирующего кода:

```css
<селектор_родитель> {
    <селектор_ребенок> {
        /*..*/
    }
}
```

Что аналогично записи: `<селектор_родитель> <селектор_ребенок>`. Для того чтобы ссылаться на самого себя в секции детей, используется символ `&`. В этом случае на место `&` будет подставлен `<селектор_родитель>` и итоговый селектор останется.
```css
.example {
    font-family: system-ui;
    font-size: 1.2rem;
    & > a {
        color: tomato;
        &:hover,
        &:focus {
            color: ivory;
            background-color: tomato;
        }
    }
}
``` 

## <a id="Псевдоклассы" href="#Псевдоклассы">Псевдоклассы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Псевдоклассы используются для обеспечения стилевого оформления различных состояний элементов.  
`<селектор><псевдокласс> {...}`

Псевдокласс                    | Описание
 ----------------------------- | -------
`:invalid`                     | применяется к полям формы, содержимое которых не соответствует указанному типу.
`:user-invalid`                | применяется к полям формы, содержимое которых не соответствует указанному типу, не сработают, пока пользователь не начнёт взаимодействовать с полем.
`:read-only`                   | применяется к полям формы, у которых задан атрибут `readonly`.
`:active`                      | определяет стиль активной ссылки или нажатой кнопки.
`:checked`                     | применяется к элементам интерфейса, таким как переключатели (`checkbox`) и флажки (`radio`), когда они находятся в положение "включено"
`:default`                     | применяет стиль к элементам форм, которые установлены по умолчанию в группе похожих элементов.
`:disabled`                    | применяет стиль к заблокированным элементам форм.
`:empty`                       | представляет пустые элементы, т.е. те, которые не содержат дочерних элементов, текста или пробелов.
`:enabled`                     | используется для применения стиля к доступным (не заблокированным) элементам форм.
`:first-child`                 | применяет стилевое оформление к первому дочернему элементу своего родителя.
`:first-of-type`               | задает правила стилей для первого элемента в списке дочерних элементов своего родителя.
`:focus`                       | определяет стиль для элемента получающего фокус.
`:focus-within`                | определяет стиль для элемента в котором дочений элемент получил фокус.
`:hover`                       | определяет стиль элемента при наведении на него курсора мыши, но при этом элемент еще не активирован.
`:indeterminate`               | задает стиль для элементов форм, таким как флажки и переключатели, когда они находятся в неопределенном состоянии.
`:lang`                        | определяет язык, который используется в документе или фрагменте.
`:last-child`                  | задает стилевое оформление последнего элемента своего родителя.
`:last-of-type`                | задает правила стилей для последнего элемента в списке дочерних элементов своего родителя.
`:link`                        | применяется к ссылкам, которые еще не посещались пользователем.
`:nth-child(<соответствие>)`   | используется для добавления стиля к элементам на основе нумерации в дереве элементов, без исключения по типу.
`:nth-last-child`              | используется для добавления стиля к элементам на основе нумерации в дереве элементов.
`:nth-last-of-type`            | используется для добавления стиля к элементам указанного типа на основе нумерации в дереве элементов.
`:nth-of-type(<соответствие>)` | используется для добавления стиля к элементам указанного типа на основе нумерации в дереве элементов.
`:only-child`                  | применяется к дочерним элементам, только если он единственный у родителя.
`:only-of-type`                | применяется к дочерним элементам указанного типа, только если он единственный у родителя.
`:optional`                    | применяет стилевые правила к полю формы, у которого не задан атрибут `required`.
`:placeholder-shown`           | применяется когда отображается `placeholder` у элементов `<input>` и `<textarea>`.
`:popover-open`                | применяется когда отображается `popover` у элементов.
`:auto-fill`                   | применяется когда элемент `<input>` или `<textarea>` автоматически заполнены браузером.
`:read-write `                 | применяется к полям формы, доступных для изменения.
`:required`                    | применяет стилевые правила к тегу `<input>`, у которого установлен атрибут `required`.
`:root`                        | определяет корневой элемент документа. В HTML этот селектор всегда соответствует элементу `<html>`.
`:target`                      | применяется к целевому элементу, иными словами, к идентификатору, который указан в адресной строке браузера.
`:valid`                       | применяется к полям формы, содержимое которых проходит проверку в браузере на соответствие указанному типу.
`:user-valid`                  | применяется к полям формы, содержимое которых проходит проверку в браузере на соответствие указанному типу, не сработают, пока пользователь не начнёт взаимодействовать с полем.
`:visited`                     | применяется к ссылкам, уже посещенным пользователем, и задает для них стилевое оформление.
`:scope`                       | представляет элементы которые корневые для текущих элементов, в css-файлах соответствует `:root`
`:where(<селектор>)`           | выбирает все элементы, которые удовлетворяют селектору и имеет специфичность равную 0
`:is(<селектор>)`              | выбирает все элементы, которые удовлетворяют селектору и имеет специфичность равную специфичности селекторов
`:has(<селектор>)`             | выбирает все элементы, которые удовлетворяют условию, что внутри них есть элементы, которые удовлетворяют селектору (`:scope <селектор>`)
`:not(<селектор>)`             | выбирает все селекторы, которые не удовлетворяют простому селектору, примененному к одному элементу, то есть не исключает родителей элемента
`:host`                        | применяет стиль к shadow хосту
`:host(<селектор>)`            | применяет стиль к shadow хосту, который удолетворяет указанному селектору
`:host-context(<селектор>)`    | позволяет применить стиль к shadow хосту при условии что shadow хост удовлетворяет селектору (`<селектор> :host`)
`:state(<состояние>)`          | позволяет применить стиль к shadow хосту при условии что у shadow хост есть состояние `<состояние>`

Где `<соответствие>` может быть одним из:
- `odd` - все нечетные номера элементов;
- `even` - все четные номера элементов;
- `<число>` - конкретный номер;
- `<выражение>` - задается в виде `an+b`, где `a` и `b` целые числа, а `n` - счетчик, который автоматически принимает значение 0, 1, 2..., нумерация элементов в списке идет с 1 и если номер совпадает с выражением, то соответствие будет верно и применится этот селектор.

Также после `<соответствие>` может указываться `of <селектор>`, который указывает, что нужно применять только к элементам, которые удовлетворяют селектору `<селектор>`.

## <a id="Псевдоэлементы" href="#Псевдоэлементы">Псевдоэлементы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Псевдоэлементы добавляются к селекторам, но вместо описания специального состояния, они позволяют стилизовать некоторые части документа.  
`<селектор><псевдоэлемент> {...}`

Псевдоэлемент          | Описание
 --------------------- | -------
`::after`              | после селектора
`::before`             | перед селектором
`::first-letter`       | для первого символа
`::first-line`         | для первой строки блочного текста
`::selection`          | для выделеного участка текста, поддерживает только свойства `color`, `background` и `text-shadow`
`::part(<part_1>)`     | для доступа в shadow-tree к элементам с атрибутом `part` в котором находится `<part_1>`
`::slotted(<селектор>)`| для доступа к элементам (только на одном уровне вложенности), которые содержатся в `slot` и которые удовлетворяют селектору, где `<селектор>` - это тег с классами и атрибутами или `*` - для любого элемента
`::backdrop`           | позволяет стилизовать задний фон диалога `dialog`

## <a id="Комментарии" href="#Комментарии">Комментарии</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Комментарии в CSS начинаются с `/*` и заканчиваются `*/`.

<a id="Специфичность" href="#Специфичность">Специфичность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=============

Если к одному элементу одновременно применяются противоречивые стилевые правила, то более высокий приоритет имеет правило, у которого значение специфичности селектора больше. Специфичность это некоторая условная величина, вычисляемая следующим образом:
- за каждый идентификатор (a) начисляется 100;
- за каждый класс и псевдокласс (b), а также атрибут начисляется 10;
- за каждый селектор тега и псевдоэлемент (c) начисляется 1.

Складывая указанные значения в определенном порядке, получим значение специфичности для данного селектора.

Пример           | Описание    | Результат
 --------------- | ----------- | --------
`*`              | a=0 b=0 c=0 | специфичность = 0
`li`             | a=0 b=0 c=1 | специфичность = 1
`li:first-line`  | a=0 b=0 c=2 | специфичность = 2
`ul li`          | a=0 b=0 c=2 | специфичность = 2
`ul ol+li`       | a=0 b=0 c=3 | специфичность = 3
`ul li.red`      | a=0 b=1 c=2 | специфичность = 12
`li.red.level`   | a=0 b=2 c=1 | специфичность = 21
`#t34`           | a=1 b=0 c=0 | специфичность = 100
`#content #wrap` | a=2 b=0 c=0 | специфичность = 200

Встроенный стиль, добавляемый к тегу через атрибут `style`, имеет специфичность 1000, поэтому всегда перекрывает связанные и глобальные стили. Однако добавление `!important` перекрывает в том числе и встроенные стили.

Если два селектора имеют одинаковую специфичность, то применяться будет тот стиль, что указан в коде ниже.

## <a id="Разнообразные-селекторы" href="#Разнообразные-селекторы">Разнообразные селекторы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`.<класс>:not(.<класс> + .<класс>)` - обозначает только первый класс в списке классов.

<a id="Правила-форматирования-CSS" href="#Правила-форматирования-CSS">Правила форматирования CSS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========================

Каждое свойство - на отдельной строке.

Каждый селектор - на отдельной строке.

Свойства, сильнее влияющие на документ, идут первыми. Рекомендуется располагать свойства в следующем порядке:
1. Сначала положение элемента относительно других: `position`, `left/right/top/bottom`, `float`, `clear`, `z-index`;
2. Затем размеры и отступы: `width`, `height`, `margin`, `padding`...;
3. Рамка `border`, она частично относится к размерам;
4. Общее оформление содержимого: `list-style-type`, `overflow`...;
5. Цветовое и стилевое оформление: `background`, `color`, `font`...

Общая логика сортировки: "*от общего - к локальному и менее важному*". При таком порядке свойства, определяющие структуру документа, будут видны наиболее отчетливо, в начале, а самые незначительно влияющие (например цвет) - в конце.

Свойство без префикса пишется последним.

Организация CSS-файлов проекта:
- блоки-компоненты имеют свой CSS. Такой CSS идет "в комплекте" с модулем, его удобно выделять в отдельные файлы и подключать через `@import "<url>"`;
- страничный и интегрирующий CSS. Этот CSS описывает общий вид страницы, расположение компонент и их дополнительную стилизацию, зависящую от места на странице и т.п.

<a id="Включение-таблиц-стилей-в-HTML-документ" href="#Включение-таблиц-стилей-в-HTML-документ">Включение таблиц стилей в HTML-документ</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======================================

**Внешние таблицы стилей** - через отдельный файл:
```html
<head>
    <link rel="stylesheet" href="style.css" type="text/css">
</head>
```

**Внутренние таблицы стилей** - через описание в теге:
```html
<head>
    <style type="text/css">
        h1 {text-align: center}
    </style>
</head>
```

**Таблицы стилей элементов** - через описание в элементе:
```html
<h1 style="text-align: center"></h1>
```

<a id="Правила-задания-свойств" href="#Правила-задания-свойств">Правила задания свойств</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======================

## <a id="Значения-стилевых-свойств" href="#Значения-стилевых-свойств">Значения стилевых свойств</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Строки** - любые строки необходимо брать в двойные `"` или одинарные кавычки `'`. Если внутри строки требуется оставить одну или несколько кавычек, то можно комбинировать типы кавычек или добавить перед кавычкой обратный слэш `\`.

**Числа** - значением может выступать целое число, содержащее цифры от 0 до 9 и десятичная дробь, в которой целая и десятичная часть разделяются точкой. Если в десятичной дроби целая часть равна нулю, то ее разрешается не писать.

**Проценты** - процентная запись обычно применяется в тех случаях, когда надо изменить значение относительно родительского элемента или когда размеры зависят от внешних условий.

## <a id="Размеры" href="#Размеры">Размеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Абсолютные единицы не зависят от устройства вывода, а относительные единицы определяют размер элемента относительно значения другого размера.

**Относительные единицы** обычно используют для работы с текстом, либо когда надо вычислить процентное соотношение между элементами:
- `em` - размер шрифта текущего элемента;
- `ch` - размер символа в ширину шрифта текущего элемента;
- `ex` - высота символа **x**;
- `px` - пиксел;
- `%` - процент, для элементов с не статической позицией берутся проценты от ближайшего элемента с нестатической позицией в качестве основы;
- `rem` - root em;
- `vw` - 1% от ширины **viewport**;
- `vh` - 1% от высоты **viewport**;
- `vmin` - 1% от меньшей стороны (ширины или высоты) **viewport**;
- `vmax` - 1% от большей стороны (ширины или высоты) **viewport**;
- `fr` - обозначает дробную часть свободного пространства (в свободное пространство не входят отсупы) (`2fr` из `2fr 300px 3fr` это будет `2/(2+3)` от всего свободного пространства который будет равен `5fr - 300px`);
- `cqw` - 1% от ширины **container**.

Единица `em` это изменяемое значение, которое зависит от размера шрифта текущего элемента (размер устанавливается через стилевое свойство `font-size`). В каждом браузере заложен размер текста, применяемый в том случае, когда этот размер явно не задан. Поэтому изначально `1em` равен размеру шрифта, заданного в браузере по умолчанию или размеру шрифта родительского элемента. Процентная запись идентична `em`, в том смысле, что значения `1em` и `100%` равны.

Единица `ex` определяется как высота символа `x` в нижнем регистре. На `ex` распространяются те же правила, что и для `em`, а именно, он привязан к размеру шрифта, заданного в браузере по умолчанию, или к размеру шрифта родительского элемента.

Пиксел это элементарная точка, отображаемая монитором или другим подобным устройством, например, смартфоном. Размер пиксела зависит от разрешения устройства и его технических характеристик.

Единица размера `rem` (root em), которая похожа на `em`, но вместо сложной цепочки зависимостей по родительским элементам, она вычисляется только на основе размера шрифта элемента `<html>`.

**Абсолютные единицы** применяются реже, чем относительные и обычно при работе с текстом:
- `in` - дюйм (1 дюйм равен 2,54 см);
- `cm` - сантиметр;
- `mm` - миллиметр;
- `pt` - пункт (1 пункт равен 1/72 дюйма);
- `pc` - пика (1 пика равна 12 пунктам).

### <a id="Вычисления-значений" href="#Вычисления-значений">Вычисления значений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="calc" href="#calc">`calc`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`calc(<выражение>)` - это функция CSS, которая может быть использована для вычисления значений для длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`.

Где `<выражение>` - математическое выражение, результат вычисления которого можно использовать как значение CSS свойства, может использовать операторы `+`, `-`, `*`, `/` с использованием стандартных правил приоритета операторов, которые должны быть окружены пробелами. При этом операнды могут быть различными выражениями длины.

#### <a id="min" href="#min">`min`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`min(<выражение_1>, <выражение_2>)` - это функция CSS, которая может быть использована для вычисления минимального из двух значений для выражений длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`.

#### <a id="max" href="#max">`max`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`max(<выражение_1>, <выражение_2>)` - это функция CSS, которая может быть использована для вычисления максимального из двух значений для выражений длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`.

#### <a id="minmax" href="#minmax">`minmax`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`minmax(<мин_выражение>, <макс_выражение>)` - это функция CSS, которая может быть использована для вычисления значения больше или равно минимальному и меньше или равно максимальному для выражений длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`. По смыслу напоминает использование `auto` только с минимальным и максимальным ограничением.

#### <a id="clamp" href="#clamp">`clamp`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`clamp(<мин_выражение>, <предпочитаемое_выражение>, <макс_выражение>)` - это функция CSS, которая может быть использована для вычисления значения ограниченого максимум и минимум (аналогично `max(<мин_выражение>, min(<предпочитаемое_выражение>, <макс_выражение>))`) для выражений длины, которые принимают: `<length>`, `<frequency>`, `<angle>`, `<time>`, `<number>`, или `<integer>`.

#### <a id="repeat" href="#repeat">`repeat`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`repeat(<количество>, <значение>)` - повторяет переданое значение `<значение>` (может быть множеством значений указанных через пробел) указаное количество `<количество>` раз через пробел.

##### <a id="Особые-случаи" href="#Особые-случаи">Особые случаи</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`repeat(auto-fill, <значение>)` - для `grid` свойств: `grid-template-rows` `grid-template-columns` обозначает уместить как можно больше значений `<значение>`.
> `grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));`

`repeat(auto-fit, <значение>)` - аналогично `auto-fill`, только старается уместить элементы на весь размер, то есть при наличии свободного места элементы сетки будут растянуты.
> `grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));`

#### <a id="auto" href="#auto">`auto`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`auto` - автоматически вычисляемое значение:
- для `width` будет равно размеру содержимого за вычетом ширины его частей, задаваемых свойствами `margin` (поле, внешний отступ), `padding` (внутренний отступ) и `border` (граница) и при этом, не будет больше своего родительского элемента;
- для `height` будет равно высоте содержимого элемента;
- для `margin-left` и `margin-right` ширина полей оказывается одинаковой, то это приводит к горизонтальной центровке элемента относительно краев включающего его в себя блока;
- для `margin` ширина и высота полей оказывается одинаковой, то это приводит к центровке элемента относительно краев включающего его в себя блока;
- для `top`, `right`, `bottom` и `left` сбрасывает значение свойства, и приводит к такому значению как он должен был бы быть позиционирован в том случае, если бы был статическим элементом.

### <a id="Изначальное-значение-initial" href="#Изначальное-значение-initial">Изначальное значение `initial`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Ключевое слово `initial` в качестве значения позволяет использовать начальное значение свойства, которое есть у каждого свойства изначально.

### <a id="Наследование-inherit" href="#Наследование-inherit">Наследование `inherit`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Наследование в CSS является механизмом, с помощью которого определенные свойства передаются от элемента предка его элементам потомкам. Наследуются не все свойства CSS, значения, заданные в виде процентных величин, не наследуются никогда. Для свойств, которые не наследуются по умолчанию, можно определить принудительное наследование, используя ключевое слово `inherit` в качестве значения.

Для того, чтобы правила пользовательской таблицы стилей могли перекрывать авторскую, CSS содержит атрибут `!important`, ставится после значения свойства. Правило пользовательской таблицы стилей, имеющее такой атрибут, имеет больший вес, чем соответствующее правило авторской таблицы стилей.

### <a id="Сброс-unset" href="#Сброс-unset">Сброс `unset`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Ключевое слово `unset` в качестве значения позволяет сбросить значение свойства до унаследованного значения в том случае, если свойство естественным образом наследует это значение от родительского элемента. В противном случае значение сбрасывается до его исходного значения `initial`.

### <a id="Сброс-revert" href="#Сброс-revert">Сброс `revert`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Ключевое слово `revert` работает как `unset`, только сбрасывается до заданого браузером значения.

## <a id="Цвет" href="#Цвет">Цвет</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Цвет в стилях можно задавать способами:
- **по шестнадцатеричному значению** - используются числа в шестнадцатеричном коде. Шестнадцатеричная система, в отличие от десятичной системы, базируется, как следует из ее названия, на числе 16. Цифры будут следующие: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Цифры от 10 до 15 заменены латинскими буквами. Числа больше 15 в шестнадцатеричной системе образуются объединением двух чисел в одно. Каждый из трех цветов - красный, зеленый и синий - может принимать значения от 00 до FF. Таким образом, обозначение цвета разбивается на три составляющие `#rrggbb`, где первые два символа отмечают красную компоненту цвета, два средних - зеленую, а два последних - синюю. Допускается использовать сокращенную форму вида `#rgb` / `#rgba`, где каждый символ следует удваивать (`#rrggbb` / `#rrggbbaa`);
- **по названию** - браузеры поддерживают некоторые цвета по их названию;
- **с помощью функции rgb** - можно определить цвет, используя значения красной, зеленой, синей и прозрачной составляющей в десятичном исчислении. Значение каждого из трех цветов может принимать значения от 0 до 255, а прозрачной от 0 до 1. Также можно задавать цвет в процентном отношении. Вначале указывается ключевое слово `rgb`, а затем в скобках, через запятую указываются компоненты цвета:
    - `rgb(<красный>, <зеленый>, <синий>)`
    - `rgba(<красный>, <зеленый>, <синий>, <прозрачность>)`
        > `rgb(100%, 20%, 20%)`
    - `rgb(<красный> <зеленый> <синий> [/ <прозрачность>])`
        > `rgb(255 0 0 / 0.25)`
    - `rgb(from <цвет> r g b [/ alpha])` - позволяет забрать цветовые компоненты из другого цвета `<цвет>`, где `r`, `g`, `b`, `alpha` ссылаются на цветовые компоненты из цвета, их можно использовать в функции `calc` для вычисления нового
        > `rgb(from hsl(0 100% 50%) calc(r / 2) calc(g + 25) calc(b + 175) / calc(alpha - 0.1))`

### <a id="Задание-цвета-с-помощью-HSL" href="#Задание-цвета-с-помощью-HSL">Задание цвета с помощью HSL</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Цвет может задаваться с помощью HSL, то есть оттенка, насыщенности и яркости.
Для того, чтобы задать цвет этим способом необходимо указать:
- **оттенок** цвета указывается в градусах поворота цветового круга (0 градусов - красный, 120 градусов - зеленый, 240 градусов - голубой и т.д.);
- **насыщенность** цвета указывается в процентах (по мере понижения процентов цвет будет блекнуть);
- **яркость** цвета также указывается в процентах (0% - темный, 100% - светлый).

Можно задавать в виде:
- `hsl(<оттенок>, <насыщенность>, <яркость>)`
- `hsla(<оттенок>, <насыщенность>, <яркость>, <прозрачность>)`
- `hsl(<оттенок> <насыщенность> <яркость> [/ <прозрачность>])`
- `hsl(from <цвет> h s l [/ alpha])` - позволяет забрать цветовые компоненты из другого цвета `<цвет>`, где `h`, `s`, `l`, `alpha` ссылаются на цветовые компоненты из цвета, их можно использовать в функции `calc` для вычисления нового
    > `hsl(from rgb(200 0 0) calc(h + 30) s calc(l + 30))`

### <a id="Задание-цвета-с-помощью-RGBA-HSLA" href="#Задание-цвета-с-помощью-RGBA-HSLA">Задание цвета с помощью RGBA, HSLA</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Данный способ позволяет определять цвет и прозрачность одновременно. Вначале необходимо указать значения RGB, а затем значение прозрачности (0 - максимальная прозрачность, 1 - минимальная прозрачность). Подобно RGBA цвет сразу вместе с прозрачностью можно задавать используя HSLA.

## <a id="Адреса" href="#Адреса">Адреса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Адреса (*URI*, *Uniform Resource Identifiers*, *унифицированный идентификатор ресурсов*) применяются для указания пути к файлу, например, для установки фоновой картинки на странице. Для этого применяется ключевое слово `url()`, внутри скобок пишется относительный или абсолютный адрес файла. При этом адрес можно задавать в необязательных одинарных или двойных кавычках.

## <a id="Ключевые-слова" href="#Ключевые-слова">Ключевые слова</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В качестве значений активно применяются ключевые слова, которые определяют желаемый результат действия стилевых свойств. Ключевые слова пишутся без кавычек.

<a id="Основные-свойства" href="#Основные-свойства">Основные свойства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=================

## <a id="Свойство-all" href="#Свойство-all">Свойство `all`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Данное свойство сбрасывает все свойства до их начального или унаследованного значения. Имеет значения:
- `initial` - устанавливает для всех свойств соответствующие начальное значение;
- `inherit` - устанавливает для всех свойств унаследованные значения;
- `unset` - изменяет все значения на их соответствующее значение по умолчанию, которое равно `inherit` или `initial`;
- `revert` - результат зависит от источника таблицы стилей, в котором находится это свойство;
- `revert-layer` - с помощью этого свойства переходит к следующему каскадному слою, чтобы унаследовать стили от другого селектора.

## <a id="Свойства-для-работы-с-текстом" href="#Свойства-для-работы-с-текстом">Свойства для работы с текстом</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Семейство-шрифтов-свойство-font-family" href="#Семейство-шрифтов-свойство-font-family">Семейство шрифтов: свойство `font-family`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `font-family` используется для задания списка имен семейств шрифтов для отображения содержимого элемента. Список шрифтов может включать одно или несколько названий, разделенных запятыми. Если в имени шрифта содержатся пробелы, например, Times New Roman, оно должно заключаться в двойные или одинарные кавычки. Гарнитуры должны указываться в порядке возрастающей вероятности доступности или предпочтения. В качестве защиты от отказа значение свойства `font-family` всегда должно заканчиваться ключевым словом, ссылающимся на родовое имя шрифта. Таким образом, последовательность шрифтов лучше начинать с экзотических типов и заканчивать обобщенным именем, которое задает вид начертания.

Имя семейства шрифтов может быть задано как название семейства шрифтов (например, Times New Roman, Arial и т.д.) или как родовое имя. Родовые имена шрифтов были разработаны на тот случай, если на компьютере пользователя не установлен ни один из шрифтов, заданных разработчиком. В этом случае браузер использует родовой шрифт, начертание которого напоминает шрифт, который планировал использовать разработчик.

Спецификацией определено пять родовых имен:
- `sans-serif` - шрифт без засечек;
- `serif` - шрифт с засечками;
- `cursive` - каллиграфический шрифт;
- `fantasy` - декоративный шрифт;
- `monospace` - телетайпный.

### <a id="Размер-шрифтов-свойство-font-size" href="#Размер-шрифтов-свойство-font-size">Размер шрифтов: свойство `font-size`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Набор констант `хх-small`, `x-small`, `small`, `medium`, `large`, `x-large`, `xx-large` задает размер, который называется абсолютным. Другой набор констант `larger`, `smaller` устанавливает относительные размеры шрифта, относительно родителя. Также разрешается использовать любые допустимые единицы CSS: `em` (высота шрифта элемента), `ех` (высота символа х), пункты (`pt`), пиксели (`рх`), проценты (`%`) и др. При использовании процентной записи за 100% принимается размер шрифта родительского элемента.

### <a id="Насыщенность-шрифтов-свойство-font-weight" href="#Насыщенность-шрифтов-свойство-font-weight">Насыщенность шрифтов: свойство `font-weight`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Значениями этого свойства могут быть ключевые слова `bold`, `bolder`, `lighter` и `normal`, которые устанавливают полужирное, жирное, светлое и нормальное начертание шрифта. Также можно использовать условные единицы от `100` до `900` с шагом `100`, причем чем больше значение, тем выше жирность. Установленное по умолчанию нормальное начертание шрифта эквивалентно значению `400`, а стандартный полужирный текст - `700`.

### <a id="Стиль-шрифта-свойство-font-style" href="#Стиль-шрифта-свойство-font-style">Стиль шрифта: свойство `font-style`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Определяет начертание шрифта как обычное, курсивное или наклонное. Данным начертаниям соответствуют значения свойства `normal`, `italic` и `oblique`.

### <a id="Капитель-свойство-font-variant" href="#Капитель-свойство-font-variant">Капитель: свойство `font-variant`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Капителью называется текст, набранный прописными буквами уменьшенного размера. Для создания такого эффекта используется свойство `font-variant` со значением `small-caps`. Особенность капители заключается в том, что заглавные и строчные буквы при ее использовании сохраняются.

### <a id="Свойство-font" href="#Свойство-font">Свойство `font`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`font: [<font-style>||<font-variant>||<font-weight>] <font-size> [/<line-height>] <font-family> | inherit`

### <a id="Свойство-font-face" href="#Свойство-font-face">Свойство `@font-face`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет использовать любые шрифты. Необходимый шрифт просто нужно разместить на веб-сервере и подключить с помощью свойства `@font-face`. Подключенный шрифт будет загружен и отображен автоматически при посещении страницы пользователем.

```css
@font-face {
    font-family: <имя_шрифта_для_использования>;
    src: url(<путь_к_шрифту>);
}
```

### <a id="Преобразование-текста-свойство-text-transform" href="#Преобразование-текста-свойство-text-transform">Преобразование текста: свойство `text-transform`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Данное свойство может принимать четыре значения:
- `none` - текст пишется без изменений;
- `capitalize` - каждое слово будет начинаться с заглавного символа;
- `lowercase` - все символы становятся строчными (нижний регистр);
- `uppercase` - все символы становятся прописными (верхний регистр).

### <a id="Украшение-текста-свойство-text-decoration" href="#Украшение-текста-свойство-text-decoration">Украшение текста: свойство `text-decoration`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет задать тексту дополнительное оформление. Значениями данного свойства являются константы none, `underline`, `overline`, `line-through` и `blink`, позволяющие отобразить обычный текст, провести линию над, под или через текст, а также сделать текст мигающим.

### <a id="Добавление-теней-к-тексту-свойство-text-shadow" href="#Добавление-теней-к-тексту-свойство-text-shadow">Добавление теней к тексту: свойство `text-shadow`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`text-shadow: none / <тень>[,<тень>]*`

Где `<тень>`: `<сдвиг_по_x> <сдвиг_по_y> [<радиус_размытия>] [<цвет>]`

### <a id="Свойство-text-overflow" href="#Свойство-text-overflow">Свойство `text-overflow`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет указать, что должно случиться с текстом вышедшем за пределы границ элемента. Принимает значения `clip` текст обрезается по размеру области, `ellipsis` текст обрезается и к концу строки добавляется многоточие (также нужно свойство: `overflow: hidden;`).

#### <a id="Свойство-line-clamp" href="#Свойство-line-clamp">Свойство `line-clamp`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет указать сколько строк текста оставить при обрезании.

### <a id="Интервал-между-словами-свойство-word-spacing" href="#Интервал-между-словами-свойство-word-spacing">Интервал между словами: свойство `word-spacing`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Значения данного свойства можно задать с помощью ключевого слова `normal`, которое используется по умолчанию и задает стандартный интервал для текущего шрифта. Для задания интервала в дополнение к стандартному можно указать значение в любых доступных единицах CSS, причем значение может быть и отрицательным.

### <a id="Свойство-word-wrap" href="#Свойство-word-wrap">Свойство `word-wrap`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Указывает, переносить или нет длинные слова, которые не помещаются по ширине в заданную область.

`word-wrap: normal | break-word | inherit`

### <a id="Свойство-hyphens" href="#Свойство-hyphens">Свойство `hyphens`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Определяет будут ли использованы переносы строк, требует установленного языка через атрибут тега `lang="<язык>"`.

`hyphens: auto`

### <a id="Свойство-overflow-wrap" href="#Свойство-overflow-wrap">Свойство `overflow-wrap`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Является алиасом свойства: `word-wrap`.

### <a id="Пробелы-между-словами-свойство-white-space" href="#Пробелы-между-словами-свойство-white-space">Пробелы между словами: свойство `white-space`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Устанавливает, как отображать пробелы между словами. Возможные значения:
- `normal` - текст в окне браузера выводится как обычно, переносы строк устанавливаются автоматически.
- `nowrap` - пробелы не учитываются, переносы строк в коде HTML игнорируются, весь текст отображается одной строкой; вместе с тем, добавление тега `<br>` переносит текст на новую строку.
- `pre` - текст показывается с учетом всех пробелов и переносов, как они были добавлены разработчиком в коде HTML. Если строка получается слишком длинной и не помещается в окне браузера, то будет добавлена горизонтальная полоса прокрутки.
- `pre-line` - в тексте пробелы не учитываются, текст автоматически переносится на следующую строку, если он не помещается в заданную область.
- `pre-wrap` - в тексте сохраняются все пробелы и переносы, однако если строка по ширине не помещается в заданную область, то текст автоматически будет перенесен на следующую строку.

### <a id="Выравнивание-текста-свойство-text-align" href="#Выравнивание-текста-свойство-text-align">Выравнивание текста: свойство `text-align`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Допустимыми значениями данного свойства являются `left`, `right`, `center` и `justify`, задающие выравнивание по левому краю, по правому краю, по центру и по ширине соответственно.

### <a id="Интерлиньяж-свойство-line-height" href="#Интерлиньяж-свойство-line-height">Интерлиньяж: свойство `line-height`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Интерлиньяжем называется расстояние между базовыми линиями близких друг к другу строк. При обычных обстоятельствах расстояние между строками зависит от вида и размера шрифта и автоматически определяется браузером. Заданное по умолчанию значение `normal` заставляет браузер вычислять расстояние между строками автоматически. Любое число больше нуля воспринимается как множитель от размера шрифта текущего текста. В качестве значений данного свойства допустимо также использовать любые единицы длины, принятые в CSS. Разрешается также использовать процентную запись, причем в этом случае за 100% принимается высота шрифта. Отрицательное значение межстрочного расстояния не допускается.

### <a id="Интервал-между-буквами-свойство-letter-spacing" href="#Интервал-между-буквами-свойство-letter-spacing">Интервал между буквами: свойство `letter-spacing`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Браузер автоматически подбирает интервалы между символами, исходя из размера и типа шрифта. В качестве значений данного свойства могут использоваться любые единицы длины, принятые в CSS, однако рекомендуется использовать относительные единицы, основанные на размере шрифта (`em` и `ех`), допускает использование отрицательного значения.

### <a id="Управление-цветом-переднего-плана-свойство-color" href="#Управление-цветом-переднего-плана-свойство-color">Управление цветом переднего плана: свойство `color`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Цвет текста задается свойством `color`. Значения данного свойства можно задавать несколькими способами. Можно задать явное название цвета (`red`, `yellow` и др.), указать шестнадцатеричное значение или значение RGB. Шестнадцатеричное значение состоит из символа `#`, за которым следует шесть символов. Первая пара указывает уровень красного цвета, а вторая и третья - уровни зеленого и синего цветов соответственно, например, `#FF0000`. Можно определить цвет, используя значения уровня красной, зеленой и синей составляющей в десятичном исчислении, например, `RGB(49, 151, 116)`. Также можно задавать цвет в процентном отношении.

`currentColor` - переменная которая берет свое значение цвета из свойства `color`.

> `color: red; text-shadow: 0 0 5px currentColor;`

## <a id="Свойства-для-работы-с-фоном" href="#Свойства-для-работы-с-фоном">Свойства для работы с фоном</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Управление-цветом-фона-свойство-background-color" href="#Управление-цветом-фона-свойство-background-color">Управление цветом фона: свойство `background-color`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это свойство можно применять и к другим элементам, в том числе к заголовкам и тексту.

### <a id="Повторение-фонового-изображения-свойство-background-repeat" href="#Повторение-фонового-изображения-свойство-background-repeat">Повторение фонового изображения: свойство `background-repeat`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Если фоновое изображение меньше области элемента, то по умолчанию оно будет повторяться по горизонтали и по вертикали, стремясь заполнить всю выделенную область. Может принимать значения `repeat-x`, `repeat-y` и `repeat`, которое соответствуют повторению изображения по горизонтали, по вертикали и в обоих направлениях соответственно. Еще одно значение `no-repeat` является значением, которое требуется использовать, чтобы изображение не повторялось.

### <a id="Присоединение-свойство-background-attachment" href="#Присоединение-свойство-background-attachment">Присоединение: свойство `background-attachment`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Данное свойство имеет два значения `scroll` и `fixed`. Значением по умолчанию является `scroll`, которое заставляет фоновое изображение прокручиваться вместе с содержимым элемента. Значение `fixed` фиксирует изображение, а содержимое страницы прокручивается.

### <a id="Положение-фонового-изображения-свойство-background-position" href="#Положение-фонового-изображения-свойство-background-position">Положение фонового изображения: свойство `background-position`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

По умолчанию, фоновый рисунок располагается в левом верхнем углу экрана. Это свойство позволяет располагать фоновое изображение в любом месте. Набор координат (по горизонтали по вертикали) можно указывать в процентах от ширины экрана, в фиксированных единицах (пиксели, сантиметры, и т. п.), либо использовать символьные константы `top`, `bottom`, `center`, `left` и `right`.  
`background-position: <отступ_по_x>, <отступ_по_y>`

### <a id="Свойство-background" href="#Свойство-background">Свойство `background`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью свойства `background` можно объединить несколько свойств и записывать стили в сокращенном виде, что облегчает чтение таблиц. Для обеспечения межбраузерной совместимости и для организации и обслуживания таблицы стилей при объединении отдельных свойств фона в группу рекомендуется размещать свойства в следующем порядке:  
`background: <background-color>, <background-image>, <background-repeat>, <background-attachment>, <background-position>`.  
Если какое-либо свойство отсутствует, то оно автоматически получает значение по умолчанию.

Порядок наложения изображений друг на друга обратный порядку написания.

Для того чтобы использовать много цветных фонов - используется сплошной градиент: `linear-gradient(<background-color>, <background-color>)`, тогда появится возможность смешивать фоны.

### <a id="Размер-фонового-изображения-свойство-background-size" href="#Размер-фонового-изображения-свойство-background-size">Размер фонового изображения: свойство `background-size`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`background-size: [ <значение> | <проценты> | auto ]{1,2} | cover | contain`

Где:
- `<значение>` - задает размер в любых доступных для CSS единицах;
- `<проценты>` - задает размер фоновой картинки в процентах от ширины или высоты элемента;
- `cover` - масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока;
- `contain` - масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь блока.

### <a id="Несколько-фоновых-изображений" href="#Несколько-фоновых-изображений">Несколько фоновых изображений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью свойства свойства `background-image` теперь один элемент может иметь несколько фоновых изображений одновременно. Все новые изображения перечисляются через запятую в связанных с ними свойствами.

### <a id="Свойство-background-origin" href="#Свойство-background-origin">Свойство `background-origin`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью свойства `background-origin` можно установить как должно вычисляться положение элемента относительно границ его родительского элемента. Данное свойство может иметь 3 различных значения:
- `border-box` - положение элемента вычисляется относительно верхнего левого угла границы элемента;
- `padding-box` - положение элемента вычисляется относительно верхнего левого угла блока `padding`;
- `content-box` - положение элемента вычисляется относительно верхнего левого угла содержимого.

## <a id="Маски" href="#Маски">Маски</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные свойства:
- `mask-image: <маска_1>[, ...];` - устанавливает маски для текущего элемента;
- `mask-position: <позиция_по_y_маски_1> <позиция_по_x_маски_1>[, ...];` - устанавливает позиции масок;
- `mask-size: <размер_маски_1>[, ...];` - устанавливает размеры масок;
- `mask-repeat: { no-repeat | repeat-x | repeat-y | repeat };` - устанавливает режим повторения для масок;
- `mask-composite: { exclude };` - устанавливает режим композиции масок;

## <a id="Свойства-для-компоновки-CSS" href="#Свойства-для-компоновки-CSS">Свойства для компоновки CSS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Документ HTML состоит из множества перемешанных элементов. Когда такой документ изображается на экране компьютера или печатается на бумаге, эти элементы генерируют прямоугольные боксы. По умолчанию, встроенная таблица стилей в браузере заставляет элементы HTML блочного уровня генерировать блочные боксы, в то время как строковые элементы генерируют строковые боксы.
```
                      top
         +---------------------------+          
         |                           |           - margin
         |   +===================+   |           - border
         |   |                   |   |           - padding
         |   |   +----------+    |   |          
    left |   |   | Content  |    |   | right     - inner content in element
         |   |   +----------+    |   |          
         |   |                   |   |           - padding
         |   +===================+   |           - border
         |                           |           - margin
         +---------------------------+          
                      bottom
```

### <a id="Положение-эелемента-свойство-inset" href="#Положение-эелемента-свойство-inset">Положение эелемента: свойство `inset`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Определяется путем положения в логическом блоке и строке в зависимости от режима записи.

`inset: <top> <right> <bottom> <left>` - сокращенная запись для `top`, `right`, `bottom` и `left`.

`inset-block: <start> <end>` - указывает логические положения блока в зависимости от режима записи.  
`inset-block-start: <start>` - указывает логическое положение начала блока в зависимости от режима записи.  
`inset-block-end: <end>` - указывает логическое положение конца блока в зависимости от режима записи.

`inset-inline: <start> <end>` - указывает логические положения строк в зависимости от режима записи.  
`inset-inline-start: <start>` - указывает логическое положение начала строки в зависимости от режима записи.  
`inset-inline-end: <end>` - указывает логическое положение конца строки в зависимости от режима записи.

### <a id="Поля-элемента-свойство-margin" href="#Поля-элемента-свойство-margin">Поля элемента: свойство `margin`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это универсальный параметр, в зависимости от числа значений, он устанавливает поля со всех сторон элемента или для каждой его стороны отдельно. Например, указание одного значения задаст равные поля вокруг элемента. Допустимые значения обычно определяют в единицах измерения `px` или `em`. Для задания полей с разных сторон элемента предназначены производные от свойства `margin-left`, `margin-right`, `margin-top` и `margin-bottom`, задающие значения левого, правого, верхнего и нижнего поля соответственно.

Отступ `margin` для двух соседних элементов будет равен максимальному отступу из двух элементов, т.е. он схлопнется. Исключения:
- плавающие элементы;
- абсолютно позиционированные элементы;
- строчно-блочные (`inline-block`) элементы;
- элементы с параметром `overflow`, установленным в любое значение кроме `visible` (они не схлопываются отступы со своими элементами-потомками);
- элементы, к которым применено правило `clear` (их верхние отступы не схлопываются с нижними отступами их родительских блоков);
- корневой элемент дерева документа.

`margin-block: <start> <end>` - указывает логические поля блока в зависимости от режима записи.  
`margin-block-start: <start>` - указывает логическое поле начала блока в зависимости от режима записи.  
`margin-block-end: <end>` - указывает логическое поле конца блока в зависимости от режима записи.

`margin-inline: <start> <end>` - указывает логические поля строк в зависимости от режима записи.  
`margin-inline-start: <start>` - указывает логическое поле начала строки в зависимости от режима записи.  
`margin-inline-end: <end>` - указывает логическое поле конца строки в зависимости от режима записи.

### <a id="Добавление-границы-свойство-border" href="#Добавление-границы-свойство-border">Добавление границы: свойство `border`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для задания границ применяется несколько способов, один из которых основан на использовании свойства `border` и его производных. Это свойство позволяет одновременно установить толщину, стиль и цвет границы вокруг элемента. Значения разделяются пробелами и могут идти в любом порядке. Можно задать толщину, стиль и цвет любой из четырех сторон элемента, используя свойства `border-top`, `border-bottom`, `border-left` и `border-right`.  
`border: <border-width> <border-style> <border-color>`

### <a id="Толщина-границы-свойство-border-width" href="#Толщина-границы-свойство-border-width">Толщина границы: свойство `border-width`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это свойство задает толщину одной или нескольких сторон границы. Принимает значения в той же нотации, что и сокращенное свойство `margin`, за исключением того, что процентные значения не поддерживаются.

### <a id="Стиль-границы-свойство-border-style" href="#Стиль-границы-свойство-border-style">Стиль границы: свойство `border-style`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Задает стиль линии и может принимать одно из восьми значений:
- `dotted` - в точку;
- `dashed` - в черточку;
- `solid` - сплошная;
- `double` - двойная линия;
- `groove` - от темного к светлому внутрь;
- `ridge` - от светлого к темному внутрь;
- `inset` - свет с правого нижнего угла;
- `outset` - свет с левого верхнего угла.

### <a id="Цвет-границы-свойства-border-color" href="#Цвет-границы-свойства-border-color">Цвет границы: свойства `border-color`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для каждой границы можно задать любой цвет с помощью сокращенного свойства `border-color` или его уточнения.

### <a id="Создание-элементов-со-сглаженными-углами-свойство-border-radius" href="#Создание-элементов-со-сглаженными-углами-свойство-border-radius">Создание элементов со сглаженными углами: свойство `border-radius`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью свойства border-radius можно делать углы элементов сглаженными.

`border-radius: <радиус>{1,4} [ / <радиус_по_вертикали>{1,4}]`

Данное свойство может применяться не ко всем углам элемента, а только к определенным:
- `border-top-right-radius` - делает сглаженным только верхний правый угол элемента;
- `border-bottom-left-radius` - делает сглаженным только нижний левый угол элемента;
- `border-bottom-right-radius` - делает сглаженным только нижний правый угол элемента;
- `border-top-left-radius` - делает сглаженным только верхний левый угол элемента.

### <a id="Заполнение-элемента-свойство-padding" href="#Заполнение-элемента-свойство-padding">Заполнение элемента: свойство `padding`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Заполнение определяет внутреннее расстояние между границей и содержимым элемента. Для изменения этой характеристики предназначено свойство `padding`. Оно позволяет задать расстояние между границей и содержанием для всех или определенных сторон элемента. Это свойство действует аналогично `margin`, поэтому итоговый результат зависит от числа аргументов. Для указания расстояний от разных сторон элемента можно воспользоваться свойствами `padding-left`, `padding-right`, `padding-top` и `padding-bottom`, которые управляют величиной расстояния слева, справа, сверху и снизу соответственно.

`padding-block: <start> <end>` - указывает логические расстояния блока в зависимости от режима записи.  
`padding-block-start: <start>` - указывает логическое расстояние начала блока в зависимости от режима записи.  
`padding-block-end: <end>` - указывает логическое расстояние конца блока в зависимости от режима записи.

`padding-inline: <start> <end>` - указывает логические расстояния строк в зависимости от режима записи.  
`padding-inline-start: <start>` - указывает логическое расстояние начала строки в зависимости от режима записи.  
`padding-inline-end: <end>` - указывает логическое расстояние конца строки в зависимости от режима записи.

### <a id="Размеры-элемента" href="#Размеры-элемента">Размеры элемента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Установить высоту и ширину элемента можно с помощью свойств `height` и `width` соответственно для блочных элементов.

`inline-size: <размер>` - устанавливает размер по ширине или высоте, который зависит от направления письма (по вертикали или по горизонтали).

`block-size: <размер>` - устанавливает блочный размер по ширине или высоте, который зависит от направления письма (по вертикали или по горизонтали).

`aspect-ratio: <ширина> / <высота> | <коэффициент>` - устанавливает отношение высоты и ширины блока, который будет вычисляться автоматически.

### <a id="Область-вырезки-свойство-clip" href="#Область-вырезки-свойство-clip">Область вырезки: свойство `clip`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `clip` определяет область позиционированного элемента, в которой будет показано его содержимое. Все, что не помещается в эту область, будет обрезано и становится невидимым.

`clip: rect(<top_y_1>, <left_x_1>, <top_y_2>, <left_x_2>)` - вырезает прямоугольную область, в качестве параметров принимает расстояние от края элемента до области вырезки. Если край области нужно оставить без изменений, следует установить `auto`.

### <a id="Свойство-clip-path" href="#Свойство-clip-path">Свойство `clip-path`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `clip-path` позволяет задать область вырезки как:
- **полигон точек** - `polygon(<x_1> <y_1>, ...)`;
- **прямоугольник** - `inset(<top_y_1> <left_x_1> <top_y_2> <left_x_2> [round <border-radius>])`;
- **круг** - `circle(<r>? [at <position>])`, где `<position>` - как у `background-position`;
- **эллипс** - `ellipse(<rx> <ry> [at <position>])`, где `<position>` - как у `background-position`.

### <a id="Свойство-box-sizing" href="#Свойство-box-sizing">Свойство `box-sizing`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Применяется для изменения алгоритма расчета ширины и высоты элемента. Имеет значения:
- `content-box` основывается на стандартах CSS, при этом свойства `width` и `height` задают ширину и высоту контента и не включают в себя значения отступов, полей и границ;
- `border-box` свойства `width` и `height` включают в себя значения полей и границ, но не отступов (`margin`);
- `padding-box` свойства `width` и `height` включают в себя значения полей, но не отступов (`margin`) и границ (`border`).

### <a id="Добавление-к-элементам-тени-свойство-box-shadow" href="#Добавление-к-элементам-тени-свойство-box-shadow">Добавление к элементам тени: свойство `box-shadow`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью свойства `box-shadow` можно добавить к элементам страницы тени.

`box-shadow: none | <тень>[,<тень>]*`

Где `<тень>`: `[inset] <сдвиг_по_x> <сдвиг_по_y> [<нулевое_размытие>] [<радиус_распространения>] [<цвет>]`

### <a id="Создание-прозрачных-элементов-и-картинок-свойство-opacity" href="#Создание-прозрачных-элементов-и-картинок-свойство-opacity">Создание прозрачных элементов и картинок: свойство `opacity`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для создания прозрачных элементов используется это свойство, где принимает значение которое может изменяться от 0.0 (полностью прозрачный элемент) до 1.0 (полностью непрозрачный элемент).

### <a id="Свойство-object-fit" href="#Свойство-object-fit">Свойство `object-fit`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `object-fit` в значении `contain` позволяет задать размер изображения так чтобы оно попадало точно в указаные размеры.

## <a id="Работа-с-потоком-элементов" href="#Работа-с-потоком-элементов">Работа с потоком элементов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Типы-блоков-свойство-display" href="#Типы-блоков-свойство-display">Типы блоков: свойство `display`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Каждый элемент имеет соответствующий строковый или блочный тип. Каждый тип определяет поведение компоновки по умолчанию различным образом: последовательно идущие строковые элементы изображаются на общей базовой линии, в то время как блочные элементы всегда отделяются друг от друга и выводятся с предшествующим и последующим разрывом строки.

Свойство `display` имеет три наиболее часто используемых значения - `block`, `inline` и `none` - два из которых имеют прямое отношение к соответствующим типам элементов. Данное свойство позволяет изменить поведение элементов (например, строковый элемент будет вести себя как блочный или наоборот).

Свойство `display` со значением `none` может изменять представление данного элемента в документе не отображая его.

#### <a id="display-contents" href="#display-contents">`display: contents`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Приводит к тому что блок, которому назначено это свойство становится элементом-"оберткой" и все его дочерние элементы становятся дочерними элементами его родителей.

### <a id="Всплывающие-элементы-свойства-float-и-clear" href="#Всплывающие-элементы-свойства-float-и-clear">"Всплывающие" элементы: свойства `float` и `clear`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Элемент может "всплывать" вправо или влево с помощью свойства `float`. То есть бокс с его содержимым может смещаться к правому или левому краю в окне документа (или содержащего бокса) с помощью значений свойства `right`, `left` или `none`.

Свойство `clear` управляет поведением последовательности всплывающих элементов документа. По умолчанию, последовательные элементы смещаются вверх, заполняя доступное пространство, которое освобождается, если бокс смещается в сторону. Свойство `clear` может иметь значения `left`, `right`, `both` или `none`, которые обозначают с какой стороны элемента запрещено его обтекание другими элементами.

Каждый элемент HTML представляет собой прямоугольник (*бокс*), для которого можно задать такие параметры как поля, границы и заполнения. Позиционирование определяет, где должен располагаться этот прямоугольник, а также как он должен влиять на элементы вокруг себя. При помощи позиционирования можно разместить любой элемент точно в нужном месте страницы. В основе позиционирования лежит представление окна браузера как системы координат. Любой бокс возможно расположить в этой системе координат где угодно.

### <a id="Свойство-position" href="#Свойство-position">Свойство `position`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имеет четыре значения `static`, `relative`, `absolute` и `fixed`, которые определяют тип позиционирования и влияют на расположение элемента.

Значение `static` свойства `position` используется по умолчанию. Любой элемент со статическим позиционированием находится в общем потоке документа. Правила для его размещения определяются боксовой моделью. Блочные и строковые элементы размещаются по разным правилам. По умолчанию, **блочные боксы** выкладываются вертикально сверху вниз в порядке появления их в разметке. Каждый бокс обычно занимает всю ширину документа и имеет разрыв строки перед и после себя.

**Строковые боксы** выстраиваются по горизонтали в том порядке, в котором они появляются в разметке, переходя на новую строку, только если исчерпано доступное горизонтальное пространство. В зависимости от свойства `direction`, строковые боксы будут располагаться либо слева направо (`direction: ltr`), либо справа налево (`direction: rtl`). Множество строковых боксов, которые составляют строку на экране, заключаются еще в один прямоугольник, называемый линейным боксом. Линейные боксы выкладываются вертикально в своих предках блочного уровня без дополнительного пробела между ними. Высотой линейных боксов можно управлять с помощью свойства `line-height`. Для строковых боксов нельзя определить размеры и вертикальные поля.

Элемент со значением свойства `position`, равным `relative`, сначала размещается по правилам статического позиционирования. Но затем сгенерированный бокс смещается относительно своего положения в потоке, согласно значениям свойств `top`, `bottom`, `left` и `right`. Но при этом из потока он не исключается, а продолжает занимать там свое место. То есть сдвигается со своего места он только визуально, а положение всех боксов вокруг него никак не меняется. Это означает, что смещенный бокс может перекрывать боксы других элементов, так как они по-прежнему действуют, как если бы относительно позиционированный элемент остался там, где он должен был быть перед применением позиционирования.

Бокс с абсолютным позиционированием располагается по заданным координатам, а из того места, где он должен был бы быть, он удаляется, и в этом месте сразу начинают размещаться следующие боксы. Считается, что бокс исключается из потока. Для абсолютного позиционирования элемента свойство `position` должно принимать значение `absolute`. А для задания положения размещения блока используются значения `left`, `right`, `top` и `bottom`. Все четыре свойства можно использовать одновременно для определения расстояния от каждого края позиционируемого элемента до соответствующего края браузера или родительского блока. Можно определить также позицию одного из углов абсолютно позиционируемого (например, используя `top` и `left`), а затем определить размеры бокса, используя `width` и `height`.  
Влияет на свойство `display` и представляет элемент блочным, вне зависимости от того что он указан строчным.

Фиксированное позиционирование со значением свойства `position`, равным `fixed`, действует подобно абсолютному, однако элемент с фиксированным позиционированием всегда располагается только относительно окна браузера и никогда не смещается при прокручивании веб-страницы.

Приклееное позиционирование со значением свойства `position`, равным `sticky`, действует подобно фиксируемому, однако элемент с приклееным позиционированием не смещается при прокручивании элемента. Он будет остоваться при прокрутке на своем месте, пока прокрутка не достигнет конца родительского блока, а затем прокрутиться вместе с родителем.

### <a id="Третье-измерение-веб-страницы-свойство-z-index" href="#Третье-измерение-веб-страницы-свойство-z-index">Третье измерение веб-страницы: свойство `z-index`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Страница сайта двухмерная: для нее заданы ширина и высота. CSS позволяет добавить к веб-станице глубину (третье измерение) с помощью свойства `z-index`. Данное свойство позволяет создавать слои и располагать одни элементы поверх других. Для создания слоев необходимо для каждого элемента задать значение свойства `z-index`, которое является своеобразным порядковым номером слоя, в котором находится данный элемент. Это значение может быть целым числом (которое может быть отрицательным) или одним из ключевых слов `auto` или `inherit`. Значением по умолчанию является `auto` или `0`. Элемент с большим значением свойства `z-index` перекрывает элемент с меньшим значением данного свойства.

### <a id="Переполнение-контейнеров-свойство-overflow" href="#Переполнение-контейнеров-свойство-overflow">Переполнение контейнеров: свойство `overflow`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для управления отображением содержимого контейнера когда размер контента превышает границы размеров контейнера используется атрибут стиля `overflow`, принимающий следующие значения:
- `visible` - отображается весь контент даже за пределами контейнера;
- `hidden` - отображается только область внутри контейнера, оставшаяся часть контента скрывается;
- `scroll` - добавление полос прокрутки контейнеру, полосы будут отображаться даже если в них нет необходимости;
- `auto` - полосы прокрутки появятся только в случае необходимости.

Существует возможность управления отображением содержания контейнера отдельно по горизонтали и вертикали, соответственно при помощи атрибутов `overflow-x` (для работы для блоков, необходимо чтобы было установленно свойство `white-space: nowrap;`) и `overflow-y`, значения которых аналогичны значениям `overflow`.

### <a id="Прокрутка" href="#Прокрутка">Прокрутка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="Свойство-scroll-behavior" href="#Свойство-scroll-behavior">Свойство `scroll-behavior`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `scroll-behavior` в значении `smooth` добавляет плавную прокрутку элементу.

#### <a id="Свойство-overscroll-behavior" href="#Свойство-overscroll-behavior">Свойство `overscroll-behavior`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `overscroll-behavior` в значении `none` позволяет предотвратить прокрутку родительского блока при достижении конца прокрутки текущего элемента.

#### <a id="Свойство-scrollbar-gutter" href="#Свойство-scrollbar-gutter">Свойство `scrollbar-gutter`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `scrollbar-gutter` в значении `stable` выставляет постоянный отступ под полосу прокрутки.

#### <a id="Scroll-snap" href="#Scroll-snap">Scroll snap</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

##### <a id="Свойства-контейнера" href="#Свойства-контейнера">Свойства контейнера</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`scroll-snap-type: <направление> <тип_привязки>;` - позволяет указать направление, в котором происходит привязка прокрутки, а также строгость привязки, где `<направление>`:
- `x` - горизонтальная прокрутка;
- `y` - вертикальная прокрутка;
- `inline` - горизонтальная прокрутка;
- `block` - вертикальная прокрутка;
- `both` - привязка в обоих направлениях.

`<тип_привязки>`:
- `none` - нет привязки к точке;
- `mandatory` - обязательное смещение прокрутки к указанной точке;
- `proximity` - смещение происходит только в тех ситуациях, когда область видимости находится близко к точке привязки. Степень близости браузер определяет самостоятельно.

`scroll-padding: <верхний_отступ> <правый_отступ> <нижний_отступ> <левый_отступ>;` - позволяет задать внутренний отступ для элементов, при котором будет срабатывать привязка.

##### <a id="Свойства-дочерних-элементов" href="#Свойства-дочерних-элементов">Свойства дочерних элементов:</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`scroll-snap-align: <точка_привязки>;` - позволяет задать точку привязки, где `<точка_привязки>`:
- `start` - точка находится в начале элемента;
- `center` - точка находится в центре элемента;
- `end` - точка находится в конце элемента.

`scroll-snap-stop: <тип_прокрутки>;` - позволяет управлять прокруткой, где `<тип_прокрутки>`:
- `normal` - привязка происходит только тогда, когда пользователь прекращает прокрутку, отдельные точки привязки могут быть пропущены;
- `always` - контейнер останавливается на каждой точке привязке, прежде чем пользователь сможет скроллить дальше.

`scroll-margin: <верхний_отступ> <правый_отступ> <нижний_отступ> <левый_отступ>;` - позволяет задать внешний отступ, при котором будет срабатывать привязка.

### <a id="Видимость-элемента-свойство-visibility" href="#Видимость-элемента-свойство-visibility">Видимость элемента: свойство `visibility`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Предназначен для отображения или скрытия элемента, включая рамку вокруг него и фон. При скрытии элемента, хотя он и становится не виден, место, которое элемент занимает, остается за ним. Доступные значения:
- `visible` - отображает элемент как видимый;
- `hidden` - элемент становится невидимым или правильней сказать, полностью прозрачным, поскольку он продолжает участвовать в форматировании страницы.
- `collapse` - если это значение применяется не к строкам или колонкам таблицы, то результат его использования будет таким же, как `hidden`. В случае использования `collapse` для содержимого ячеек таблиц, то они реагируют, словно к ним было добавлено `display: none`. Иными словами, заданные строки и колонки убираются, а таблица перестраивается по новой;
- `inherit` - наследует значение родителя.

## <a id="Счетчики" href="#Счетчики">Счетчики</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`counter-set: <имя> <значение>;` - устанавливает счетчик с указанным именем если он существует, а иначе создает новый и указанным значением `<значение>`;

`counter-reset: <имя> [<значение>];` - создает новый счетчик и сбрасывает с указанным именем в значение 0 [указанное `<значение>`];

`counter-reset: reversed(<имя>);` - обратный счетчик;

`counter-increment: <имя> [<значение>];` - увеличивает значение счетчика на 1 [указанное `<значение>`];

`counter(<имя>)` - возвращает значение счетчика, можно использовать в `content`;

> `content: "Section " counter(section) ": ";`

## <a id="Курсор" href="#Курсор">Курсор</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Свойство-pointer-events" href="#Свойство-pointer-events">Свойство `pointer-events`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Отвечает за реагирование элемента на события мыши. Принимает значения:
- `none` - элемент перестанет реагировать на `hover`, `click` и другие события мыши. Он станет "прозрачным" для взаимодействия, а `hover` и `click` будут передаваться элементу, лежащему под ним;
- `auto` - (значение по-умолчанию) включает стандартное поведение элемента.

### <a id="Свойство-user-select" href="#Свойство-user-select">Свойство `user-select`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Отвечает за возможность выделения текста. Принимает значения:
- `none` - запрещает возможность выделения;
- `auto` - (значение по-умолчанию) включает стандартное поведение элемента;
- `text` - можно выделять текст;
- `contain` - позволяет выделять только то что находится в элементе;
- `all` - выделяет все содержимое элемента при клике.

## <a id="Трансформирование-элементов" href="#Трансформирование-элементов">Трансформирование элементов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Свойство-transform" href="#Свойство-transform">Свойство `transform`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью свойства `transform` можно трансформировать элементы. В качестве значения данного свойства должна указываться одна из функций трансформирования:
- `translate(<x>, <y>)` - смещает элемент от изначальной позиции по горизонтали и вертикали;
- `translateX(<x>)` - смещает элемент по горизонтали;
- `translateY(<y>)` - смещает элемент по вертикали;
- `scale(<kx>, <ky>)` - растягивает элемент по вертикали и горизонтали;
- `scaleX(<kx>)` - растягивает элемент по горизонтали;
- `scaleY(<ky>)` - растягивает элемент по вертикали;
- `rotate(<градусы>)` - поворачивает элемент по часовой стрелке;
- `skew(<градусы_по_x>, <градусы_по_y>)` - скашивает элемент по горизонтали и вертикали;
- `skewX(<градусы_по_x>)` - скашивает элемент по горизонтали;
- `skewY(<градусы_по_y>)` - скашивает элемент по вертикали;
- `matrix(<a>, <b>, <c>, <d>, <e>, <f>)` - матрица для изменения в 2d. Представляет из себя матрицу вида:
```
| a c e |
| b d f |
| 0 0 1 |
```
- `matrix3d(<a_1>, <b_1>, <c_1>, <d_1>, <a_2>, <b_2>, <c_2>, <d_2>, <a_3>, <b_3>, <c_3>, <d_3>, <a_4>, <b_4>, <c_4>, <d_4>)` - матрица для изменения в 3d.

### <a id="Свойство-translate" href="#Свойство-translate">Свойство `translate`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Работает аналогично конструкции: `transform: translate(<x>, <y>)`.

### <a id="Свойство-scale" href="#Свойство-scale">Свойство `scale`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Работает аналогично конструкции: `transform: scale(<x>, <y>)`.

### <a id="Свойство-rotate" href="#Свойство-rotate">Свойство `rotate`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Работает аналогично конструкции: `transform: rotate(<градусы>)`.

## <a id="Градиенты" href="#Градиенты">Градиенты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Линейные-градиенты" href="#Линейные-градиенты">Линейные градиенты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Линейные градиенты создаются с помощью функции `linear-gradient()`, который должен указываться в значение свойства `background`. Для того, чтобы создать линейный градиент необходимо указать его направление (может задаваться с помощью ключевых слов или градусов) и цвета перехода.

`background: linear-gradient(<направление_в_углах>, <цвет_перехода_1>[ <%_px_градиента>][, ...]);`

`0` вместо процентной величины обозначает оставшееся расстояние, последнее значение.

### <a id="Сферические-градиенты" href="#Сферические-градиенты">Сферические градиенты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью функции `radial-gradient()` можно создавать сферические градиенты. Синтаксис определения сферических градиентов похож на синтаксис линейных, но требует также задания формы градиента (может быть сферической или эллипсоидной).

`background: radial-gradient([circle at <pos_x> <pos_y>, ]<цвет_перехода_1>[ <%_px_градиента>][, ...]);` где [`circle` позволяется указать центральную позицию круга].

### <a id="Повторяющиеся-градиенты" href="#Повторяющиеся-градиенты">Повторяющиеся градиенты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Повторяющиеся градиенты задаются с помощью функции `repeating-linear-gradient` (создает повторяющийся линейный градиент) и `repeating-radial-gradient` (создает повторяющийся сферический градиент), и дальнейшее определение как у `linear-gradient` и `radial-gradient` соответственно.

## <a id="Анимация" href="#Анимация">Анимация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Переходы-свойство-transition" href="#Переходы-свойство-transition">Переходы: свойство `transition`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью свойства `transition` можно создавать эффекты перехода. Для создания переходов необходимо указать какое CSS свойство будет изменятся и скорость выполнения этих изменений в секундах.

`transition: [<имя_свойства_1> | all] <время_в_сек> [<функ_смягчения>] [<задержка_в_сек>] [<шаги>][, ...];`

#### <a id="Шаги-steps" href="#Шаги-steps">Шаги: steps</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяют указать на сколько шагов разбивать анимацию. На то же количество частей делится и временной интервал.

`steps(<количество_шагов_анимации>[, start | end]) | step-start | step-end`

Где:
- `start` - означает, что при начале анимации нужно сразу применить первое изменение;
- `end` - означает, что изменения нужно применять не в начале, а в конце каждого шага;
- `step-start` - то же, что `steps(1, start)`, то есть завершить анимацию в 1 шаг сразу;
- `step-end` - то же, что `steps(1, end)`, то есть завершить анимацию в 1 шаг по истечении `transition-duration`.

### <a id="Функции-смягчения" href="#Функции-смягчения">Функции смягчения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Плавность выполнения переходов контролируется с помощью функций смягчения. Существуют несколько видов таких функций:
- `linear` - перемещение происходит постоянной скоростью от начала и до конца.
- `ease` - перемещение начинается медленно и затем набирает скорость (функция смягчения по умолчанию).
- `ease-in` - перемещение начинается медленно.
- `ease-out` - перемещение заканчивается медленно.
- `ease-in-out` - перемещение начинается и заканчивается медленно.
- `cubic-bezier(x,x,x,x)` - ручное определение значения перемещения.

#### <a id="Свойство-will-change" href="#Свойство-will-change">Свойство `will-change`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство` will-change` предоставляет автору возможность уведомить браузер об ожидаемом изменении элемента, таким образом браузер может настроить соответствующую оптимизацию до того как элемент действительно изменится.

Основные рекомендации по применению:
- `will-change` не должно применяться к большому числу элементов;
- рекомендуется включать и отключать `will-change` используя скрипт до и после того как произошли изменения;
- `will-change` не применяется к элементам для выполнения преждевременной оптимизации;
- `will-change` необходимо достаточно времени, чтобы работать.

`will-change: auto | scroll-position | contents | <CSS_свойство>[, ...]`

Значения:
- `auto` - это ключевое слово не выражает конкретной цели;
- `scroll-position` - указывает, что автор ожидает анимацию или изменение положения скролла элемента в ближайшем будущем;
- `contents` - указывает, что автор ожидает анимацию или изменение чего то в контенте элемента в ближайшем будущем;
- `<CSS_свойство>` - CSS свойство, которое должно измениться.

### <a id="Анимация-свойство-keyframes-свойство-animation" href="#Анимация-свойство-keyframes-свойство-animation">Анимация: свойство `@keyframes`, свойство `animation`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для создания анимации в используется свойство `@keyframes`. Данное свойство представляет собой контейнер, в который должны помещаться различные свойства оформления.

```css
@keyframes <имя_анимации> {
    from {<CSS_свойства_элемента_перед_началом_анимации>}
    to {<CSS_свойства_элемента_после_началом_анимации>}
    [<процент_времени>% {<CSS_свойства_элемента_после_началом_анимации>}]
    [...]
}
```

После того, как анимация была создана необходимо добавить к элементу, который нужно анимировать с помощью свойства `animation` и указать в нем имя анимации и время, в течении которого она будет выполняться. Также можно устанавливать количество повторов анимации.

`animation: <имя_анимации> [<время_в_сек>] [<функ_смягчения>] [<задержка_в_сек>] [<шаги>] [<кол_повторов> | infinite] [normal | reverse | alternate | alternate-reverse] [<режим_воздействия>];`

При значении `alternate` в нечетные разы (1,3,5 ...) анимация будет проигрываться в нормальном, а в четные (2,4,6 ...) в обратном порядке.

Режимы воздействия:
- `none` - анимация воздействует на элемент только во время воспроизведения, по окончании элемент возвращается в исходное состояние.
- `forwards` - анимация воздействует на элемент по окончании воспроизведения.
- `backwards` - анимация воздействует на элемент до начала воспроизведения.
- `both` - анимация воздействует на элемент и до начала, и после окончания воспроизведения.

#### <a id="Ход-выполнения-анимации" href="#Ход-выполнения-анимации">Ход выполнения анимации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Можно определять ход выполнения анимации не только с помощью ключевых слов `from` и `to` (которые использовались в предыдущем примере), но и с помощью %(от 0% до 100%).

### <a id="Правила-анимациии" href="#Правила-анимациии">Правила анимациии</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для плавной анимации используются свойства, которые расчитываются на GPU, которые очень дешевые с точки зрения расчетов:
- **позиция** - `transform: translate(<n>px, <n>px)`;
- **масштаб** - `transform: scale(<n>)`;
- **поворот** - `transform: rotate(<n>deg)`;
- **прозрачность** - `opacity: <n>`.

Следующие по стоимости при изменении производят перерасчет стилей:
- `color`;
- `border-style`;
- `visibility`;
- `background`;
- `text-decoration`;
- `background-image`;
- `background-position`;
- `background-repeat`;
- `outline-color`;
- `outline`;
- `outline-style`;
- `border-radius`;
- `outline-width`;
- `box-shadow`;
- `background-size`.

Самые дорогии операции вызывают изменение расположения (layout):
- `width`;
- `height`;
- `padding`;
- `margin`;
- `display`;
- `border-width`;
- `border`;
- `top`;
- `position`;
- `font-size`;
- `float`;
- `text-align`;
- `overflow-y`;
- `font-weight`;
- `overflow`;
- `left`;
- `font-family`;
- `line-height`;
- `vertical-align`;
- `right`;
- `clear`;
- `white-space`;
- `bottom`;
- `min-height`.

### <a id="Разбиение-текста-на-столбцы" href="#Разбиение-текста-на-столбцы">Разбиение текста на столбцы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью свойства `column-count` можно указать количество столбцов, на которые необходимо разбить текст выбранного элемента.

С помощью свойство `column-gap` можно установить величину отступа между столбцами текста.

С помощью свойства `column-rule` можно задать ширину, цвет и стиль оформления пространства между столбцами.

Свойство `column-width` позволяет указывать ширину столбцов текста.

Свойство `column-rule` позволяет указывать границу между колонками в синтаксисе `border`.

Свойство `column-fill` позволяет указывать выравнивание текста в столбцах, при значении `balance` - выравнивает количество контента в столбцах.

## <a id="Произвольные-свойства-и-переменные-CSS" href="#Произвольные-свойства-и-переменные-CSS">Произвольные свойства и переменные CSS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Переменные объявляются в селекторе как свойство: `--<имя_переменной>: <значение>;`
```css
header {
    --primary-color: 'red';
    --background-color: linear-gradient(#000, #000) center/50px;
    --offset: 10px;
}
```

`<значение>` - может хранить несколько значений независимо от значения переменной.

Для их использования необходимо написать: `var(--<имя_переменной>[, <значение_по_умолчанию>])` - заменит на указаное значение переменной `<значение>`.
```css
h1 {
    color: var(--primary-color, 'white');
    background-color: var(--background-color, 'black');
    padding: var(--offset, 10px) min(calc(var(--offset, 10px) * 2), 15px);
}
```

Если переназначить переменную ниже по дереву, то это подействует на все элементы-потомки.

Когда переменная CSS внутри функции `var()` невалидна, браузер заменяет ее начальным или унаследованным значением в зависимости от свойства.

#### <a id="Использование-переключение-переменных" href="#Использование-переключение-переменных">Использование переключение переменных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для реализации переключения переменных через флаги, подобно булевой логике, используется такая конструкция:  
`--<имя_переменной>: var(--<имя_переменной_флага_1>, <значение_1>) var(--<имя_переменной_флага_2>, <значение_2>;`

Если установить значение переменной `--<имя_переменной_флага_1>` равное `initial`, а значение переменной `--<имя_переменной_флага_2>` равное чему-то не валидному, к примеру пробелу, то будет использоватья значение `<значение_1>`. Для обратного поведения используюется аналогичная запись.

```css
:root {
    /* --ON и --OFF заменяют двоичную переменную */
    --ON: initial;
    --OFF: ;
}
.theme-default,
.theme-light {
    --light: var(--ON);
    --dark: var(--OFF);
}
.theme-dark {
    --light: var(--OFF);
    --dark: var(--ON);
}
/* Определение переменных для темы */
.theme {
    --background: var(--light, red) var(--dark, green);
}
span {
    background: var(--background);
}
```

#### <a id="Использование-переменных-в-JS" href="#Использование-переменных-в-JS">Использование переменных в JS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Эти переменные могут меняются и назначаться в JS:
```javascript
element.style.getPropertyValue("--my-var");
element.style.setProperty("--my-var", jsVar + 4);
```

### <a id="Свойства-property" href="#Свойства-property">Свойства (property)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для описания типа переменных:
```css
@property --<имя_переменной> {
    syntax: '<<тип>>';
    initial-value: <начальное_значение>;
    inherits: <наследование>;
}
```
Где:
- свойство `syntax` - обозначает тип переменной, и `<тип>` может быть одним из:
    - `length`;
    - `number`;
    - `percentage`;
    - `length-percentage`;
    - `color`;
    - `image`;
    - `url`;
    - `integer`;
    - `angle`;
    - `time`;
    - `resolution`;
    - `transform-list`;
    - `transform-function`;
    - `custom-ident` - произвольная строка.
- свойство `initial-value` - обозначает начальное значение переменной, и `<начальное_значение>` может быть только типа переменной;
- свойство `inherits` - обозначает наследование значение переменной от родителя, и `<наследование>` может быть `true` - наследуется или `false`.

Таким образом переменная типизируется указаным типом и не может принимать значения другого типа, если так будет то будет использовано значение по умолчанию.

Описаная переменная будет доступна в коде как обычная переменная: `var(--<имя_переменной>[, <значение_по_умолчанию>])` и ей также можно произвольно назначать значения.

```css
@property --colorPrimary {
    syntax: '<color>';
    initial-value: magenta;
    inherits: false;
}
```

## <a id="Атрибуты-данных" href="#Атрибуты-данных">Атрибуты данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Атрибуты данных можно использовать для динамического CSS-содержимого, они доступны через функцию `attr(<имя_атрибута>[ <тип>][, <значение_по_умолчанию>])`, где `<тип>` определяет какой формат данных использовать:
> `content: attr(data-text);`

<a id="Flexbox" href="#Flexbox">Flexbox</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==============

**Flexbox** позволяет контролировать размер, порядок и выравнивание элементов по нескольким осям, распределение свободного места между элементами и многое другое.

Flexbox состоит из двух основных элементов, для которых определены наборы CSS свойств:
- **контейнер** (flex-контейнер) - задается как `display: flex` или `display: inline-flex`;
- **дочерние элементы** (flex-блоков).

Внутри флекс-контейнера элементы становятся блочными.

## <a id="Основные-свойства-flex-контейнера" href="#Основные-свойства-flex-контейнера">Основные свойства flex-контейнера</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Главная-и-поперечная-ось-свойство-flex-direction" href="#Главная-и-поперечная-ось-свойство-flex-direction">Главная и поперечная ось: свойство `flex-direction`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Главной осью** flex-контейнера является направление, в соответствии с которым располагаются все его дочерние элементы.

**Поперечной осью** называется направление, перпендикулярное главной оси.

Главная ось в `ltr` локали по умолчанию располагается слева направо. Поперечная - сверху вниз. Направление главной оси flex-контейнера можно задавать, используя базовое свойство `flex-direction`, принимает значения:
- `row` - (значение по умолчанию) элементы следуют слева направо (в `rtl` справа налево);
- `row-reverse` - справа налево (в `rtl` слева направо);
- `column` - сверху вниз;
- `column-reverse` - снизу вверх.

### <a id="Выравнивание-по-главной-оси-свойство-justify-content" href="#Выравнивание-по-главной-оси-свойство-justify-content">Выравнивание по главной оси: свойство `justify-content`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `justify-content` определяет то, как будут выровнены элементы вдоль главной оси, принимает значения:
- `flex-start` - (значение по умолчанию) блоки прижаты к началу главной оси;
- `start` - аналогично предыдущему;
- `flex-end` - блоки прижаты к концу главной оси;
- `end` - аналогично предыдущему;
- `center` - блоки располагаются в центре главной оси;
- `space-between` - первый блок располагается в начале главной оси, последний блок - в конце, все остальные блоки равномерно распределены в оставшемся пространстве;
- `space-around` - все блоки равномерно распределены вдоль главной оси, разделяя все свободное пространство поровну.

### <a id="Выравнивание-по-поперечной-оси-свойство-align-items" href="#Выравнивание-по-поперечной-оси-свойство-align-items">Выравнивание по поперечной оси: свойство `align-items`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `align-items` определяет то, как будут выровнены элементы вдоль поперечной оси, принимает значения:
- `flex-start` - блоки прижаты к началу поперечной оси;
- `flex-end` - блоки прижаты к концу поперечной оси;
- `center` - блоки располагаются в центре поперечной оси;
- `baseline` - блоки выровнены по их *baseline*;
- `stretch` - (значение по умолчанию) блоки растянуты, занимая все доступное место по поперечной оси, при этом все же учитываются `min-width`/`max-width`, если таковые заданы.

### <a id="Многострочная-организация-блоков" href="#Многострочная-организация-блоков">Многострочная организация блоков</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

За многострочность внутри flex-контейнера отвечает свойство `flex-wrap`, принимает значения:
- `nowrap` - (значение по умолчанию) блоки расположены в одну линию слева направо (в `rtl` справа налево);
- `wrap` - блоки расположены в несколько горизонтальных рядов (если не помещаются в один ряд). Они следуют друг за другом слева направо (в `rtl` справа налево);
- `wrap-reverse` - то-же что и `wrap`, но блоки располагаются в обратном порядке.

Свойство `flex-flow` предоставляет возможность в одном свойстве описать направление главной и многострочность поперечной оси. По умолчанию `flex-flow: row nowrap`.

`flex-flow: <flex-direction> || <flex-wrap>`

### <a id="Свойство-align-content" href="#Свойство-align-content">Свойство `align-content`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `align-content` определяет то, каким образом образовавшиеся ряды блоков будут выровнены по линии контейнера flex в контейнере flex при наличии дополнительного пространства на перекрестной оси, работает только в многострочном режиме (т.е. в случае `flex-wrap: wrap;` или `flex-wrap: wrap-reverse;`), принимает значения:
- `flex-start` - ряды блоков прижаты к началу flex-контейнера;
- `start` - аналогично предыдущему;
- `flex-end` - ряды блоков прижаты к концу flex-контейнера;
- `end` - аналогично предыдущему;
- `center` - ряды блоков находятся в центре flex-контейнера;
- `space-between` - первый ряд блоков располагается в начале flex-контейнера, последний ряд блоков блок - в конце, все остальные ряды равномерно распределены в оставшемся пространстве;
- `space-around` - ряды блоков равномерно распределены в от начала до конца flex-контейнера, разделяя все свободное пространство поровну;
- `stretch` - (значение по умолчанию) ряды блоков растянуты, дабы занять все имеющееся пространство.

Общее свойство.

### <a id="Свойство-place-content" href="#Свойство-place-content">Свойство `place-content`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `place-content` предоставляет возможность в одном свойстве описать выравнивание по линии контейнера и выровнивание элементы вдоль главной оси. При наличии только одного значения свойства, оно будет использовано для двух свойств.

`place-content: <align-content> || <justify-content>`

## <a id="CSS-правила-для-дочерних-элементов-flex-блоков" href="#CSS-правила-для-дочерних-элементов-flex-блоков">CSS правила для дочерних элементов (flex-блоков)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Базовый-размер-отдельно-взятого-flex-блока-свойство-flex-basis" href="#Базовый-размер-отдельно-взятого-flex-блока-свойство-flex-basis">Базовый размер отдельно взятого flex-блока: свойство `flex-basis`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `flex-basis` - задает изначальный размер по главной оси для flex-блока до того, как к нему будут применены преобразования, основанные на других flex-факторах. Может быть задан в любых единицах измерения длинны (px, em, %, ...) или `auto`(по умолчанию). Если задан как `auto` - за основу берутся размеры блока (`width`, `height`), которые, в свою очередь, могут зависеть от размера контента, если не указаны явно.

### <a id="Жадность-отдельно-взятого-flex-блока-свойство-flex-grow" href="#Жадность-отдельно-взятого-flex-блока-свойство-flex-grow">"Жадность" отдельно взятого flex-блока: свойство `flex-grow`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `flex-grow` - определяет как много свободного пространства (разница между размером flex-контейнера и размером всех его flex-элементов вместе) во flex-контейнере должно быть назначено текущему элементу, и следовательно в сколько раз отдельный flex-блок может быть больше соседних элементов в качестве пропорции с другими `flex-grow`, если это необходимо. `flex-grow` принимает безразмерное значение (по умолчанию 0).

`<итоговый_размер> = <размер> + <свободное_пространство> * <flex-grow> / <сумма_всех_flex-grow>`

элемент                       | элемент1 | элемент2 | элемент3 | свободное пространство
----------------------------- | -------- | -------- | -------- | -----------------------
размер                        | 40px     | 60px     | 100px    | 320px                  
flex-grow                     | 2        | 1        | 1        |                        
часть свободного пространства | 160px    | 80px     | 80px     |                        
итоговый размер               | 200px    | 140px    | 180px    |                        

### <a id="Фактор-сжимаемости-отдельно-взятого-flex-блока-свойство-flex-shrink" href="#Фактор-сжимаемости-отдельно-взятого-flex-блока-свойство-flex-shrink">Фактор "сжимаемости" отдельно взятого flex-блока: свойство `flex-shrink`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `flex-shrink` - определяет, насколько частей будет уменьшаться элемент относительно других элементов в flex-контейнере, в тех случаях, когда для него недостаточно места в этом самом контейнере (по умолчанию 1).

`<вес> = <flex-shrink_элемента_1> * <размер_элемента_1> + ... + <flex-shrink_элементаN> * <размер_элементаN>`

`<итоговый_размер> = <размер> - (<сумма_всех_размеров> - <контейнер>) * <flex-shrink> * <размер> / <вес>`

элемент                | элемент1 | элемент2 | элемент3 | элемент4 | контейнер
---------------------- | -------- | -------- | -------- | -------- | ------------
размер                 | 100px    | 200px    | 200px    | 100px    | 400px       
flex-shrink            | 1        | 0        | 1        | 2        |             
вес                    | 100px    | 0px      | 200px    | 200px    | 500px       
часть отнятого размера | 40px     | 0px      | 80px     | 80px     | 200px       
итоговый размер        | 60px     | 200px    | 120px    | 20px     | 400px       

### <a id="Свойство-flex" href="#Свойство-flex">Свойство `flex`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `flex` - короткая запись для свойств `flex-grow`, `flex-shrink` и `flex-basis`

`flex: none | [<flex-grow> <flex-shrink>? || <flex-basis>]`

### <a id="Выравнивание-отдельно-взятого-flex-блока-по-поперечной-оси-свойство-align-self" href="#Выравнивание-отдельно-взятого-flex-блока-по-поперечной-оси-свойство-align-self">Выравнивание отдельно взятого flex-блока по поперечной оси: свойство `align-self`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Делает возможным переопределять свойство flex-контейнера `align-items` для отдельного flex-блока с помощью свойства `align-self`:
- `flex-start` - flex-блок прижат к началу поперечной оси;
- `flex-end` - flex-блок прижат к концу поперечной оси;
- `center` - flex-блок располагаются в центре поперечной оси;
- `baseline` - flex-блок выравнен по baseline;
- `stretch` - (значение по умолчанию) flex-блок растянут, чтобы занять все доступное место по поперечной оси, при этом учитываются `min-width`/`max-width`, если таковые заданы.

### <a id="Порядок-следования-отдельно-взятого-flex-блока-внутри-flex-контейнера-свойство-order" href="#Порядок-следования-отдельно-взятого-flex-блока-внутри-flex-контейнера-свойство-order">Порядок следования отдельно взятого flex-блока внутри flex-контейнера: свойство `order`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

По умолчанию все блоки будут следовать друг за другом в порядке, заданном в html. Однако этот порядок можно изменить с помощью свойства `order`. Оно задается целым числом и по умолчанию равно 0. Значение `order` не задает абсолютную позицию элемента в последовательности. Оно определяет вес позиции элемента.

Выравнивание по горизонтали через `margin: auto` здесь работает и для вертикали.

`margin`-ы в flexbox не "коллапсятся", т.е. не сливаются, как это происходит в обычном потоке.

Значение `float` у flex-блоков не учитывается и не имеет значения.

`gap: <размер_промежутка>` - определяет размер промежутка между элементами как по главной оси так и по поперечной в случае переноса элементов.

<a id="Grid" href="#Grid">Grid</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====

**CSS Grid layout** приносит инструмент двумерного макета в Веб, с возможностью размещения элементов в строках и столбцах. CSS сетка может использоваться для достижения многих различных макетов. Он разделяет страницу на крупные регионы, или определяет отношения с точки зрения размера, положения и слоя, между частями элемента управления, построенных из HTML примитивов.

## <a id="Главный-контейнер" href="#Главный-контейнер">Главный контейнер</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`display: grid;` - определяет то, что это контейнер для двумерного макета.  
`grid-template-columns: <размер_колонки_1> [<размер_колонки_2> [...]];` - определяет ширину колонок (столбцов), можно использовать вместе с `fr` или `auto`.  
`grid-template-rows: <размер_строки_1> [<размер_строки_2> [...]];` - определяет ширину строк, можно использовать вместе с `fr` или `auto`.

`grid-gap: <размер_промежутка> [<размер_промежутка_колонок>];` - определяет размер промежутка между ячейками сетки как по вертикали так и по горизонтали [по горизонтали переопределяется отдельно].  
`grid-column-gap: <размер_промежутка>;` - определяет размер промежутка между ячейками сетки по горизонтали.  
`grid-row-gap: <размер_промежутка>;` - определяет размер промежутка между ячейками сетки по вертикали.

`grid-auto-columns: <размер_строки_1> [<размер_строки_2> [...]];` - определяет высоту строк, для элементов которые выходят за пределы сетки.  
`grid-auto-rows: <размер_строки_1> [<размер_строки_2> [...]];` - определяет ширину строк, для элементов которые выходят за пределы сетки.  
`grid-auto-flow` - управляет поведением автоматически размещаемых элементов, точно указывая, как они попадают в сетку, принимает значения:
- `row` - указывает размещать элементы, заполняя поочередно каждую строку и добавляя новые строки по мере необходимости, по умолчанию;
- `column` - указывает размещать элементы, заполняя поочередно каждый столбец и добавляя новые столбцы по мере необходимости;
- `dense` - указывает заполнять элементами свободное пространство сетки. Это может привести к нарушению порядка, т.к. элементы будут выстраиваться не в соответствии со своим расположением, а в соответсвии с размером;
- `row dense`;
- `column dense`.

Ключевое слово `subgrid` для `grid-template-columns` и `grid-template-rows` - указывает что, будет использоваться сеточное размещения родителя для внутренней сетки.

`grid: <grid-template-rows> / <grid-template-columns>` - сокращенная запись.

### <a id="Шаблон-сетки" href="#Шаблон-сетки">Шаблон сетки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Задается с помощью матрицы, где каждая строка кода представляет строку в макете, и каждый из символов `<сим>` представляет ячейку сетки. Одинаковые символы образуют одинаковую область. `.` - обозначает пустую ячейку сетки. Одинаковые символы должны образовывать **прямоугольник**.

```css
{
    grid-template-areas:
        "<сим_1_1> ... <сим_N_1>"
        ...
        "<сим_1_M> ... <сим_N_M>";
}
```

### <a id="Названия-линий" href="#Названия-линий">Названия линий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В свойствах `grid-template-columns` и `grid-template-rows` можно указывать названия линий, для этого они указываются в квадратных скобках перед размерами и это будет означать что название линии будет алиасом номеру при дальнейшем использовании: `[<имя_линии_1>] <размер_1>[ ...] [ [<имя_линии_2>] <размер_1>[ ...] ] [ ...]`.

```css
{
    grid-template-columns: [left] 100px 200px [center] 300px [right];
    /* left = 1, center = 3, right = 4 (такой колонки нет, но ее можно использовать для указания до)*/
    grid-template-rows: [top] 100px [center] 20px 40px [bottom];
    /* top = 1, center = 2, bottom = 4 (такой строки нет, но ее можно использовать для указания до)*/
}
```

Имен у линий может быть больше чем одно, они должны разделяться пробелом.

Если названием области является `<сим>`, то названием начальных (первых) линий (строчной и колоночной) области будет `<сим>-start`, а последних - `<сим>-end`.

Свойство `grid-template` - короткая запись: `grid-template: <grid-template-rows> / <grid-template-columns>;`

```css
{
    grid-template:
        "a a ." minmax(50px, auto)
        "a a ." 80px
        "b b c" auto / 2em 3em auto;
}
```

## <a id="Дочерние-контейнеры" href="#Дочерние-контейнеры">Дочерние контейнеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Задание горизонтального положения (по умолчанию 1), т.е. элемент начнется на `<номер_колонки_начала>` линии сетки и закончится на `<номер_колонки_окончания>` линии сетки по горизонтали.
```
      1   2   .   N
    1 +---+---.---+
      |   |   .   |
    2 +---+---.---+
      |   |   .   |
    . .............
      |   |   .   |
    M +---+---.---+
```

`grid-column-start: <номер_колонки_начала>;`  
`grid-column-end: <номер_колонки_окончания>;`  
`grid-column: <номер_строки_начала> / <номер_строки_окончания>;` - сокращение

Задание вертикального положения (по умолчанию 1), т.е. элемент начнется на `<номер_строки_начала>` линии сетки и закончится на `<номер_строки_окончания>` линии сетки по вертикали (но не включит ее).

`grid-row-start: <номер_строки_начала>;`  
`grid-row-end: <номер_строки_окончания>;`  
`grid-row: <номер_строки_начала> / <номер_строки_окончания>;` - сокращение

Вместо номера строки / колонки можно использовать названия линий.

> `grid-column: left / center;` что аналогично `grid-column: 1 / 3;`

`grid-area: <grid-row-start> / <grid-column-start> / <grid-row-end> / <grid-column-end>;` - общая запись.

Можно передавать отрицательные индексы и тогда отсчет будет идти в обратную сторону.
> `grid-column: 1 / -1;`

Ключевое слово `auto` - указывает что это будет колонка или строка, на которую элемент будет помещен в результате автоматического размещения.

`span <длина>` - обозначает протяженность элемента.
> `grid-column: auto / span 3;`

### <a id="Расположение-на-шаблоне-сетки" href="#Расположение-на-шаблоне-сетки">Расположение на шаблоне сетки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Указанный элемент должен располагаться на месте `<сим>` - символа зоны, в макете шаблона сетки.

`grid-area: <сим>;`

### <a id="Выравнивание" href="#Выравнивание">Выравнивание</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `align-self` используется для выравнивания по вертикали и принимает значения:
- `start` - по верхнему краю ячейки;
- `center` - по центру краю ячейки;
- `end` - по нижнему краю ячейки.

Свойство `justify-self` используется для выравнивания по горизонтали и принимает значения:
- `start` - по левому краю ячейки;
- `center` - по центру краю ячейки;
- `end` - по правому краю ячейки.

### <a id="Свойство-justify-items" href="#Свойство-justify-items">Свойство `justify-items`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `justify-items` определяет атрибут по умолчанию `justify-self` для всех элементов блока, предоставляя всем им способ выравнивания по умолчанию каждого блока вдоль соответствующей оси:
- `flex-start` - блоки прижаты к началу горизональной (главной) оси;
- `flex-end` - блоки прижаты к концу горизональной (главной) оси;
- `center` - блоки располагаются в центре горизональной (главной) оси;
- `baseline` - блоки выровнены по их *baseline*;
- `stretch` - (значение по умолчанию) блоки растянуты, занимая все доступное место по горизональной (главной) оси, при этом все же учитываются `min-width`/`max-width`, если таковые заданы.

### <a id="Свойство-align-items" href="#Свойство-align-items">Свойство `align-items`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `align-items` определяет атрибут по умолчанию `align-self` для всех элементов блока, предоставляя всем им способ выравнивания по умолчанию каждого блока вдоль соответствующей оси:
- `start` - блоки прижаты к началу вертикальной (поперечной) оси;
- `end` - блоки прижаты к концу вертикальной (поперечной) оси;
- `center` - блоки располагаются в центре вертикальной (поперечной) оси;
- `stretch` - (значение по умолчанию) блоки растянуты, занимая все доступное место по вертикальной (поперечной) оси, при этом все же учитываются `min-height`/`max-height`, если таковые заданы.

### <a id="Свойство-place-items" href="#Свойство-place-items">Свойство `place-items`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `place-items` предоставляет возможность в одном свойстве описать выравнивание по линии контейнера и выровнивание элементы вдоль главной оси. При наличии только одного значения свойства, оно будет использовано для двух свойств.

`place-items: <align-items> || <justify-items>`

### <a id="Свойство-justify-content" href="#Свойство-justify-content">Свойство `justify-content`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `justify-content` определяет выравнивание сетки вдоль горизонтальной (главной) оси, если размер элемента меньше размера контейнера:
- `start` - сдвигает сетку в начало контейнера (левая граница);
- `end` - сдвигает сетку в конец контейнера (правая граница);
- `center` - сетка располагается по центру;
- `stretch` - колонки растягиваются таким образом, чтобы сетка занимала всю ширину контейнера;
- `space-around` - одинаковое пространство между колонками, и половина такого пространства по краям контейнера;
- `space-between` - первая колонка сдвигается в начало контейнера, последняя - в конец, свободное пространство равномерно распределяется между остальными колонками;
- `space-evenly` - одинаковое пространство как между колонками, так и по краям контейнера.

### <a id="Свойство-align-content" href="#Свойство-align-content">Свойство `align-content`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `align-content` определяет выравнивание сетки вдоль вертикальной (поперечной) оси, если размер элемента меньше размера контейнера:
- `start` - сдвигает сетку в начало контейнера (верхняя граница);
- `end` - сдвигает сетку в конец контейнера (нижняя граница);
- `center` - сетка располагается по центру;
- `stretch` - колонки растягиваются таким образом, чтобы сетка занимала всю высоту контейнера;
- `space-around` - одинаковое пространство между строками, и половина такого пространства по краям контейнера;
- `space-between` - первая строка сдвигается в начало контейнера, последняя - в конец, свободное пространство равномерно распределяется между остальными строками;
- `space-evenly` - одинаковое пространство как между строками, так и по краям контейнера.

### <a id="Свойство-place-content" href="#Свойство-place-content">Свойство `place-content`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Свойство `place-content` предоставляет возможность в одном свойстве описать выравнивание сетки в контейнере.

`place-content: <align-content> || <justify-content>`

## <a id="Отличие-Grid-от-Flexbox" href="#Отличие-Grid-от-Flexbox">Отличие Grid от Flexbox</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Grid для макетов, Flexbox для компонентов.

Если у компонента все дочерние элементы отображаются встроенными (inline) в ряд, то лучше использовать Flexbox. Если присутствуют столбцы и строки, то лучше Grid.

<a id="Адаптивность" href="#Адаптивность">Адаптивность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

## <a id="CSS-viewport-в-HTML" href="#CSS-viewport-в-HTML">CSS viewport в HTML</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<meta name="viewport" content="<свойство>=<значение>[, ...]" />` - используется для задания видимой области страницы.

Основные свойства мета-тега `viewport`:
- `width` - ширина видимой области. Рекомендуемое значение: `device-width`. Принимает натуральное число или ключевое слово `device-width`, устанавливающее оптимальную ширину `viewport` для устройства;
- `height` - высота видимой области. Работает аналогично `width`, только используется ключевое слово `device-height`;
- `initial-scale` - первоначальный масштаб страницы. Рекомендуемое значение: 1. Принимает число от 1 до 5;
- `minimum-scale` - минимальный масштаб страницы. Принимает натуральное число, которое идеологически должно быть меньше или равным `initial-scale`. Значение 1 запретит уменьшение масштаба страницы;
- `maximum-scale` - максимальный масштаб страницы. Принимает натуральное число, которое идеологически должно быть больше или равным `initial-scale`. Значение 1 запретит увеличение масштаба страницы;
- `user-scalable` - отключает или включает возможность масштабирования страницы. Принимает значение `no` или `yes`. Масштабирование отключается также при указании одинаковых значений `minimum-scale` и `maximum-scale`.

## <a id="Media-Queries-в-CSS" href="#Media-Queries-в-CSS">Media Queries в CSS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```css
@media [not | only] <тип_носителя> and (<медиа-функция>: <значение>) {
    <описание_CSS_селекторов_для_этого_media>
}
```

Основные типы носителей:
- `all` - все типы, значение по умолчанию;
- `screen` - экраны настольных компьютеров, планшетов и современных мобильных телефонов;
- `print` - принтеры;
- `speech` - речевые браузеры, которыми пользуются люди с ограниченными возможностями.

Наиболее часто используемые медиа-функции:
- **width** (`min-width`, `max-width`) - ширина окна браузера;
    - `min-width` означает, что стили будут применены при ширине, равной или большей указанной;
    - `max-width` означает, что стили будут применены при ширине не больше указанной.
- **height** (`min-height`, `max-height`) - высота окна браузера;
- **device-width** (`min-device-width`, `max-device-width`) - ширина экрана устройства (может быть больше ширины браузера);
- **device-height** (`min-device-height`, `max-device-height`) - высота экрана устройства;
- **orientation** - принимает значения `landscape` или `portrait` для определения альбомной и портретной ориентации соответственно;
- **aspect-ratio** (`min-aspect-ratio`, `max-aspect-ratio`) - принимает значения `<ширина>/<высота>` (`16/9`) для определения соотношения сторон: ширине к высоте;
- **hover** (`any-hover`) - принимает значения `hover` или `none` для определения возможности наводиться на элементы или нет соответственно;
- **pointer** (`any-pointer`) - принимает значения `coarse`, `fine` или `none` для определения основного механизма ввода: включает в себя указатель неточного ввода, точного ввода или нет указателя ввода соответственно;
- **color-scheme** (`prefers-color-scheme`) - принимает значения `light` или `dark` для определения предпочитаемой пользователем цветовой темы.

## <a id="Директива-supports" href="#Директива-supports">Директива `@supports`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для определения поддерживаемости свойства и его значения в текущем браузере:
```css
@supports (<свойство>: <значение>) {
    <описание_CSS_селекторов_в_случае_поддержки>
}
```

Могут применяться условные операторы `and`, `or` или `not`, тогда каждое свойство со значением должно быть обернуто в скобки.
> `(display: flexbox) and ( not (display: inline-grid) ) or (transform-style: preserve)`

## <a id="Директива-container" href="#Директива-container">Директива `@container`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для применения стилей к селекторам, которые находятся внутри контейнера и удовлетворяют условиям:
```css
@container [<имя_контейнера>] [not] (<медиа-функция>: <значение>) {
    <описание_CSS_селекторов_для_этого_контейнера>
}
```

Для того чтобы контейнер применился к селектору, необходимо назначить ему контейнер с помощью свойства `container-name` или `container` если он именованный или указать что он контейнер с помощью `container-type` и тогда все селекторы будут применяться только внутри него.

`container-name: <имя_контейнера>`

`container-type: inline-size | size | normal` - тип контейнера.

`container: <имя_контейнера> / <тип_контейнера>`

<a id="Приемы" href="#Приемы">Приемы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

## <a id="Эффект-длинных-теней-для-текста" href="#Эффект-длинных-теней-для-текста">Эффект длинных теней для текста</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```css
* {
    color: #444444;
    background: #ffffff;
    text-shadow: 1px 0px 1px #cccccc, 0px 1px 1px #eeeeee, 2px 1px 1px #cccccc, 1px 2px 1px #eeeeee, 3px 2px 1px #cccccc, 2px 3px 1px #eeeeee, 4px 3px 1px #cccccc, 3px 4px 1px #eeeeee, 5px 4px 1px #cccccc, 4px 5px 1px #eeeeee, 6px 5px 1px #cccccc, 5px 6px 1px #eeeeee, 7px 6px 1px #cccccc;
}
```

## <a id="Эффект-контурного-текста" href="#Эффект-контурного-текста">Эффект контурного текста</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```css
* {
    color: #fff;
    text-shadow:
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
}
```

## <a id="Размытие-текста" href="#Размытие-текста">Размытие текста</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```css
* {
    color: transparent;
    text-shadow: 0 0 3px #fff;
}
```

<a id="БЭМ" href="#БЭМ">БЭМ</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===

**БЭМ** (*Блок*, *Элемент*, *Модификатор*) - компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки.

## <a id="Блок" href="#Блок">Блок</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Функционально независимый компонент страницы, который может быть повторно использован. В HTML блоки представлены атрибутом `class`. Особенности:
- **название блока** характеризует смысл (*"что это?" - "меню": menu, "кнопка": button*), а не состояние (*"какой, как выглядит?" - "красный": red, "большой": big*);
- **имя блока** формируется по схеме `<имя-блока>`, каждое слово в имени идет через тире `-` и задает пространство имен для элементов и модификаторов;
- блок не должен влиять на свое окружение, т. е. блоку не следует задавать внешнюю геометрию (в виде отступов, границ, влияющих на размеры) и позиционирование;
- в CSS по БЭМ также не рекомендуется использовать селекторы по тегам или id.

Таким образом обеспечивается независимость, при которой возможно повторное использование или перенос блоков с места на место.

Вложенность блоков:
- блоки можно вкладывать друг в друга;
- допустима любая вложенность блоков.

## <a id="Элемент" href="#Элемент">Элемент</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Составная часть блока, которая не может использоваться в отрыве от него. Особенности:
- **название элемента** характеризует смысл (*"что это?" - "пункт": item, "текст": text*), а не состояние (*"какой, как выглядит?" - "красный": red, "большой": big*);
- **структура полного имени элемента** соответствует схеме: `<имя-блока>__<имя-элемента>`. Имя элемента отделяется от имени блока двумя подчеркиваниями `__`, каждое слово в имени идет через тире `-` и задает пространство имен, которое гарантирует зависимость элементов от блока (`block__elem`).

Вложенность элементов:
- элементы можно вкладывать друг в друга;
- допустима любая вложенность элементов;
- элемент - всегда часть блока, а не другого элемента. Это означает, что в названии элементов нельзя прописывать иерархию вида `block__elem1__elem2`.

Блок может иметь вложенную структуру элементов в DOM-дереве. Однако эта же структура блока в методологии БЭМ всегда будет представлена плоским списком элементов. Это позволяет изменять DOM-структуру блока без внесения правок в коде каждого отдельного элемента. Структура блока меняется, а правила для элементов и их названия остаются прежними.

**Элемент** - всегда часть блока и не должен использоваться отдельно от него.  
**Элемент** - необязательный компонент блока. Не у всех блоков должны быть элементы.  
**Элемент** создается, если фрагмент кода не может использоваться самостоятельно, без родительской сущности (блока).

## <a id="Модификатор" href="#Модификатор">Модификатор</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сущность, определяющая внешний вид, состояние или поведение блока либо элемента. Особенности:
- **название модификатора** характеризует внешний вид (*"какой размер?", "какая тема?" и т. п. - "размер": size_s, "тема": theme_islands*), состояние (*"чем отличается от прочих?" - "отключен": disabled, "фокусированный": focused*) и поведение (*"как ведет себя?", "как взаимодействует с пользователем?" - "направление": directions_left-top*);
- **имя модификатора** отделяется от имени блока или элемента одним подчеркиванием `_`, каждое слово в имени идет через тире `-` или `_`.

### <a id="Типы-модификаторов" href="#Типы-модификаторов">Типы модификаторов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Булевый**:
- используют, когда важно только наличие или отсутствие модификатора, а его значение несущественно. Например, `"отключен": disabled`. Считается, что при наличии булевого модификатора у сущности его значение равно `true`;
- структура полного имени модификатора соответствует схеме:
    - `<имя-блока>_<имя_модификатора>`;
    - `<имя-блока>__<имя-элемента>_<имя_модификатора>`.

**Ключ-значение**:
- используют, когда важно значение модификатора. Например, "меню с темой оформления islands": menu_theme_islands;
- структура полного имени модификатора соответствует схеме:
    - `<имя-блока>_<имя_модификатора>_<значение_модификатора>`;
    - `<имя-блока>__<имя-элемента>_<имя_модификатора>_<значение_модификатора>`.

### <a id="Принципы-работы-с-модификаторами" href="#Принципы-работы-с-модификаторами">Принципы работы с модификаторами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С точки зрения БЭМ-методологии модификатор не может использоваться в отрыве от модифицируемого блока или элемента. Модификатор должен изменять вид, поведение или состояние сущности, а не заменять ее.

## <a id="Микс" href="#Микс">Микс</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Прием, позволяющий использовать разные БЭМ-сущности на одном DOM-узле. Миксы позволяют:
- совмещать поведение и стили нескольких сущностей без дублирования кода;
- создавать семантически новые компоненты интерфейса на основе имеющихся.

Микс содержит одновременно и блок и элемент.