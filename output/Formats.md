[Содержание](#Содержание)
==========

- [Форматы](#user-content-Форматы)
    - [YAML](#user-content-YAML)
        - [Типы данных](#user-content-Типы-данных)
            - [Строки](#user-content-Строки)
            - [Числа](#user-content-Числа)
            - [Массивы](#user-content-Массивы)
    - [Синтаксис](#user-content-Синтаксис)
        - [Ссылки](#user-content-Ссылки)
    - [Расширенная форма Бэкуса - Наура](#user-content-Расширенная-форма-Бэкуса---Наура)
- [Base64](#user-content-Base64)
- [Протоколы](#user-content-Протоколы)
    - [HTTP](#user-content-HTTP)
        - [Коды состояния HTTP](#user-content-Коды-состояния-HTTP)
            - [**1xx: Informational** (информационные)](#user-content-1xx-Informational-информационные)
            - [**2xx: Success** (успешно)](#user-content-2xx-Success-успешно)
            - [**3xx: Redirection** (перенаправление)](#user-content-3xx-Redirection-перенаправление)
            - [**4xx: Client Error** (ошибка клиента)](#user-content-4xx-Client-Error-ошибка-клиента)
            - [**5xx: Server Error** (ошибка сервера)](#user-content-5xx-Server-Error-ошибка-сервера)
        - [Заголовки](#user-content-Заголовки)
            - [`cache-control`](#user-content-cache-control)
            - [`Range`](#user-content-Range)
    - [REST](#user-content-REST)
        - [HTTP методы](#user-content-HTTP-методы)
            - [Метод **GET**](#user-content-Метод-GET)
            - [Метод **PUT**](#user-content-Метод-PUT)
            - [Метод **POST**](#user-content-Метод-POST)
            - [Метод **DELETE**](#user-content-Метод-DELETE)
        - [Именование ресурсов](#user-content-Именование-ресурсов)
            - [Наименование ресурса](#user-content-Наименование-ресурса)
            - [Взаимодействие с подресурсом ресурса](#user-content-Взаимодействие-с-подресурсом-ресурса)
        - [Идемпотентность](#user-content-Идемпотентность)
        - [Безопасность](#user-content-Безопасность)
        - [HATEOAS](#user-content-HATEOAS)
        - [JSON:API](#user-content-JSONAPI)
            - [Дополнительные параметры запроса](#user-content-Дополнительные-параметры-запроса)
            - [Получение ресурса](#user-content-Получение-ресурса)
            - [Создание ресурсов](#user-content-Создание-ресурсов)
            - [Обновление ресурсов](#user-content-Обновление-ресурсов)
            - [Удаление ресурсов](#user-content-Удаление-ресурсов)
            - [Изменение связей один к одному](#user-content-Изменение-связей-один-к-одному)
            - [Изменение множественных связей](#user-content-Изменение-множественных-связей)
            - [Множественные операции](#user-content-Множественные-операции)

<a id="Форматы" href="#Форматы">Форматы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

## <a id="YAML" href="#YAML">YAML</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Формат для описания данных. Имеет расширение `.yml`.

### <a id="Типы-данных" href="#Типы-данных">Типы данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`# <комментарий>` - комментарий, все что идет после `#` считается комментарием и не влияет ни на что. Может располагаться где угодно.
> `key one: value one # this is temporary`

#### <a id="Строки" href="#Строки">Строки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<строка>` - строка, если не содержит спец символов `@`, `_`.  
`'<строка>'` - строка.  
`"<строка>"` - строка.  
> `This is a string`  
> `"This is @ string"`

#### <a id="Числа" href="#Числа">Числа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Если число без точки - то оно имеет тип integer, иначе float.
> `200 # integer`  
> `20.1 # float`

#### <a id="Массивы" href="#Массивы">Массивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`[<значение1>[, ...]]` - описание списка (массива) в одной строке. В виде синтаксиса дефиса:
```yaml
  - <значение1>
  ...
```

> `['Anne', 'John', 'Max']`
```yaml
  - Anne
  - John
  - Max
```

## <a id="Синтаксис" href="#Синтаксис">Синтаксис</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Вложеность задается пробелами (2). 0 пробелов обозначает корень.

`<ключ>: <значение>` - описание ключа и его значения. Все что до `:` идет за ключ, а после за значение. Значением может быть число, строка или массив.
> `key: value`  
> `key one: value one`  
> `people: ['Anne', 'John', 'Max']`
```yaml
people:
  - Anne
  - John
  - Max
```

### <a id="Ссылки" href="#Ссылки">Ссылки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<ключ>: &<переменная>` - объявление переменной. Все что вложено в этот ключ будет в переменной.

`<<: *<переменная>` - вставляет все ключи из переменной в текущее место.

```yaml
base-config: &config
  os: ubuntu
  manager: yarn
  run:
    - NODE_ENV=${ENVIRONMENT} yarn build
development:
  <<: *config
  env:
    - ENVIRONMENT: development
production:
  <<: *config
  env:
    - ENVIRONMENT: production
```

## <a id="Расширенная-форма-Бэкуса---Наура" href="#Расширенная-форма-Бэкуса---Наура">Расширенная форма Бэкуса - Наура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это формальная система определения синтаксиса, в которой одни синтаксические категории последовательно определяются через другие. Используется для описания граматик.

**Терминальные символы** - это минимальные элементы грамматики, не имеющие собственной грамматической структуры - это предопределенные идентификаторы (имена, считающиеся заданными для данного описания грамматики), либо цепочки - последовательности символов в кавычках или апострофах.

**Нетерминальные символы** - это элементы грамматики, имеющие собственные имена и структуру. Каждый нетерминальный символ состоит из одного или более терминальных и / или нетерминальных символов, сочетание которых определяется правилами грамматики.

**Правила** - используются для определения нетерминальных символов:  
`<идентификатор> = <выражение>.` - правило, где `<идентификатор>` - это нетерминальный символ, а `<выражение>` - это комбинация терминальных и нетерминальных символов и специальных знаков, могут быть комбинацией конструкций:
- **конкатенация** - это перечисление терминальных и не терминальных символов через символ `,`, что обозначает что нетерминал состоит из последовательности символов. Правило вида `A = B,C.`, иногда символ `,` может опускаться:
    > `SELECT = 'select', COLUMN_LIST, 'from', TABLE.`
- **выбор** - это выбор одного из терминальных и не терминальных символов через символ `|`, что обозначает что нетерминал может состоять из одного из символов. Правило вида `A = B|C.`:
    > `COND = 'or' | 'and'.`
- **условное вхождение** - это необязательный элемент выражения, который может присутствовать, а может и отсутствовать и заключается между символами `[` и `]`. Правило вида `A = [B].`:
    > `COND = ['not'], COND.`
- **повторение** - это повторяющийся элемент выражения, который обозначают конкатенацию любого числа (включая нуль) записанных в ней элементов и заключается между символами `{` и `}`. Правило вида `A = {B}.`:
    > `LIST = ARG {',', ARG}.`
- **групировка** - это конструкция, которая применяется для группировки элементов при формировании сложных выражений и заключается между символами `(` и `)`. Правило вида `A = (B).`:
    > `COND = ARG, 'in', (ARG | LIST).`

<a id="Base64" href="#Base64">Base64</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Этот формат используется для передачи в виде текста битовой информации.

Избыточность кодирования составляет 1/3.

Содержит латинские символы `A-Z`, `a-z`, цифры `0-9` (всего 62 знака) и 2 дополнительных символа, зависящих от системы реализации. Стандартные 62 символа дополняют `+`, `/` и `=` - в качестве специального кода суффикса.

Кодирование происходит путем помещения 3 байт в 24 битный буфер, который разбивается затем по 6 бит, каждый из которых уже отображается на символы. Если кодируется только один или два байта из буффера, в результате получаются только первые два или три символа строки, а выходная строка дополняется двумя `=` при одном байте или одним знаком `=`.
```
    | 0 1 2 3 4 5   6 7 | 0 1 2 3   4 5 6 7 | 0 1   2 3 4 5 6 7 | - исходные
    | 0 1 2 3 4 5 | 0 1   2 3 4 5 | 0 1 2 3   4 5 | 0 1 2 3 4 5 | - буффер
```

<a id="Протоколы" href="#Протоколы">Протоколы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

## <a id="HTTP" href="#HTTP">HTTP</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Коды-состояния-HTTP" href="#Коды-состояния-HTTP">Коды состояния HTTP</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="1xx-Informational-информационные" href="#1xx-Informational-информационные">**1xx: Informational** (информационные)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**1xx: Informational** (информационные) - в этот класс выделены коды, информирующие о процессе передачи. В **HTTP/1.0** сообщения с такими кодами должны игнорироваться. В **HTTP/1.1** клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно. Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка. Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту:
- **100 Continue** ("продолжай");
- **101 Switching Protocols** ("переключение протоколов");
- **102 Processing** ("идет обработка");
- **105 Name Not Resolved** ("не удается преобразовать DNS-адрес сервера").

#### <a id="2xx-Success-успешно" href="#2xx-Success-успешно">**2xx: Success** (успешно)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**2xx: Success** (успешно) - сообщения данного класса информируют о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса сервер может еще передать заголовки и тело сообщения:
- **200 OK** ("хорошо");
- **201 Created** ("создано");
- **202 Accepted** ("принято");
- **203 Non-Authoritative Information** ("информация не авторитетна");
- **204 No Content** ("Нет содержимого");
- **205 Reset Content** ("сбросить содержимое");
- **206 Partial Content** ("частичное содержимое");
- **207 Multi-Status** ("многостатусный");
- **226 IM Used** ("использовано IM").

#### <a id="3xx-Redirection-перенаправление" href="#3xx-Redirection-перенаправление">**3xx: Redirection** (перенаправление)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**3xx: Redirection** (перенаправление) - коды класса 3xx сообщают клиенту что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI:
- **300 Multiple Choices** ("множество выборов");
- **301 Moved Permanently** ("перемещено навсегда");
- **302 Moved Temporarily** ("перемещено временно");
- **302 Found** ("найдено");
- **303 See Other** (смотреть другое);
- **304 Not Modified** (не изменялось);
- **305 Use Proxy** ("использовать прокси");
- **306** - зарезервировано (код использовался только в ранних спецификациях);
- **307 Temporary Redirect** ("временное перенаправление").

#### <a id="4xx-Client-Error-ошибка-клиента" href="#4xx-Client-Error-ошибка-клиента">**4xx: Client Error** (ошибка клиента)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**4xx: Client Error** (ошибка клиента) - класс кодов 4xx предназначен для указания ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя:
- **400 Bad Request** ("плохой, негодный запрос") - в случае если сервер не может понять запрос, в нем отсутсвуют некоторые параметры или они неверного формата, повторные запросы должны быть модернизированны;
- **401 Unauthorized** ("неавторизован") - в случае если необходима авторизация, ответ должен содержать заголовок `WWW-Authenticate` с указаным методом авторизации;
- **402 Payment Required** ("необходима оплата");
- **403 Forbidden** ("запрещено") - в случае если сервер понимает запрос, но отказывается его выполнять, в ответе должна содержаться причина из-за чего сервер отказывается выполнять запрос;
- **404 Not Found** ("не найдено") - в случае если сервер не находит ничего по указаной `URI`, то есть конечную точку невозможно обнаружить;
- **405 Method Not Allowed** ("метод не поддерживается") - в случае если сервер не поддерживает указаный метод запроса по указаному пути;
- **406 Not Acceptable** ("неприемлемо") - в случае если сервер не понимает `Content-Type` запроса;
- **407 Proxy Authentication Required** ("необходима аутентификация прокси");
- **408 Request Timeout** ("истекло время ожидания");
- **409 Conflict** ("конфликт");
- **410 Gone** ("удален");
- **411 Length Required** ("необходима длина");
- **412 Precondition Failed** ("условие ложно");
- **413 Request Entity Too Large** ("размер запроса слишком велик");
- **414 Request-URI Too Large** ("запрашиваемый URI слишком длинный");
- **415 Unsupported Media Type** ("неподдерживаемый тип данных");
- **416 Requested Range Not Satisfiable** ("запрашиваемый диапазон не достижим");
- **417 Expectation Failed** ("ожидаемое неприемлемо");
- **418 I'm a teapot** ("я - чайник");
- **422 Unprocessable Entity** ("необрабатываемый экземпляр");
- **423 Locked** ("заблокировано");
- **424 Failed Dependency** ("невыполненная зависимость");
- **425 Unordered Collection** ("неупорядоченный набор");
- **426 Upgrade Required** ("необходимо обновление");
- **428 Precondition Required** ("необходимо предусловие");
- **429 Too Many Requests** ("слишком много запросов");
- **431 Request Header Fields Too Large** ("поля заголовка запроса слишком большие");
- **434 Requested host unavailable** ("Запрашиваемый адрес недоступен");
- **449 Retry With** ("повторить с");
- **451 Unavailable For Legal Reasons** ("недоступно по юридическим причинам");
- **456 Unrecoverable Error** ("некорректируемая ошибка");
- **499** - используется Nginx, когда клиент закрывает соединение до получения ответа.

#### <a id="5xx-Server-Error-ошибка-сервера" href="#5xx-Server-Error-ошибка-сервера">**5xx: Server Error** (ошибка сервера)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**5xx: Server Error** (ошибка сервера) - коды 5xx выделены под случаи неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю:
- **500 Internal Server Error** ("внутренняя ошибка сервера");
- **501 Not Implemented** ("не реализовано");
- **502 Bad Gateway** ("плохой, ошибочный шлюз");
- **503 Service Unavailable** ("сервис недоступен");
- **504 Gateway Timeout** ("шлюз не отвечает");
- **505 HTTP Version Not Supported** ("версия HTTP не поддерживается");
- **506 Variant Also Negotiates** ("вариант тоже проводит согласование");
- **507 Insufficient Storage** ("переполнение хранилища");
- **508 Loop Detected** ("обнаружена петля");
- **509 Bandwidth Limit Exceeded** ("исчерпана пропускная ширина канала");
- **510 Not Extended** ("не расширено");
- **511 Network Authentication Required** ("требуется сетевая аутентификация").

### <a id="Заголовки" href="#Заголовки">Заголовки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="cache-control" href="#cache-control">`cache-control`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Отвечает за кэширование. Принимает значения:
- `private` - контент может быть закэширован только конечным клиентом, но не промежуточным узлом, таким, как прокси или CDN;
- `public` - контент может быть кэширован кем угодно;
- `no-store` - контент не должен быть кэширован никем и никогда;
- `no-cache` - контент не должен использоваться до тех пор, пока клиент не убедится, что он просматривает последнюю версию. Это реализуется за счет хедера `ETag`, который представляет собой идентификатор, уникальный для конкретного ресурса. Клиент при запросе посмотрит, что у него лежит в кэше, и отдаст `ETag` в заголовке `If-None-Match`. Если `ETag` от клиента соответствует актуальной версии у сервера, то он ответит клиенту, что можно пользоваться кэшем, иначе пришлет новую версию.
- `max-age <количество_секунд>` - указывает срок жизни ресурса в секундах с момента первого получения.

#### <a id="Range" href="#Range">`Range`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Отвечает за загрузку частичного содержимого файла в байтах. Принимает значения:
- `bytes=<first-byte-pos>-[<last-byte-pos>]` - указывает начальное смещение в файле и что нужно получить содержимое файла с позиции `<first-byte-pos>` (от 0) и до конца файла [до указаного смещения (оно включается) `<last-byte-pos>` (должно быть больше либо равно `<first-byte-pos>` и при этом меньше либо равно скачиваемому размеру файла минус один (потому что это смещение, то есть индекс в массиве байтов))]:
    > `Range: bytes=0-255`  
    > `Range: bytes=256-512`

При удолетворительном ответе будет статус `206 Partial Content` и заголовок `Content-Range: bytes <first-byte-pos>-<last-byte-pos>/<length>` - где `<length>` - это размер всего файла.
> `Content-Range: bytes 256-512/1024`

Если диапазон указан не верно, то будет ответ с кодом: `416 Range Not Satisfiable`.

## <a id="REST" href="#REST">REST</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

(**Representational State Transfer** - *"передача состояния представления"*)

Архитектурный стиль взаимодействия компонентов распределенного приложения в сети. **REST** представляет собой согласованный набор ограничений, учитываемых при проектировании распределенной гипермедиа-системы. В определенных случаях это приводит к повышению производительности и упрощению архитектуры.

В широком смысле компоненты в **REST** взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. **REST** является альтернативой **RPC**.

В сети Интернет вызов удаленной процедуры может представлять собой обычный **HTTP**-запрос (обычно "**GET**" или "**POST**"; такой запрос называют "**REST-запрос**"), а необходимые данные передаются в качестве параметров запроса.

### <a id="HTTP-методы" href="#HTTP-методы">HTTP методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**HTTP** глаголы составляют основную часть "единого интерфейса", ограничивающего и предоставляющего возможность осуществлять действия над существительным-ресурсом. Основными или наиболее часто используемыми HTTP глаголами (методами) являются **POST**, **GET**, **PUT**, и **DELETE**. Они соответствуют операциям создания, чтения, обновления и удаления (или в совокупности - **CRUD**). Есть еще и другие глаголы, но они используются реже. Из реже используемых методов выделяются **OPTIONS** и **HEAD**.

#### <a id="Метод-GET" href="#Метод-GET">Метод **GET**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**HTTP** метод **GET** используется для получения (или чтения) представления ресурса. В случае *"удачного"* (или не содержащего ошибок) адреса, **GET** возвращается представление ресурса в формате **XML** или **JSON** в сочетании с кодом состояния **HTTP** **200** (OK). В случае наличия ошибок обычно возвращается код **404** (NOT FOUND) или **400** (BAD REQUEST).

В соответствии спецификации **HTTP**, **GET** (также как и **HEAD**) запросы используются только для чтения данных, не изменя их. **GET** (а также **HEAD**) запросы являются **идемпотентными** (тождественными), что подразумевает получение идеинтичных данных при использовании одних и теж же запросов (как при единичном обращении, так и при многократном).

Не стоит использовать **GET** для небезопасных операций над данными, при данном запросе они не должны быть модифицированы.

#### <a id="Метод-PUT" href="#Метод-PUT">Метод **PUT**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Метод **PUT** обычно используется для предоставления возможности обновления ресурса. Тело запроса при отправке **PUT**-запроса к существующему ресурсу **URI** должно содержать обновленные данные оригинального ресурса (полностью, или только обновляемую часть).

Кроме того, **PUT** может быть использован для создания ресурса, в случае, когда идентификатор ресурса выбирает клиент, а не сервер (при отправке **PUT** запроса по адресу, содержащему не существующий идентификатор ресурса). Тело запроса должно быть модификацией оригинального ресурса.

Для создания новых экземпляров ресурса предпочтительнее использозвание **POST** запроса. В данном случае, при создании экземпляра будет предоставлен корректный идентфикатор экземпляра ресурса в возвращенных данных об экземпляре.

При успешном обновлении посредством выполнения **PUT** запроса возвращается код **200** (или **204** если не был передан какой либо контент в теле ответа). Если **PUT** используется для создания экземпляра - обычно возвращают **HTTP** код **201** при успешном создании. Возвращать данные в ответ на запрос не обязательно. Также не обязательно возвращать ссылку на экземпляр ресурса посредством заголовка `Location` по причине того, что клиент и так обладает идентификатором экземпляра ресурса.

**PUT** не безопасная операция, так как в следствии ее выполнения происходит модификация (или создание) экземпляров ресурса на стороне сервера, но этот метод идемпотентен (создание или обновление ресурса посредством отправки **PUT** запроса - ресурс не исчезнет, будет располагаться там же, где и был при первом обращении, а также, многократное выполнение одного и того же **PUT** запроса не изменит общего состояния системы, за исключением первого раза).

Если **PUT** запрос используется для увеличесния счетчика просмотра конкретного ресурса - данный запрос уже не считается идемпотентным. Иногда такое происходит и считается достаточным задокументировать тот факт, что вызов не идемпотентен. Однако, строго рекомендуется выдерживать идемпотентность **PUT** запроса.

#### <a id="Метод-POST" href="#Метод-POST">Метод **POST**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Метод **POST** наиболее часто используется для создания новых ресурсов. Используется для создания вложенных ресурсов (при создании нового ресурса, **POST** запрос отправляется к родительскому ресурсу и, таким образом, сервис берет на себя ответственность на установление связи создаваемого ресурса с родительским ресурсом, назначение новому ресурсу ID и т.п.)
При успешном создании ресурса возвращается **HTTP** код **201**, а также в заголовке `Location` передается адрес созданного ресурса.

**POST** не является безопасным или идемпотентным запросом. Потому рекомендуется его использование для не идемпотентных запросов. В результате выполнения идентичных **POST** запросов предоставляются сильно похожие, но не идеинтичные данные.

#### <a id="Метод-DELETE" href="#Метод-DELETE">Метод **DELETE**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Метод **DELETE** используется для удаления ресурса, идентифицированного конкретным **URI** (ID).

При успешном удалении возвращается **200** (OK) код **HTTP**, совместно с телом ответа, содаржащим данные удаленного ресурса (отрицательно сказывается на экономии трафика) или завернутые ответы. Также возможно использование HTTP кода **204** (NO CONTENT) без тела ответа.

Согласно спецификации **HTTP**, **DELETE** запрос идемпотентен. Если выполняется **DELETE** запрос к ресурсу, он удаляется. Повторный **DELETE** запрос к ресурсу закончится также: ресурс удален. Если **DELETE** запрос используется для декремента счетчика, **DELETE** запрос не является идемпотентным. Необходимо использовать **POST** для не идемпотентых операций.

Повторный **DELETE** запрос к ресурсу часто сопровождается **404** (NOT FOUND) кодом **HTTP** по причине того, что ресурс уже удален и более не доступен. Это делает **DELETE** операцию не идемпотентной, но это общепринятый компромисс на тот случай, если ресурс был удален, а не помечен, как удаленный.

### <a id="Именование-ресурсов" href="#Именование-ресурсов">Именование ресурсов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

За основу адресации берется покрытие уникальными идентификаторами ресурсов (**URI**). У каждого ресурса есть свой адрес или **URI**: вся интересная информация, которую сервер может предоставить, представлена как ресурс. Ограничение однообразия интерфейса частично реализовано с помощью комбинаций **URI** и **HTTP** глаголов и их использованием в соответствии со стандартами и конвенциями.

Ресурсы необходимо называть **существительными**, в противоположность глаголам, или действиям (**URI** должен ссылаться на ресурс, а не на действие).

**URI** должны иметь предсказуемую, иерархичную структуру, чтобы увеличить понятность и, как следствие, юзабилити: предсказуемость означает, что они консистентны, иерархичность означает, что у данных есть структура взаомоотношений. Это не принцип и не ограничение **REST**, но это улучшает **API**.

**RESTful API** пишут для потребителей. Назавания и струтрука **URI** должна передавать смысл этим потребителям.

#### <a id="Наименование-ресурса" href="#Наименование-ресурса">Наименование ресурса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`GET /<имя_ресурса>` - возвращает список ресурсов.  
`POST /<имя_ресурса> `- создает новый экземпляр ресурса.  
`GET /<имя_ресурса>/<идентификатор>` - возвращает ресурс из коллекции по указанному идентификатору.  
`GET|PUT|DELETE /<имя_ресурса>/<идентификатор>` - читает, обновляет, удаляет ресурс с указанным идентификатором.

#### <a id="Взаимодействие-с-подресурсом-ресурса" href="#Взаимодействие-с-подресурсом-ресурса">Взаимодействие с подресурсом ресурса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`GET /<имя_ресурса>/<идентификатор>/<имя_подресурса>` - возвращает список подресурсов, который связан с указанным ресурсом по указанному идентификатору.  
`POST /<имя_ресурса>/<идентификатор>/<имя_подресурса>` - создает новый экземпляр подресурса, который связан с указанным ресурсом по указанному идентификатору.  
`GET|PUT|DELETE /<имя_ресурса>/<идентификатор>/<имя_подресурса>/<подидентификатор>` - читает, обновляет, удаляет подресурс ресурса с указанным идентификатором.

Так же можно продолжать концепцию иерархичности ресурсом и подресурсов. Для разбиения подвложености, доступ к подресурсу можно выносить вотдельно.

### <a id="Идемпотентность" href="#Идемпотентность">Идемпотентность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.

С точки зрения **RESTful**-сервиса, операция (или вызов сервиса) идемпотентна тогда, когда клиенты могут делать один и тот же вызов неоднократно при одном и том же результате.
В то время, как идемпотентные операции производят один и тот же результат на сервере (побочные эффекты), ответ сам по себе может не быть тем же самым (например, состояние ресурса может измениться между запросами).

### <a id="Безопасность" href="#Безопасность">Безопасность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Некоторые **HTTP**-методы (**HEAD**, **GET**, **OPTIONS**, **TRACE** и др.) определены как безопасные, это означает, что они предназначены только для получения информации и не должны изменять состояние сервера (они не должны иметь побочных эффектов, за исключением безобидных эффектов, таких как: логирование, кэширование, показ баннерной рекламы или увеличение веб-счетчика). Созданный произвольный **GET**-запрос, который не учитывает контекст состояния приложения, следует считать безопасным.

Безопасность означает, что вызов метода не имеет побочных эффектов. Следовательно, такие (безопасные) запросы клиенты могут безопасно совершать неоднократно, не опасаясь изменить состояние сервера.

По определению, безопасные операции идемпотентны, так как они приводят к одному и тому же результату на сервере.

Безопасные методы реализованы как операции только для чтения. Однако безопасность не означает, что сервер должен возвращать тот же самый результат каждый раз.

### <a id="HATEOAS" href="#HATEOAS">HATEOAS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это дополнение к REST, которая говорит что вместе с ресурсом возвращается набор предоставляемых действий с этим ресурсом. Для списков - это:
- количество страниц, на которые разбит этот список;
- ссылки на предыдущую и следующую страницы;
- в каждом элементе списка будет ссылка на конкретный ресурс.

### <a id="JSONAPI" href="#JSONAPI">JSON:API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это развитие HATEOAS, которое подразумевает, что общение происходит в формате JSON. Ответ от сервера должен быть объектом JSON с определенной структурой:
- `data` - данные ресурса, не должно быть, когда есть `errors`;
- `errors` - массив объектов ошибок, не должно быть, когда есть `data`;
- `meta` - объект с нестандартизированной мета информацией - тут может храниться количество ресурсов;
- `links` - объект с ссылками на ресурс;
- `included` - массив объектов ресурсов, которые относятся к данным ресурса, у этих ресурсов ссылка `self` должна иметь вид `<тип_ресурса>/<идентификатор_ресурса>`.

Объект с ссылками на ресурс состоит из:
- `self` - обязательное поле, строка со ссылкой на текущий ресурс;
- `related` - строка со ссылкой на текущий ресурс;
- `first` - строка с ссылкой на первую страницу ресурса или `null`;
- `last` - строка с ссылкой на последнюю страницу ресурса или `null`;
- `prev` - строка с ссылкой на предыдущую страницу ресурса или `null`;
- `next` - строка с ссылкой на следующую страницу ресурса или `null`.

Каждая ссылка может быть не только строкой, а еще объектом, который состоит из:
- `href` - обязательное поле, строка со ссылкой на текущий ресурс;
- `title` - человеко читаемый заголовок ссылки;
- `meta` - объект с нестандартизированной мета информацией - тут может храниться количество ресурсов.

Значение `data` может быть:
- для запроса ресурса: `null`, если ресурса нет, объектом ресурса или идентификатором ресурса;
- для запроса множества ресурсов: массив объектов ресурса, массив идентификаторов ресурсов или пустой массив.

Тип ресурса рекомендуется называть во множественном числе.

**Идентификатор ресурса** - это объект со структурой:
- `type` - обязательное поле, строка обозначающая тип ресурса;
- `id` - обязательное поле, строка обозначающая идентификатор ресурса.

**Ресурс** - это объект со структурой:
- `type` - обязательное поле, строка обозначающая тип ресурса;
- `id` - обязательное поле, строка обозначающая идентификатор ресурса;
- `lid` - локальный идентификатор ресурса;
- `attributes` - объект с атрибутами ресурса (ключ - значение), не должен содержать ключи, которые ссылаются на другие ресурсы;
- `relationships` - объект с отношениями ресурса к другим ресурсам - связи, представляет из себя объект где ключи - это имя связи, а значения - объекты:
    - `links` - объект с ссылками на связь, где:
        - `self` должно иметь вид `<тип_ресурса>/<идентификатор_ресурса>/relationships/<имя_связи>`;
        - `related` должно иметь вид `<тип_ресурса>/<идентификатор_ресурса>/<имя_связи>`;
    - `data` - данные связанного ресурса:
        - для связи один к одному может быть `null`, если ресурса нет, или объектом ресурса в основном с полями `type` и `id`;
        - для связи один ко многим может быть массивом объектов ресурса, в основном состоящие из полей `type` и `id` или пустым массивом.
- `links` - объект с ссылками на ресурс;
- `meta` - объект с нестандартизированной мета информацией.

```json
{
    "type": "articles",
    "id": "1",
    "attributes": {
        "title": "JSON:API paints my bikeshed!"
    },
    "links": {
        "self": "http://example.com/articles/1"
    },
    "relationships": {
        "author": {
            "links": {
                "self": "http://example.com/articles/1/relationships/author",
                "related": "http://example.com/articles/1/author"
            },
            "data": { "type": "people", "id": "9" }
        },
        "comments": {
            "links": {
                "self": "http://example.com/articles/1/relationships/comments",
                "related": "http://example.com/articles/1/comments"
            },
            "data": [
                { "type": "comments", "id": "5" },
                { "type": "comments", "id": "12" }
            ]
        }
    }
}
```

**Ошибка** - это объект со структурой:
- `id` - строковой уникальный идентификатор ошибки для этого запроса;
- `code` - строковой код ошибки;
- `title` - строковой краткий человеко читаемый заголовок ошибки;
- `source` - объект со структурой:
    - `pointer` - строковой JSON-путь (`<ключ_1>/<ключ_2>/...`) к ошибке в структуре JSON;
    - `parameter` - строка обозначающая нахождение ошибки;
- `detail` - строковое человеко читаемое описание ошибки.

#### <a id="Дополнительные-параметры-запроса" href="#Дополнительные-параметры-запроса">Дополнительные параметры запроса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`include=<имя_связи_ресурса_1>[.<имя_связи_ресурса_связанного_с_ресурсом_1>[....]][,...]` - указывает, что вместе с ресурсом загрузить еще его связи: `<имя_связи_ресурса_1>` [и ресурс `<имя_связи_ресурса_связанного_с_ресурсом_1>`] и поместить в поле `included` в ответе:
> `/articles/1?include=comments.author,ratings`

`fields[<тип_ресурса>]=<только_поле_1>[,...]` - указывает какие поля ресурса нужно загрузить - это поля `attributes` и `relationships`, может в запросе повторяться для разных типов ресурса:
> `/articles?include=author&fields[articles]=title,body&fields[people]=name`

`sort=[-]<только_поле_1>[.<имя_поля_ресурса_связанного_с_полем_1>[....]][,...]` - указывает по каким полям производить сортировку `-` перед полем указывает на обратную сортировку по полю:
> `/articles?sort=-author.name,title`

`filter` - используется для фильтрации ответа. К примеру `filter[<поле>]` - фильтр по полю:
> `filter[author.status]=active`

Для фильтрации используется `page`. К примеру `page[offset]` - отступ и `page[limit]` - количество:
> `page[offset]=0&page[limit]=10`

#### <a id="Получение-ресурса" href="#Получение-ресурса">Получение ресурса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Медиа тип для запросов и ответов: `application/vnd.api+json`.

Для получения списка (или одного ресурса) отправляется `GET` запрос на `/<тип_ресурса>`.

Для получения одного ресурса отправляется `GET` запрос на `/<тип_ресурса>/<идентификатор>`.

Для получения связи одного ресурса отправляется `GET` запрос на:
- `/<тип_ресурса>/<идентификатор>/relationships/<имя_связи>` при этом вернется массив идентификаторов ресурсов или идентификатор ресурса;
- `/<тип_ресурса>/<идентификатор>/<имя_связи>` при этом вернется массив ресурсов или ресурс.

В ответе сервера:
- при успешном получении ресурса содержится:
    - код 200 и JSON-объект с массивом ресурсов или связей;
    - код 200 и JSON-объект с ресурсом или связью;
    - код 200 и `data` = `null`, если ресурса или связи нет.
- при неуспешном поиске:
    - код 404 (для связей если родительского ресурса не существует) и ошибки.

#### <a id="Создание-ресурсов" href="#Создание-ресурсов">Создание ресурсов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для создания отправляется `POST` запрос на `/<тип_ресурса>` с JSON-объектом:
- `data` - объект с данными ресурса, при этом связи ресурса со внешними ресурсами должны передаваться в поле `relationships`;

В ответе сервера:
- при успешном создании ресурса содержится:
    - код 201, 202, 204 и JSON-объект с новым ресурсом при коде 201 и заголовком `Location` со ссылкой на новый ресурс.
- при неуспешном:
    - код 403, если запрос неподдерживаемый для добавления;
    - код 404, если не существует ресурса на который указана одны из связей;
    - код 409, если возник конфлик при создании.

```http
POST /photos HTTP/1.1
{
    "data": {
        "type": "photos",
        "attributes": {
            "title": "Ember Hamster",
            "src": "http://example.com/images/productivity.png"
        },
        "relationships": {
            "photographer": {
                "data": { "type": "people", "id": "9" }
            }
        }
    }
}
```

#### <a id="Обновление-ресурсов" href="#Обновление-ресурсов">Обновление ресурсов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для обновления отправляется `PATCH` запрос на `/<тип_ресурса>/<идентификатор>` с JSON-объектом:
- `data` - объект с данными для обновления в котором содержатся новые аттрибуты и связви, при этом должны быть указаны `type` и `id`, при этом связи ресурса со внешними ресурсами должны передаваться в поле `relationships` и все что содержится в полях заменяет связи на новые;

В ответе сервера:
- при успешном обновлении ресурса содержится:
    - код 200, 202, 204 и JSON-объект с обновленным ресурсом при коде 200.
- при неуспешном:
    - код 403, если запрос неподдерживаемый для обновления;
    - код 404, если обновляемого ресурса нет;
    - код 409, если возник конфлик при обновлении.

```http
PATCH /articles/1 HTTP/1.1
{
    "data": {
        "type": "articles",
        "id": "1",
        "attributes": {
            "title": "To TDD or Not",
            "text": "TLDR; It's complicated... but check your test coverage regardless."
        },
        "relationships": {
            "author": {
                "data": { "type": "people", "id": "1" }
            }
        }
    }
}
```

#### <a id="Удаление-ресурсов" href="#Удаление-ресурсов">Удаление ресурсов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для обновления отправляется `DELETE` запрос на `/<тип_ресурса>/<идентификатор>`.

В ответе сервера:
- при успешном удалении ресурса содержится:
    - код 200, 202, 204 и JSON-объект с `data` = `null` при коде 200.
- при неуспешном удалении ресурса содержится:
    - код 404, если удаляемого ресурса нет.

#### <a id="Изменение-связей-один-к-одному" href="#Изменение-связей-один-к-одному">Изменение связей один к одному</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Связи можно обновлять полностью или удалить используя метод `PATCH` на `<тип_ресурса>/<идентификатор_ресурса>/relationships/<имя_связи>` с JSON-объектом:
- `data` - объект с идентификатором ресурса для обновления связи или `null` для ее удаления;

```http
PATCH /articles/1/relationships/author HTTP/1.1
{
    "data": { "type": "people", "id": "12" }
}
```

#### <a id="Изменение-множественных-связей" href="#Изменение-множественных-связей">Изменение множественных связей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Связи можно обновлять полностью используя метод `PATCH` на `<тип_ресурса>/<идентификатор_ресурса>/relationships/<имя_связи>` с JSON-объектом:
- `data` - объект с идентификаторами ресурсов для обновления связей и все что содержится в полях заменяет связи на новые;

```http
PATCH /articles/1/relationships/author HTTP/1.1
{
    "data": [
        { "type": "tags", "id": "2" },
        { "type": "tags", "id": "3" }
    ]
}
```

Для добавления связи используется метод `POST` на `<тип_ресурса>/<идентификатор_ресурса>/relationships/<имя_связи>` с JSON-объектом:
- `data` - объект с идентификаторами ресурсов для добавления связей, при этом добавится только те, которых еще нет;

```http
POST /articles/1/relationships/comments HTTP/1.1
{
    "data": [
        { "type": "comments", "id": "123" }
    ]
}
```

Для удаления связи используется метод `DELETE` на `<тип_ресурса>/<идентификатор_ресурса>/relationships/<имя_связи>` с JSON-объектом:
- `data` - объект с идентификаторами ресурсов для удаления связей;

```http
POST /articles/1/relationships/comments HTTP/1.1
{
    "data": [
        { "type": "comments", "id": "12" },
        { "type": "comments", "id": "13" }
    ]
}
```

В ответе сервера:
- при успешном обновлении ресурса содержится:
    - код 200, 202, 204 и JSON-объект с обновленным списком связей при коде 200.
- при неуспешном:
    - код 403, если запрос неподдерживаемый для обновления.

#### <a id="Множественные-операции" href="#Множественные-операции">Множественные операции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Осуществляются путем методом `PATCH` на `bulk` / `operations` с JSON-объектом:
- `operations` - массив состоящий из объекта операций:
    - `op` - вид операции, может быть:
        - `"get"` - для получения списка ресурсов, ресурса и связей ресурса;
        - `"add"` - для добавления ресурса или добавления связей ресурса;
        - `"update"` - для обновления ресурса, обновления связей ресурса, обновления связи ресурса;
        - `"remove"` - для удаления ресурса или удаления связей ресурса;
    - `data` - данные для операции;
    - `ref` - объект с путем к ресурсу:
        - `type`;
        - `id`;
        - `lid`;
        - `relationship`;
    - `params` - объект с параметрами запроса:
        - `include`;
        - `sort`;
        - `filter`;
        - `page`;
        - `fields`.

На сервере операции выполняются последовательно. Если одна из операций завершается с ошибкой, то все предыдущие операции должны отмениться и вернуться объект с ошибкой.

```
PATCH /bulk HTTP/1.1
{
    "operations": [{
        "op": "add",
        "ref": {
            "type": "authors"
        },
        "data": {
            "type": "authors",
            "lid": "a",
            "attributes": {
                "name": "dgeb"
            }
        }
    }, {
        "op": "add",
        "ref": {
            "type": "articles"
        },
        "data": {
            "type": "articles",
            "attributes": {
                "title": "JSON API paints my bikeshed!"
            },
            "relationships": {
                "author": {
                    "data": {
                        "type": "authors",
                        "lid": "a"
                    }
                }
            }
        }
    }]
}
```

В ответе сервера:
- при успешном обновлении ресурса содержится:
    - код 200 и JSON-объект со свойством `operations` в котором содержится массив ответов по операциям.
- при неуспешном:
    - код 403, если запрос неподдерживаемый для обновления.

```
HTTP/1.1 200 OK
Content-Type: application/vnd.api+json
{
    "operations": [{
        "links": {
            "self": "http://example.com/authors/9"
        },
        "data": {
            "type": "authors",
            "lid": "a",
            "id": "9",
            "attributes": {
                "name": "dgeb"
            }
        }
    }, {
        "links": {
            "self": "http://example.com/articles/13"
        },
        "data": {
            "type": "articles",
            "id": "13",
            "attributes": {
                "title": "JSON API paints my bikeshed!"
            },
            "relationships": {
                "author": {
                    "links": {
                        "self": "http://example.com/articles/13/relationships/author",
                        "related": "http://example.com/articles/13/author"
                    }
                }
            }
        }
    }]
    }
```