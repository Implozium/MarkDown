[Содержание](#Содержание)
==========

- [Основы скриптов bash](#Основы-скриптов-bash)
    - [Основные понятия](#Основные-понятия)
    - [Специальные символы](#Специальные-символы)
    - [Сочетания клавиш для командной строки](#Сочетания-клавиш-для-командной-строки)
        - [Запуск](#Запуск)
        - [Строение файла скрипта](#Строение-файла-скрипта)
            - [Вывод `echo`](#Вывод-echo)
                - [Изменение цвета текста и фона в расширенном режиме `-e`](#Изменение-цвета-текста-и-фона-в-расширенном-режиме--e)
    - [Переменные](#Переменные)
    - [Конструкция if-then-else](#Конструкция-if-then-else)
        - [Сравнения и проверки](#Сравнения-и-проверки)
            - [Сравнение чисел](#Сравнение-чисел)
            - [Сравнение строк](#Сравнение-строк)
            - [Проверки файлов](#Проверки-файлов)
    - [Циклы](#Циклы)
        - [Цикл `for`](#Цикл-for)
        - [Установка разделителей полей](#Установка-разделителей-полей)
        - [Обход директорий](#Обход-директорий)
        - [Цикл `for` в стиле C](#Цикл-for-в-стиле-C)
        - [Цикл `while`](#Цикл-while)
        - [Команда `break`](#Команда-break)
        - [Команда `continue`](#Команда-continue)
        - [Перенаправление вывода цикла](#Перенаправление-вывода-цикла)
    - [Параметры командной строки](#Параметры-командной-строки)
        - [Команда `shift`](#Команда-shift)
    - [Конструкция case](#Конструкция-case)
    - [Стандартные ключи Linux](#Стандартные-ключи-Linux)
    - [Ввод значений от пользователя](#Ввод-значений-от-пользователя)
    - [Дескрипторы файлов](#Дескрипторы-файлов)
        - [Перенаправление потоков ошибок и вывода](#Перенаправление-потоков-ошибок-и-вывода)
        - [Временное перенаправление вывода](#Временное-перенаправление-вывода)
        - [Постоянное перенаправление вывода](#Постоянное-перенаправление-вывода)
        - [Перенаправление ввода в скриптах](#Перенаправление-ввода-в-скриптах)
        - [Создание собственного перенаправления вывода](#Создание-собственного-перенаправления-вывода)
        - [Получение сведений об открытых дескрипторах](#Получение-сведений-об-открытых-дескрипторах)
        - [Подавление вывода](#Подавление-вывода)
    - [Конвеер Pipe `|`](#Конвеер-Pipe-)
    - [Сигналы Linux](#Сигналы-Linux)
        - [Основные сигналы](#Основные-сигналы)
        - [Временная остановка процесса](#Временная-остановка-процесса)
        - [Перехват сигналов](#Перехват-сигналов)
    - [Выполнение сценариев командной строки в фоновом режиме](#Выполнение-сценариев-командной-строки-в-фоновом-режиме)
    - [Планирование запуска скриптов](#Планирование-запуска-скриптов)
    - [Запуск скриптов по расписанию](#Запуск-скриптов-по-расписанию)
    - [Функции](#Функции)
        - [Переменные](#Переменные)
        - [Массив](#Массив)
        - [Манипуляции со строками](#Манипуляции-со-строками)
    - [Создание и использование библиотек](#Создание-и-использование-библиотек)
- [`sed`](#sed)
    - [Опции](#Опции)
        - [Дополнительные ключи](#Дополнительные-ключи)
        - [Флаги](#Флаги)
        - [Символы-разделители](#Символы-разделители)
        - [Выбор фрагментов текста для обработки](#Выбор-фрагментов-текста-для-обработки)
        - [Удаление строк](#Удаление-строк)
        - [Вставка текста в поток](#Вставка-текста-в-поток)
        - [Замена строк](#Замена-строк)
        - [Замена символов](#Замена-символов)
        - [Вывод номеров строк](#Вывод-номеров-строк)
        - [Чтение данных для вставки из файла](#Чтение-данных-для-вставки-из-файла)
        - [Регулярные выражения](#Регулярные-выражения)
- [`awk`](#awk)
    - [Опции](#Опции)
    - [Программа](#Программа)
        - [Позиционные переменные, хранящие данные полей](#Позиционные-переменные-хранящие-данные-полей)
        - [Файл скрипта](#Файл-скрипта)
        - [Выполнение команд до начала обработки данных](#Выполнение-команд-до-начала-обработки-данных)
        - [Выполнение команд после окончания обработки данных](#Выполнение-команд-после-окончания-обработки-данных)
        - [Встроенные переменные](#Встроенные-переменные)
        - [Условный оператор](#Условный-оператор)
        - [Цикл while](#Цикл-while)
        - [Цикл for](#Цикл-for)
    - [Форматированный вывод данных](#Форматированный-вывод-данных)
        - [Символы](#Символы)
        - [Модификаторы](#Модификаторы)
    - [Встроенные математические функции](#Встроенные-математические-функции)
    - [Строковые функции](#Строковые-функции)
    - [Пользовательские функции](#Пользовательские-функции)
- [Регулярные выражения](#Регулярные-выражения)
    - [Специальные классы символов](#Специальные-классы-символов)
- [Структура Linux](#Структура-Linux)
    - [Устройства](#Устройства)
- [Архивирование](#Архивирование)
    - [`tar`](#tar)
        - [Запаковывание](#Запаковывание)
        - [Распаковывание](#Распаковывание)
    - [`gzip`](#gzip)
    - [`bzip2`](#bzip2)
    - [`zip`](#zip)
- [`wget`](#wget)
- [`grep`](#grep)
- [Процессы](#Процессы)
    - [`ps`](#ps)
    - [Выводимая информация](#Выводимая-информация)
    - [`kill`](#kill)
    - [`pkill`](#pkill)
    - [`killall`](#killall)
- [`ssh`](#ssh)
- [`screen`](#screen)
- [wildcards - шаблоны замены](#wildcards---шаблоны-замены)
- [`find`](#find)
- [Пользователи и группы](#Пользователи-и-группы)
- [Права и владение файлами](#Права-и-владение-файлами)
    - [Права](#Права)
    - [Владение](#Владение)
- [Сеть](#Сеть)
    - [Установка DNS](#Установка-DNS)
- [Сервисы](#Сервисы)
- [Другие команды](#Другие-команды)

<a id="Основы-скриптов-bash" href="#Основы-скриптов-bash">Основы скриптов bash</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====================

## <a id="Основные-понятия" href="#Основные-понятия">Основные понятия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Сценарии командной строки** - это наборы команд, которые можно вводить с клавиатуры, собранные в файлы и объединенные некоей общей целью. При этом результаты работы команд могут представлять либо самостоятельную ценность, либо служить входными данными для других команд.

## <a id="Специальные-символы" href="#Специальные-символы">Специальные символы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Символ   | Название             | Применение
 ------- | -------------------- | ---------
 `*`     | Звездочка            | Регулярные выражения, джокерные символы
 `.`     | Точка                | Текущий каталог, разделитель имени файла и хоста
 `!`     | Восклицательный знак | Отрицание, история команд
 `|`     | Вертикальная черта   | Командный конвейер
 `/`     | Прямой слеш          | Разделитель каталогов, команда поиска
 `\`     | Обратный слеш        | Литералы, макросы (но не каталоги)
 `$`     | Доллар               | Обозначение переменной, конец строки
 `'`     | Одиночная кавычка    | Буквенные строки
 `` ` `` | "Обратная галочка"   | Замена команды
 `"`     | Двойная кавычка      | Частично буквенные строки
 `^`     | Знак вставки         | Отрицание, начало строки
 `~`     | Тильда               | Отрицание, ярлык каталога
 `#`     | Диез, знак фунта     | Комментарии, препроцессор, подстановки
 `[ ]`   | Квадратные скобки    | Массивы
 `{ }`   | Фигурные скобки      | Блоки инструкций, массивы
 `_`     | Подчеркивание        | Просто замена символа пробела

`^<клавиша>` = `Ctrl + <клавиша>`

## <a id="Сочетания-клавиш-для-командной-строки" href="#Сочетания-клавиш-для-командной-строки">Сочетания клавиш для командной строки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сочетание клавиш | Действие
 --------------- | --------
 `Ctrl + B`      | Перемещение курсора влево
 `Ctrl + F`      | Перемещение курсора вправо
 `Ctrl + P`      | Просмотр предыдущей команды (или перемещение курсора вверх)
 `Ctrl + N`      | Просмотр следующей команды (или перемещение курсора вниз)
 `Ctrl + A`      | Перемещение курсора в начало строки
 `Ctrl + E`      | Перемещение курсора в конец строки
 `Ctrl + W`      | Удаление предыдущего слова
 `Ctrl + U`      | Удаление текста от курсора до начала строки
 `Ctrl + K`      | Удаление текста от курсора до конца строки
 `Ctrl + Y`      | Вставка удаленного текста (например, после команды `CTRL+U`)



### <a id="Запуск" href="#Запуск">Запуск</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для того чтобы сценарий запускался ему необходимо установить разрешение, сделать его выполняемым:  
`chmod +x ./<имя_файла>`  
`./<имя_файла>` - запускает скрипт

### <a id="Строение-файла-скрипта" href="#Строение-файла-скрипта">Строение файла скрипта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Первая строка должна быть такого вида:  
`#!/bin/bash`

Команды оболочки отделяются знаком перевода строки или знаком точки с запятой `;`, комментарии выделяют знаком решетки `#`.

`<команда1> && <команда2>` - выполняет команду `<команда2>` только если команда `<команда1>` выполнилась успешно.  
`!!` - алиас предыдущей команды.

#### <a id="Вывод-echo" href="#Вывод-echo">Вывод `echo`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`echo [-n] [-e] "<текст>"` - выводит текст в консоль, для вывода знака `$` нужно писать `\$` [, `-n` - без перехода на новую строку] [, `-e` - расширенный режим].

> `echo "Home for the current user is: $HOME"`

##### <a id="Изменение-цвета-текста-и-фона-в-расширенном-режиме--e" href="#Изменение-цвета-текста-и-фона-в-расширенном-режиме--e">Изменение цвета текста и фона в расширенном режиме `-e`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`\033[<атрибут_1>[;<атрибут_2>[;...]]m` - выводит последующие символы, с указанными характеристиками.  
`\u001b[<атрибут_1>[;<атрибут_2>[;...]]m` - аналогично.

Значения общих атрибутов:
- `0` - сбросить все атрибуты;
- `1` - bright (повышенная яркость);
- `2` - dim (затемнение);
- `4` - underscore (нижнее подчеркивание);
- `5` - blink (мигание);
- `7` - reverse (инверсия);
- `8` - hidden (скрыть текст).

Значения атрибутов цвета шрифта:
- `30` - black (черный);
- `31` - red (красный);
- `32` - green (зеленый);
- `33` - yellow (желтый);
- `34` - blue (синий);
- `35` - magenta (пурпурный);
- `36` - cyan (голубой);
- `37` - white (белый).

Значения атрибутов цвета фона:
- `40` - black (черный);
- `41` - red (красный);
- `42` - green (зеленый);
- `43` - yellow (желтый);
- `44` - blue (синий);
- `45` - magenta (пурпурный);
- `46` - cyan (голубой);
- `47` - white (белый).

## <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<имя_переменной>=<значение>` - установка значения переменной.
> `person="Adam"`

`$<имя_переменной>` - возвращает значение переменной, это можно использовать также в строке.  
`${<имя_переменной>}` - аналогично.

``<имя_переменной>=`<команда>` `` - записывает результат вывода команды в переменную.  
`<имя_переменной>=$(<команда>)` - аналогично.
```
mydir=`pwd`
mydir2=$(pwd)
```

`<имя_переменной>=$((<математические_операции>))` - выполняет математические операции и записывает результат в переменную.
`<имя_переменной>=$[<математические_операции>]` - аналогично.
> `var2=$(( $var1 * 2 ))`

`export <имя_переменной>` - экспортирует переменную как переменную окружения с указанным значением.
> `export STUFF`

## <a id="Конструкция-if-then-else" href="#Конструкция-if-then-else">Конструкция if-then-else</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
if <команда>
then
    <комманды>
[elif <команда>
then
    <комманды>]
[else
    <комманды>]
fi
```

> `if ps aux | grep some_proces[s] > /tmp/test.txt; then echo 1; else echo 0; fi`

Если выполнение команды `<команда>` завершится успешно, а именно будет возвращено нуль, то выполнятся комманды от `then` и до `elif / else / fi` [, иначе выполнятся комманды от `else` и до `fi`]

### <a id="Сравнения-и-проверки" href="#Сравнения-и-проверки">Сравнения и проверки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`[` - является синонимом команды `test`, и является встроенной командой, `[<выражение>]`. Условие, находящееся внутри квадратных скобок может быть проверено без использования оператора `if`.  
`if [ <выражение> ]`

`[[<выражение>]]` - расширенный вариант команды `test`, которая выполняет сравнение более стандартным способом, пишущим на других языках программирования.

Круглые скобки `((<выражение>))` и предложение `let <выражение>` возвращают код 0, если результатом арифметического выражения является ненулевое значение.

Выражение должно быть заключено в квадратные скобки `[<выражение>]` и использоваться вместо команды `<команда>`.
Операторы `&&`, `||`, `<` и `>` внутри `[[ ]]` вполне допустимы, в то время как внутри `[ ]` порождают сообщения об ошибках.

#### <a id="Сравнение-чисел" href="#Сравнение-чисел">Сравнение чисел</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `<число1> -eq <число2>` - возвращает истинное значение, если `<число1>` равно `<число2>`;
- `<число1> -ge <число2>` - возвращает истинное значение, если `<число1>` больше или равно `<число2>`;
- `<число1> -gt <число2>` - возвращает истинное значение, если `<число1>` больше `<число2>`;
- `<число1> -le <число2>` - возвращает истинное значение, если `<число1>` меньше или равно `<число2>`;
- `<число1> -lt <число2>` - возвращает истинное значение, если `<число1>` меньше `<число2>`;
- `<число1> -ne <число2>` - возвращает истинное значение, если `<число1>` не равно `<число2>`.
> `[ $val1 -gt 5 ]`

Вместо чисел можно использовать переменные.

#### <a id="Сравнение-строк" href="#Сравнение-строк">Сравнение строк</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `"<строка1>" = "<строка2>"` - проверяет строки на равенство, возвращает истину, если строки идентичны;
- `"<строка1>" != "<строка2>"` - возвращает истину, если строки не идентичны. ;
- `"<строка1>" \< "<строка2>"` - возвращает истину, если `<строка1>` меньше, чем `<строка2>`;
- `"<строка1>" \> "<строка2>"` - возвращает истину, если `<строка1>` больше, чем `<строка2>`;
- `-n "<строка>"` - возвращает истину, если длина `<строка>` больше нуля;
- `-z "<строка>"` - возвращает истину, если длина `<строка>` равна нулю.
> `[ $val = "user" ]`

Вместо строк можно использовать переменные, но их нужно заключать в кавычки `"`.
> `[ $val1 \> "$val2" ]`

#### <a id="Проверки-файлов" href="#Проверки-файлов">Проверки файлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `-d <файл>` - проверяет, существует ли файл, и является ли он директорией;
- `-e <файл>` - проверяет, существует ли файл;
- `-f <файл>` - проверяет, существует ли файл, и является ли он файлом;
- `-r <файл>` - проверяет, существует ли файл, и доступен ли он для чтения;
- `-s <файл>` - проверяет, существует ли файл, и не является ли он пустым;
- `-w <файл>` - проверяет, существует ли файл, и доступен ли он для записи;
- `-x <файл>` - проверяет, существует ли файл, и является ли он исполняемым;
- `<файл1> -nt <файл2>` - проверяет, новее ли `<файл1>`, чем `<файл2>`;
- `<файл1> -ot <файл2>` - проверяет, старше ли `<файл1>`, чем `<файл2>`;
- `-O <файл>` - проверяет, существует ли файл, и является ли его владельцем текущий пользователь;
- `-G <файл>` - проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя;
- `<файл>` - должен выглядеть как путь к файлу, если в нем есть пробелы, то он должен быть заключен в кавычки.
> `[ -d /home/likegeeks ]`

Вместо файл можно использовать переменные.
> `[ -d $mydir ]`

## <a id="Циклы" href="#Циклы">Циклы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Циклы можно вкладывать друг в друга.

### <a id="Цикл-for" href="#Цикл-for">Цикл `for`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
for <имя_переменной> in <список>
do
    <комманды>
done
```

В каждой итерации цикла в переменную `<имя_переменной>` будет записываться следующее значение из списка `<список>`.

Список может быть набором значений разделенных разделителем полей (**пробел**, **знак табуляции**, **знак перевода строки**) или результатом вывода команды.

> ```bash
> for var in first "the second" "the third" fourth fifth
> do
>     echo The $var item
> done
> ```

> `file="myfile"; for var in $(cat $file); do echo " $var"; done`

### <a id="Установка-разделителей-полей" href="#Установка-разделителей-полей">Установка разделителей полей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого нужно изменить переменную среды `IFS`:  
`IFS=$'\n'` - устанавливает в качестве разделителя - символ новой строки.  
`IFS=<символ>` - установка произвольного символа.  
`IFS="<символ>[...]"` - установка произвольных символов

### <a id="Обход-директорий" href="#Обход-директорий">Обход директорий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В качестве списка может быть указано путь к директории, подстановочный знак `*` - обозначает все.

> `for file in /home/likegeeks/*`

### <a id="Цикл-for-в-стиле-C" href="#Цикл-for-в-стиле-C">Цикл `for` в стиле C</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
for ((<начальное_значение_переменной>; <условие_окончания_цикла>; <изменение переменной>))
do
    <комманды>
done
```

> ```bash
> for (( i = 1; i <= 10; i++ ))
> do
>     echo "number is $i"
> done
> ```

### <a id="Цикл-while" href="#Цикл-while">Цикл `while`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
while <команда>
do
    <комманды>
done
```

Будет выполнять тело цикла до тех пор, пока проверяемое условие возвращает ноль, или сигнал успешного завершения некоей операции.

Вместо команды `<команда>`, можно использовать выражение.

### <a id="Команда-break" href="#Команда-break">Команда `break`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Эта команда позволяет прервать выполнение цикла.

### <a id="Команда-continue" href="#Команда-continue">Команда `continue`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Эта команда завершает текущую итерацию досрочно и начинает следующую, при этом выхода из цикла не происходит.

### <a id="Перенаправление-вывода-цикла" href="#Перенаправление-вывода-цикла">Перенаправление вывода цикла</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

После слова `done`, на той же сточке можно указать перенаправление в файл: `done > <файл>`.
> `done > myfile.txt`

## <a id="Параметры-командной-строки" href="#Параметры-командной-строки">Параметры командной строки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Параметры командной строки разделяются из переменной `IFS`.

**Специальные переменные** - позиционные параметры, введенные при вызове скрипта параметры командной строки, можно получить:
- `$0` - имя скрипта;
- `$1` - первый параметр;
- `$<n>` - n-ый параметр, вплоть до переменной $9;
- `${<n>}` - n-ый параметр, от 10;
- `$#` - содержит количество параметров, переданных сценарию при вызове;
- `${!#}` - содержит последний параметр;
- `$*` - содержит все параметры командной строки, в виде единого "*слова*";
- `$@` - содержит все параметры командной строки, где параметры разбиты на отдельные "*слова*". Эти параметры можно перебирать в циклах.

### <a id="Команда-shift" href="#Команда-shift">Команда `shift`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Она, по умолчанию, сдвигает значения позиционных параметров влево: `$<n>` становится `$<n-1>`, при этом `$0`, не меняется.

## <a id="Конструкция-case" href="#Конструкция-case">Конструкция case</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
case "<ключ>" in
<значение_1>) <комманды> ;;
...
*) <комманды_при_не_совпадении> ;;
esac
```

> ```bash
> echo
> while [ -n "$1" ]
> do
>     case "$1" in
>     -a) echo "Found the -a option" ;;
>     -b) echo "Found the -b option" ;;
>     -c) echo "Found the -c option" ;;
>     *) echo "$1 is not an option" ;;
>     esac
>     shift
> done
> ```

Сверяет `<ключ>` со значениями и выполняет указанные команды при соответствии значения с ключом. Если соответствия не найдется, будет исполнена ветвь `*`.

Последовательность - двойное тире `--` - признак окончания ключей.

## <a id="Стандартные-ключи-Linux" href="#Стандартные-ключи-Linux">Стандартные ключи Linux</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `-a` - вывести все объекты;
- `-c` - произвести подсчет;
- `-d` - указать директорию;
- `-e` - развернуть объект;
- `-f` - указать файл, из которого нужно прочитать данные;
- `-h` - вывести справку по команде;
- `-i` - игнорировать регистр символов;
- `-l` - выполнить полноформатный вывод данных;
- `-n` - использовать неинтерактивный (пакетный) режим;
- `-o` - позволяет указать файл, в который нужно перенаправить вывод;
- `-q` - выполнить скрипт в quiet-режиме;
- `-r` - обрабатывать папки и файлы рекурсивно;
- `-s` - выполнить скрипт в silent-режиме;
- `-v` - выполнить многословный вывод;
- `-x` - исключить объект;
- `-y` - ответить `yes` на все вопросы.

## <a id="Ввод-значений-от-пользователя" href="#Ввод-значений-от-пользователя">Ввод значений от пользователя</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`read [-p "<текст>"] [-t <время_ожидания>] [-s] <имя_переменной> [...]` - позволяет принимать введенные данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов, после получения данных, эта команда помещает их в указанную переменную, [`-s` - не отображать вывод].
> `read -p "Enter your name: " first last`

Если, не указывать переменную, данные, введенные пользователем, будут помещены в специальную переменную среды `REPLY`.

`read` может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится.

`read line` - такая команда может быть использована в цикле `while` в качестве команды условия, для построчного чтения файла и записи строки в переменную `line`.

> ```bash
> cat myfile | while read line
> do
>     echo "Line: $line"
> done
> ```

## <a id="Дескрипторы-файлов" href="#Дескрипторы-файлов">Дескрипторы файлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Все в Linux - это файлы, в том числе - ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2. Вот что они означают:
- `0`, `STDIN` - стандартный поток ввода. Для терминала стандартный ввод - это клавиатура. Когда в сценариях используют символ перенаправления ввода - `<`, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры;
- `1`, `STDOUT` - стандартный поток вывода. По умолчанию это - экран. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда `>>`, или перезаписать его содержимое новым, для этого служит команда `>`;
- `2`, `STDERR` - стандартный поток ошибок. По умолчанию этот дескриптор указывает на то же самое, на что указывает `STDOUT`.

### <a id="Перенаправление-потоков-ошибок-и-вывода" href="#Перенаправление-потоков-ошибок-и-вывода">Перенаправление потоков ошибок и вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<команда> [1> <дескриптор>] [2> <дескриптор>]` - перенаправляет потоки вывод и ошибки. Для того чтобы перенаправить `STDERR`, и `STDOUT` в один и тот же файл, воспользовавшись командой `&>`. Где `<дескриптор>` - может быть путь к файлу или дескриптором `&<номер>`.

### <a id="Временное-перенаправление-вывода" href="#Временное-перенаправление-вывода">Временное перенаправление вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<команда> >&1` - перенаправление вывода команды в поток вывода.  
`<команда> >&2` - перенаправление вывода команды в поток ошибки.

### <a id="Постоянное-перенаправление-вывода" href="#Постоянное-перенаправление-вывода">Постоянное перенаправление вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`exec 1> <дескриптор>` - перенаправляет весь вывод в определенный дескриптор на время выполнения скрипта.  
`exec 2> <дескриптор>` - перенаправляет все ошибки в определенный дескриптор на время выполнения скрипта.

### <a id="Перенаправление-ввода-в-скриптах" href="#Перенаправление-ввода-в-скриптах">Перенаправление ввода в скриптах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`exec 0< <дескриптор>` - перенаправляет весь ввод из определенного дескриптора на время выполнения скрипта.

### <a id="Создание-собственного-перенаправления-вывода" href="#Создание-собственного-перенаправления-вывода">Создание собственного перенаправления вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Шесть дескрипторов с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.

`exec <дескриптор_номер>><дескриптор_источник>`  
`exec <дескриптор_номер><<дескриптор_источник>`

Где `<дескриптор_источник>` - может быть путь к файлу или дескриптором `&<номер>`.

`exec <дескриптор_номер>>&-` - закрывает дескриптор, его потом можно открыть по новой.

### <a id="Получение-сведений-об-открытых-дескрипторах" href="#Получение-сведений-об-открытых-дескрипторах">Получение сведений об открытых дескрипторах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$$` - содержит текущий PID.
`lsof -a -p <PID> -d <дескриптор_номер>[, ...]` - выводит сведения о каждом дескрипторе, открытом в системе. Ключ `-a` используется для выполнения операции логического И над результатами, возвращенными благодаря использованию двух других ключей.

### <a id="Подавление-вывода" href="#Подавление-вывода">Подавление вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого можно перенаправить вывод в `/dev/null`.

`<дескриптор_номер>> /dev/null` - перенаправляет весь вывод в файл.

`cat /dev/null > <файл>` - очищает файл, не удаляя его.  
`: > <файл>` - аналогичное действие.

## <a id="Конвеер-Pipe-" href="#Конвеер-Pipe-">Конвеер Pipe `|`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Pipe** (конвеер) - это однонаправленный канал межпроцессного взаимодействия, используя символ конвеера `|`. Конвеер обеспечивает асинхронное выполнение команд с использованием буферизации ввода/вывода. Таким образом все команды в конвейере работают параллельно, каждая в своем процессе.

Размер буфера начиная с ядра версии 2.6.11 составляет 65536 байт (64Кб) и равен странице памяти в более старых ядрах. При попытке чтения из пустого буфера процесс чтения блокируется до появления данных. Аналогично при попытке записи в заполненный буфер процесс записи будет заблокирован до освобождения необходимого места.

Важно, что несмотря на то, что конвейер оперирует файловыми дескрипторами потоков ввода/вывода, все операции выполняются в памяти, без нагрузки на диск.

`<команда> | <команда> | ...`

> `cat *.txt | sort | uniq > result-file.txt`

## <a id="Сигналы-Linux" href="#Сигналы-Linux">Сигналы Linux</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Основные-сигналы" href="#Основные-сигналы">Основные сигналы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `1` - `SIGHUP` - закрытие терминала;
- `2` - `SIGINT` - сигнал остановки процесса пользователем с терминала (`CTRL + C`);
- `3` - `SIGQUIT` - сигнал остановки процесса пользователем с терминала (`CTRL + \`) с дампом памяти;
- `9` - `SIGKILL` - безусловное завершение процесса;
- `15` - `SIGTERM` - сигнал запроса завершения процесса;
- `17` - `SIGSTOP` - принудительная приостановка выполнения процесса, но не завершение его работы;
- `18` - `SIGTSTP` - приостановка процесса с терминала (`CTRL + Z`), но не завершение работы;
- `19` - `SIGCONT` - продолжение выполнения ранее остановленного процесса.
- с помощью сочетания клавиш `CTRL + D` в пустой строке останавливает текущий стандартный поток ввода из терминала.

### <a id="Временная-остановка-процесса" href="#Временная-остановка-процесса">Временная остановка процесса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сигнал `SIGTSTP` - приостанавливает работу процесса, но не завершает его выполнение. Такой процесс остается в памяти. Оболочка возвращает число в квадратных скобках - это номер задания, который оболочка назначает процессу. Оболочка рассматривает процессы, выполняющиеся в ней, как задания с уникальными номерами. Первому процессу назначается номер 1, второму - 2, и так далее.

`ps -l` - выводит приостановленные задания.  
`jobs` - выводит текущие задания и приостановленные задания.  
`jobs -l` - выводит приостановленные задания с их идентификаторами.  
`disown <идентификатор>` - убирает приостановленное задание по идентификатору.  
`fg <номер>` - возобновляет приостановленное задание по номеру в списке.

### <a id="Перехват-сигналов" href="#Перехват-сигналов">Перехват сигналов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`trap "<команды>" <СИГНАЛ> [...]` - перехватывает указанные сигналы и вызывает указанные команды, для перехвата выхода из скрипта нужно указать имя сигнала `EXIT`.

Для модификации перехваченных скриптом сигналов можно выполнить команду `trap` с новыми параметрами.

`trap -- <СИГНАЛ> [...]` - отменяет перехват указанных сигналов.

## <a id="Выполнение-сценариев-командной-строки-в-фоновом-режиме" href="#Выполнение-сценариев-командной-строки-в-фоновом-режиме">Выполнение сценариев командной строки в фоновом режиме</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для это нужно запустить его, указав после имени символ амперсанда `&`. Скрипт будет запущен в фоновом процессе, в терминал выведется его идентификатор, а когда его выполнение завершится, выведется сообщение об этом. При этом скрипт продолжает использовать терминал для вывода сообщений в `STDOUT` и `STDERR`. Если выйти из терминала, скрипт, выполняющийся в фоне, так же завершит работу.

`nohup <скрипт> &` - позволяет запустить программу, блокируя сигналы `SIGHUP`, отправляемые процессу и отвязывает процесс от терминала, что значит что процесс потеряет ссылки на `STDOUT` и `STDERR` и `nohup` автоматически перенаправляет сообщения, поступающие в `STDOUT` и в `STDERR`, в файл `nohup.out` в текущем каталоге; если это невозможно сделать, то перенаправление происходит в файл `$HOME/nohup.out`. Если и это невозможно сделать, то команда не запускается совсем.

`jobs -l` - выводит текущие задания, которые выполняются в оболочке.

## <a id="Планирование-запуска-скриптов" href="#Планирование-запуска-скриптов">Планирование запуска скриптов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`at [-f <файл>] <время>` - запускает файл в указанное время, где время может быть в виде: `HH:MM`, `now`, `noon`, `midnight`, `MMDDYY`, `MM/DD/YY`, или `DD.MM.YY`.

Ключ `-M` при вызове `at` используется для отправки того, что выведет скрипт, по электронной почте, если система соответствующим образом настроена. Если отправка электронного письма невозможна, этот ключ просто подавит вывод.

`atq` - возвращает список заданий.  
`atrm <номер_задания>` - удаляет задание под указанным номером.

## <a id="Запуск-скриптов-по-расписанию" href="#Запуск-скриптов-по-расписанию">Запуск скриптов по расписанию</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`crontab -l` - выводит существующую таблицу заданий `cron` в консоль.

`crontab -e` - выводит существующую таблицу заданий `cron` в редакторе по умолчанию (`vi`) и позволяет редактировать его.

`<минута> <час> <день_месяца> <месяц> <день_недели> <скрипт>` - запускает указанный скрипт по расписанию в указаное время запуска, т.е. когда время будет равно заданой структуре. Единицы измерения:
- минуты (0-59);
- часы (0-23);
- дни месяца (1-31);
- месяцы (1-12) (jan feb mar apr may jun jul aug sep oct nov dec);
- дни недели (0-6 (0=воскресенье)) (sun mon tue wed thu fri sat).

Единицы измерения можно указывать в виде:
- `<число>` - числа;
- `<число_от>-<число_до>` - диапазон;
- `<число1>[,<число2>[,...]]` - перечисление;
- `*/<шаг>` - шаг (когда остаток от деления на `<шаг>` будет равен 0);
- `<число_от>-<число_до>/<шаг>` - шаг (когда остаток от деления минус `<число_от>` на `<шаг>` будет равен 0);
- `*` - любое значение.

Диапазоны и перечисления можно комбинировать.

Комментарий начинается с `#` и это задание не будет исполняться.

> `10 12 * * * script.sh` - скрипт выполнится в 12 часов 10 минут.  
> `0 22 * * 1-5 echo "Пора домой" | mail -s "Уже 22:00" john` - скрипт выполнится в 22 часа 00 минут по будням.  
> `1-59/2 * * * * echo "Выполняется по нечетным минутам"` - скрипт выполнится по нечетным минутам.

`crontab -r` - удаляет файл текущего расписания.

В `.bashrc` - содержатся скрипты, которые запускаются при открытии терминала.  
В `.bash_profile` - при входе в систему.

## <a id="Функции" href="#Функции">Функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объявление функции, имена для функций, должны быть уникальными, так как новая функция затирает старую.

```bash
function <имяФункции>[()] {
    <код>
    [return <значение>]
}
```
`return <значение>` - позволяет задавать возвращаемый функцией целочисленный код завершения.

Имя функции хранится внутри функции в параметре `$0`, первый переданный ей аргумент - в `$1`, второй - в `$2`, и так далее, а количество переданных аргументов в `$#`, `$@` - содержит все аргументы в виде массива.

`<имяФункции> [<аргумент> [...]]` - вызов функции

В переменной `$?` хранится код возврата последней выполненной команды в том числе и функции, тогда максимальное число, которое может вернуть команда `return` - `255`.

`<переменная>=$(<имяФункции> [<аргумент> [...]])` - записывает в переменную результат функции.

Внутри функции можно вызвать саму функцию по имени.

### <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Глобальные переменные** - это переменные, которые видны из любого места bash-скрипта. По умолчанию все объявленные в скриптах переменные глобальны.  
**Локальные переменные** - их объявляют и используют внутри функции. Если за пределами функции есть переменная с таким же именем, это на нее не повлияет.

`local <имя_переменной>=<значение>` - установка значения локальной переменной.

### <a id="Массив" href="#Массив">Массив</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<имя_переменной>= (<значение> [...])` - объявление массива (списка).  
`${<имя_переменной>[<индекс>]}` - возвращает указанный индекс элемента массива, `*` (`@`) - все.  
`${!<имя_переменной>[@]}` - возвращает индексы массива.  
`${#<имя_переменной>[@]}` - возвращает размер массива.  
`<имя_переменной>[<индекс>]=<значение>` - перезаписывает элемент массива.  
`<имя_переменной>+=(<значение>)` - присоединяет к массиву значения.  
`<имя_переменной>=$(<команда>)` - сохраняет вывод команды в виде строки в переменную.  
`<имя_переменной>=( $(<команда>) )` - сохраняет вывод команды в виде массива.  
`${<имя_переменной>[@]:s:n}` - возвращает элементы массива начиная с элемента с индексом `s` до элемента с индексом `s+(n-1)`.

> `str=$(ls)`  
> `arr=( $(ls) )`

Для передачи массива в функцию из него надо извлечь имеющиеся в нем данные и передать их функции как самостоятельные аргументы - `${<имя_переменной>[*]}`.

### <a id="Манипуляции-со-строками" href="#Манипуляции-со-строками">Манипуляции со строками</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`${#<имя_переменной>}` - возвращает длину строки.  
`` `expr length $<имя_переменной>` `` - возвращает длину строки.  
`` `expr [match] "$<имя_переменной>" : '<регулярное_выражение>'` `` - возвращает длину строки, которая удолетворяет регулярному выражению.
> ``stringZ=abcABC123ABCabc; echo `expr match "$stringZ" 'abc[A-Z]*.2'` ``

`${<имя_переменной>:<позиция>[:<длина>]}` - возвращает подстроку начиная с символа на позиции [указанной длины].  
`${<имя_переменной>:(-<длина>)}` - возвращает подстроку начиная с конца указанной длины.
> `${stringZ:(-4)}`

`` `expr [match] "$<имя_переменной>" : '[.*]\(<регулярное_выражение>\)'` `` - возвращает подстроку, которая удолетворяет регулярному выражению с начала строки [`.*` - с конца].
> `` `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'` ``

`${<имя_переменной>#<строка>}` - возвращает из пременной строку в которой удалена короткая подстрока с начала строки.  
`${<имя_переменной>##<строка>}` - возвращает из пременной строку в которой удалена длинная подстрока с начала строки.  
`${<имя_переменной>%<строка>}` - возвращает из пременной строку в которой удалена короткая подстрока с конца строки.  
`${<имя_переменной>%%<строка>}` - возвращает из пременной строку в которой удалена длинная подстрока с конца строки.
> `${stringZ#a*C}`

`${<имя_переменной>/<строка1>/<строка2>}` - возвращает из пременной строку в которой заменена строка `<строка1>` на строку `<строка2>`.  
`${<имя_переменной>//<строка1>/<строка2>}` - возвращает из пременной строку в которой заменены все строки `<строка1>` на строки `<строка2>`.
> `${stringZ//abc/xyz}`  
> `${<имя_переменной>//:/$'\n'}`

## <a id="Создание-и-использование-библиотек" href="#Создание-и-использование-библиотек">Создание и использование библиотек</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`source <путь_к_скрипту>` - подключает скрипт как библиотеку к скрипту и в результате функции, объявленные в библиотеке, становятся доступными в скрипте.  
`. <путь_к_скрипту>` - аналогично.

<a id="sed" href="#sed">`sed`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

Утилита `sed` называется потоковым текстовым редактором, поточно обрабатывает строки. Схема вызова команды:  
`sed <опции> [<файл>]`

По умолчанию `sed` применяет указанные при вызове правила, выраженные в виде набора команд, к `STDIN`. Это позволяет передавать данные непосредственно `sed` через `|`.

## <a id="Опции" href="#Опции">Опции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'s/<шаблон_поиска>/<шаблон_замены>/[<флаги>]'` - производит потоковую замену найденных шаблонов.

> `'s/search/replace/'`

Для выполнения нескольких действий с данными, используется ключ `-e` при вызове и опции разделяются символом точкой с запятой `;`, при этом между окончанием команды и точкой с запятой не должно быть пробела:  
`sed -e <опции> [<файл>]`

Для того, чтобы указать `sed` файл, содержащий команды, используют ключ `-f`:  
`sed -f <файл_с_командами> [<файл>]`

### <a id="Дополнительные-ключи" href="#Дополнительные-ключи">Дополнительные ключи</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `-n` - указанный при вызове sed, подавляет обычный вывод;
- `-e` - добавление скрипта или regex в исполняемые команды;
- `-r` - использовать расширенный синтаксис регулярных выражений (спец символы активны по умолчанию);
- `-d` - удалить;
- `-s` - заменить;
- `-p` - распечатать найденную строку;
- `-i` - выполнять изменения непосредственно в файле.

### <a id="Флаги" href="#Флаги">Флаги</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При передаче номера учитывается порядковый номер вхождения шаблона в строку, заменено будет именно это вхождение.

Флаг `g` указывает на то, что нужно обработать все вхождения шаблона, имеющиеся в строке.  
Флаг `p` указывает на то, что нужно вывести содержимое исходной строки.  
Флаг вида `w <файл>` указывает команде на то, что нужно записать результаты обработки текста в файл.

### <a id="Символы-разделители" href="#Символы-разделители">Символы-разделители</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Разделителем считается первый символ, который будет встречен после `s`:  
`'s<символ_разделитель><шаблон_поиска><символ_разделитель><шаблон_замены><символ_разделитель>[<флаги>]'`

> `'s:as:like:'`

### <a id="Выбор-фрагментов-текста-для-обработки" href="#Выбор-фрагментов-текста-для-обработки">Выбор фрагментов текста для обработки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Перед `s` можно указать номер строки для обработки:  
`'<номер_строки>s/<шаблон_поиска>/<шаблон_замены>/'`  
`'<номер_строки_начала>,<номер_строки_конца>s/<шаблон_поиска>/<шаблон_замены>/'` - воздействует на диапазон строк. Где концом может выступать символ `$`, означающий номер последней строки.

> `'2,$s/find/replace/'`

`'/<шаблон_строки>/s/<шаблон_поиска>/<шаблон_замены>/'` - только строки, которые удовлетворяют указанному шаблону.

> `'/filter/s/find/replace/'`

### <a id="Удаление-строк" href="#Удаление-строк">Удаление строк</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'<номер_строки>d'` - удаляет указанную строку из потока вывода.  
`'<номер_строки_начала>,<номер_строки_конца>d'` - удаляет указанный диапазон строк из потока вывода. Где концом может выступать символ `$`, означающий номер последней строки.  
`'/<шаблон_строки>/[,...]d'` - только строки, которые удовлетворяют указанному шаблону [одному из них].

### <a id="Вставка-текста-в-поток" href="#Вставка-текста-в-поток">Вставка текста в поток</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'[<номер_строки>]i\<строка>'` - добавляет новую строку перед заданной.  
`'[<номер_строки>]a\<строка>'` - добавляет новую строку после заданной.

### <a id="Замена-строк" href="#Замена-строк">Замена строк</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'<номер_строки>c\<строка>'` - заменяет указанную строку переданной.  
`'/<шаблон_строки>/c/<строка>'` - заменяет строки удовлетворяющие указанному шаблону переданной.

### <a id="Замена-символов" href="#Замена-символов">Замена символов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'y/<символы>/<символы_замены>/'` - заменяет символы в соответствии символам замены.

### <a id="Вывод-номеров-строк" href="#Вывод-номеров-строк">Вывод номеров строк</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`=` - выводит номер строки.  
`'/<шаблон_строки>/='` - выводит номер строки удовлетворяющей указанному шаблону.

### <a id="Чтение-данных-для-вставки-из-файла" href="#Чтение-данных-для-вставки-из-файла">Чтение данных для вставки из файла</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'[<номер_строки>]r <файл>'` - вставляет содержимое файла после [указанной строки] в поток данных.  
`'/<шаблон_строки>/r <файл>'` - вставляет содержимое файла после строк удовлетворяющих указанному шаблону в поток данных.

### <a id="Регулярные-выражения" href="#Регулярные-выражения">Регулярные выражения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Все шаблоны поиска могут представлять из себя регулярное выражение.

<a id="awk" href="#awk">`awk`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

Утилита **awk** похожа на **sed** , но более разнообразна.

Awk воспринимает поступающие к нему данные в виде **набора записей**. Записи представляют собой наборы полей. **Запись** - это строка. **Поле** - это слово в строке.

Awk обрабатывает текст из потока ввода построчно.

`awk [<опции>] [<программа>] [<файл> [ ...]]`

## <a id="Опции" href="#Опции">Опции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `-F <символ>` - позволяет указать символ-разделитель для полей в записи;
- `-f <файл>` - указывает имя файла, из которого нужно прочесть awk-скрипт;
- `-v <переменная>=<значение>`- позволяет объявить переменную и задать ее значение по умолчанию, которое будет использовать awk;
- `-mf <кол>` - задает максимальное число полей для обработки в файле данных;
- `-mr <кол>` - задает максимальный размер записи в файле данных;
- `-W <режим>` - позволяет задать режим совместимости или уровень выдачи предупреждений awk.

## <a id="Программа" href="#Программа">Программа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Скрипты awk, которые можно писать прямо в командной строке, оформляются в виде текстов команд, заключенных в фигурные скобки. Кроме того, awk предполагает, что скрипт представляет собой текстовую строку, его нужно заключить в одинарные кавычки.

`'{<команда> [; ...]}'`

Для того, чтобы завершить работу awk, нужно передать ему символ конца файла (*EOF*, *End-of-File*). С помощью сочетания клавиш `CTRL + D`.

`print <текст> [, ...]` - печатает текст, он может состоять из строк и переменных.

`"<текст>"` - строка.

### <a id="Позиционные-переменные-хранящие-данные-полей" href="#Позиционные-переменные-хранящие-данные-полей">Позиционные переменные, хранящие данные полей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

По умолчанию `awk` назначает следующие переменные каждому полю данных, обнаруженному им в записи:
- `$0` - представляет всю строку текста (запись);
- `$1` - первое поле;
- `$2` - второе поле;
- `$n` - n-ное поле.

Поля выделяются из текста с использованием **символа-разделителя**. По умолчанию - это пробельные символы вроде пробела или символа табуляции.

### <a id="Файл-скрипта" href="#Файл-скрипта">Файл скрипта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В файле скрипта может содержаться множество команд, при этом каждую из них достаточно записывать с новой строки, ставить после каждой точку с запятой не требуется.

Внутри скрипта можно объявлять переменные.

### <a id="Выполнение-команд-до-начала-обработки-данных" href="#Выполнение-команд-до-начала-обработки-данных">Выполнение команд до начала обработки данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`BEGIN {<команда> [; ...]}` - выполнит указанную секцию команд до начала обработки данных.

### <a id="Выполнение-команд-после-окончания-обработки-данных" href="#Выполнение-команд-после-окончания-обработки-данных">Выполнение команд после окончания обработки данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`END {<команда> [; ...]}` - выполнит указанную секцию команд после начала обработки данных.

### <a id="Встроенные-переменные" href="#Встроенные-переменные">Встроенные переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `FIELDWIDTHS` - разделенный пробелами список чисел, определяющий точную ширину каждого поля данных с учетом разделителей полей;
- `FS="<символ>"` - позволяет указать символ-разделитель для полей в записи;
- `RS="<символ>"` - переменная, которая позволяет задавать символ-разделитель записей;
- `OFS="<символ>"` - разделитель полей на выводе awk-скрипта;
- `ORS="<символ>"` - разделитель записей на выводе awk-скрипта;
- `ARGC` - количество аргументов командной строки;
- `ARGV` - массив с аргументами командной строки (`ARGV[<n>]`);
- `ARGIND` - индекс текущего обрабатываемого файла в массиве `ARGV`;
- `ENVIRON` - ассоциативный массив с переменными окружения и их значениями (`ENVIRON["<ключ>"]`);
- `ERRNO` - код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов;
- `FILENAME` - имя входного файла с данными;
- `FNR` - номер текущей записи в файле данных;
- `IGNORECASE` - если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов;
- `NF` - общее число полей данных в текущей записи, $NF позволяет обращаться к последнему полю данных в записи, не зная его точной позиции;
- `NR` - общее число обработанных записей.

### <a id="Условный-оператор" href="#Условный-оператор">Условный оператор</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`if (<условие>) <команда> [; else <команда>]`
```
if (<условие>)
{
    <команды>
}[ else {
    <команды>
}]
```

Операторы сравнения:
- `==` - равно;
- `!=` - не равно;
- `>` - больше;
- `<` - меньше;
- `<=` - больше или равно;
- `>=` - меньше или равно.

### <a id="Цикл-while" href="#Цикл-while">Цикл while</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
while (<условие>)
{
    <команды>
}
```
В циклах `while` можно использовать команды `break` и `continue`.

### <a id="Цикл-for" href="#Цикл-for">Цикл for</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
for (<начало>; <условие>; <итерация>)
{
    <команды>
}
```

## <a id="Форматированный-вывод-данных" href="#Форматированный-вывод-данных">Форматированный вывод данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Команда `printf` в awk позволяет выводить форматированные данные:  
`printf "<текст_со_спецификаторами>" [, <переменная> [, ...]]`

Первый спецификатор соответствует первой переменной, второй спецификатор - второй, и так далее.

`%[<модификатор>]<символ_спецификатора>` - спецификатор.

### <a id="Символы" href="#Символы">Символы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `c` - воспринимает переданное ему число как код ASCII-символа и выводит этот символ;
- `d` - выводит десятичное целое число;
- `i` - то же самое, что и d;
- `e` - выводит число в экспоненциальной форме;
- `f` - выводит число с плавающей запятой;
- `g` - выводит число либо в экспоненциальной записи, либо в формате с плавающей запятой, в зависимости - от того, как получается короче;
- `o` - выводит восьмеричное представление числа;
- `s` - выводит текстовую строку.

### <a id="Модификаторы" href="#Модификаторы">Модификаторы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Могут комбинироваться и писаться в указанном порядке.

- `-` - выравнивание по левой стороне;
- ` ` - отрицательные числа пишутся со знака минуса, положительные с пробела;
- `+` - отрицательные числа пишутся со знака минуса, положительные с плюса;
- `0` - дополняет слева число нулями;
- `<число>` - минимальная ширина поля;
- `.<число>` - максимальная ширина поля.

## <a id="Встроенные-математические-функции" href="#Встроенные-математические-функции">Встроенные математические функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `cos(x)` - косинус x (x выражено в радианах);
- `sin(x)` - синус x;
- `exp(x)` - экспоненциальная функция;
- `int(x)` - возвращает целую часть аргумента;
- `log(x)` - натуральный логарифм;
- `rand()` - возвращает случайное число с плавающей запятой в диапазоне 0 - 1;
- `sqrt(x)` - квадратный корень из x.

## <a id="Строковые-функции" href="#Строковые-функции">Строковые функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются аналогично математическим.

## <a id="Пользовательские-функции" href="#Пользовательские-функции">Пользовательские функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объявляются до всех секций.

```
function <функция>()
{
    <команды>
}
```

`<функция>()` - использование.

<a id="Регулярные-выражения" href="#Регулярные-выражения">Регулярные выражения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====================

Утилита **sed** поддерживает часть стандарта *POSIX Basic Regular Expression* (BRE).  
Регулярное выражение может находиться в шаблоне.

Утилита **awk** поддерживает стандарт *POSIX Extended Regular Expression* (ERE).  
Регулярное выражение может находиться в перед списком команд:  
`/<регулярное_выражение>/{<команда> [; ...]}`

Специальные символы экранируются с помощью обратной косой черты (обратного слэша) - `\`.

## <a id="Специальные-классы-символов" href="#Специальные-классы-символов">Специальные классы символов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В BRE имеются специальные классы символов, которые можно использовать при написании регулярных выражений:
- `[[:alpha:]]` - соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре;
- `[[:alnum:]]` - соответствует любому алфавитно-цифровому символу, а именно - символам в диапазонах 0-9, A-Z, a-z;
- `[[:blank:]]` - соответствует пробелу и знаку табуляции;
- `[[:digit:]]` - любой цифровой символ от 0 до 9;
- `[[:upper:]]` - алфавитные символы в верхнем регистре - A-Z;
- `[[:lower:]]` - алфавитные символы в нижнем регистре - a-z;
- `[[:print:]]` - соответствует любому печатаемому символу;
- `[[:punct:]]` - соответствует знакам препинания;
- `[[:space:]]` - пробельные символы, в частности - пробел, знак табуляции, символы NL, FF, VT, CR.

<a id="Структура-Linux" href="#Структура-Linux">Структура Linux</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===============

- `/bin` - содержит готовые к запуску команды (известные также как исполняемые файлы), как в двоичном формате, так и сценарии оболочки;
- `/boot` - содержит файлы загрузчика ядра;
- `/dev` - содержит файлы устройств:
    - `/sd*` (`*` - `a`, `b`, ...) - жесткие диски;
    - `/sr*` (`*` - `a`, `b`, ...) - приводы CD и DVD;
    - `/hd*` (`*` - `a`, `b`, ...) - жесткие диски PATA;
    - `/tty*` (`*` - `1`, `2`, ...) - виртуальная консоль;
    - `/pts/*` (`*` - `0`, `1`, ...) - псевдотерминальное устройство;
    - `/tty` - управляющий терминал текущего процесса;
    - `/ttyS*` (`*` - `0`, `1`, ...) - последовательные порты (COM);
    - `/ttyUSB*` (`*` - `0`, `1`, ...) - последовательные порты USB;
    - `/ttyACM*` (`*` - `0`, `1`, ...) - последовательные порты ACM;
    - `/lp*` (`*` - `0`, `1`, ...) - параллельные порты (LPT);
    - `/parport*` (`*` - `0`, `1`, ...) - двунаправленные параллельные порты;
- `/etc` - содержит файлы конфигурации, файлы загрузки, файлы устройств, сетевые настройки и другие параметры. Многие элементы каталога зависят от аппаратного обеспечения:
    - `/sudoers` - файл прав привилегированных пользователей `sudo`;
- `/home` - содержит личные каталоги пользователей;
- `/lib` - содержит файлы библиотек для совместного пользования:
    - `/modules` - содержит загружаемые модули ядра;
- `/media` - основная точка подключения для таких съемных устройств, как флешнакопители;
- `/opt` - содержит дополнительное ПО сторонних разработчиков;
- `/proc` - содержит информацию о запущенных в данный момент процессах, а также о некоторых параметрах ядра в виде "каталог-файл";
- `/lib` - содержит интерфейс устройствам и системе в виде "каталог-файл";
- `/sbin` - содержит системные исполняемые файлы;
- `/tmp` - содержит небольшие временные файлы. Любой пользователь может выполнять чтение и запись в этом каталоге, однако доступ к файлам другого пользователя может быть запрещен. Многие команды применяют данный каталог в качестве рабочего пространства;
- `/usr` - содержит обширную иерархию каталогов, включающую основную часть системы Linux. Многие имена каталогов здесь такие же, как и в корневом каталоге (типа `/usr/bin` и `/usr/lib`), и содержат те же типы файлов, предназначен для хранения большей части команд и данных пространства пользователя:
    - `/include` - содержит заголовочные файлы, используемые компилятором C;
    - `/info` - содержит руководства GNU в формате info;
    - `/local` - здесь администраторы могут устанавливать собственное программное обеспечение. Структура этого каталога должна выглядеть подобно структуре каталогов `/` и `/usr`;
    - `/man` - содержит страницы руководства;
    - `/share` - содержит файлы, которые должны работать в других типах систем Unix  без потери функциональности;
- `/var` - изменяемый подкаталог, в котором команды хранят информацию во время исполнения;
- `/vmlinuz` - содержит ядро.

## <a id="Устройства" href="#Устройства">Устройства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Распологаются по пути: `/dev`.

Виды устройств:
- **блочные устройства** - доступ к данным в виде фиксированных порций. Поскольку общий объем блочного устройства фиксирован и легко поддается индексации, процессы с помощью ядра получают случайный доступ к любому блоку устройства;
- **символьные устройства** - работают с потоками данных. Можно лишь считывать символы с таких устройств или записывать символы на них. Символьные устройства не обладают размером;
- **каналы** - подобны символьным устройствам, но у них на другом конце потока ввода-вывода располагается другой процесс, а не драйвер ядра;
- **сокеты** - являются специализированными интерфейсами, которые часто используются для взаимодействия между процессами.

`udevadm info --query=all --name=/dev/<устройство>` - показывает путь и другие атрибуты устройства.

<a id="Архивирование" href="#Архивирование">Архивирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=============

## <a id="tar" href="#tar">`tar`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Запаковывание" href="#Запаковывание">Запаковывание</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`tar [-<ключи>] [<название_архива>] [<путь_что_запаковать>]`

Значения ключей:
- `с` - "create" - создать файл архива;
- `v` - "verbose" - выводить информацию в процессе выполнения;
- `z` - "gzip" - запаковать файл при помощи gzip;
- `j` - "bzip2" - запаковать файл при помощи bzip2;
- `f` - "file" - использовать имя файла архива указаное после ключей. Если не указать ключ `f` то команда будет использовать настройки по умолчанию либо выведет результат прямо в консоль.

`.tar.gz` = `.tgz`

> `tar -zcvf prog-1-jan-2005.tar.gz /home/jerry/prog`

### <a id="Распаковывание" href="#Распаковывание">Распаковывание</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`tar [-<ключи>] [<название_архива>]`

Значения ключей:
- `x` - "eXtract" - извлечь файлы;
- `v` - "verbose" - выводить информацию в процессе выполнения;
- `z` - "gzip" - распаковать файл при помощи gzip;
- `j` - "bzip2" - распаковать файл при помощи bzip2;
- `f` - "file" - использовать имя файла архива для распаковки указаное после ключей.

> `tar -zxvf prog-1-jan-2005.tar.gz`

## <a id="gzip" href="#gzip">`gzip`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`gzip <файл>` - архивирует файл в формате GNU Zip и добавляет к названию новому файлу расширение `.gz`.  
`gunzip [-d] [-c] <файл>.gz` - разархивирует файл [`-d` - включает архивирацию] [`-c` - выводит результат в стандартный поток вывода] в формате GNU Zip и убирает из названия нового файла расширение `.gz`.

## <a id="bzip2" href="#bzip2">`bzip2`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`bzip <файл>` - архивирует файл в формате GNU BZip и добавляет к названию новому файлу расширение `.bz2`.  
`bunzip [-d] [-c] <файл>.bz2` - разархивирует файл [`-d` - включает архивирацию] [`-c` - выводит результат в стандартный поток вывода] в формате GNU BZip и убирает из названия нового файла расширение `.bz2`.

## <a id="zip" href="#zip">`zip`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`zip <файл>` - архивирует файл в формате Zip-архива Windows и добавляет к названию новому файлу расширение `.gz`.  
`unzip [-d] [-c] <файл>.gz` - разархивирует файл [`-d` - включает архивирацию] [`-c` - выводит результат в стандартный поток вывода] в формате Zip-архива Windows и убирает из названия нового файла расширение `.gz`.

<a id="wget" href="#wget">`wget`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Загрузка всех URL, указанных в локальном или внешнем ФАЙЛЕ:  
`wget -i <файл>`

Скачивание файлов в указанный каталог `-P`:  
`wget -P <каталог> <ссылка>`

Использование имени пользователя и пароля на FTP/HTTP (вариант 1):  
`wget ftp://<логин>:<пароль>@<ссылка>`

Использование имени пользователя и пароля на FTP/HTTP (вариант 2):  
`wget --user=<логин> --password=<пароль> <ссылка>`

Скачивание в фоновом режиме `-b`:  
`wget -b <ссылка>`

Продолжить (`-c` continue) загрузку ранее не полностью загруженного файла:  
`wget -c <ссылка>`

Скачать содержимое каталога <ссылка> и всех его подкаталогов, при этом не поднимаясь по иерархии каталогов выше:  
`wget -r --no-parent <ссылка>`

Идентификация на сервере:
```
wget --save-cookies <файл_с_куками> \
--post-data '<POST_данные>' \
<ссылка>
```

Скачать весь сайт целиком:  
`wget -r -l <глубина рекурсии> -k -o <файл_лога> -p <ссылка>`

Где:
- `-r`, `--recursive` - включение рекурсивной загрузки;
- `-l`, `--level=<число>` - глубина рекурсии (`inf` и `0` - бесконечность);
- `-k`, `--convert-links` - делать ссылки локальными в загруженном HTML или CSS;
- `-o`, `--output-file=<файл>` - записывать сообщения (логи) в `<файл>`;
- `-p`, `--page-requisites` - загрузить все изображения и проч., необходимые для отображения HTML-страницы;
- `-m`, `--mirror` - короткий параметр, эквивалентный `-N -r -l inf --no-remove-listing`.

<a id="grep" href="#grep">`grep`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Утилита командной строки, которая находит на вводе строки, отвечающие заданному регулярному выражению, и выводит их, если вывод не отменен специальным ключом.

Поиск строки в файле:  
`cat <файл> | grep [<опции>] <строка_поиска>`  
`grep [<опции>] <строка_поиска> <файл>`

Опции:
- `-c` - выводит количество отобранных строк;
- `-w` - ищет по слову целиком;
- `-i` - игнорирует регистр при поиске;
- `-C <количество>` - выводит заданное количество строк сверху и снизу от искомой;
- `-A <количество>` - выводит заданное количество строк снизу от искомой;
- `-B <количество>` - выводит заданное количество строк сверху от искомой;
- `-E` - интерпретировать строку поиска как регулярное выражение и по ней искать;
- `-oE` - интерпретировать строку поиска как регулярное выражение и по ней искать и выводить только полное совпадение регулярному выражению;
- `-v` - все строки только без искомой;
- `-n` - выводит номер строки;
- `-r` - ищет по всем файлам каталога;
- `--colour` / `--color` - подсвечивает искомую строку.

Формирование строки поиска:
- `'\<<строка_поиска>'` - поиск по началу слова;
- `'<строка_поиска>\>'` - поиск по концу слова;
- `'^<строка_поиска>'` - поиск по началу строки;
- `'<строка_поиска>$'` - поиск по концу строки.

Для удобства пользования делают цепочки поисков:  
`... | grep <строка_поиска1> | grep <строка_поиска2> | ...`

`grep -rnw '<путь>/' -e '<строка_поиска>'` - рекурсивно ищет строку во всех файлах.

Для файлов `gz` используется `zgrep`.

<a id="Процессы" href="#Процессы">Процессы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========

## <a id="ps" href="#ps">`ps`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Программа в UNIX, Unix-подобных и других POSIX-совместимых операционных системах, выводящая отчет о работающих процессах.

`ps [<опции>]` - показывает все процессы которые запущены текущим пользователем.

Опции, отбирающие процессы для отчета:
- `-A` - все процессы;
- `-a` - связанные с конкретным терминалом, кроме главных системных процессов сеанса, часто используемая опция;
- `-N` - отрицание выбора;
- `-d` - все процессы, кроме главных системных процессов сеанса;
- `-e` - все процессы;
- `-f` - расширение информации;
- `T` - все процессы на конкретном терминале;
- `a` - процессы, связанные с текущим терминалом, а также процессы других пользователей;
- `r` - информация только о работающих процессах;
- `u` - включает детализированную информацию о работающих процессах;
- `x` - процессы, отсоединенные от терминала.

## <a id="Выводимая-информация" href="#Выводимая-информация">Выводимая информация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Столбцы:
- **UID** - идентификатор пользователя;
- **PID** - идентификатор процесса;
- **PPID** - идентификатор родительского процесса;
- **C** - приоритет процесса, используемый планировщиком задач;
- **STIME** - время старта процесса;
- **TTY** - терминал, с которым связан данный процесс;
- **TIME** - процессорное время, занятое этим процессом;
- **CMD** - команда, запустившая данный процесс "с некоторыми опциями выводит и каталог откуда процесс был запущен";
- **STAT** - состояние, в котором на данный момент находится процесс. Параметры **STAT**:
    - **R** - процесс выполняется в данный момент;
    - **S** - процесс ожидает (т.е. спит менее 20 секунд);
    - **I** - процесс бездействует (т.е. спит больше 20 секунд);
    - **D** - процесс ожидает ввода-вывода (или другого недолгого события), непрерываемый;
    - **Z** - *zombie* или *defunct* процесс, то есть завершившийся процесс, код возврата которого пока не считанный родителем;
    - **T** - процесс остановлен;
    - **W** - процесс в свопе;
    - **<** - процесс в приоритетном режиме;
    - **N** - процесс в режиме низкого приоритета;
    - **L** - *real-time* процесс, имеются страницы, заблокированные в памяти;
    - **s** - лидер сессии.

Опция o позволяет указать набор столбцов в ответе:
`ps o [<имя_столбца> [, <имя_столбца> [, ...]]]`

## <a id="kill" href="#kill">`kill`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Завершает работу процесса, фактически посылает процессу сигнал.

`kill [<сигнал>] [<опция>] <PID1>[ <PID2>[ ...]]`

Основные сигналы:
- `SIGTERM` - этот сигнал запрашивает остановку работы процесса. Он может быть проигнорирован. Процессу дается время на корректное завершение;
- `SIGKILL` - этот сигнал заставляет процесс прекратить работу немедленно. Программа не может проигнорировать этот сигнал. Несохраненные результаты будут потеряны.

Вывод всех видов сигналов: `kill -l`.  
Сигнал по умолчанию (если он не задан) - `SIGTERM`.

> `kill -9 3629`  
> `kill SIGKILL 3629`

## <a id="pkill" href="#pkill">`pkill`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Команда `pkill` позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID можно завершить приложение, введя имя его процесса.

> `pkill firefox`

## <a id="killall" href="#killall">`killall`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Команда `killall` позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID можно завершить приложение, введя имя его процесса и завершить все экземпляры процесса с этим именем.

> `killall firefox`

<a id="ssh" href="#ssh">`ssh`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

`ssh-keygen -t rsa [-f <имя_файла>]` - генерирование пары ключей RSA, создаст ключи по умолчанию:
- `~/.ssh/id_rsa.pub` - открытый ключ;
- `~/.ssh/id_rsa` - закрытый ключ.

> `ssh-keygen -t rsa -b 4096`

`ssh-keygen -l -f <имя_файла>` - проверяет файл на валидность ключа.  
`ssh-keygen -y <имя_файла>` - выводит содержимое ключа после ввода пароля (служит для проверки пароля).

По умолчанию берутся ключи с именем:
- `~/.ssh/id_rsa`;
- `~/.ssh/id_ed25519`;
- `~/.ssh/id_dsa`;
- `~/.ssh/id_ecdsa`.

Для указания определенного ключа для адреса `<url>` используется файл конфигурации `~/.ssh/config` со структурой:
```bash
# <коментарий>
Host <url1>
  Preferredauthentications publickey
  IdentityFile ~/.ssh/<приватный_ключ>
# ...
```

В каталоге пользователя, под которым нужно зайти, если создать файл: `~/.ssh/authorized_keys` и положить туда открытый ключ, то можно будет заходить без пароля, права на файл не должны давать возможность писать в этот файл посторонним пользователям, иначе `ssh` его не примет. В ключе последнее поле - `user@server`. Оно не имеет никакого отношения к авторизации и служит только для удобства определения где чей ключ, это поле может быть поменяно (или даже удалено) без нарушения структуры ключа.

`ssh-add [<key>]` - добавляет ключи по пути `$HOME/.ssh/identity`, `$HOME/.ssh/id_rsa`, `$HOME/.ssh/id_dsa` [или указанный ключ] для ssh-agent на текущую сессию, который будет использоваться для проброса на другие сервера.

`ssh-add -L` - выводит список всех добавленных ключей для агента.

`ssh-add -D` - удаляет все добавленные ключи из агента.

`ssh-add -d <key>` - удаляет указанный ключ из агента.

`ssh-copy-id [-i ~/.ssh/id_rsa.pub] "[-p <port> ]<user>@<server>"` - копирует ключ на машину при этом не редактируя файлы вручную.

`~/.ssh/known_hosts` - хранятся ключи сервера, с которыми есть связь. Узнать, где какой ключ нельзя.

`ssh-keygen -R <server>` - удаляет известный ключ сервера, также необходимо сделать это и для IP, так как они хранятся раздельно: `ssh-keygen -R <IP>`.

Ключ сервера хранится в `/etc/ssh/ssh_host_rsa_key` и `/etc/ssh/ssh_host_rsa_key.pub`.

`scp <путь_к_локальному_файлу> <user>@<server>:<путь_к_каталогу_на_сервере>` - осуществляет копирование файла через ssh-сессию на сервер.

`scp -r <путь_к_локальному_каталогу> <user>@<server>:<путь_к_каталогу_на_сервере>` - осуществляет копирование каталога через ssh-сессию на сервер.

`scp <user>@<server>:<путь_к_файлу_на_сервере> <путь_к_локальному_каталогу>` - осуществляет копирование файла через ssh-сессию с сервера.

`ssh <user>@<server> [-t] <команда>[ <аргумент1>[ ...]]` - выполняет команду на удаленном сервере и тут же закрывает соединение [с управляющим терминалом для команд]. Для таких команд можно использовать pipe `|`, stdin `<`, stout `>` как для простых программ.

> `ssh user@8.8.8.8 command > my_file`  
> `mycommand | ssh user@8.8.8.8 "scp - user@10.1.1.2:/path/to/file"` - позволяет прокидывать файлы с сервера на сервер.  
> `ssh example.com -t "cd /www/example.com && git status -sb | head -1"`

В файле `~/.ssh/config` позволяет задать параметры подключения, в том числе специальные для каждого из серверов, а также задать им алиасы и так для каждого из серверов:
```
Host <алиас>
    Hostname <server>
    User <user>
    ForwardX11 yes
    Compression yes
    PasswordAuthentication no
```

Настройки соединения по умолчанию с помощью конструкции `Host *`.

В файле `/etc/ssh/ssh_config` задаются для всех.

`ssh -D localhost:<port> <user>@<server>` - задает туннелирование порта, заключается в том, что создается сокет для прослушивания порта на локальной машине, привязанный (необязательно) к конкретному адресу. Когда создается соединение к этому порту, это соединение туннелируется по зашифрованному каналу, и протокол приложения затем используется, чтобы определить, куда соединяться с удаленной машиной. При этом SSH работает как SOCKS сервер.

`ssh -L [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<user>@]<server>` - все соединения на `<локальный_адрес>:<локальный_порт>` будут переадресовываться удаленному серверу, который будет соединяться с `<удаленный_адрес>:<удаленный_порт>` от своего имени. По умолчанию `<локальный_адрес>` соответствует `127.0.0.1`. Возможно использование нескольких ключей `-L` в одном клиенте.

`ssh -R [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<user>@]<server>` - работает также как и `-L`, только соединения перебрасываются с удаленной машины на локальную.

`ssh -A <user1>@<server1> ssh <user2>@<server2>` - пробрасывает авторизацию на удаленный сервер.

`ssh -T <url>` - проверяет наличие соединения с `<url>`.

`ssh -vT <user>@<server>` - пытается подключиться к серверу и выводит информацию (дебаг) по попыткам подключения к нему. `-1` - файл не существует, `1` - существует.

<a id="screen" href="#screen">`screen`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========

Позволяет сворачивать в фон программы, которые сами этого не умеют, с возможностью последующего возврата к ним.

`screen` - создает новый скрин, в котором откроет сессию командной оболочки.  
`screen <команда>` - создает новый скрин, в котором откроет указаную команду.

`Ctrl+a` - переводит `screen` в командный режим, в котором требуется нажать дополнительные клавиши для дополнительных команд.

`Ctrl+a d` - сворачивает текущий скрин, отключает его от терминала.  
`Ctrl+a k` - завершает текущий скрин вместе со всем, что в нем работает, необходимо подтвердить выход нажав `y`.  
`Ctrl+a c` - запускает новое окно скрина.  
`Ctrl+a w` - выводит список активных окон скрина в верхнем углу окна.  
`Ctrl+a p` - переключает на предыдущее окно скрина.  
`Ctrl+a n` / `Ctrl+a <пробел>` - переключает на следующее окно скрина.  
`Ctrl+a "` - выводит интерактивный список активных окон скрина, по которому можно перемещаться стрелками вверх-вниз и входить с помощью `Enter` в нужное.  
`Ctrl+a <номер_окна>` - переключает на указаное `<номер_окна>` окно скрина (0, 1, ...).  
``Ctrl+a ` `` - а затем номер и будет осуществлен переход на указанный номер окна скрина.  
`Ctrl+a A` - а затем необходимо ввести новое имя окна и с помощью `Enter` задать его.  
`Ctrl+a N` - выводит имя активного окна скрина в верхнем углу окна.  
`Ctrl+a S` - добавляет горизонтальный регион на экран, в котором будет отображено указаное окно скрина.  
`Ctrl+a |` - добавляет вертикальный регион на экран, в котором будет отображено указаное окно скрина.  
`Ctrl+a Tab` - переходит на следующий регион.  
`Ctrl+a X` - закрывает текущий регион.  
`Ctrl+a Q` - закрывает все регионы, кроме текущего региона.  

`screen -r` - возвращает к заранее сернутому скрину.

Для выхода из окна скрина необходимо написать `exit`.

`screen -S <имя> <команда>` - создает новый именованный скрин, в котором откроет указаную команду.  
`screen -r <имя>` - возвращает к заранее сернутому именному скрину.

`screen -list` / `screen -ls` - выводит список запущенных скринов.

<a id="wildcards---шаблоны-замены" href="#wildcards---шаблоны-замены">wildcards - шаблоны замены</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========================

Командный интерпретатор линукс поддерживает возможность указания множества файлов используя шаблоны. Bash и другие команды линукс выбирают только те файлы, которые совпадают с шаблоном. Шаблоны:
- `*` - соответствует нулю или большему количеству символов;
    > `/tmp/my*1` - все файлы в директории `/tmp` имена которых начинаются с `my` и заканчиваются на `1` (включая файл с именем "my1")
    - `**` - соответствует всем файлам и нулю или более директорий и поддиректорий в пути;
    - `/**` - соответствует нулю или более директорий и поддиректорий:
        > `org/**/servlet/bla.jsp` - все файлы в директории `org/` пути которых заканчиваются на `/servlet/bla.jsp`
- `?` - заменяет один любой символ;
    > `/tmp/notes?txt` - соответствует файлам с именами "`notes.txt`" и "`notes_txt`" (если они существуют в `/tmp/`)
- `[<диапазон>]` - совпадает с одним символом из тех что указаны в скобках. Также в скобках можно указать диапазон символов, для этого используется символ `-` или несколько диапазонов подряд, тогда шаблон будет совпадать с одним любым символом из этого диапазона;
    > `/tmp/[A-Za-z]*` - все файлы в директории `/tmp/` имена которых начинаются с буквы (заглавной или прописной)
- `[[<диапазон>]` - похожа на `[]`, за исключением того что она соответствует единичному символу, не упомянутому между `[[` и `]`;
    > `myfile[[9]` - удалит все файлы, имена которых состоят из слова `myfile` и идущей за ним одной цифрой, кроме файла `myfile9`

Так как bash интерпретирует символы `?`, `[`, `]`, `*` как шаблоны замены, то для использования их как сивмолов их экранировать, т.е. поставить знак `\` перед ними или взять строку в одинарные кавычки `'`. Чтобы указать текстовый символ `\` можно заключить его в одинарные кавычки или написать `'\\\'`.

При использовании с командами, они преобразуются в последовательность файлов, т.е. конструкция вида `<команда> <шаблон>` будет равна `<команда> <файл1> <файл2>[ ...]`.

> `ls ./lib*` = `ls ./lib ./lib64 ./libexec`

<a id="find" href="#find">`find`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`find <каталог>` - выводит список всех файлов в каталоге и его подкаталогах. Опции:
- `-name <имя>` - только те, которые соответствуют имени;
- `-iname <имя>` - только те, которые соответствуют имени, но без учета регистра в названии файлов;
- `-type f` - только файлы;
- `-type d` - только каталоги;
- `-atime [<мод>]<n>` - производит поиск по дате создания или последнего доступа к ним, где `<n>` - количество суток, в пределах `<n>` и `<n> + 1` дней [при модификаторе `<мод>` равным `-` - меньше `<n>` дней, при `+` - больше `<n>` дней];
- `-ctime [<мод>]<n>` - производит поиск по дате создания или изменения статуса файла или папки;
- `-mtime [<мод>]<n>` - производит поиск файлов, которые были изменены (редактированы, или созданы);
- `-amin [<мод>]<n>` - аналогично `-atime`, только `<n>` - означает количество минут;
- `-cmin [<мод>]<n>` - аналогично `-ctime`, только `<n>` - означает количество минут;
- `-mmin [<мод>]<n>` - аналогично `-mtime`, только `<n>` - означает количество минут;
- `-exec <команда>[<аргумент1>[ ...]] {} \;` - используется для указания другой команды, которую надо выполнить над каждым аргументом результат поиска, где `{}` - заменяет список найденных аргументов, а `\;` - конец команды;
- `-size {+ | -}<n>{c | w | b | k | M | G}` - выводит только файлы, которые больше при знаке `+` или меньше при `-` определенного размера `<n>` в величине измерении (`c` - в байтах).

> `find . -type d -atime +2`  
> `find . -size +2048k`  
> `find .` - выводит список всех файлов в текущем каталоге и его подкаталогах.  
> `find /home/nobody/public_html -type f -exec chmod 644 {} \;` - меняет права на все файлы в папке.  
> `find . -type f -size +100M | xargs ls -lh` - выводит все файлы, размер которых больше 100 Мегабайт.

<a id="Пользователи-и-группы" href="#Пользователи-и-группы">Пользователи и группы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====================

`users` - выводит список авторизованных пользователей.  
`cut -d: -f1 /etc/passwd | sort | uniq` - выводит список всех пользователей.

`useradd <имя_пользователя>` - добавляет пользователя.  
`userdel <имя_пользователя>` - удаляет пользователя.

`groups [<имя_пользователя>]` - выводит список групп, в которых состоит текущий [указанный] пользователь. Основная (первичная) группа пользователя находится в файле: `/etc/passwd`.

`newgrp <имя_группы>` - производит смену первичной группы на указаную до конца сеанса или вызова команды `exit`.

`cut -d: -f1 /etc/group > | sort` - выводит список всех групп.

`groupadd <имя_группы>` - добавляет группу.  
`groupdel <имя_группы>` - удаляет группу.

`su { - | <имя_пользователя>}` - запускает в текущей консоли командную оболочку c правами другого пользователя `<имя_пользователя>`, по умолчанию - рута.  
`sudo [-u <имя_пользователя>] <команда>` - позволяет запустить одиночную команду с правами другого пользователя [`<имя_пользователя>`], по умолчанию - рута.  
Чтобы вернуться в оболочку обычного пользователя, нужно дать команду `exit`, `logout` или нажать `Ctrl + D`.

`w` - выводит список подключенных пользователей и их терминалов.

`whoami` - выводит логин пользователя под которым произведен вход.

`passwd [<имя_пользователя>]` - изменяет пароль текущему пользователю [указаному `<имя_пользователя>`].

<a id="Права-и-владение-файлами" href="#Права-и-владение-файлами">Права и владение файлами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========================

Пользователь, который создает файл становится владельцем этого файла, а **первичная** группа, в которую входит этот же пользователь, так же становится владельцем этого файла.

`ls -l` - выводит список файлов с правами на них.

## <a id="Права" href="#Права">Права</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

двоичная | восьмеричная | символьная | права на файл       | права на каталог
-------- | ------------ | ---------- | ------------------- | ---------------
`000`    | `0`          | `---`      | нет                 | нет
`001`    | `1`          | `--x`      | выполнение          | чтение файлов и их свойств
`010`    | `2`          | `-w-`      | запись              | нет
`011`    | `3`          | `-wx`      | запись и выполнение | все, кроме чтения списка файлов
`100`    | `4`          | `r--`      | чтение              | чтение имен файлов
`101`    | `5`          | `r-x`      | чтение и выполнение | доступ на чтение
`110`    | `6`          | `rw-`      | чтение и запись     | чтение имен файлов
`111`    | `7`          | `rwx`      | все права           | все права

`chmod [-R] [[u][g][o][a]{+ | - | =}[w][r][x]] <файл>` - устанавливает права на файл или каталог [рекурсивно], где: `u` - для пользователя, `g` - группы, `o` - других и `a` - для всех.  
`chmod <вос_права_для_пользователя><вос_права_для_группы><вос_права_для_других> <файл>` - устанавливает права на файл или каталог в восьмеричной системе записи.
> `chmod u+rx file.txt`  
> `chmod 755 file.txt`

## <a id="Владение" href="#Владение">Владение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`chown [-R] <имя_пользователя>[.<имя_группы>] <файл>` - устанавливает владельца [и группу владельцев] на файл или каталог [рекурсивно].
> `chown luser public`  
> `chown lisa.sales myfile`

`chgrp [-R] <имя_группы> <файл>` - устанавливает группу владельцев на файл или каталог [рекурсивно].
> `chgrp geekpress public`

<a id="Сеть" href="#Сеть">Сеть</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====

`ip addr show` - выводит на экран список сетевых интерфейсов.  

`ip link set <интерфейс> up` - поднимает сетевой интерфейс.  
`ip link set <интерфейс> down` - отключает сетевой интерфейс.
> `ip link set eth1 up`

`ifup <интерфейс>` - поднимает сетевой интерфейс.  
`ifdown set <интерфейс>` - отключает сетевой интерфейс.

Перезапуск сети: `systemctl restart network`.

`brctl show` - выводит на экран список мостов.

## <a id="Установка-DNS" href="#Установка-DNS">Установка DNS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для интерфейса `<интерфейс>` выполняется команда `nmcli con mod <интерфейс> ipv4.dns "8.8.8.8 8.8.4.4"` и затем перезапускается с помощью команд `nmcli con down <интерфейс>` и `nmcli con up <интерфейс>`.

<a id="Сервисы" href="#Сервисы">Сервисы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

`systemctl list-units [-a]` - выводит список служб [все службы].  
`systemctl status <служба>` - посмотреть состояние и вывод службы.  
`systemctl show <служба>` - посмотреть параметры управления службой в Linux.  
`systemctl is-active <служба>` - проверить запущена ли служба linux.

`systemctl start <служба>` - запустить службу linux.  
`systemctl stop <служба>` - остановить службу linux.  
`systemctl reload <служба>` - обновить конфигурацию службы из файла юнита.  
`systemctl restart <служба>` - перезапустить службу.

`systemctl enable <служба>` - добавить службу в автозагрузку.  
`systemctl disable <служба>` - удалить службу из автозагрузки.  
`systemctl is-enabled <служба>` - проверить если ли уже служба в автозагрузке.  
`systemctl reenable <служба>` - сначала выполнить `disable` потом `enable` для службы.

Флаг `--runtime` позволяет не сохранять вносимые изменения после перезагрузки.

<a id="Другие-команды" href="#Другие-команды">Другие команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==============

`alias <алиас>="<список_команд>"` - задает алиас для спика команд. Используется как `<алиас>`. Для установки алиасов по умолчанию их добавляют в файл: `~/.bash_profile`.

`cd <каталог>` - перемещение в указанный каталог.  
`cd` - перемещение в домашний каталог.  
`cd ..` - перемещение на каталог выше по иерархии.  
`cd -` - перемещение в предыдущий каталог, в который находились до этого перемещения.

`~` - специальное имя, указывающее в bash на домашнюю директорию пользователя.

`ls [<опции>] {<каталог> | <файл>}` - выводит на экран список файлов хранящихся в указанном каталоге (текущем, если не указан) или информацию о файле. Опции:
- `-a` - все файлы, включая скрытые (имена которых начинаются с точки);
- `-l` - выводит подробную информацию, такую как:
    - тип файла - первый символ:
        - `-` - файл;
        - `d` - каталог;
        - `l` - ссылка;
        - `b` - блочное устройство;
        - `c` - символьное устройство;
        - `p` - канал;
        - `s` - сокет;
    - права на файл;
    - имя владельца;
    - время последнего изменения файла и его размер;
    - если это ссылка, то после знака `->` стоит имя объекта на который она ссылается;
- `-h` - вместе с `-l` выводит размер фалов в удобочитаемом формате;
- `-d` - только каталоги;
- `-R` - рекурсивный вывод всех файлов находящихся в директории;
- `-i` - показывает **инод** (inode number) - уникальный номер;
- `-F` - показывает типы файлов;
- `-1` - выдавать в одноколоночном формате.

`pwd` - показать текущую директорию.

`cp [-r] <откуда>[ ...] <куда>` - копирует файлы [рекурсивно копирует каталог], если `<куда>` - существующая директория, то копирует файлы в нее.  
`cp <файл>{,.copy}` - быстрое создание резервной копии файла.

`rsync -av --progress <откуда> <куда>[ --exclude <исключение>[ ...]]` - копирует файлы.

`mv <откуда>[ ...] <куда>` - перемещает или переименовывает файлы, если `<куда>` - существующая директория, то перемещает файлы в нее.

`ln <имя> <файл>` - создает жесткую ссылку на файл. Таким образом, получается что файл присутствует в системе под несколькими разными именами. Файл существует до тех пор, пока с его инодом связано хотя бы одно имя. Понятия "*жесткая ссылка на файл*" и "*имя файла*" являются синонимами.

`ln -s <имя> <объект>` - создает символьную ссылку на любой объект (файл, директория, сокет...) любой файловой системы. *Симлинк* это специальный вид файла, который ссылается на другой файл по имени, а не напрямую на инод. Симлинки не предохраняют файл от удаления.

`locate <файл>` - выводит все места расположения файла с таким именем.

`rm <файл>[ ...]` - удаляет файлы. Опции:
- `-i` - запрашивает у пользователя подтверждение удаления каждого файла;
- `-f` - без подтверждения.

`rmdir <каталог>` - удаляет **пустой** каталог.  
`rm -rf <каталог>` - удаляет рекурсивно файлы и каталоги в указаном каталоге.

`<команда> | xargs <команда> [<начальный_аргумент>[ ...]]` - объединяет зафиксированный набор заданных в командной строке начальных аргументов с аргументами, прочитанными со стандартного ввода, и выполняет указанную команду.
> `ls -1 | xargs git diff`

Просмотр записи в текстовый файл в реальном времени:  
`tailf <файл>`  
`tail -f <файл>`

`head -n <количество_строк> <файл>` - выводит только указаное количество первых строк.

`tail -n <количество_строк> <файл>` - выводит только указаное количество последних строк.

`df [-h]` - показывает список всех файловых систем по именам устройств, сообщает их размер, занятое и свободное пространство и точки монтирования [отобразит размер в человеко-читаемом формате, добавив названия единиц].

`time <команда>` - выводит время выполнения команды.

`watch <команда>` - следит за изменениями в выводе команды.

`touch <файл>` - изменяет временные метки файла или создает его, если его нет.  
`> <файл>` - очистка файла или его создание.

`truncate -s <размер_в_байтах> <файл>` - усекает размер файла до `<размер_в_байтах>`.

`mkdir [-p] <путь>` - производит создание директории [и всех вложенных директорий, если они отсутствуют].
> `mkdir -p my-app/{css,js}` - создание нескольких поддерикторий

Вывод файла в консоль:  
`cat <файл1>[ ...]`  
`more <файл>`

`less[ <файл>]` - постранично выводит содержимое файла или из стандартного потока ввода. Управление:
- `Пробел` - перемещение на следующий экран;
- `B` - перемещение на предыдущий экран;
- `Q` - выход;
- `N` - продолжение поиска. Поиск происходит вводом:
    - `/<строка_поиска>` - поиск в прямом направлении;
    - `?<строка_поиска>` - поиск в обратном направлении.

`diff [-u] <файл1> <файл2>` - сравнивает два файла.

`file <файл>` - выводит информацию о файле.

Преобразование символов из входящего потока в исходящий:  
`tr "<строка1>" "<строка2>"` - замена каждого символа из входящего потока, который соответствует символу из `"<строка1>"` на соответствующий ему символ по позиции из `"<строка2>"`.  
`tr -d "<строка>"` - удаляет все вхождения символов, указанных в `"<строка>"`.

`sort [-n] [-r]` - сортирует данные в соответствии с какими-либо критериями [`-n` в порядке следования чисел] [`-r` - обратная сортировка], например, арифметически по второму столбцу.

`uniq` - удаляет повторяющиеся строки. Или (с ключом `-с`) не просто удалить, а написать сколько таких строк было. Учитываются только подряд идущие одинаковые строки, поэтому часто данные сортируются перед тем как отправить их на вход программе.

`host <dns_домен>` - возвращает ip-адрес указаного домена и все его dns-алиасы.

`md5sum <файл>` - возвращает md5-хеш для файла.

`cat /proc/cpuinfo` - выводит информацию о процессоре.  
`cat /proc/meminfo` - выводит информацию о памяти.

`du -sh <каталог>` - выводит размер директории.  
`du -sh *` - выводит размер файлов и директорий в текущем каталоге.

`free -m` - показывает объем оперативной памяти, весь, свободный и занятый в МБ.

`wc <файл>` - выводящая число (количество) переводов строк, слов и байт для каждого указанного файла и итоговую строку, если было задано несколько файлов. Если входной файл не задан, или равен `-`, то данные считываются со стандартного ввода. Флаги:
- `-l` - только количество строк;
- `-c` - только количество байт;
- `-m` - только количество символов;
- `-L` - только длину самой длинной строки;
- `-w` - только количество слов.

> `ls | wc -l` - считает количество файлов.

`xxd -p <файл>` - выводит в hex-формате содержимое файла

> `xxd -p <файл> | tr -d '\n'` - то же самое, только в одну строку.

`date` - выводит текущую дату в консоль.  
`date +%s` - выводит текущую дату в консоль в секундах.

`cal` - выводит календарь для текущего месяца.

`uptime` - выводит время работы сервера.

`type <команда>` - выводит тип команды и ее расположение.  
`type -t <команда>` - выводит только тип команды.  
`type -a <команда>` - выводит все расположение команды и ее алиасы.

`command -v <команда>` - возвращает путь к команде.  
`command -V <команда>` - возвращает только путь к команде.

`whereis <приложение>` - выводит все возможные местоположения (расположение) программы.

`which <приложение>` - выводит местоположение программы, которое вызовется по умолчанию.

`uname -or` - выводит версию Linux.  
`cat /proc/version` - выводит информацию о версии Linux.

`yum repolist -v` - (CentOS) выводит список подключенных репозиториев.  
`rpm -qa`- выводит список установленных пакетов.

`clear` - очищает терминал.