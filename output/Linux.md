[Содержание](#Содержание)
==========

- [Основы скриптов bash](#Основы-скриптов-bash)
    - [Основные файлы для запуска](#Основные-файлы-для-запуска)
    - [Перехват ошибок](#Перехват-ошибок)
    - [Основные понятия](#Основные-понятия)
    - [Специальные символы](#Специальные-символы)
    - [Сочетания клавиш для командной строки](#Сочетания-клавиш-для-командной-строки)
        - [Запуск](#Запуск)
        - [Строение файла скрипта](#Строение-файла-скрипта)
            - [Строки](#Строки)
            - [Вывод `echo`](#Вывод-echo)
                - [Изменение цвета текста и фона в расширенном режиме `-e`](#Изменение-цвета-текста-и-фона-в-расширенном-режиме--e)
                - [Перемещение курсора](#Перемещение-курсора)
    - [Переменные](#Переменные)
        - [Встроенный документ](#Встроенный-документ)
        - [Встроенная строка](#Встроенная-строка)
        - [Переменные окружения](#Переменные-окружения)
            - [Специальные переменные окружения](#Специальные-переменные-окружения)
    - [Конструкция if-then-else](#Конструкция-if-then-else)
        - [Сравнения и проверки](#Сравнения-и-проверки)
            - [Сравнение чисел](#Сравнение-чисел)
            - [Сравнение строк](#Сравнение-строк)
            - [Проверки файлов](#Проверки-файлов)
    - [Циклы](#Циклы)
        - [Цикл `for`](#Цикл-for)
        - [Установка разделителей полей](#Установка-разделителей-полей)
        - [Обход директорий](#Обход-директорий)
        - [Цикл `for` в стиле C](#Цикл-for-в-стиле-C)
        - [Цикл `while`](#Цикл-while)
        - [Цикл `until`](#Цикл-until)
        - [Команда `break`](#Команда-break)
        - [Команда `continue`](#Команда-continue)
        - [Перенаправление вывода цикла](#Перенаправление-вывода-цикла)
    - [Параметры командной строки](#Параметры-командной-строки)
        - [Команда `shift`](#Команда-shift)
    - [Конструкция case](#Конструкция-case)
    - [Функции](#Функции)
        - [Переменные](#Переменные)
        - [Массив](#Массив)
        - [Операции со строками](#Операции-со-строками)
    - [Создание и использование библиотек](#Создание-и-использование-библиотек)
    - [Стандартные ключи Linux](#Стандартные-ключи-Linux)
    - [Ввод значений от пользователя](#Ввод-значений-от-пользователя)
    - [Дескрипторы файлов](#Дескрипторы-файлов)
        - [Перенаправление потоков ошибок и вывода](#Перенаправление-потоков-ошибок-и-вывода)
        - [Временное перенаправление вывода](#Временное-перенаправление-вывода)
        - [Постоянное перенаправление вывода](#Постоянное-перенаправление-вывода)
        - [Перенаправление ввода в скриптах](#Перенаправление-ввода-в-скриптах)
        - [Создание собственного перенаправления вывода](#Создание-собственного-перенаправления-вывода)
        - [Получение сведений об открытых дескрипторах](#Получение-сведений-об-открытых-дескрипторах)
        - [Подавление вывода](#Подавление-вывода)
    - [Конвеер Pipe `|`](#Конвеер-Pipe-)
        - [Именованные каналы](#Именованные-каналы)
    - [Сигналы Linux](#Сигналы-Linux)
        - [Основные сигналы](#Основные-сигналы)
        - [Временная остановка процесса](#Временная-остановка-процесса)
        - [Перехват сигналов](#Перехват-сигналов)
    - [Выполнение сценариев командной строки в фоновом режиме](#Выполнение-сценариев-командной-строки-в-фоновом-режиме)
    - [Планирование запуска скриптов](#Планирование-запуска-скриптов)
    - [Запуск скриптов по расписанию](#Запуск-скриптов-по-расписанию)
- [`sed`](#sed)
    - [Опции](#Опции)
        - [Дополнительные ключи](#Дополнительные-ключи)
        - [Флаги](#Флаги)
        - [Символы-разделители](#Символы-разделители)
        - [Выбор фрагментов текста для обработки](#Выбор-фрагментов-текста-для-обработки)
        - [Удаление строк](#Удаление-строк)
        - [Вставка текста в поток](#Вставка-текста-в-поток)
        - [Замена строк](#Замена-строк)
        - [Замена символов](#Замена-символов)
        - [Вывод номеров строк](#Вывод-номеров-строк)
        - [Чтение данных для вставки из файла](#Чтение-данных-для-вставки-из-файла)
        - [Регулярные выражения](#Регулярные-выражения)
- [`awk`](#awk)
    - [Опции](#Опции)
    - [Программа](#Программа)
        - [Позиционные переменные, хранящие данные полей](#Позиционные-переменные-хранящие-данные-полей)
        - [Файл скрипта](#Файл-скрипта)
        - [Выполнение команд до начала обработки данных](#Выполнение-команд-до-начала-обработки-данных)
        - [Выполнение команд после окончания обработки данных](#Выполнение-команд-после-окончания-обработки-данных)
        - [Встроенные переменные](#Встроенные-переменные)
        - [Условный оператор](#Условный-оператор)
        - [Цикл while](#Цикл-while)
        - [Цикл for](#Цикл-for)
    - [Форматированный вывод данных](#Форматированный-вывод-данных)
        - [Символы](#Символы)
        - [Модификаторы](#Модификаторы)
    - [Встроенные математические функции](#Встроенные-математические-функции)
    - [Строковые функции](#Строковые-функции)
    - [Пользовательские функции](#Пользовательские-функции)
- [Регулярные выражения](#Регулярные-выражения)
    - [Специальные классы символов](#Специальные-классы-символов)
- [Структура Linux](#Структура-Linux)
    - [Ядро](#Ядро)
    - [Каталоги](#Каталоги)
    - [Устройства](#Устройства)
        - [Блочные устройства](#Блочные-устройства)
    - [Область подкачки](#Область-подкачки)
    - [Устройство файловой системы](#Устройство-файловой-системы)
    - [Загрузка ядра](#Загрузка-ядра)
        - [Команда `systemd`](#Команда-systemd)
            - [Основные команды](#Основные-команды)
- [Архивирование](#Архивирование)
    - [`tar`](#tar)
        - [Запаковывание](#Запаковывание)
        - [Распаковывание](#Распаковывание)
        - [Вывод содержания](#Вывод-содержания)
        - [Добавление к концу архива файла](#Добавление-к-концу-архива-файла)
    - [`gzip`](#gzip)
    - [`bzip2`](#bzip2)
    - [`zip`](#zip)
- [`wget`](#wget)
- [`grep`](#grep)
- [`rsync`](#rsync)
- [Процессы](#Процессы)
    - [`ps`](#ps)
        - [Выводимая информация](#Выводимая-информация)
    - [`top`](#top)
    - [`kill`](#kill)
    - [`pkill`](#pkill)
    - [`killall`](#killall)
    - [Остановка системы](#Остановка-системы)
    - [Другие команды](#Другие-команды)
- [`ssh`](#ssh)
    - [`scp`](#scp)
    - [`sftp`](#sftp)
- [`screen`](#screen)
- [wildcards - шаблоны замены](#wildcards---шаблоны-замены)
- [Поиск файлов](#Поиск-файлов)
    - [`find`](#find)
- [Пользователи и группы](#Пользователи-и-группы)
- [Права и владение файлами](#Права-и-владение-файлами)
    - [Права](#Права)
    - [Владение](#Владение)
- [Сеть](#Сеть)
    - [Установка DNS](#Установка-DNS)
- [Пакеты](#Пакеты)
- [Сервисы](#Сервисы)
- [Команды для файловой системы](#Команды-для-файловой-системы)
- [Команды для обработки текста](#Команды-для-обработки-текста)
- [Команды для форматирования вывода](#Команды-для-форматирования-вывода)
- [Компиляция программ](#Компиляция-программ)
    - [`configure`](#configure)
    - [`make`](#make)
- [Другие команды](#Другие-команды)
    - [Разное](#Разное)

<a id="Основы-скриптов-bash" href="#Основы-скриптов-bash">Основы скриптов bash</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====================

## <a id="Основные-файлы-для-запуска" href="#Основные-файлы-для-запуска">Основные файлы для запуска</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При сеансе командной оболочки входа (login shell session) выполняются файлы:
- `/etc/profile` - обшесистемный файл для всех пользователей;
- `~/.bash_profile` - личный файл для пользователя для расширения обшесистемного файла;
- `~/.bash_login` - личный файл, когда файл `~/.bash_profile` отсутствует;
- `~/.profile` - личный файл, когда файлы `~/.bash_profile` и `~/.bash_login` отсутствуют.

При сеансе простой командной оболочки (non-login shell session) выполняются файлы:
- `/etc/bash.bashrc` - обшесистемный файл для всех пользователей;
- `~/.bashrc` - личный файл для пользователя для расширения обшесистемного файла.

## <a id="Перехват-ошибок" href="#Перехват-ошибок">Перехват ошибок</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`set -euo pipefail` - обозначает установку строгого режима, обычно пишется в первых строках скрипта, где:
- `e` - останавливает выполнение команды в случае ошибки в скрипте;
- `u` - вызывает ошибку при доступе к несуществующим переменным;
- `o` и `pipefail` - вызывает ошибку в случае ошибки в пайплайне.

`set -x` - включает трассировку и тогда в консоль выводятся команды после применения подстановки с символом `+`, который задается переменной окружения `PS4` (`export PS4='$LINENO + '` - добавляет вывод номера строки).  
`set +x` - выключает трассировку.

## <a id="Основные-понятия" href="#Основные-понятия">Основные понятия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Сценарии командной строки** - это наборы команд, которые можно вводить с клавиатуры, собранные в файлы и объединенные некоей общей целью. При этом результаты работы команд могут представлять либо самостоятельную ценность, либо служить входными данными для других команд.

## <a id="Специальные-символы" href="#Специальные-символы">Специальные символы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Символ  | Название             | Применение
------- | -------------------- | ---------
`*`     | Звездочка            | Регулярные выражения, джокерные символы
`.`     | Точка                | Текущий каталог, разделитель имени файла и хоста
`!`     | Восклицательный знак | Отрицание, история команд
`|`     | Вертикальная черта   | Командный конвейер
`/`     | Прямой слеш          | Разделитель каталогов, команда поиска
`\`     | Обратный слеш        | Литералы, макросы (но не каталоги)
`$`     | Доллар               | Обозначение переменной, конец строки
`'`     | Одиночная кавычка    | Буквенные строки
`` ` `` | "Обратная галочка"   | Замена команды
`"`     | Двойная кавычка      | Частично буквенные строки
`^`     | Знак вставки         | Отрицание, начало строки
`~`     | Тильда               | Отрицание, ярлык каталога
`#`     | Диез, знак фунта     | Комментарии, препроцессор, подстановки
`[ ]`   | Квадратные скобки    | Массивы
`{ }`   | Фигурные скобки      | Блоки инструкций, массивы
`_`     | Подчеркивание        | Просто замена символа пробела

`^<клавиша>` = `Ctrl + <клавиша>`

## <a id="Сочетания-клавиш-для-командной-строки" href="#Сочетания-клавиш-для-командной-строки">Сочетания клавиш для командной строки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сочетание клавиш | Действие
---------------- | --------
`Ctrl + B`       | Перемещение курсора влево
`Ctrl + F`       | Перемещение курсора вправо
`Ctrl + P`       | Просмотр предыдущей команды (или перемещение курсора вверх)
`Ctrl + N`       | Просмотр следующей команды (или перемещение курсора вниз)
`Ctrl + A`       | Перемещение курсора в начало строки
`Ctrl + E`       | Перемещение курсора в конец строки
`Ctrl + W`       | Удаление предыдущего слова
`Ctrl + U`       | Удаление текста от курсора до начала строки
`Ctrl + K`       | Удаление текста от курсора до конца строки
`Ctrl + Y`       | Вставка удаленного текста (например, после команды `CTRL+U`)

### <a id="Запуск" href="#Запуск">Запуск</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для того чтобы сценарий запускался ему необходимо установить разрешение, сделать его выполняемым:  
`chmod +x ./<имя_файла>`  
`./<имя_файла>` - запускает скрипт

### <a id="Строение-файла-скрипта" href="#Строение-файла-скрипта">Строение файла скрипта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Первая строка должна быть такого вида:  
`#!/bin/bash`

`#!<имя_интерпритатора>` - в первой строке указывает на имя интерпретатора, который должен использоваться для выполнения следующего за ним текста сценария.

Команды оболочки отделяются знаком перевода строки или знаком точки с запятой `;`, комментарии выделяют знаком решетки `#`.

`<команда1> && <команда2>` - выполняет команду `<команда2>` только если команда `<команда1>` выполнилась успешно.

`<команда1> || <команда2>` - выполняет команду `<команда2>` только если команда `<команда1>` не выполнилась успешно.

`{ <команда1>; <команда2>; [<команда3>; ...] }` - группирует команды.  
`(<команда1>; <команда2>; [<команда3>; ...])` - создает подоболочку команд, которая выполняется в дочерней копии текущей командной оболочки.

Сгруппированные команды и команды в оболочке, можно перенаправлять с использованием конвеера `|` или в файл `>`.
> `{ ls -l; echo "Listing of foo.txt"; cat foo.txt; } > output.txt`

`<(<команда1>; <команда2>; [<команда3>; ...])` - используется для подстановки результата вывода команд в другую команду.
> `read < <(echo "foo")`

`>(<команда1>; <команда2>; [<команда3>; ...])` - используется для подстановки результата ввода в команды из другой команды.

Команды можно переносить по строкам с помощью экранирования символа переноса строки: `\`:
```bash
find playground \
    -type f \
    -not -perm 0600 \
    -exec chmod 0600 '{}' ';'
```

`!!` - алиас предыдущей команды.

`exit [<код>]` - завершает выполнение сценария с кодом завершения равным 0 [указаннм кодом].

#### <a id="Строки" href="#Строки">Строки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`"<текст>"` - при объявлении строки в таком формате будут работать только символы `$`, `\`, `` ` ``. Для их экранирования нужно использовать символ `\`.

`'<текст>'` - при объявлении строки в таком формате подавлены все символы подстановки.

Для вывода кавычек в строках используется экранировани с помощью символа `\` перед кавычкой.

Строки в кавычках могут содержать символы перевода строк, которые не влияют и остаются только в строке и строка оканчивается только кавычкой.

#### <a id="Вывод-echo" href="#Вывод-echo">Вывод `echo`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`echo [-n] [-e] "<текст>"` - выводит текст (список своих аргументов после флага в консоль) в консоль, для вывода знака `$` нужно писать `\$` [, `-n` - без перехода на новую строку] [, `-e` - расширенный режим для возможности интерпритации управляющи последовательностей].

> `echo "Home for the current user is: $HOME"`

##### <a id="Изменение-цвета-текста-и-фона-в-расширенном-режиме--e" href="#Изменение-цвета-текста-и-фона-в-расширенном-режиме--e">Изменение цвета текста и фона в расширенном режиме `-e`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`\033[<атрибут_1>[;<атрибут_2>[;...]]m` - выводит последующие символы, с указанными характеристиками.  
`\u001b[<атрибут_1>[;<атрибут_2>[;...]]m` - аналогично.

Значения общих атрибутов:
- `0` - сбросить все атрибуты;
- `1` - bright (повышенная яркость);
- `2` - dim (затемнение);
- `4` - underscore (нижнее подчеркивание);
- `5` - blink (мигание);
- `7` - reverse (инверсия);
- `8` - hidden (скрыть текст).

Значения атрибутов цвета шрифта:
- `30` - black (черный);
- `31` - red (красный);
- `32` - green (зеленый);
- `33` - yellow (желтый);
- `34` - blue (синий);
- `35` - magenta (пурпурный);
- `36` - cyan (голубой);
- `37` - white (белый).

Значения атрибутов цвета фона:
- `40` - black (черный);
- `41` - red (красный);
- `42` - green (зеленый);
- `43` - yellow (желтый);
- `44` - blue (синий);
- `45` - magenta (пурпурный);
- `46` - cyan (голубой);
- `47` - white (белый).

> `\033[33msome text\033[0m`

##### <a id="Перемещение-курсора" href="#Перемещение-курсора">Перемещение курсора</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Производится с помощью управляющих последовательностей:
- `\033[<номер_строки>;<номер_колонки>H` - перемещает курсор в строку `<номер_строки>` и позицию `номер_колонки>`;
- `\033[<количество>A` - перемещает курсор в вверх на `<количество>` строк;
- `\033[<количество>B` - перемещает курсор в вниз на `<количество>` строк;
- `\033[<количество>C` - перемещает курсор в вперед (вправо) на `<количество>` символов;
- `\033[<количество>D` - перемещает курсор в назад (влево) на `<количество>` символов;
- `\033[2J` - очищает экран и помещает курсор в левый верхний угол (строка 0, позиция 0);
- `\033[K` - очищает экран от позиции курсора до конца текущей строки;
- `\033[s` - сохраняет текущую позицию курсора;
- `\033[u` - восстанавливает сохраненную позицию курсора.

## <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<имя_переменной>=<значение>` - установка значения переменной.
> `person="Adam"`

`declare -u <имя_переменной>` - объявляет переменную, в которой значение будет всегда хранится в верхнем регистре.  
`declare -l <имя_переменной>` - объявляет переменную, в которой значение будет всегда хранится в нижнем регистре.
> `declare -u upper;`

`$<имя_переменной>` - возвращает значение переменной или подставляет его в строку.  
`${<имя_переменной>}` - аналогично.
> `echo "Current script is ${srcipt}";`

`${<имя_переменной>:-<значение_по_умолчанию>}` - подстановка значения по умолчанию, если переменная не определена или имеет пустое значение.
> `echo ${foo:-"substitute value if unset"}`

`${<имя_переменной>:=<значение_по_умолчанию>}` - установка значения по умолчанию переменной, если переменная не определена или имеет пустое значение и подстановка его.
> `echo ${foo:="default value if unset"}`

`${<имя_переменной>:?<значение_ошибки>}` - если переменная не определена или содержит пустое значение, то сценарий завершится с ошибкой и выводом `<значение_ошибки>` в поток ошибок.
> `echo ${foo:?"parameter is empty"}`

`${<имя_переменной>:+<значение>}` - подстановка пустого значения, если переменная не определена или имеет пустое значение, иначе вернет значение.
> `echo ${foo:+"substitute value if set"}`

`${<имя_переменной>,,}` - возвращает значение переменной в которой все символы преобразовыны в верхний регистр.  
`${<имя_переменной>,}` - возвращает значение переменной в которой первый символ преобразован в верхний регистр.  
`${<имя_переменной>^^}` - возвращает значение переменной в которой все символы преобразовыны в нижний регистр.  
`${<имя_переменной>^}` - возвращает значение переменной в которой первый символ преобразован в нижний регистр.
> `echo "${1^^}"`

``<имя_переменной>=`<команда>` `` - записывает результат вывода команды в переменную.  
`<имя_переменной>=$(<команда>)` - аналогично.
```
mydir=`pwd`;
mydir2=$(pwd);
```

`<имя_переменной>=$((<выражение>))` - вычисляет арифметическое выражение и возвращает его значение.  
`<имя_переменной>=$[<выражение>]` - аналогично.
> `var2=$(( $var1 * 2 ))`

`expr "<выражение>"` - вычисляет математическое выражение и возвращает его результат.
> `a=$( expr 10 - 3 )`

Если переменная используется в качестве подстановки куда-то, то ее следует всегда заключать в кавычки, это предохранит от пустых строк или строк с пробелами.

`${!<префикс>*}` - возвращает список переменных, которые начинаются с указанного префикса.  
`${!<префикс>@}` - аналогично.
> `echo ${!BASH*}`

### <a id="Встроенный-документ" href="#Встроенный-документ">Встроенный документ</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для записи многострочного текста в переменную, поток или команду используется конструкция с использованием **встроенного документа** (here document), в котором кавычки являются просто символами и внутри можно использовать переменные `${}` и выполнять команды `$()`, которые свой поток вывода запишут в документ, где `<команда>` - это имя команды, принимающей указанный текст через стандартный ввод, а `<индикатор>` - это строка, отмечающая конец встроенного текста:
```bash
<команда> << <индикатор>
<текст>
<индикатор>
```

`<<-` - указывает игнорировать начальные символы табуляции во встроенном документе.

```bash
html=$(cat <<EOF
big "text"
with new line: ${new_line}
<h2>Disk Space Utilization</h2>
<pre>$(df -h)</pre>
EOF
)
```

### <a id="Встроенная-строка" href="#Встроенная-строка">Встроенная строка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Встроенная строка** (here string) подобна встроенному документу, только короче, она простирается лишь до конца текущей строки кода: `<команда> <<< <строка>`:
> `cut -d ":" -f 2 <<< "User:delorian"` = `echo "User:delorian" | cut -d ":" -f 2`

### <a id="Переменные-окружения" href="#Переменные-окружения">Переменные окружения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`export <имя_переменной>` - экспортирует переменную как переменную окружения с указанным значением, которая будет доступна дочерним процессам этой оболочки.
> `export STUFF`

`printenv [<имя>]` - выводит список всех [только значние указанной с именем `<имя>`] переменных окружения с их значениями.

`set` - выводит список всех переменных окружения и оболочки с их значениями.

Переменные окружения можно указывать перед командами и тогда они будут установлены в эти значения только для этой команды и не будут влиять на окружающие: `<имя_переменной_1>=<значение>[ ...] <команда>`.
> `IFS=":" read user pw uid gid name home shell`

#### <a id="Специальные-переменные-окружения" href="#Специальные-переменные-окружения">Специальные переменные окружения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`PATH` - содержит командный путь для поиска команд, пути разделяются знаком `:`.

`PS1` - содержит приглашение ко вводу в терминале, состоит из специальных символов.

`RANDOM` - содержит случайное число из диапазона от 1 до 32 767, и при каждом обращении возвращает разное.

## <a id="Конструкция-if-then-else" href="#Конструкция-if-then-else">Конструкция if-then-else</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
if <команда>; then
    <команды>
[elif <команда>; then
    <команды>]
[else
    <команды>]
fi
```

> `if ps aux | grep some_proces[s] > /tmp/test.txt; then echo 1; else echo 0; fi`

Если выполнение команды `<команда>` завершится успешно, а именно будет возвращено `0`, то выполнятся команды от `then` и до `elif` / `else` / `fi` [, иначе выполнятся команды от `else` и до `fi`].

Команда в условии может быть не одной, а содержать конструкции `&&` и `||` или быть списком комадн разделенных `;`.

Команда `true` - всегда завершается кодом `0`.  
Команда `false` - всегда завершается кодом `1`.

`$?` - переменная, которая содержит код завершения предыдущей команды.

### <a id="Сравнения-и-проверки" href="#Сравнения-и-проверки">Сравнения и проверки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`test <выражение>` - выполняет проверку выражения и если проверка успешна, то завершается кодом `0`, а иначе кодом `1`.  
`[ <выражение> ]` - аналогично.

`[[ <выражение> ]]` - расширенный вариант команды `test`, которая выполняет сравнение более стандартным способом, пишущим на других языках программирования.

Условие, находящееся внутри квадратных скобок может быть проверено без использования оператора `if`: `[ <выражение> ]` или `[[ <выражение> ]]`.
> `[[ -d "$dir_name" ]] && cd "$dir_name" && rm *`

Круглые скобки `((<выражение>))` и предложение `let <выражение>` возвращают код 0, если результатом арифметического выражения является ненулевое значение.

`let <выражение>` - позволяет вычислить выражение и записать его в переменную.
> `let a=5+4`  
> `let "a = $1 + 30"`

Выражение должно быть заключено в квадратные скобки `[ <выражение> ]` и использоваться вместо команды `<команда>`.

Операторы `&&`, `||`, `<` и `>`, `(` и `)` внутри `[[ ]]` вполне допустимы, в то время как внутри `[ ]` порождают сообщения об ошибках.

Скобки `()` для группировки внутри выражений в `[[ ]]` можно использовать, а в `[ ]` их необходимо экранировать.

Логические операторы:
Операция | `test` | `[[ ]]` и `(( ))`
-------- | ------ | -----------------
И        | `-a`   | `&&`
ИЛИ      | `-o`   | `||`
НЕ       | `!`    | `!`

Оператор отрицания `!` обращает результат выражения.

> `[[ ! ("$INT" -ge "$MIN_VAL" && "$INT" -le "$MAX_VAL") ]]`  
> `[ ! \( "$INT" -ge "$MIN_VAL" -a "$INT" -le "$MAX_VAL" \) ]`

#### <a id="Сравнение-чисел" href="#Сравнение-чисел">Сравнение чисел</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `<число1> -eq <число2>` - возвращает истинное значение, если `<число1>` равно `<число2>`;
- `<число1> -ge <число2>` - возвращает истинное значение, если `<число1>` больше или равно `<число2>`;
- `<число1> -gt <число2>` - возвращает истинное значение, если `<число1>` больше `<число2>`;
- `<число1> -le <число2>` - возвращает истинное значение, если `<число1>` меньше или равно `<число2>`;
- `<число1> -lt <число2>` - возвращает истинное значение, если `<число1>` меньше `<число2>`;
- `<число1> -ne <число2>` - возвращает истинное значение, если `<число1>` не равно `<число2>`.
> `[ $val1 -gt 5 ]`

Вместо чисел можно использовать переменные.

#### <a id="Сравнение-строк" href="#Сравнение-строк">Сравнение строк</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `"<строка1>" = "<строка2>"` - проверяет строки на равенство, возвращает истину, если строки идентичны;
- `"<строка1>" != "<строка2>"` - возвращает истину, если строки не идентичны;
- `"<строка1>" \< "<строка2>"` - возвращает истину, если `<строка1>` меньше, чем `<строка2>`;
- `"<строка1>" \> "<строка2>"` - возвращает истину, если `<строка1>` больше, чем `<строка2>`;
- `-n "<строка>"` - возвращает истину, если длина `<строка>` больше нуля;
- `"<строка>"` - возвращает истину, если `<строка>` не пустая;
- `-z "<строка>"` - возвращает истину, если длина `<строка>` равна нулю.
> `[ $val = "user" ]`

Вместо строк можно использовать переменные, но их нужно заключать в кавычки `"`.
> `[ $val1 \> "$val2" ]`

В `[[ ]]` можно использовать:
- `"<строка>" =~ <регулярное_выражение>` - возвращает истину, если строка соответствует расширенному регулярному выражению:
    > `[[ "$INT" =~ ^-?[0-9]+$ ]]`
- `"<строка>" == <шаблон>` - возвращает истину, если строка соответствует шаблону:
    > `[[ $FILE == foo.* ]]`

#### <a id="Проверки-файлов" href="#Проверки-файлов">Проверки файлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `-d <файл>` - проверяет, существует ли файл, и является ли он директорией;
- `-e <файл>` - проверяет, существует ли файл;
- `-f <файл>` - проверяет, существует ли файл, и является ли он файлом;
- `-r <файл>` - проверяет, существует ли файл, и доступен ли он для чтения;
- `-s <файл>` - проверяет, существует ли файл, и не является ли он пустым;
- `-w <файл>` - проверяет, существует ли файл, и доступен ли он для записи;
- `-x <файл>` - проверяет, существует ли файл, и является ли он исполняемым;
- `<файл1> -nt <файл2>` - проверяет, новее ли `<файл1>`, чем `<файл2>`;
- `<файл1> -ot <файл2>` - проверяет, старше ли `<файл1>`, чем `<файл2>`;
- `-O <файл>` - проверяет, существует ли файл, и является ли его владельцем текущий пользователь;
- `-G <файл>` - проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя;
- `<файл>` - должен выглядеть как путь к файлу, если в нем есть пробелы, то он должен быть заключен в кавычки.
> `[ -d /home/likegeeks ]`

Вместо файл можно использовать переменные.
> `[ -d $mydir ]`

## <a id="Циклы" href="#Циклы">Циклы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Циклы можно вкладывать друг в друга.

### <a id="Цикл-for" href="#Цикл-for">Цикл `for`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
for <переменная> in <список>
do
    <команды>
done
```

В каждой итерации цикла в переменную `<переменная>` будет записываться следующее значение из списка `<список>`.

Список может быть набором значений разделенных разделителем полей (**пробел**, **знак табуляции**, **знак перевода строки** указанным с помощью `IFS`) или результатом вывода команды.

> `for i in distros*.txt; do echo "$i"; done`

```bash
for var in first "the second" "the third" fourth fifth
do
    echo The $var item
done
```

> `file="myfile"; for var in $(cat $file); do echo " $var"; done`

### <a id="Установка-разделителей-полей" href="#Установка-разделителей-полей">Установка разделителей полей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого нужно изменить переменную среды `IFS`:  
`IFS=$'\n'` - устанавливает в качестве разделителя - символ новой строки.  
`IFS=<символ>` - установка произвольного символа.  
`IFS="<символ>[...]"` - установка произвольных символов

### <a id="Обход-директорий" href="#Обход-директорий">Обход директорий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В качестве списка может быть указано путь к директории, подстановочный знак `*` - обозначает все.

> `for file in /home/likegeeks/*`

### <a id="Цикл-for-в-стиле-C" href="#Цикл-for-в-стиле-C">Цикл `for` в стиле C</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
for (( <выражение1>; <выражение2>; <выражение3> ))
do
    <команды>
done
```

Где `<выражение1>` инициализирует цикл, `<выражение2>` определяет условие завершения цикла, `<выражение3>` выполняется в конце каждой итерации.

Аналогично записи:
```bash
(( <выражение1> ))
while (( <выражение2> )); do
    <команды>
    (( <выражение3> ))
done
```

```bash
for (( i = 1; i <= 10; i++ ))
do
    echo "number is $i"
done
```

```bash
for (( i = 0; i < ${#scripts[@]}; i++ ))
do
    script=${scripts[$i]};
    (( i++ ));
    log=${scripts[$i]};
    > ${log};
    echo "Run script '${script}' to log '${log}'";
    ${script} &> ${log} &
done
```

### <a id="Цикл-while" href="#Цикл-while">Цикл `while`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
while <команда>
do
    <команды>
done
```

`while <команда>; do <команды>; done`

Будет выполнять тело цикла до тех пор, пока код завершения `<команда>` равен `0`.

Вместо команды `<команда>`, можно использовать выражение.

```bash
count=1;
while [[ $count -le 5 ]]; do
      echo $count;
      count=$((count + 1));
done
echo "Finished."
```

В цикл можно перенаправлять файл с помощью `<` после `done` или с помощью конвеера `|`.

```bash
while read distro version release; do
      printf "Distro: %s\tVersion: %s\tReleased: %s\n" \
      "$distro" \
      "$version" \
      "$release"
done < distros.txt
```

> `sort -k 1,1 -k 2n distros.txt | while read distro; do echo $distro; done`

### <a id="Цикл-until" href="#Цикл-until">Цикл `until`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
until <команда>
do
    <команды>
done
```

`until <команда>; do <команды>; done`

Подобно циклу `while`, только будет выполнять тело цикла до тех пор, пока код завершения `<команда>` не будет равен `0`.

### <a id="Команда-break" href="#Команда-break">Команда `break`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Эта команда позволяет прервать выполнение цикла.

### <a id="Команда-continue" href="#Команда-continue">Команда `continue`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Эта команда завершает текущую итерацию досрочно и начинает следующую, при этом выхода из цикла не происходит.

### <a id="Перенаправление-вывода-цикла" href="#Перенаправление-вывода-цикла">Перенаправление вывода цикла</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

После слова `done`, на той же сточке можно указать перенаправление в файл: `done > <файл>`.
> `done > myfile.txt`

## <a id="Параметры-командной-строки" href="#Параметры-командной-строки">Параметры командной строки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Параметры командной строки разделяются из переменной `IFS`.

**Специальные переменные** - позиционные параметры, введенные при вызове скрипта параметры командной строки, можно получить:
- `$0` - имя скрипта;
- `$1` - первый параметр;
- `$<n>` - n-ый параметр, вплоть до переменной $9;
- `${<n>}` - n-ый параметр, от 10;
- `$#` - содержит количество параметров, переданных сценарию при вызове;
- `${!#}` - содержит последний параметр;
- `$*` - содержит все параметры командной строки (от `$1`), в виде единого "*слова*" разделенных через пробел (`IFS`);
- `$@` - содержит все параметры командной строки (от `$1`), где параметры разбиты на отдельные "*слова*". Эти параметры можно перебирать в циклах.

Для прокидывания всех параметров как есть в другую команду или функцию используется конструкция `"$@"`.
> `echo "$@"`

### <a id="Команда-shift" href="#Команда-shift">Команда `shift`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Она, по умолчанию, сдвигает значения позиционных параметров влево: `$<n>` становится `$<n-1>`, при этом `$0`, не меняется. Значение `$#` при этом уменьшается на 1.

## <a id="Конструкция-case" href="#Конструкция-case">Конструкция case</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
case "<строка>" in
<шаблон_1_1>[ | <шаблон_1_2> [...]]) <команды> ;;
# ...
*) <команды_при_не_совпадении> ;;
esac
```

`;;&` - позволяет команде `case` продолжить проверку вместо простого завершения после первого найденного совпадения.

```bash
PROGNAME="$(basename "$0")";
usage () {
    echo "$PROGNAME: usage: $PROGNAME [-f file | -i]";
    return;
}
interactive=
filename=
while [[ -n "$1" ]]; do
    case "$1" in
        -f | --file)
            shift;
            filename="$1";
            ;;
        -i | --interactive)
            interactive=1;
            ;;
        -h | --help)
            usage;
            exit;
            ;;
        *)
            usage >&2;
            exit 1;
            ;;
    esac
    shift;
done
```

Сверяет `<строка>` с шаблонами и выполняет указанные команды при соответствии шаблона строке. Если соответствия не найдется, будет исполнена ветвь `*`.

Шаблоны обрабатываются командой `case` точно так же, как пути механизмом подстановки.
> `*.txt)`

Последовательность - двойное тире `--` - признак окончания ключей.

## <a id="Функции" href="#Функции">Функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объявление функции, имена для функций, должны быть уникальными, так как новая функция затирает старую.

```bash
function <имя_функции> [()] {
# <имя_функции> () { # альтернативное объявление
    <код>
    [return <значение>] # целочисленный код завершения
}
```

`return <значение>` - позволяет задавать возвращаемый функцией целочисленный код завершения.

Первый переданный аргумент в функцию содержится в `$1`, второй - в `$2`, и так далее, а количество переданных аргументов в `$#`, `$@` - содержит все аргументы в виде массива.

```bash
msg () {
    echo >&2 -e "${1-}"
}
```

`<имя_функции> [<аргумент> [...]]` - вызов функции.
> `msg "This is text"`

В переменной `$?` хранится код возврата последней выполненной команды в том числе и функции, тогда максимальное число, которое может вернуть команда `return` - `255`.

`<переменная>=$(<имя_функции> [<аргумент> [...]])` - записывает в переменную результат функции.

Внутри функции можно вызвать саму функцию по имени.

`FUNCNAME` - переменная оболочки, которая содержит имя функции. Оболочка автоматически присваивает значение этой переменной в момент вызова функции.

### <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Глобальные переменные** - это переменные, которые видны из любого места bash-скрипта. По умолчанию все объявленные в скриптах переменные глобальны.  
**Локальные переменные** - их объявляют и используют внутри функции. Если за пределами функции есть переменная с таким же именем, это на нее не повлияет.

`local <имя_переменной>=<значение>` - установка значения локальной переменной для функции.

### <a id="Массив" href="#Массив">Массив</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<имя_переменной>=(<значение_1>[ ...])` - объявление массива (списка) состоящего из элементов.  
`<имя_переменной>=([<индекс_1>=]<значение_1>[ ...])` - объявление массива (списка) состоящего из элементов по указанным индексам.  
`declare -a <имя_переменной>` - объявление переменной типа массив с индесами в виде чисел.  
`declare -A <имя_переменной>` - объявление переменной типа массив с индесами в виде строк.  
`${<имя_переменной>[<индекс>]}` - возвращает значение по указанному индексу в массиве, `*` (`@`) - все.  
`${<имя_переменной>["<индекс>"]}` - аналогично для массивов с ключами в виде строк.  
`${!<имя_переменной>[@]}` - возвращает индексы массива.  
`${#<имя_переменной>[@]}` - возвращает размер массива.  
`<имя_переменной>[<индекс>]=<значение>` - перезаписывает элемент массива.  
`<имя_переменной>+=(<значение_1>[ ...])` - присоединяет к массиву значения.  
`<имя_переменной>=$(<команда>)` - сохраняет вывод команды в виде строки в переменную.  
`<имя_переменной>=( $(<команда>) )` - сохраняет вывод команды в виде массива.  
`${<имя_переменной>[@]:s:n}` - возвращает элементы массива начиная с элемента с индексом `s` до элемента с индексом `s+(n-1)`.

> `str=$(ls)`  
> `arr=( $(ls) )`

`unset <имя_переменной>` - удаляет массив.  
`unset '<имя_переменной>[<индекс>]'` - удаляет элемент из массива по индексу.

Любая ссылка на переменную-массив без индекса возвращает элемент с индексом 0.

Инициализация массива пустыми значениями может проводится с помощью цикла:
> `for i in {0..23}; do hours[i]=0; done`

Для передачи массива в функцию из него надо извлечь имеющиеся в нем данные и передать их функции как самостоятельные аргументы - `${<имя_переменной>[*]}`.

### <a id="Операции-со-строками" href="#Операции-со-строками">Операции со строками</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`${#<имя_переменной>}` - возвращает длину строки.  
`` `expr length $<имя_переменной>` `` - возвращает длину строки.  
`` `expr [match] "$<имя_переменной>" : '<регулярное_выражение>'` `` - возвращает длину строки, которая удолетворяет регулярному выражению.
> ``stringZ=abcABC123ABCabc; echo `expr match "$stringZ" 'abc[A-Z]*.2'` ``

`${<имя_переменной>:<смещение>[:<длина>]}` - возвращает подстроку начиная с символа с указанного смещения и до конца строки [указанной длины]. Если смещение отрицательное, то отсчет будет идти с конца строки и для этого перед смещением нужно поставить пробел ` `.  
`${<имя_переменной>:(-<длина>)}` - возвращает подстроку начиная с конца указанной длины.
> `${stringZ:(-4)}`

`` `expr [match] "$<имя_переменной>" : '[.*]\(<регулярное_выражение>\)'` `` - возвращает подстроку, которая удолетворяет регулярному выражению с начала строки [`.*` - с конца].
> `` `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'` ``

`${<имя_переменной>#<шаблон>}` - возвращает из пременной строку в которой удалена кратчайшая строка по шаблону с начала строки.  
`${<имя_переменной>##<шаблон>}` - возвращает из пременной строку в которой удалена длинная строка по шаблону с начала строки.  
`${<имя_переменной>%<шаблон>}` - возвращает из пременной строку в которой удалена кратчайшая строка по шаблону с конца строки.  
`${<имя_переменной>%%<шаблон>}` - возвращает из пременной строку в которой удалена длинная строка по шаблону с конца строки.
> `${stringZ#a*C}`

`${<имя_переменной>/<шаблон>/<строка>}` - возвращает из пременной строку в которой заменена строка по шаблону `<шаблон>` на строку `<строка>`.  
`${<имя_переменной>/#<шаблон>/<строка>}` - возвращает из пременной строку в которой заменена строка по шаблону `<шаблон>` на строку `<строка>` только если она находится в начале строки.  
`${<имя_переменной>/%<шаблон>/<строка>}` - возвращает из пременной строку в которой заменена строка по шаблону `<шаблон>` на строку `<строка>` только если она находится в конце строки.  
`${<имя_переменной>//<шаблон>/<строка>}` - возвращает из пременной строку в которой заменены все строки по шаблону `<шаблон>` на строки `<строка2>`.
> `${stringZ//abc/xyz}`  
> `${<имя_переменной>//:/$'\n'}`

Строку из переменной можно преобразавать к массиву, путем его создания: `<array>=(${<имя_переменной>//<разделитель>/ });`:
> `array=(${string//:/ })`

## <a id="Создание-и-использование-библиотек" href="#Создание-и-использование-библиотек">Создание и использование библиотек</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`source <путь_к_скрипту>` - подключает скрипт как библиотеку к скрипту и в результате функции, объявленные в библиотеке, становятся доступными в скрипте.  
`. <путь_к_скрипту>` - аналогично.
> `source .bashrc`

## <a id="Стандартные-ключи-Linux" href="#Стандартные-ключи-Linux">Стандартные ключи Linux</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `-a` - вывести все объекты;
- `-c` - произвести подсчет;
- `-d` - указать директорию;
- `-e` - развернуть объект;
- `-f` - указать файл, из которого нужно прочитать данные;
- `-h` - вывести справку по команде;
- `-i` - игнорировать регистр символов;
- `-l` - выполнить полноформатный вывод данных;
- `-n` - использовать неинтерактивный (пакетный) режим;
- `-o` - позволяет указать файл, в который нужно перенаправить вывод;
- `-q` - выполнить скрипт в quiet-режиме;
- `-r` - обрабатывать папки и файлы рекурсивно;
- `-s` - выполнить скрипт в silent-режиме;
- `-v` - выполнить многословный вывод;
- `-x` - исключить объект;
- `-y` - ответить `yes` на все вопросы.

## <a id="Ввод-значений-от-пользователя" href="#Ввод-значений-от-пользователя">Ввод значений от пользователя</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`read <имя_переменной_1> [...]` - помещает введенные данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов, после получения данных, в указанные переменные. Основные параметры:
- `-p "<текст>"` - показывает пришлашение ко вводу;
- `-d "<разделитель>"` - устанавливает признаком конца ввода один из символов из строки `<разделитель>`;
- `-a <массив>` - сохраняет переменные в массив;
- `-n <количество_символоа>` - использует только указанное количество символов;
- `-i $<переменная>` - позволяет брать значение по умолчанию из переменной и записывать в нее;
- `-t <количество_секунд>` - максимальное время ожидания в секундах для ввода, при превышении будет завершена программа с ненулевым значением;
- `-e` - позволяет редактировать ввод символов;
- `-r` - включает режим не интерпритирования обратных слешей как экранирующих символов;
- `-s` - не отображать вывод вводимых символов;
> `read -p "Enter your name: " first last`  
> `read -e -p "What is your user name? " -i $USER`

При вводе переменные разделены пробелами и если не хватает данных для переменных, то они будут заполнены пустотой, а при избыточном количестве, последняя переменная получит весь остаток введенной строки.

Если, не указывать переменную, данные, введенные пользователем, будут помещены в специальную переменную среды `REPLY`.

В качестве разделителей вводимых данных используется символы из переменной `IFS`.
> `IFS=":" read user pw uid gid name home shell <<< "$file_info"`

`read` может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится.

`read line` - такая команда может быть использована в цикле `while` в качестве команды условия, для построчного чтения файла и записи строки в переменную `line`.

```bash
cat myfile | while read line
do
    echo "Line: $line"
done
```

## <a id="Дескрипторы-файлов" href="#Дескрипторы-файлов">Дескрипторы файлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Все в Linux - это файлы, в том числе - ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2. Вот что они означают:
- `0`, `STDIN` - стандартный поток ввода. Для терминала стандартный ввод - это клавиатура. Когда в сценариях используют символ перенаправления ввода - `<`, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры;
- `1`, `STDOUT` - стандартный поток вывода. По умолчанию это - экран. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда `>>`, или перезаписать его содержимое новым, для этого служит команда `>`;
- `2`, `STDERR` - стандартный поток ошибок. По умолчанию этот дескриптор указывает на то же самое, на что указывает `STDOUT`.

### <a id="Перенаправление-потоков-ошибок-и-вывода" href="#Перенаправление-потоков-ошибок-и-вывода">Перенаправление потоков ошибок и вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<команда> [1> <дескриптор>] [2> <дескриптор>]` - перенаправляет потоки вывод и ошибки. Для того чтобы перенаправить `STDERR`, и `STDOUT` в один и тот же файл, воспользовавшись командой `&>`. Где `<дескриптор>` - может быть путь к файлу или дескриптором `&<номер>`.

### <a id="Временное-перенаправление-вывода" href="#Временное-перенаправление-вывода">Временное перенаправление вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<команда> >&1` - перенаправление вывода команды в поток вывода.  
`<команда> >&2` - перенаправление вывода команды в поток ошибки.

`<команда> 2>&1` - перенаправление вывода ошибок команды в поток вывода.

### <a id="Постоянное-перенаправление-вывода" href="#Постоянное-перенаправление-вывода">Постоянное перенаправление вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`exec 1> <дескриптор>` - перенаправляет весь вывод в определенный дескриптор на время выполнения скрипта.  
`exec 2> <дескриптор>` - перенаправляет все ошибки в определенный дескриптор на время выполнения скрипта.

### <a id="Перенаправление-ввода-в-скриптах" href="#Перенаправление-ввода-в-скриптах">Перенаправление ввода в скриптах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`exec 0< <дескриптор>` - перенаправляет весь ввод из определенного дескриптора на время выполнения скрипта.

### <a id="Создание-собственного-перенаправления-вывода" href="#Создание-собственного-перенаправления-вывода">Создание собственного перенаправления вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Шесть дескрипторов с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.

`exec <дескриптор_номер>><дескриптор_источник>`  
`exec <дескриптор_номер><<дескриптор_источник>`

Где `<дескриптор_источник>` - может быть путь к файлу или дескриптором `&<номер>`.

`exec <дескриптор_номер>>&-` - закрывает дескриптор, его потом можно открыть по новой.

### <a id="Получение-сведений-об-открытых-дескрипторах" href="#Получение-сведений-об-открытых-дескрипторах">Получение сведений об открытых дескрипторах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$$` - содержит текущий PID.

`$!` - содержит PID последней запущенной программы в фоновом режиме.

`wait <PID>[ ...]` - ждет завершения программ.  
`wait` - ждет завершения всех фоновых программ.

`lsof -a -p <PID> -d <дескриптор_номер>[, ...]` - выводит сведения о каждом дескрипторе, открытом в системе. Ключ `-a` используется для выполнения операции логического И над результатами, возвращенными благодаря использованию двух других ключей.

### <a id="Подавление-вывода" href="#Подавление-вывода">Подавление вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого можно перенаправить вывод в `/dev/null`.

`<дескриптор_номер>> /dev/null` - перенаправляет весь вывод в файл.

`cat /dev/null > <файл>` - очищает файл, не удаляя его.  
`: > <файл>` - аналогичное действие.

## <a id="Конвеер-Pipe-" href="#Конвеер-Pipe-">Конвеер Pipe `|`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Pipe** (конвеер) - это однонаправленный канал межпроцессного взаимодействия, используя символ конвеера `|`. Конвеер обеспечивает асинхронное выполнение команд с использованием буферизации ввода/вывода. Таким образом все команды в конвейере работают параллельно, каждая в своем процессе.

Размер буфера начиная с ядра версии 2.6.11 составляет 65536 байт (64Кб) и равен странице памяти в более старых ядрах. При попытке чтения из пустого буфера процесс чтения блокируется до появления данных. Аналогично при попытке записи в заполненный буфер процесс записи будет заблокирован до освобождения необходимого места.

Важно, что несмотря на то, что конвейер оперирует файловыми дескрипторами потоков ввода/вывода, все операции выполняются в памяти, без нагрузки на диск.

Все команды конвеера выполняются в подоболочках, поэтому после завершения команд конвеера любые переменные, созданные в них, будут потеряны.

`<команда> | <команда> | ...`

> `cat *.txt | sort | uniq > result-file.txt`

### <a id="Именованные-каналы" href="#Именованные-каналы">Именованные каналы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`mkfifo <канал>` - создание файла для именованного канала. Перенаправление ввода и вывода в канал действует подобно конвееру.

`<процесс1> > <канал>` и `<процесс2> < <канал>` аналогично `<процесс1> | <процесс2>`.

Пока из канала не считают информацию, процесс, который в него пишет будет заблокирован и разблокируется только после стения всех данных из канала.

## <a id="Сигналы-Linux" href="#Сигналы-Linux">Сигналы Linux</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Основные-сигналы" href="#Основные-сигналы">Основные сигналы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `1` - `SIGHUP` - закрытие терминала (обрыв связи);
- `2` - `SIGINT` - сигнал остановки процесса пользователем с терминала (`CTRL + C`);
- `3` - `SIGQUIT` - сигнал остановки процесса пользователем с терминала (`CTRL + \`) с дампом памяти;
- `9` - `SIGKILL` - безусловное завершение процесса;
- `15` - `SIGTERM` - сигнал запроса завершения процесса;
- `17` - `SIGSTOP` - принудительная приостановка выполнения процесса, но не завершение его работы;
- `18` - `SIGTSTP` - приостановка процесса с терминала (`CTRL + Z`), но не завершение работы;
- `19` - `SIGCONT` - продолжение выполнения ранее остановленного процесса.
- с помощью сочетания клавиш `CTRL + D` в пустой строке останавливает текущий стандартный поток ввода из терминала.

Префикс `SIG` можно опускать.

### <a id="Временная-остановка-процесса" href="#Временная-остановка-процесса">Временная остановка процесса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сигнал `SIGTSTP` - приостанавливает работу процесса, но не завершает его выполнение. Такой процесс остается в памяти. Оболочка возвращает число в квадратных скобках - это номер задания, который оболочка назначает процессу. Оболочка рассматривает процессы, выполняющиеся в ней, как задания с уникальными номерами. Первому процессу назначается номер 1, второму - 2, и так далее.

`ps -l` - выводит приостановленные задания.  
`jobs` - выводит текущие задания и приостановленные задания.  
`jobs -l` - выводит приостановленные задания с их идентификаторами.  
`disown <идентификатор>` - убирает приостановленное задание по идентификатору.  
`fg %<номер>` - возобновляет приостановленное задание по номеру в списке.  
`bg %<номер>` - переводит приостановленное задание по номеру в списке в фоновый режим.

### <a id="Перехват-сигналов" href="#Перехват-сигналов">Перехват сигналов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`trap "<команды>" <СИГНАЛ> [...]` - перехватывает указанные сигналы и вызывает указанные команды, для перехвата выхода из скрипта нужно указать имя сигнала `EXIT`.

Для модификации перехваченных скриптом сигналов можно выполнить команду `trap` с новыми параметрами.

`trap - <СИГНАЛ> [...]` - отменяет перехват указанных сигналов.

```bash
trap cleanup SIGINT SIGTERM ERR EXIT
cleanup() {
    trap - SIGINT SIGTERM ERR EXIT
    # script cleanup here
}
```

## <a id="Выполнение-сценариев-командной-строки-в-фоновом-режиме" href="#Выполнение-сценариев-командной-строки-в-фоновом-режиме">Выполнение сценариев командной строки в фоновом режиме</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для это нужно запустить его, указав после имени символ амперсанда `&`. Скрипт будет запущен в фоновом процессе, в терминал выведется его идентификатор, а когда его выполнение завершится, выведется сообщение об этом. При этом скрипт продолжает использовать терминал для вывода сообщений в `STDOUT` и `STDERR` и их лучше перенаправить в файлы. Процесс продолжит свое выполнение и после того, как будет произведен выход из системы.

`nohup <скрипт> &` - позволяет запустить программу, блокируя сигналы `SIGHUP`, отправляемые процессу и отвязывает процесс от терминала, что значит что процесс потеряет ссылки на `STDOUT` и `STDERR` и `nohup` автоматически перенаправляет сообщения, поступающие в `STDOUT` и в `STDERR`, в файл `nohup.out` в текущем каталоге; если это невозможно сделать, то перенаправление происходит в файл `$HOME/nohup.out`. Если и это невозможно сделать, то команда не запускается совсем.

`nohup <команда> > <файл_вывода> 2> <файл_ошибок> < /dev/null &`
> `nohup myprogram > foo.out 2> foo.err < /dev/null &`

`jobs -l` - выводит текущие задания, которые выполняются в оболочке.

## <a id="Планирование-запуска-скриптов" href="#Планирование-запуска-скриптов">Планирование запуска скриптов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`at [-f <файл>] <время>` - запускает файл в указанное время, где время может быть в виде: `HH:MM`, `now`, `noon`, `midnight`, `MMDDYY`, `MM/DD/YY`, или `DD.MM.YY`.

Ключ `-M` при вызове `at` используется для отправки того, что выведет скрипт, по электронной почте, если система соответствующим образом настроена. Если отправка электронного письма невозможна, этот ключ просто подавит вывод.

`atq` - возвращает список заданий.  
`atrm <номер_задания>` - удаляет задание под указанным номером.

## <a id="Запуск-скриптов-по-расписанию" href="#Запуск-скриптов-по-расписанию">Запуск скриптов по расписанию</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`crontab -l` - выводит существующую таблицу заданий `cron` в консоль.

`crontab -e` - выводит существующую таблицу заданий `cron` в редакторе по умолчанию (`vi`) и позволяет редактировать его.

`<минута> <час> <день_месяца> <месяц> <день_недели> <скрипт>` - запускает указанный скрипт по расписанию в указаное время запуска, т.е. когда время будет равно заданой структуре. Единицы измерения:
- минуты (0-59);
- часы (0-23);
- дни месяца (1-31);
- месяцы (1-12) (jan feb mar apr may jun jul aug sep oct nov dec);
- дни недели (0-6 (0=воскресенье)) (sun mon tue wed thu fri sat).

Единицы измерения можно указывать в виде:
- `<число>` - числа;
- `<число_от>-<число_до>` - диапазон;
- `<число1>[,<число2>[,...]]` - перечисление;
- `*/<шаг>` - шаг (когда остаток от деления на `<шаг>` будет равен 0);
- `<число_от>-<число_до>/<шаг>` - шаг (когда остаток от деления минус `<число_от>` на `<шаг>` будет равен 0);
- `*` - любое значение.

Диапазоны и перечисления можно комбинировать.

Комментарий начинается с `#` и это задание не будет исполняться.

> `10 12 * * * script.sh` - скрипт выполнится в 12 часов 10 минут.  
> `0 22 * * 1-5 echo "Пора домой" | mail -s "Уже 22:00" john` - скрипт выполнится в 22 часа 00 минут по будням.  
> `1-59/2 * * * * echo "Выполняется по нечетным минутам"` - скрипт выполнится по нечетным минутам.

`crontab -r` - удаляет файл текущего расписания.

<a id="sed" href="#sed">`sed`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

Утилита `sed` называется потоковым текстовым редактором, поточно обрабатывает строки. Схема вызова команды:  
`sed <опции> [<файл>]`

По умолчанию `sed` применяет указанные при вызове правила, выраженные в виде набора команд, к `STDIN`. Это позволяет передавать данные непосредственно `sed` через `|`.

## <a id="Опции" href="#Опции">Опции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'s/<шаблон_поиска>/<шаблон_замены>/[<флаги>]'` - производит потоковую замену найденных шаблонов.

> `'s/search/replace/'`

Для выполнения нескольких действий с данными, используется ключ `-e` при вызове и опции разделяются символом точкой с запятой `;`, при этом между окончанием команды и точкой с запятой не должно быть пробела:  
`sed -e <опции> [<файл>]`

Для того, чтобы указать `sed` файл, содержащий команды, используют ключ `-f`:  
`sed -f <файл_с_командами> [<файл>]`

### <a id="Дополнительные-ключи" href="#Дополнительные-ключи">Дополнительные ключи</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `-n` - указанный при вызове sed, подавляет обычный вывод всех строк, и выводит только измененные;
- `-e` - добавление скрипта или regex в исполняемые команды;
- `-r` - использовать расширенный синтаксис регулярных выражений (спец символы активны по умолчанию);
- `-d` - удалить;
- `-s` - заменить;
- `-p` - распечатать найденную строку;
- `-i` - выполнять изменения непосредственно в файле, без вывода в консоль.

### <a id="Флаги" href="#Флаги">Флаги</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При передаче номера учитывается порядковый номер вхождения шаблона в строку, заменено будет именно это вхождение.
> `'s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/'`

- флаг `g` указывает на то, что нужно обработать все вхождения шаблона, имеющиеся в строке.
    > `echo "aaabbbccc" | sed 's/b/B/g'`
- флаг `p` указывает на то, что нужно вывести содержимое исходной строки.
    > `'/SUSE/p'`
- флаг `!p` указывает на то, что нужно вывести все строки, которые не удолетворяют искомой.
    > `'/SUSE/!p'`
- флаг вида `w <файл>` указывает команде на то, что нужно записать результаты обработки текста в файл.

### <a id="Символы-разделители" href="#Символы-разделители">Символы-разделители</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Разделителем считается первый символ, который будет встречен после `s`:  
`'s<символ_разделитель><шаблон_поиска><символ_разделитель><шаблон_замены><символ_разделитель>[<флаги>]'`

> `'s:as:like:'`

### <a id="Выбор-фрагментов-текста-для-обработки" href="#Выбор-фрагментов-текста-для-обработки">Выбор фрагментов текста для обработки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Перед `s` можно указать номер строки для обработки:  
`'<номер_строки>s/<шаблон_поиска>/<шаблон_замены>/'`  
`'<номер_строки_начала>,<номер_строки_конца>s/<шаблон_поиска>/<шаблон_замены>/'` - воздействует на диапазон строк. Где концом может выступать символ `$`, означающий номер последней строки.

> `'2,$s/find/replace/'`

`'/<шаблон_строки>/s/<шаблон_поиска>/<шаблон_замены>/'` - только строки, которые удовлетворяют указанному шаблону.

> `'/filter/s/find/replace/'`

### <a id="Удаление-строк" href="#Удаление-строк">Удаление строк</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'<номер_строки>d'` - удаляет указанную строку из потока вывода.  
`'<номер_строки_начала>,<номер_строки_конца>d'` - удаляет указанный диапазон строк из потока вывода. Где концом может выступать символ `$`, означающий номер последней строки.  
`'/<шаблон_строки>/[,...]d'` - только строки, которые удовлетворяют указанному шаблону [одному из них].

### <a id="Вставка-текста-в-поток" href="#Вставка-текста-в-поток">Вставка текста в поток</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'[<номер_строки>]i\<строка>'` - добавляет новую строку перед заданной.  
`'[<номер_строки>]a\<строка>'` - добавляет новую строку после заданной.

### <a id="Замена-строк" href="#Замена-строк">Замена строк</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'<номер_строки>c\<строка>'` - заменяет указанную строку переданной.  
`'/<шаблон_строки>/c/<строка>'` - заменяет строки удовлетворяющие указанному шаблону переданной.

### <a id="Замена-символов" href="#Замена-символов">Замена символов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'y/<символы>/<символы_замены>/'` - заменяет символы в соответствии символам замены.
> `'y/abcd/ABCD/'`

### <a id="Вывод-номеров-строк" href="#Вывод-номеров-строк">Вывод номеров строк</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`=` - выводит номер строки.  
`'/<шаблон_строки>/='` - выводит номер строки удовлетворяющей указанному шаблону.

### <a id="Чтение-данных-для-вставки-из-файла" href="#Чтение-данных-для-вставки-из-файла">Чтение данных для вставки из файла</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`'[<номер_строки>]r <файл>'` - вставляет содержимое файла после [указанной строки] в поток данных.  
`'/<шаблон_строки>/r <файл>'` - вставляет содержимое файла после строк удовлетворяющих указанному шаблону в поток данных.

### <a id="Регулярные-выражения" href="#Регулярные-выражения">Регулярные выражения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Все шаблоны поиска могут представлять из себя регулярное выражение.

<a id="awk" href="#awk">`awk`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

Утилита **awk** похожа на **sed** , но более разнообразна.

Awk воспринимает поступающие к нему данные в виде **набора записей**. Записи представляют собой наборы полей. **Запись** - это строка. **Поле** - это слово в строке.

Awk обрабатывает текст из потока ввода построчно.

`awk [<опции>] [<программа>] [<файл> [ ...]]`

## <a id="Опции" href="#Опции">Опции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `-F <символ>` - позволяет указать символ-разделитель для полей в записи;
- `-f <файл>` - указывает имя файла, из которого нужно прочесть awk-скрипт;
- `-v <переменная>=<значение>`- позволяет объявить переменную и задать ее значение по умолчанию, которое будет использовать awk;
- `-mf <кол>` - задает максимальное число полей для обработки в файле данных;
- `-mr <кол>` - задает максимальный размер записи в файле данных;
- `-W <режим>` - позволяет задать режим совместимости или уровень выдачи предупреждений awk.

## <a id="Программа" href="#Программа">Программа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Скрипты awk, которые можно писать прямо в командной строке, оформляются в виде текстов команд, заключенных в фигурные скобки. Кроме того, awk предполагает, что скрипт представляет собой текстовую строку, его нужно заключить в одинарные кавычки.

`'{<команда> [; ...]}'`

Для того, чтобы завершить работу awk, нужно передать ему символ конца файла (*EOF*, *End-of-File*). С помощью сочетания клавиш `CTRL + D`.

`print <текст> [, ...]` - печатает текст, он может состоять из строк и переменных.

`"<текст>"` - строка.

### <a id="Позиционные-переменные-хранящие-данные-полей" href="#Позиционные-переменные-хранящие-данные-полей">Позиционные переменные, хранящие данные полей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

По умолчанию `awk` назначает следующие переменные каждому полю данных, обнаруженному им в записи:
- `$0` - представляет всю строку текста (запись);
- `$1` - первое поле;
- `$2` - второе поле;
- `$n` - n-ное поле.

Поля выделяются из текста с использованием **символа-разделителя**. По умолчанию - это пробельные символы вроде пробела или символа табуляции.

### <a id="Файл-скрипта" href="#Файл-скрипта">Файл скрипта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В файле скрипта может содержаться множество команд, при этом каждую из них достаточно записывать с новой строки, ставить после каждой точку с запятой не требуется.

Внутри скрипта можно объявлять переменные.

### <a id="Выполнение-команд-до-начала-обработки-данных" href="#Выполнение-команд-до-начала-обработки-данных">Выполнение команд до начала обработки данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`BEGIN {<команда> [; ...]}` - выполнит указанную секцию команд до начала обработки данных.

### <a id="Выполнение-команд-после-окончания-обработки-данных" href="#Выполнение-команд-после-окончания-обработки-данных">Выполнение команд после окончания обработки данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`END {<команда> [; ...]}` - выполнит указанную секцию команд после начала обработки данных.

### <a id="Встроенные-переменные" href="#Встроенные-переменные">Встроенные переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `FIELDWIDTHS` - разделенный пробелами список чисел, определяющий точную ширину каждого поля данных с учетом разделителей полей;
- `FS="<символ>"` - позволяет указать символ-разделитель для полей в записи;
- `RS="<символ>"` - переменная, которая позволяет задавать символ-разделитель записей;
- `OFS="<символ>"` - разделитель полей на выводе awk-скрипта;
- `ORS="<символ>"` - разделитель записей на выводе awk-скрипта;
- `ARGC` - количество аргументов командной строки;
- `ARGV` - массив с аргументами командной строки (`ARGV[<n>]`);
- `ARGIND` - индекс текущего обрабатываемого файла в массиве `ARGV`;
- `ENVIRON` - ассоциативный массив с переменными окружения и их значениями (`ENVIRON["<ключ>"]`);
- `ERRNO` - код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов;
- `FILENAME` - имя входного файла с данными;
- `FNR` - номер текущей записи в файле данных;
- `IGNORECASE` - если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов;
- `NF` - общее число полей данных в текущей записи, $NF позволяет обращаться к последнему полю данных в записи, не зная его точной позиции;
- `NR` - общее число обработанных записей.

### <a id="Условный-оператор" href="#Условный-оператор">Условный оператор</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`if (<условие>) <команда> [; else <команда>]`
```
if (<условие>)
{
    <команды>
}[ else {
    <команды>
}]
```

Операторы сравнения:
- `==` - равно;
- `!=` - не равно;
- `>` - больше;
- `<` - меньше;
- `<=` - больше или равно;
- `>=` - меньше или равно.

### <a id="Цикл-while" href="#Цикл-while">Цикл while</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
while (<условие>)
{
    <команды>
}
```
В циклах `while` можно использовать команды `break` и `continue`.

### <a id="Цикл-for" href="#Цикл-for">Цикл for</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
for (<начало>; <условие>; <итерация>)
{
    <команды>
}
```

## <a id="Форматированный-вывод-данных" href="#Форматированный-вывод-данных">Форматированный вывод данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Команда `printf` в awk позволяет выводить форматированные данные:  
`printf "<текст_со_спецификаторами>" [, <переменная> [, ...]]`

Первый спецификатор соответствует первой переменной, второй спецификатор - второй, и так далее.

`%[<модификатор>]<символ_спецификатора>` - спецификатор.

### <a id="Символы" href="#Символы">Символы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `c` - воспринимает переданное ему число как код ASCII-символа и выводит этот символ;
- `d` - выводит десятичное целое число;
- `i` - то же самое, что и d;
- `e` - выводит число в экспоненциальной форме;
- `f` - выводит число с плавающей запятой;
- `g` - выводит число либо в экспоненциальной записи, либо в формате с плавающей запятой, в зависимости - от того, как получается короче;
- `o` - выводит восьмеричное представление числа;
- `s` - выводит текстовую строку.

### <a id="Модификаторы" href="#Модификаторы">Модификаторы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Могут комбинироваться и писаться в указанном порядке.

- `-` - выравнивание по левой стороне;
- ` ` - отрицательные числа пишутся со знака минуса, положительные с пробела;
- `+` - отрицательные числа пишутся со знака минуса, положительные с плюса;
- `0` - дополняет слева число нулями;
- `<число>` - минимальная ширина поля;
- `.<число>` - максимальная ширина поля.

## <a id="Встроенные-математические-функции" href="#Встроенные-математические-функции">Встроенные математические функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `cos(x)` - косинус x (x выражено в радианах);
- `sin(x)` - синус x;
- `exp(x)` - экспоненциальная функция;
- `int(x)` - возвращает целую часть аргумента;
- `log(x)` - натуральный логарифм;
- `rand()` - возвращает случайное число с плавающей запятой в диапазоне 0 - 1;
- `sqrt(x)` - квадратный корень из x.

## <a id="Строковые-функции" href="#Строковые-функции">Строковые функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются аналогично математическим.

## <a id="Пользовательские-функции" href="#Пользовательские-функции">Пользовательские функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объявляются до всех секций.

```
function <функция>()
{
    <команды>
}
```

`<функция>()` - использование.

<a id="Регулярные-выражения" href="#Регулярные-выражения">Регулярные выражения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====================

Утилита **sed** поддерживает часть стандарта *POSIX Basic Regular Expression* (BRE).  
Регулярное выражение может находиться в шаблоне.

Утилита **awk** поддерживает стандарт *POSIX Extended Regular Expression* (ERE).  
Регулярное выражение может находиться в перед списком команд:  
`/<регулярное_выражение>/{<команда> [; ...]}`

Специальные символы BRE:
- `.` - один любой символ;
- `^` - якорь начала строки (не считается за символ);
- `$` - якорь конца строки (не считается за символ);
- `[<символ_1>[...]]` - один символ, который может быть или символом `<символ_1>`[, или ...];
- `[^<символ_1>[...]]` - один символ, который не может быть или символом `<символ_1>`[, или ...];
- `[<символ_от>-<символ_до>[...]]` - один символ, который может быть в интервале символов `<символ_от>` и до `<символ_до>`, включая эти символы, для включения символа `-`, то он ставится в начало выражения.



Специальные символы ERE, которые дополняют BRE:
- `<выражение_1>|<выражение_2>[|...]` - одно из выражений;
- `(<выражение>)` - группировка выражений;
- `?` - совпадение с предыдущем элементов ноль или один раз;
- `*` - совпадение с предыдущем элементов ноль или более раз;
- `+` - совпадение с предыдущем элементов один или более раз;
- `{<количество>}` - совпадение с предыдущем элементов указанное количество `<количество>` раз;
- `{<количество_от>,<количество_до>}` - совпадение с предыдущем элементов не менее `<количество_от>` раз и не более `<количество_до>`;
- `{<количество_от>,}` - совпадение с предыдущем элементов не менее `<количество_от>` раз;
- `{,<количество_до>}` - совпадение с предыдущем элементов не более `<количество_до>`.

Специальные символы экранируются с помощью обратной косой черты (обратного слэша) - `\`.

## <a id="Специальные-классы-символов" href="#Специальные-классы-символов">Специальные классы символов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В BRE имеются специальные классы символов, которые можно использовать при написании регулярных выражений:
- `[:alpha:]` - соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре;
- `[:alnum:]` - соответствует любому алфавитно-цифровому символу, а именно - символам в диапазонах 0-9, A-Z, a-z;
- `[:blank:]` - соответствует пробелу и знаку табуляции;
- `[:digit:]` - любой цифровой символ от 0 до 9;
- `[:upper:]` - алфавитные символы в верхнем регистре - A-Z;
- `[:lower:]` - алфавитные символы в нижнем регистре - a-z;
- `[:print:]` - соответствует любому печатаемому символу;
- `[:punct:]` - соответствует знакам препинания;
- `[:space:]` - пробельные символы, в частности - пробел, знак табуляции, символы NL, FF, VT, CR.

Используются в конструкции `[]`: `[<спец_класс>]`:
> `[[:space:]]`

Могут комбинироваться в рамках конструкции `[]`:
> `[[:space:][:punct:]]`

<a id="Структура-Linux" href="#Структура-Linux">Структура Linux</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===============

## <a id="Ядро" href="#Ядро">Ядро</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Ядро - это программа, расположенная в памяти компьютера и от дающая распоряжения центральному процессору. Ядро управляет аппаратными средствами и выступает главным образом в качестве интерфейса между аппаратными средствами и любой запущенной программой.

Ядро отвечает за:
- **процессы** - за их работу, за **переключение контекста**. Так как все процессоры работают определенный отрезок времени - **квант времени**.
- **память** - за состояние всей памяти.
- **драйверы устройст** - в качестве интерфейса между аппаратными средствами и процессами.
- **системные вызовы и поддержка** - для обработки системных вызовов процессов для взаимодействия с ядром.

**Переключение контекста** состоит из шагов:
1. Прерывание процессором текущего процесса, по внутреннему таймеру.
2. Переключение в режим ядра и возврат управления ядру.
3. Сохранения ядром текущего состояния процессора и памяти текущего процесса для его возобновления.
4. Выполнение ядром задач, которые возникли в течении предыдущего кванта времени.
5. Запуск другого процесса по определенным условиям.
6. Подготовка ядром памяти для нового процесса, а затем подготовка процессора.
7. Сообщение ядром процессору длительности кванта для нового процесса.
8. Перевод ядром процессора в режим пользователя и передача управления процессору.

**Управления памятью** использует модуль управления памятью (MMU), который активизирует схему доступа к памяти под названием **виртуальная память**. При использовании виртуальной памяти процесс не обращается к памяти напрямую по ее физическому расположению в аппаратных средствах. Вместо этого ядро настраивает каждый процесс таким образом, словно в его распоряжении находится вся машина. Когда процесс получает доступ к памяти, модуль MMU перехватывает такой запрос и применяет карту адресов памяти, чтобы перевести местоположение памяти, полученное от процесса, в физическое положение памяти на компьютере. Для каждого проесса ядро меняет карту адресов памяти.

## <a id="Каталоги" href="#Каталоги">Каталоги</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `/bin` - содержит готовые к запуску команды (известные также как исполняемые файлы), как в двоичном формате, так и сценарии оболочки;
- `/boot` - содержит файлы загрузчика ядра:
    - `/vmlinuz` - содержит ядро.
- `/dev` - содержит файлы устройств:
    - `/sd*` (`*` - `a`, `b`, ...) - жесткие диски:
        - `*` (`*` - `1`, `2`, ...) - разделы жесткого диска.
    - `/sr*` (`*` - `a`, `b`, ...) - приводы CD и DVD;
    - `/hd*` (`*` - `a`, `b`, ...) - жесткие диски PATA;
    - `/tty*` (`*` - `1`, `2`, ...) - виртуальная консоль;
    - `/pts/*` (`*` - `0`, `1`, ...) - псевдотерминальное устройство;
    - `/tty` - управляющий терминал текущего процесса;
    - `/ttyS*` (`*` - `0`, `1`, ...) - последовательные порты (COM);
    - `/ttyUSB*` (`*` - `0`, `1`, ...) - последовательные порты USB;
    - `/ttyACM*` (`*` - `0`, `1`, ...) - последовательные порты ACM;
    - `/lp*` (`*` - `0`, `1`, ...) - параллельные порты (LPT);
    - `/parport*` (`*` - `0`, `1`, ...) - двунаправленные параллельные порты;
    - `/null` - устройство для подавления ввода;
    - `/zero` - устройство для ввода непрерывного количества 0;
- `/etc` - содержит файлы конфигурации, файлы загрузки, файлы устройств, сетевые настройки и другие параметры. Многие элементы каталога зависят от аппаратного обеспечения:
    - `/sudoers` - файл прав привилегированных пользователей `sudo`;
    - `/crontab` - файл, определяющий время запуска автоматизированных заданий;
    - `/fstab` - таблица устройств хранения и соответствующих им точек монтирования;
    - `/passwd` - список всех учетных записей пользователей;
- `/home` - содержит личные каталоги пользователей;
- `/lib` - содержит файлы библиотек для совместного пользования:
    - `/modules` - содержит загружаемые модули ядра;
- `/media` - основная точка подключения для таких съемных устройств, которые монтируются в момент подключения;
- `/opt` - содержит дополнительное ПО сторонних разработчиков;
- `/proc` - содержит информацию о запущенных в данный момент процессах, а также о некоторых параметрах ядра в виде "каталог-файл";
- `/sys` - подобен `/proc`, но предоставляет интерфейс устройствам и системе в виде "каталог-файл";
- `/sbin` - содержит системные исполняемые файлы;
- `/tmp` - содержит небольшие временные файлы. Любой пользователь может выполнять чтение и запись в этом каталоге, однако доступ к файлам другого пользователя может быть запрещен. Многие команды применяют данный каталог в качестве рабочего пространства;
- `/usr` - содержит обширную иерархию каталогов, включающую основную часть системы Linux. Многие имена каталогов здесь такие же, как и в корневом каталоге (типа `/usr/bin` и `/usr/lib`), и содержат те же типы файлов, предназначен для хранения большей части команд и данных пространства пользователя:
    - `/bin` - содержит выполняемые программы;
    - `/sbin` - содержит дополнительные программы для администрирования;
    - `/lib` - содержит разделяемые библиотеки для программ в `/usr/bin`;
    - `/include` - содержит заголовочные файлы, используемые компилятором C;
    - `/info` - содержит руководства GNU в формате info;
    - `/local` - здесь администраторы могут устанавливать собственное программное обеспечение. Структура этого каталога должна выглядеть подобно структуре каталогов `/` и `/usr`;
    - `/man` - содержит страницы руководства;
    - `/share` - содержит файлы для программ в `/usr/bin`, которые должны работать в других типах систем Unix без потери функциональности;
- `/var` - изменяемый подкаталог, в котором команды хранят информацию во время исполнения;
    - `/log` - содержит файлы журналов с записями о различных действиях, выполнявшихся в системе;
- `/vmlinuz` - содержит ядро.

## <a id="Устройства" href="#Устройства">Устройства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Распологаются по пути: `/dev`.

Виды устройств:
- **блочные устройства** - `b` - доступ к данным в виде фиксированных порций. Поскольку общий объем блочного устройства фиксирован и легко поддается индексации, процессы с помощью ядра получают случайный доступ к любому блоку устройства;
- **символьные устройства** - `c` - работают с потоками данных. Можно лишь считывать символы с таких устройств или записывать символы на них. Символьные устройства не обладают размером;
- **каналы** - `p` - подобны символьным устройствам, но у них на другом конце потока ввода-вывода располагается другой процесс, а не драйвер ядра;
- **сокеты** - `s` - являются специализированными интерфейсами, которые часто используются для взаимодействия между процессами.

`udevadm info --query=all --name=/dev/<устройство>` - показывает путь и другие атрибуты устройства.

В каталоге `/sys/devices` распологаются "каталоги-файлы" для просмотра информации об устройстве и для управления им.

`dd if=<входной_файл> of=<выходной_файл> bs=<размер_блока> [ibs=<размер_блока_чтения> obs=<размер_блока_записи>] count=<количество_блоков> skip=<количество_блоков_пропуска>` - копирует данные блочно из одного файла или устройства в другой.
> `dd if=/dev/zero of=new_file bs=1024 count=1`  
> `dd if=/dev/sdb of=flash_drive.img`

`lsscsi` - выводит список устройств в системе.

### <a id="Блочные-устройства" href="#Блочные-устройства">Блочные устройства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Виды таблиц разделов:
- **MBR** - Master Boot Record - главной загрузочная запись;
- **GPT** - Globally Unique Identifier Partition Table - глобальная таблица разделов с уникальными идентификаторами.

`parted -l` - выводи информацию о разделах.

Виды файловых систем:
- **ext4**;
- **ext3**;
- **ext2**;
- **iso9660** - файловая система ISO 9660 для CD-ROM;
- **msdos** - файловая система FAT;
- **vfat** - файловая система FAT;
- **umsdos** - файловая система FAT;
- **hfsplus** - файловая система HFS+ для Macintosh.

`fdisk <устройство>` - запускает программу по форматированию разделов устройства.

`mkfs -t <файловая_система> <раздел>` - создает файловую систему на указаном разделе.
> `mkfs -t ext4 /dev/sdf2`

`mkfs - n` - выводит информацию о суперблоках.

`blkid` - выводит список устройств, соответствующих им файловых систем, а также идентификаторы UUID.

`mount` - выводит построчно примонтированные фаловые системы в виде: `<устройство> on <точка_монтирования> type <тип_системы> (<параметры_монтирования>)`.

`mount -t <тип_файловой_системы> <устройство> <точка_монтирования> [<флаги>]` - монтирует файловую систему типом `<тип_файловой_системы>` устройства `<устройство>` в точку монтирования `<точка_монтирования>`.
> `mount -t ext4 /dev/sdf2 /home/extra`

`mount UUID=<UUID> <точка_монтирования> [<флаги>]` - монтирует файловую систему по UUID `<UUID>` в точку монтирования `<точка_монтирования>`.
> `mount UUID=a9011c2b-1c03-4288-b3fe-8ba961ab0898 /home/extra`

Флаги монтирования для `mount`:
- `-r` - монтирует файловую систему в режиме "только для чтения";
- `-o <параметр1>[,...]` - включает использование длинных параметров:
    - `ro` - только чтение файловой системы;
    - `rw` - чтение-запись файловой системы;
    - `exec` - включает исполнение команд над файловой системой;
    - `noexec` - отключает исполнение команд над файловой системой;
    - `noauto` - отключает автомонтирование;
    - `suid` - включает команды `setuid` (установка идентифи катора пользователя);
    - `nosuid` - отключает команды `setuid` (установка идентифи катора пользователя).

Файл `/etc/fstab` содержит список файловых систем и их параметров в виде строк формата: `<устройство_или_UUID> <точка_монтирования> <тип_файловой_системы> <параметры_монтирования> <частота_резервного_копирования> <порядок_проверки_целостности_системы>`.

`mount -a` - монтирует все системы из файла `/etc/fstab`, кроме `noauto`.

`unmount <точка_монтирования>` - размонтирует систему из точки монтирования `<точка_монтирования>`. Если система используется чем-то, то ее не удастся размонтировать.
> `unmount /home/extra`

`sync` - принудительно записывает изменения из буфера ядра на диск.

`df [-h]` - показывает список всех файловых систем по именам устройств, сообщает их размер, занятое и свободное пространство и точки монтирования [отобразит размер в человеко-читаемом формате, добавив названия единиц]. В отображении занятого и свободного пространства не учтены 5% от общего их размера, так как оно зарезирвированно.

`du -sh <каталог>` - выводит размер директории.  
`du -sh *` - выводит размер файлов и директорий в текущем каталоге.

`fsck [-p] [-n] <устройство>` - проверяет фаловую систему в режиме интерактивного руководства [`-p` с автоматическим исправлением типичных проблем] [`-n` только проверка без изменений].

Специальные фаловые системы:
- `proc` - смонтирована в каталоге `/proc` для хранения каталогов с процессами. Файл `/proc/self` представляет текущий процесс, `/proc/cpuinfo` - информации о ядре и аппаратных средствах.
- `sysfs` - смонтирована в каталоге `/sys`.
- `tmpfs` - смонтирована в каталоге `/run` и д.р.

## <a id="Область-подкачки" href="#Область-подкачки">Область подкачки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`free` - выводит размер области подкачки.

`mkswap <устройство>` - создает область подкачки на разделе.  
`mkswap <файл>` - создает область подкачки в файле.

`swapon <устройство_или_файл>` - включает область подкачки.  
`swapoff <устройство_или_файл>` - выключает область подкачки.

## <a id="Устройство-файловой-системы" href="#Устройство-файловой-системы">Устройство файловой системы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из двух основных компонентов:
- **пул блоков данных** - где хранятся данные;
- **база данных** - которая управляет пулом данных с основой в виде структруры данных inode.

**Дескриптор inode** - это набор данных, который описывает конкретный файл, включая его тип, права доступа и расположение его данных в пуле данных.

Дескриптор каталога содержит перечень имен файлов и соответствующих ссылок на другие дескрипторы и на каталоги `.` и `..`.

```
 Таблица дескрипторов inode                     Пул данных
| Номер | Счетчик ссылок | Тип  |
| 2     | 4              | dir  | --------> | .      inode 2  |
| 13    | 1              | file | --\       | file_1 inode 13 |
                                    |
                                    \-----> | "a"             |
```

`stat <файл>` - показывает информацию о файле и его дескрипторе.

## <a id="Загрузка-ядра" href="#Загрузка-ядра">Загрузка ядра</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Процесс загрузки состоит и следующих шагов:
1. Система BIOS или прошивка загрузки загружают и запускают загрузчик системы, который может:
    - давать выбор среди нескольких ядер;
    - переключаться между наборами параметров ядра;
    - ручное изменение параметров ядра;
    - загрузка других операционных систем.
2. Загрузчик системы отыскивает образ ядра на диске, загружает его в память и запускает.
3. Ядро выполняет инициализацию устройств и их драйверов в следующем порядке:
    1. Проверка центрального процессора.
    2. Проверка оперативной памяти.
    3. Обнаружение шины устройств.
    4. Обнаружение устройств.
    5. Настройка вспомогательной подсистемы ядра (сеть и т. п.).
    6. Монтирование корневой файловой системы.
    7. Запуск пространства пользователя.
4. Ядро монтирует корневую файловую систему.
5. Ядро запускает команду `init` (которая разная для разных версий ОС) с идентификатором процесса `1`. Эта точка является началом пространства пользователя.
6. Команда `init` приводит в действие остальные системные процессы.
7. В определенный момент команда `init` запускает процесс, позволяющий войти в систему в конце или незадолго до окончания загрузки системы.

Сообщения о загрузке хранятся в файле `/var/log/kern.log` или в каталоге `var/log/messages`.

`dmesg` - выводит в консоль сообщения о загрузки.

В файле `/proc/cmdline` содержится информация о параметрах ядра.

Виды команды `init`:
- `systemd` - расположена по пути `/usr/lib/systemd` и `/etc/systemd`;
- `Upstart` - расположена по пути `/etc/init` и использует файлы `.conf`;
- `System V init` - расположена по пути `/etc/inittab`.

### <a id="Команда-systemd" href="#Команда-systemd">Команда `systemd`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные шаги запуска:
1. Загружает своей конфигурации.
2. Определение цели загрузки, которая обычно называется `default.target`.
3. Определение всех зависимостей для цели загрузки по умолчанию, зависимости зависимостей и т. д.
4. Активация зависимых процессов и цели загрузки.
5. Реагирование после загрузки на системные события (такие как `uevents`) и активация дополнительных компонентов.

Основные модули:
- **Модули служб** - контролируют традиционные демоны служб в системе Unix.
- **Модули монтирования** - контролируют присоединение файловых систем.
- **Целевые модули** - контролируют другие модули, как правило группируя их.

Основные зависимости:
- **Requires** - Жесткие зависимости. При активизации модуля с зависимостью **Requires** команда `systemd` пытается активизировать модуль зависимости. Если модуль зависимости дает сбой, то команда `systemd` деактивизирует зависимый модуль.
- **Wants** - Зависимости, предназначенные только для активизации. Во время активизации какого либо модуля команда `systemd` активизирует его **Wants** зависимости, но не обращает внимания, если они дают сбой.
- **Requisite** - Модули, которые уже должны быть активными. Перед активизацией модуля с зависимостью **Requisite** команда `systemd` сначала проверяет состояние зависимости. Если такая зависимость еще не была активизирована, команда `systemd` дает сбой при активизации модуля с этой зависимостью.
- **Conflicts**. Противоположные зависимости. При активизации модуля с зависимостью **Conflict** команда `systemd` автоматически деактивизирует такую зависимость, если она активна. Одновременная активизация двух конфликтующих модулей вызовет сбой.

Порядок следования зависимостей:
- **Before** - текущий модуль будет активизирован до указанного модуля или модулей.
- **After** - текущий модуль будет активизирован после перечисленного модуля или модулей.

Файлы для подключения системных модулей распологаются по пути `/usr/lib/systemd/ system`, а системной и пользовательской конфигурации по пути `/etc/systemd/system`. Выглядят в виде файлов со структурой XDG (`.target`, которые похожи на `.ini`).

Основные секции:
- секция `[Unit]` сообщает некоторые подробности о модуле и содержит описание и сведения о зависимости.
- секция `[Mount]` описывает данный модуль в роли модуля монтирования, а так же сообщает детали о точке монтирования, типе файловой системы и параметрах монтирования.
- секция `[Service]` сообщает о том, как подготовить, запустить и перезагрузить данную службу.
- секция `[Install]` сообщает о том, что делать когда необходимо подключить данную службу - создает символические ссылки на зависимые модули.

Пример монтирования:
```
[Unit]
Description=Media Directory
Before=local-fs.target
[Mount]
What=tmpfs
Where=/media
Type=tmpfs
Options=mode=755,nosuid,nodev,noexec
```

Пример службы:
```
[Unit]
Description=OpenSSH server daemon
After=syslog.target network.target auditd.service
[Service]
EnvironmentFile=/etc/sysconfig/sshd
ExecStartPre=/usr/sbin/sshd-keygen
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
[Install]
WantedBy=multi-user.target
```

**Спецификатор** - это еще одно похожее на переменную средство, которое часто можно увидеть в файлах модулей. Спецификаторы начинаются с символа процента `%`. Например, спецификатор `%n` представляет имя текущего модуля, а специфи катор `%H` - имя текущего хоста.

#### <a id="Основные-команды" href="#Основные-команды">Основные команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`systemctl [--all] list-units` - выводит список активных [всех] модулей.  
`systemctl status <модуль>` - выводит статус модуля.

`journalctl _SYSTEMD_UNIT=<модуль>` - выводит журнал модуля.

`systemd start <модуль>` - запускает модуль.  
`systemd stop <модуль>` - останавливает модуль.  
`systemd restart <модуль>` - перезапускает модуль.  
`systemd enable <модуль>` - подключает модуль - выполняет секцию `[Install]`.  
`systemd disable <модуль>` - удаляет модуль - удаляет символические ссылки.

`systemctl reload <модуль>` - перезагружает только конфигурацию модуля.  
`systemctl demon-reload` - перезагружает конфигурацию всех модулей.

`systemctl list-jobs` - выводит список заданий на активизацию, повторную активизацию и перезапуск модулей.

<a id="Архивирование" href="#Архивирование">Архивирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=============

## <a id="tar" href="#tar">`tar`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Запаковывание" href="#Запаковывание">Запаковывание</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`tar [-<ключи>] [-] [<название_архива>] [<путь_что_запаковать>]`

Значения ключей:
- `с` - "create" - создать файл архива;
- `v` - "verbose" - выводить информацию в процессе выполнения;
- `z` - "gzip" - запаковать файл при помощи gzip;
- `j` - "bzip2" - запаковать файл при помощи bzip2;
- `f` - "file" - использовать имя файла архива указаное после ключей. Если не указать ключ `f` то команда будет использовать настройки по умолчанию либо выведет результат прямо в консоль.

`-` - обозначает вывод в стандартный поток.

`.tar.gz` = `.tgz`

> `tar -zcvf prog-1-jan-2005.tar.gz /home/jerry/prog`

### <a id="Распаковывание" href="#Распаковывание">Распаковывание</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`tar [-<ключи>] [-] [<название_архива>] [<имя_файла1>[ ...]]` - извлекает данные из архива [только указанные файлы].

Значения ключей:
- `x` - "eXtract" - извлечь файлы;
- `v` - "verbose" - выводить информацию в процессе выполнения;
- `z` - "gzip" - распаковать файл при помощи gzip;
- `j` - "bzip2" - распаковать файл при помощи bzip2;
- `p` - при распаковке останутся исходные права, какие были в архиве;
- `f` - "file" - использовать имя файла архива для распаковки указаное после ключей.

`-` - обозначает вывод в стандартный поток.

> `tar -zxvf prog-1-jan-2005.tar.gz`

### <a id="Вывод-содержания" href="#Вывод-содержания">Вывод содержания</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`tar [-<ключи>] [<название_архива>]`

Значения ключей:
- `t` - извлечь файлы;
- `v` - "verbose" - выводить информацию в процессе выполнения;
- `z` - "gzip" - распаковать файл при помощи gzip;
- `j` - "bzip2" - распаковать файл при помощи bzip2;
- `f` - "file" - использовать имя файла архива для распаковки указаное после ключей.

> `tar -t prog-1-jan-2005.tar.gz`

### <a id="Добавление-к-концу-архива-файла" href="#Добавление-к-концу-архива-файла">Добавление к концу архива файла</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`tar [-<ключи>] [<название_архива>]`

Значения ключей:
- `r` - извлечь файлы;
- `f` - "file" - использовать имя файла архива указаное после ключей.

> `tar -rf prog-1-jan-2005.tar.gz image.png`

## <a id="gzip" href="#gzip">`gzip`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`gzip [-d] [-r] [-c] <файл>` - сжимает [`-d` - включает распаковывание, а не сжатие] файл [`-r` - рекурсивно проходитвсе файлы в каталоге] [`-c` - выводит результат в стандартный поток вывода и сохраняет оригинальный файл] в формате GNU Zip и добавляет к названию этого файла расширение `.gz`, при этом оригинальный файл замещается новым, у которого сохранены все старые атрибуты.  
`gunzip [-d] [-c] <файл>.gz` - распаковывает файл [`-d` - включает сжиматие, а не распаковывание] [`-c` - выводит результат в стандартный поток вывода и сохраняет оригинальный файл] в формате GNU Zip и убирает из названия этого файла расширение `.gz`.

## <a id="bzip2" href="#bzip2">`bzip2`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`bzip2 <файл>` - сжимает файл в формате GNU BZip и добавляет к названию новому файлу расширение `.bz2`.  
`bunzip2 [-d] [-c] <файл>.bz2` - распаковывает файл [`-d` - включает сжиматие, а не распаковывание] [`-c` - выводит результат в стандартный поток вывода] в формате GNU BZip и убирает из названия нового файла расширение `.bz2`.

## <a id="zip" href="#zip">`zip`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`zip <файл>` - сжимает и архивирует файл в формате Zip-архива Windows и добавляет к названию новому файлу расширение `.zip`.  
`unzip [-d] [-c] <файл>.zip [<имя_файла_1> [...]]` - разархивирует и распаковывает файл [`-d` - включает сжиматие, а не распаковывание] [`-c` - выводит результат в стандартный поток вывода] в формате Zip-архива Windows и убирает из названия нового файла расширение `.zip`.

<a id="wget" href="#wget">`wget`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Загрузка всех URL, указанных в локальном или внешнем файле:  
`wget -i <файл>`

Скачивание файлов в указанный каталог `-P`:  
`wget -P <каталог> <ссылка>`

Использование имени пользователя и пароля на FTP/HTTP (вариант 1):  
`wget ftp://<логин>:<пароль>@<ссылка>`

Использование имени пользователя и пароля на FTP/HTTP (вариант 2):  
`wget --user=<логин> --password=<пароль> <ссылка>`

Скачивание в фоновом режиме `-b`:  
`wget -b <ссылка>`

Продолжить (`-c` continue) загрузку ранее не полностью загруженного файла:  
`wget -c <ссылка>`

Скачать содержимое каталога <ссылка> и всех его подкаталогов, при этом не поднимаясь по иерархии каталогов выше:  
`wget -r --no-parent <ссылка>`

Идентификация на сервере:
```
wget --save-cookies <файл_с_куками> \
--post-data '<POST_данные>' \
<ссылка>
```

Скачать весь сайт целиком:  
`wget -r -l <глубина рекурсии> -k -o <файл_лога> -p <ссылка>`

Где:
- `-r`, `--recursive` - включение рекурсивной загрузки;
- `-l`, `--level=<число>` - глубина рекурсии (`inf` и `0` - бесконечность);
- `-k`, `--convert-links` - делать ссылки локальными в загруженном HTML или CSS;
- `-o`, `--output-file=<файл>` - записывать сообщения (логи) в `<файл>`;
- `-p`, `--page-requisites` - загрузить все изображения и проч., необходимые для отображения HTML-страницы;
- `-m`, `--mirror` - короткий параметр, эквивалентный `-N -r -l inf --no-remove-listing`.

<a id="grep" href="#grep">`grep`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Утилита командной строки, которая находит на вводе строки, отвечающие заданному регулярному выражению, и выводит их, если вывод не отменен специальным ключом.

`cat <файл> | grep [<опции>] <строка_поиска>` - поиск строки из потока ввода.

`grep [<опции>] <строка_поиска> <файл_1>[ ...]` - поиск строки из файлов, строка может быть регулярным выражением ERE.

Опции:
- `-c` - выводит количество отобранных строк;
- `-w` - ищет по слову целиком;
- `-i` - игнорирует регистр при поиске;
- `-C <количество>` - выводит заданное количество строк сверху и снизу от искомой;
- `-A <количество>` - выводит заданное количество строк снизу от искомой;
- `-B <количество>` - выводит заданное количество строк сверху от искомой;
- `-E` - интерпретировать строку поиска как регулярное выражение BRE и по ней искать;
- `-oE` - интерпретировать строку поиска как регулярное выражение и по ней искать и выводить только полное совпадение регулярному выражению;
- `-v` - все строки только без искомой;
- `-n` - выводит номер строки;
- `-r` - ищет по всем файлам каталога;
- `-h` - не выводит имена файлов;
- `-o` - выводит только текст, который совпал, без всей строки;
- `-l` - выводит только имена файлов, в которых есть строка;
- `-L` - выводит только имена файлов, в которых нет, ни одного совпадения;
- `--colour` / `--color` - подсвечивает искомую строку.

Формирование строки поиска:
- `'\<<строка_поиска>'` - поиск по началу слова;
- `'<строка_поиска>\>'` - поиск по концу слова;
- `'^<строка_поиска>'` - поиск по началу строки;
- `'<строка_поиска>$'` - поиск по концу строки.

Для удобства пользования делают цепочки поисков:  
`... | grep <строка_поиска1> | grep <строка_поиска2> | ...`

`grep -rnw '<путь>/' -e '<строка_поиска>'` - рекурсивно ищет строку во всех файлах.

Для файлов `gz` используется `zgrep`.

<a id="rsync" href="#rsync">`rsync`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

`rsync -av --progress [--delete] <откуда> <куда>[ --exclude <исключение>[ ...]]` - копирует файлы [`--delete` и удаляет те файлы, которых нет в исходном каталоге].
> `rsync source/ destination` - копирует содержимое каталога в указанный каталог.

Параметр `--rsh=ssh` позволяет производить копирование по сети.
> `rsync -av --delete --rsh=ssh /etc /home /usr/local remotesys:/backup`

<a id="Процессы" href="#Процессы">Процессы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========

Процесс может находиться в следующих статусах:
- **выполнение** (R, Running) - процесс находится в выполнении или ожидании ЦПУ для выполнения;
- **сон** (S, Sleep) - процесс находится в прерываемом программном ожидании;
- **непрерываемый сон** (D, Direct) - процесс находится в ожидание "прямого" сигнала от аппаратной части для прерывания;
- **приостановлен** (T, Tracing) - процесс находится в отладке;
- **зомби** (Z, Zombie) - выполнение процесса завершено, однако ресурсы не освобождены.

## <a id="ps" href="#ps">`ps`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Программа в UNIX, Unix-подобных и других POSIX-совместимых операционных системах, выводящая отчет о работающих процессах.

`ps [<опции>]` - показывает все процессы которые запущены текущим пользователем.

Опции, отбирающие процессы для отчета:
- `-A` - все процессы;
- `-a` - связанные с конкретным терминалом, кроме главных системных процессов сеанса, часто используемая опция;
- `-N` - отрицание выбора;
- `-d` - все процессы, кроме главных системных процессов сеанса;
- `-e` - все процессы;
- `-f` - расширение информации;
- `T` - все процессы на конкретном терминале;
- `a` - процессы, связанные с текущим терминалом, а также процессы других пользователей;
- `r` - информация только о работающих процессах;
- `u` - включает детализированную информацию о работающих процессах;
- `x` - процессы, отсоединенные от терминала.

### <a id="Выводимая-информация" href="#Выводимая-информация">Выводимая информация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Столбцы:
- **USER** - идентификатор пользователя владельца процесса;
- **PID** - идентификатор процесса;
- **%CPU** - использование процессора в процентах;
- **%MEM** - использование памяти в процентах;
- **VSZ** - объем виртуальной памяти;
- **RSS** - размер страниц памяти - объем физической памяти (ОЗУ), используемой процессом, кб;
- **TT** (**TTY**) - терминал, с которым связан данный процесс;
- **STAT** - состояние, в котором на данный момент находится процесс. Параметры **STAT**:
    - **R** - процесс выполняется в данный момент;
    - **S** - процесс ожидает (т.е. спит менее 20 секунд);
    - **I** - процесс бездействует (т.е. спит больше 20 секунд);
    - **D** - процесс ожидает ввода-вывода (или другого недолгого события), непрерываемый;
    - **Z** - *zombie* или *defunct* процесс, то есть завершившийся процесс, код возврата которого пока не считанный родителем;
    - **T** - процесс остановлен;
    - **W** - процесс в свопе;
    - **<** - процесс в приоритетном режиме;
    - **N** - процесс в режиме низкого приоритета;
    - **L** - *real-time* процесс, имеются страницы, заблокированные в памяти;
    - **s** - лидер сессии.
- **STARTED** (**START**) - время старта процесса;
- **TIME** - объем процессорного времени, потребленного процессом;
- **COMMAND** - команда, запустившая данный процесс "с некоторыми опциями выводит и каталог откуда процесс был запущен".

Опция o позволяет указать набор столбцов в ответе:
`ps o [<имя_столбца> [, <имя_столбца> [, ...]]]`

> `ps x -o "%p %r %y %x %c"` - Linux  
> `ps x -o "pid pgid command"` - MacOS

## <a id="top" href="#top">`top`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Выводит периодически обновляемую информацию о запущенных процессах и сводную информацию о них.

## <a id="kill" href="#kill">`kill`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Завершает работу процесса, фактически посылает процессу сигнал.

`kill [<сигнал>] [<опция>] <PID1>[ <PID2>[ ...]]`

Основные сигналы:
- `SIGTERM` - этот сигнал запрашивает остановку работы процесса. Он может быть проигнорирован. Процессу дается время на корректное завершение;
- `SIGKILL` - этот сигнал заставляет процесс прекратить работу немедленно. Программа не может проигнорировать этот сигнал. Несохраненные результаты будут потеряны.

Вывод всех видов сигналов: `kill -l`.  
Сигнал по умолчанию (если он не задан) - `SIGTERM`.

> `kill -9 3629`  
> `kill SIGKILL 3629`

`kill -TERM -- -<номер_группы>` - завершает всю группу процессов по `pgid`.

## <a id="pkill" href="#pkill">`pkill`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Команда `pkill` позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID можно завершить приложение, введя имя его процесса.

> `pkill firefox`

## <a id="killall" href="#killall">`killall`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Команда `killall` позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID можно завершить приложение, введя имя его процесса и завершить все экземпляры процесса с этим именем.

> `killall firefox`

## <a id="Остановка-системы" href="#Остановка-системы">Остановка системы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`halt` - останавливает систему.

`poweroff` - выключает электропитание.

`reeboot` - перезагружает систему.

`shutdown [-h] [-r] <время>` - [выключает] [перезагружает] систему через определенное время.

## <a id="Другие-команды" href="#Другие-команды">Другие команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`cat /proc/cpuinfo` - выводит информацию о процессоре.  
`cat /proc/meminfo` - выводит информацию о памяти.  
`lscpu` - общая информация о ЦПУ.

`free -m` - показывает объем оперативной памяти, весь, свободный и занятый в МБ.



<a id="ssh" href="#ssh">`ssh`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

`ssh-keygen -t rsa [-f <имя_файла>]` - генерирование пары ключей RSA, создаст ключи по умолчанию:
- `~/.ssh/id_rsa.pub` - открытый ключ;
- `~/.ssh/id_rsa` - закрытый ключ.

> `ssh-keygen -t rsa -b 4096`

`ssh-keygen -l -f <имя_файла>` - проверяет файл на валидность ключа.  
`ssh-keygen -y <имя_файла>` - выводит содержимое ключа после ввода пароля (служит для проверки пароля).

По умолчанию берутся ключи с именем:
- `~/.ssh/id_rsa`;
- `~/.ssh/id_ed25519`;
- `~/.ssh/id_dsa`;
- `~/.ssh/id_ecdsa`.

Для указания определенного ключа для адреса `<url>` используется файл конфигурации `~/.ssh/config` со структурой:
```bash
# <коментарий>
Host <url1>
  Preferredauthentications publickey
  IdentityFile ~/.ssh/<приватный_ключ>
# ...
```

В каталоге пользователя, под которым нужно зайти, если создать файл: `~/.ssh/authorized_keys` и положить туда открытый ключ, то можно будет заходить без пароля, права на файл не должны давать возможность писать в этот файл посторонним пользователям, иначе `ssh` его не примет. В ключе последнее поле - `user@server`. Оно не имеет никакого отношения к авторизации и служит только для удобства определения где чей ключ, это поле может быть поменяно (или даже удалено) без нарушения структуры ключа.

`ssh-add [<key>]` - добавляет ключи по пути `$HOME/.ssh/identity`, `$HOME/.ssh/id_rsa`, `$HOME/.ssh/id_dsa` [или указанный ключ] для ssh-agent на текущую сессию, который будет использоваться для проброса на другие сервера.

`ssh-add -L` - выводит список всех добавленных ключей для агента.

`ssh-add -D` - удаляет все добавленные ключи из агента.

`ssh-add -d <key>` - удаляет указанный ключ из агента.

`ssh-copy-id [-i ~/.ssh/id_rsa.pub] "[-p <port> ]<user>@<server>"` - копирует ключ на машину при этом не редактируя файлы вручную.

`~/.ssh/known_hosts` - хранятся ключи сервера, с которыми есть связь. Узнать, где какой ключ нельзя.

`ssh-keygen -R <server>` - удаляет известный ключ сервера, также необходимо сделать это и для IP, так как они хранятся раздельно: `ssh-keygen -R <IP>`.

Ключ сервера хранится в `/etc/ssh/ssh_host_rsa_key` и `/etc/ssh/ssh_host_rsa_key.pub`.

`ssh <user>@<server>` - подключается к удаленному серверу.

Ключ `-o StrictHostKeyChecking=no` - игнорирует смену публичного ключа сервера.

`ssh <user>@<server> [-t] <команда>[ <аргумент1>[ ...]]` - выполняет команду на удаленном сервере и тут же закрывает соединение [с управляющим терминалом для команд]. Для таких команд можно использовать pipe `|`, stdin `<`, stout `>` как для простых программ.

> `ssh user@8.8.8.8 command > my_file`  
> `mycommand | ssh user@8.8.8.8 "scp - user@10.1.1.2:/path/to/file"` - позволяет прокидывать файлы с сервера на сервер.  
> `ssh example.com -t "cd /www/example.com && git status -sb | head -1"`

В файле `~/.ssh/config` позволяет задать параметры подключения, в том числе специальные для каждого из серверов, а также задать им алиасы и так для каждого из серверов:
```
Host <алиас>
    Hostname <server>
    User <user>
    ForwardX11 yes
    Compression yes
    PasswordAuthentication no
```

Настройки соединения по умолчанию с помощью конструкции `Host *`.

В файле `/etc/ssh/ssh_config` задаются для всех.

`ssh -D localhost:<port> <user>@<server>` - задает туннелирование порта, заключается в том, что создается сокет для прослушивания порта на локальной машине, привязанный (необязательно) к конкретному адресу. Когда создается соединение к этому порту, это соединение туннелируется по зашифрованному каналу, и протокол приложения затем используется, чтобы определить, куда соединяться с удаленной машиной. При этом SSH работает как SOCKS сервер.

`ssh -L [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<user>@]<server>` - все соединения на `<локальный_адрес>:<локальный_порт>` будут переадресовываться удаленному серверу, который будет соединяться с `<удаленный_адрес>:<удаленный_порт>` от своего имени. По умолчанию `<локальный_адрес>` соответствует `127.0.0.1`. Возможно использование нескольких ключей `-L` в одном клиенте.

`ssh -R [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<user>@]<server>` - работает также как и `-L`, только соединения перебрасываются с удаленной машины на локальную.

`ssh -A <user1>@<server1> ssh <user2>@<server2>` - пробрасывает авторизацию на удаленный сервер.

`ssh -T <url>` - проверяет наличие соединения с `<url>`.

`ssh -vT <user>@<server>` - пытается подключиться к серверу и выводит информацию (дебаг) по попыткам подключения к нему. `-1` - файл не существует, `1` - существует.

## <a id="scp" href="#scp">`scp`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Работает на основе ssh и не требует дополнительного ПО.

`scp <путь_к_локальному_файлу> <user>@<server>:<путь_к_каталогу_на_сервере>` - осуществляет копирование файла через ssh-сессию на сервер.

`scp -r <путь_к_локальному_каталогу> <user>@<server>:<путь_к_каталогу_на_сервере>` - осуществляет копирование каталога через ssh-сессию на сервер.

`scp <user>@<server>:<путь_к_файлу_на_сервере> <путь_к_локальному_каталогу>` - осуществляет копирование файла через ssh-сессию с сервера.

## <a id="sftp" href="#sftp">`sftp`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Работает на основе ssh и не требует дополнительного ПО.

`sftp <user>@<server>` - подключается к серверу и позволяет в интерактивном режиме вводить команды.

`sftp <user>@<server>:<file>` - копирует файл с сервера в текущую директорию.

Основные команды:
- `bye` - завершает соединение;
- `quit` - завершает соединение;
- `ls [<путь>]` - выводит содержимое текущей директории [по указанному пути] на сервере;
- `lls [<путь>]` - выводит содержимое текущей директории [по указанному пути] на клиенте;
- `pwd` - выводит текущую директорию на сервере;
- `lpwd` - выводит текущую директорию на клиенте;
- `cd <путь>` - изменяет директорию на сервере;
- `lcd <путь>` - изменяет директорию на клиенте;
- `mkdir <путь>` - создает каталог на сервере;
- `rmdir <путь>` - удаляет каталог на сервере;
- `get <путь>` - копирует файл по пути с сервера в текущий каталог на клиенте;
- `put <путь> [<путь_на_сервере>]` - копирует файл по пути с клиента в текущий каталог на сервере;
- `delete <путь>` - удаляет файл по пути с сервера.

Можно использовать перенаправление ввода для передачи списка команд и тогда они разделяются переводом строки:
```bash
sftp user@server <<EOF
lcd ~/dir
cd ~/remote_dir
put file.tmp sub_path/file_from_clien.txt
quit
EOF
```

<a id="screen" href="#screen">`screen`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========

Позволяет сворачивать в фон программы, которые сами этого не умеют, с возможностью последующего возврата к ним.

`screen` - создает новый скрин, в котором откроет сессию командной оболочки.  
`screen <команда>` - создает новый скрин, в котором откроет указаную команду.

`Ctrl+a` - переводит `screen` в командный режим, в котором требуется нажать дополнительные клавиши для дополнительных команд.

`Ctrl+a d` - сворачивает текущий скрин, отключает его от терминала.  
`Ctrl+a k` - завершает текущий скрин вместе со всем, что в нем работает, необходимо подтвердить выход нажав `y`.  
`Ctrl+a c` - запускает новое окно скрина.  
`Ctrl+a w` - выводит список активных окон скрина в верхнем углу окна.  
`Ctrl+a p` - переключает на предыдущее окно скрина.  
`Ctrl+a n` / `Ctrl+a <пробел>` - переключает на следующее окно скрина.  
`Ctrl+a "` - выводит интерактивный список активных окон скрина, по которому можно перемещаться стрелками вверх-вниз и входить с помощью `Enter` в нужное.  
`Ctrl+a <номер_окна>` - переключает на указаное `<номер_окна>` окно скрина (0, 1, ...).  
``Ctrl+a ` `` - а затем номер и будет осуществлен переход на указанный номер окна скрина.  
`Ctrl+a A` - а затем необходимо ввести новое имя окна и с помощью `Enter` задать его.  
`Ctrl+a N` - выводит имя активного окна скрина в верхнем углу окна.  
`Ctrl+a S` - добавляет горизонтальный регион на экран, в котором будет отображено указаное окно скрина.  
`Ctrl+a |` - добавляет вертикальный регион на экран, в котором будет отображено указаное окно скрина.  
`Ctrl+a Tab` - переходит на следующий регион.  
`Ctrl+a X` - закрывает текущий регион.  
`Ctrl+a Q` - закрывает все регионы, кроме текущего региона.  

`screen -r` - возвращает к заранее сернутому скрину.

Для выхода из окна скрина необходимо написать `exit`.

`screen -S <имя> <команда>` - создает новый именованный скрин, в котором откроет указаную команду.  
`screen -r <имя>` - возвращает к заранее сернутому именному скрину.

`screen -list` / `screen -ls` - выводит список запущенных скринов.

<a id="wildcards---шаблоны-замены" href="#wildcards---шаблоны-замены">wildcards - шаблоны замены</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========================

Командный интерпретатор линукс поддерживает возможность указания множества файлов используя шаблоны. Bash и другие команды линукс выбирают только те файлы, которые совпадают с шаблоном. Шаблоны:
- `*` - соответствует нулю или большему количеству символов;
    > `/tmp/my*1` - все файлы в директории `/tmp` имена которых начинаются с `my` и заканчиваются на `1` (включая файл с именем "my1")
    - `**` - соответствует всем файлам и нулю или более директорий и поддиректорий в пути;
    - `/**` - соответствует нулю или более директорий и поддиректорий:
        > `org/**/servlet/bla.jsp` - все файлы в директории `org/` пути которых заканчиваются на `/servlet/bla.jsp`
- `?` - заменяет один любой символ;
    > `/tmp/notes?txt` - соответствует файлам с именами "`notes.txt`" и "`notes_txt`" (если они существуют в `/tmp/`)
- `[<диапазон>]` - совпадает с одним символом из тех что указаны в скобках. Также в скобках можно указать диапазон символов, для этого используется символ `-` или несколько диапазонов подряд, тогда шаблон будет совпадать с одним любым символом из этого диапазона;
    > `/tmp/[A-Za-z]*` - все файлы в директории `/tmp/` имена которых начинаются с буквы (заглавной или прописной)
- `[[<диапазон>]` (= `[!<диапазон>]`) - похожа на `[]`, за исключением того что она соответствует единичному символу, не упомянутому между `[[` и `]`;
    > `myfile[[9]` - удалит все файлы, имена которых состоят из слова `myfile` и идущей за ним одной цифрой, кроме файла `myfile9`
- `<преамбула>{<значение1>,[ ...]}<эпилог>` - раскроет скобочную группу `{<значение1>,[ ...]}` в количестве элементов в ней содержащихся и превратит в последовательно идущие строки разделенные пробелом: `<преамбула><значение1><эпилог>[ ...]`. Может использоваться диапазон `<преамбула>{<от>..<до>}<эпилог>`.
> `touch app.{html,css,js}` = `touch app.html app.css app.js`  
> `touch version.{01..15}.txt`

Так как bash интерпретирует символы `?`, `[`, `]`, `*` как шаблоны замены, то для использования их как сивмолов их экранировать, т.е. поставить знак `\` перед ними или взять строку в одинарные кавычки `'`. Чтобы указать текстовый символ `\` можно заключить его в одинарные кавычки или написать `'\\\'`.

Вместо `<диапазон>` можно использовать классы символов: `[[:<класс>:]]`.

Для получения списка скрытых файлов, тех которые начинаются на `.` используется конструкция: `.[!.]?*`.
> `ls -d .[!.]?*`

При использовании с командами, они преобразуются в последовательность файлов, т.е. конструкция вида `<команда> <шаблон>` будет равна `<команда> <файл1> <файл2>[ ...]`.

> `ls ./lib*` = `ls ./lib ./lib64 ./libexec`

<a id="Поиск-файлов" href="#Поиск-файлов">Поиск файлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

`locate <файл>` - выводит все места расположения файла с таким именем.

`updatedb` - запускает создание или обновление БД для поиска через `locate`.

`whereis <приложение>` - выводит все возможные местоположения (расположение) программы.

`which <приложение>` - выводит местоположение программы, которое вызовется по умолчанию.

## <a id="find" href="#find">`find`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`find <каталог>` - выводит список всех файлов в каталоге и его подкаталогах. Опции:
- `-name <имя>` - только те, которые соответствуют имени;
- `-newer <файл>` - только те, которые были изменены (редактированы, или созданы) позже файла с именем `<файл>`;
- `-iname <имя>` - только те, которые соответствуют имени, но без учета регистра в названии файлов;
- `-type {f | d | l}` - только файлы с определенным типом: `f` - обычные файлы, `d` - каталоги, `l` - символичные ссылки;
- `-atime [<мод>]<n>` - производит поиск по дате создания или последнего доступа к ним, где `<n>` - количество суток, в пределах `<n>` и `<n> + 1` дней [при модификаторе `<мод>` равным `-` - меньше `<n>` дней, при `+` - больше `<n>` дней];
- `-ctime [<мод>]<n>` - производит поиск по дате создания или изменения статуса файла или папки;
- `-mtime [<мод>]<n>` - производит поиск файлов, которые были изменены (редактированы, или созданы);
- `-amin [<мод>]<n>` - аналогично `-atime`, только `<n>` - означает количество минут;
- `-cmin [<мод>]<n>` - аналогично `-ctime`, только `<n>` - означает количество минут;
- `-mmin [<мод>]<n>` - аналогично `-mtime`, только `<n>` - означает количество минут;
- `-exec <команда>[<аргумент1>[ ...]] '{}' {\; | +}` - используется для указания другой команды, которую надо выполнить над каждым найденым файлом в результате поиска, где `{}` - заменяется на символическое представление текущего пути к файлу, а `\;` - конец команды, если указан `+`, то `{}` будет представлять собой объединенный список имен файлов результата поиска;
- `-size {+ | -}<n>{c | w | b | k | M | G}` - выводит только файлы, которые больше при знаке `+` или меньше при `-` определенного размера `<n>` в величине измерения: `c` - в байтах, `w` - в 2-байтных словах, `b` - в блоках по 512 байт, `k` - в килобайтах, `M` - в мегабайтах, `G` - в гигабайтах.

> `find . -type d -atime +2`  
> `find . -size +2048k`  
> `find .` - выводит список всех файлов в текущем каталоге и его подкаталогах.  
> `find /home/nobody/public_html -type f -exec chmod 644 '{}' \;` - меняет права на все файлы в папке.  
> `find . -type f -size +100M | xargs ls -lh` - выводит все файлы, размер которых больше 100 Мегабайт.

Поддерживает группировку с помощью логических операторов:
- `-and` (`-a`) - соотвествует логическому и;
- `-or` (`-o`) - соотвествует логическому или;
- `-not` (`-!`) - соотвествует логическому не.

По умолчанию между опциями стоит `-and`.

Рекомендуется блоки условий помещать в `\(` и `\)`.
> `find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)`

<a id="Пользователи-и-группы" href="#Пользователи-и-группы">Пользователи и группы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====================

**Пользователь** - это сущность, которая может запускать процессы и обладать файлами, у каждого пользователя есть **имя пользователя** и **идентификатора пользователя**.

**Группы** состоят из пользователей. Основная цель групп заключается в том, чтобы пользователь мог предоставлять файлы для совместного доступа другим пользователям группы.

`id` - выводит информацию о текущем пользователе, его идентификатор **uid**, идентификатор основной группы **gid** и других группах в которых он состоит.

В файле `/etc/passwd` содержится информация о пользователях и содержит:
- имя пользователя (для входа);
- пароль в виде `*`;
- числовой идентификатор пользователя (uid);
- числовой идентификатор основной группы (gid);
- действительное имя пользователя;
- путь к домашнему каталогу;
- путь к командной оболочка входа (login shell).

`users` - выводит список авторизованных пользователей.  
`cut -d: -f1 /etc/passwd | sort | uniq` - выводит список всех пользователей.

`useradd <имя_пользователя>` - добавляет пользователя.  
`userdel <имя_пользователя>` - удаляет пользователя.

`groups [<имя_пользователя>]` - выводит список групп, в которых состоит текущий [указанный] пользователь. Основная (первичная) группа пользователя находится в файле: `/etc/passwd`.

`newgrp <имя_группы>` - производит смену первичной группы на указаную до конца сеанса или вызова команды `exit`.

`cut -d: -f1 /etc/group > | sort` - выводит список всех групп.

`groupadd <имя_группы>` - добавляет группу.  
`groupdel <имя_группы>` - удаляет группу.

`usermod -a -G <имя_группы_1>[, ...] <имя_пользователя>` - добавляет группы пользователю.  
`usermod -g <имя_группы> <имя_пользователя>` - изменяет первичную группу пользователя.  
`usermod -d <имя_пользователя> <имя_группы>` - удаляет пользователя из группы.

`su { - | <имя_пользователя>} [-c '<команда>']` - запускает в текущей консоли командную оболочку c правами другого пользователя `<имя_пользователя>`, по умолчанию - рута [и выполняет в ней одну команду и закрывает ее].  
`sudo [-u <имя_пользователя>] <команда>` - позволяет запустить одиночную команду с правами другого пользователя [`<имя_пользователя>`], по умолчанию - рута.  
Чтобы вернуться в оболочку обычного пользователя, нужно дать команду `exit`, `logout` или нажать `Ctrl + D`.

`w` - выводит список подключенных пользователей и их терминалов.

`whoami` - выводит логин пользователя под которым произведен вход.

`passwd [<имя_пользователя>]` - изменяет пароль текущему пользователю [указаному `<имя_пользователя>`].

<a id="Права-и-владение-файлами" href="#Права-и-владение-файлами">Права и владение файлами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========================

Пользователь, который создает файл становится владельцем этого файла, а **первичная** группа, в которую входит этот же пользователь, так же становится владельцем этого файла.

`ls -l` - выводит список файлов с правами на них.

## <a id="Права" href="#Права">Права</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

двоичная | восьмеричная | символьная | права на файл       | права на каталог
-------- | ------------ | ---------- | ------------------- | ---------------
`000`    | `0`          | `---`      | нет                 | нет
`001`    | `1`          | `--x`      | выполнение          | чтение файлов и их свойств
`010`    | `2`          | `-w-`      | запись              | нет
`011`    | `3`          | `-wx`      | запись и выполнение | все, кроме чтения списка файлов
`100`    | `4`          | `r--`      | чтение              | чтение имен файлов
`101`    | `5`          | `r-x`      | чтение и выполнение | доступ на чтение
`110`    | `6`          | `rw-`      | чтение и запись     | чтение имен файлов
`111`    | `7`          | `rwx`      | все права           | все права

`chmod [-R] [[u][g][o][a]{+ | - | =}[w][r][x][s][t]] <файл>` - устанавливает права на файл или каталог [рекурсивно], где: `u` - для пользователя, `g` - группы, `o` - других и `a` - для всех.
> `chmod u+rx file.txt`

`chmod <восмиричные_права_для_пользователя><восмиричные_права_для_группы><восмиричные_права_для_других> <файл>` - устанавливает права на файл или каталог в восьмеричной системе записи.
> `chmod 755 file.txt`

В некоторых исполняемых файлах вместо `x` указано `s` (setuid - 4000) в секции пользователя, что обозначает что данный файл запускается так, словно владельцем файла является пользователь с указанным идентификатором, а не текущий пользователь. Для секции группы (setgid - 2000) обозначает, что вместо идентификатора группы реального пользователя будет группа владельца файла, для какталога это значит, что создаваемые файлы в каталоге будут файлами с группой каталога, а не пользователя. `t` (sticky - 1000) - для остальных вместо `x` обозначает, что нельзя переименовывать каталог, файлы в нем и удалять их, если только пользователь не является из владельцем или суперпользователем.

`umask [<новое_значение>]` - выводит [устанавливает] значение маски в восьмиричной системе для установки прав на новые файлы. В позиции где маска установлена атрибут сбрасывается: `0022 = 000 000 010 010` `000 000 010 010 + --- rw- rw- rw- = --- rw- r-- r--`.
> `umask 0022`

## <a id="Владение" href="#Владение">Владение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`chown [-R] <имя_пользователя>[:[<имя_группы>]] <файл>` - устанавливает владельца [и группу владельцев] (если группа не указана при наличии `:`, то будет группа пользователя) на файл или каталог [рекурсивно].
> `chown luser public`  
> `chown lisa.sales myfile`

`chgrp [-R] <имя_группы> <файл>` - устанавливает группу владельцев на файл или каталог [рекурсивно].
> `chgrp geekpress public`

<a id="Сеть" href="#Сеть">Сеть</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====

`ping <домен>` - посылает специальные сетевые пакеты IMCP ECHO_REQUEST и выводит статистику по их приему.

`traceroute <домен>` - посылает последовательно всем узлам на пути сетевого трафика между локальной системой и указанным узлом сети и выводит список всех "переходов" (hops) со статистикой по ним.

`ip addr show` - выводит на экран список сетевых интерфейсов.  
`ip a` - выводит IP адреса.  
`ip n` - выводит ARP-таблицу.

`ip link set <интерфейс> up` - поднимает сетевой интерфейс.  
`ip link set <интерфейс> down` - отключает сетевой интерфейс.
> `ip link set eth1 up`

`ifup <интерфейс>` - поднимает сетевой интерфейс.  
`ifdown set <интерфейс>` - отключает сетевой интерфейс.

Перезапуск сети: `systemctl restart network`.

`brctl show` - выводит на экран список мостов.

`netstat -tulpn` - выводит открытые порты.  
`ss -tulpn` - аналогично.

`cat /etc/resolv.conf` - содержит конфигурацию DNS.

`host <домен>` - возвращает ip-адрес указаного домена и все его dns-алиасы.

`nslookup <домен>` - проверяет разрешение DNS-имени.

## <a id="Установка-DNS" href="#Установка-DNS">Установка DNS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для интерфейса `<интерфейс>` выполняется команда `nmcli con mod <интерфейс> ipv4.dns "8.8.8.8 8.8.4.4"` и затем перезапускается с помощью команд `nmcli con down <интерфейс>` и `nmcli con up <интерфейс>`.

<a id="Пакеты" href="#Пакеты">Пакеты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Управление пакетами (package management) - это методика установки и управления программным обеспечением в системе.

Файл пакета - это сжатая коллекция файлов, составляющих программный пакет. Может включатьв себя множество файлов и программ.

Основные системы пакетов:
- **Debian** (`.deb`) - Debian, Ubuntu, Linux Mint, Raspbian. Основные системы управления пакетами:
    - `dpkg` - низкоуровневый инструмент;
    - `apt-get`, `apt`, `aptitude` - высокуровневые инструменты.
- **Red Hat** (`.rpm`) - Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE. Основные системы управления пакетами:
    - `rpm` - низкоуровневый инструмент;
    - `yum`, `dnf` - высокуровневые инструменты.

`apt-get update` - обновление информации о пакетах, которые содержатся в репозитории.

`apt-cache search <искомая_строка>` - ищет пакеты, которые содержат указанную строку.  
`yum search <искомая_строка>` - аналогично.

`apt-cache install <имя_пакета>` - устанавливает пакет из репозитория с его зависимостями.  
`yum install <имя_пакета>` - аналогично.

`dpkg -i <файл_пакета>` - устанавливает только пакет из файла.  
`rpm -i <файл_пакета>` - аналогично.

`apt-get remove <имя_пакета>` - удаляет пакет с его зависимостями.  
`yum erase <имя_пакета>` - аналогично.

`apt-get upgrade` - обновляет пакеты из репозитория.  
`yum update` - аналогично.

`dpkg -i <файл_пакета>` - обновляет пакет из файла.  
`rpm -U <файл_пакета>` - аналогично.

`dpkg -l` - выводит список установленных пакетов.
`rpm -qa` - аналогично.

`dpkg -s <имя_пакета>` - определяет, установлен ли пакет.  
`rpm -q <имя_пакета>` - аналогично.

`apt-cache show <имя_пакета>` - выводит информацию об устанавленном пакете.  
`yum info <имя_пакета>` - аналогично.

`dpkg -S <имя_файла>` - определяет, с каким пакетом был установлен файл.  
`rpm -qf <имя_файла>` - аналогично.

`yum repolist -v` - (CentOS) выводит список подключенных репозиториев.

<a id="Сервисы" href="#Сервисы">Сервисы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

`systemctl list-units [-a]` - выводит список служб [все службы].  
`systemctl status <служба>` - посмотреть состояние и вывод службы.  
`systemctl show <служба>` - посмотреть параметры управления службой в Linux.  
`systemctl is-active <служба>` - проверить запущена ли служба linux.

`systemctl start <служба>` - запустить службу linux.  
`systemctl stop <служба>` - остановить службу linux.  
`systemctl reload <служба>` - обновить конфигурацию службы из файла юнита.  
`systemctl restart <служба>` - перезапустить службу.

`systemctl enable <служба>` - добавить службу в автозагрузку.  
`systemctl disable <служба>` - удалить службу из автозагрузки.  
`systemctl is-enabled <служба>` - проверить если ли уже служба в автозагрузке.  
`systemctl reenable <служба>` - сначала выполнить `disable` потом `enable` для службы.

Флаг `--runtime` позволяет не сохранять вносимые изменения после перезагрузки.

<a id="Команды-для-файловой-системы" href="#Команды-для-файловой-системы">Команды для файловой системы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============================

`cd <каталог>` - перемещение в указанный каталог.  
`cd` - перемещение в домашний каталог.  
`cd ..` - перемещение на каталог выше по иерархии.  
`cd -` - перемещение в предыдущий каталог, в котором находились до этого перемещения.

`~` - специальное имя, указывающее в bash на домашнюю директорию пользователя.

`ls [<опции>] {<каталог> | <файл>}` - выводит на экран список файлов хранящихся в указанном каталоге (текущем, если не указан) или информацию о файле. Опции:
- `-a` - все файлы, включая скрытые (имена которых начинаются с точки);
- `-A` - аналогично `a`, только не выводит каталоги `.` и `..`;
- `-l` - выводит подробную информацию, такую как:
    - тип файла - первый символ:
        - `-` - файл;
        - `d` - каталог;
        - `l` - ссылка;
        - `b` - блочное устройство;
        - `c` - символьное устройство;
        - `p` - канал;
        - `s` - сокет;
    - права на файл;
    - число жестких ссылок на файл;
    - имя владельца;
    - имя группы;
    - размер файла в байтах;
    - время последнего изменения файла;
    - имя файла;
    - если это ссылка, то после знака `->` стоит имя объекта на который она ссылается;
- `-h` - вместе с `-l` выводит размер фалов в удобочитаемом формате;
- `-d` - только информация о каталоге, а не о содержимом каталога;
- `-R` - рекурсивный вывод всех файлов находящихся в директории;
- `-i` - показывает **инод** (inode number) - уникальный номер;
- `-F` - показывает типы файлов;
- `-S` - сортирует по размеру;
- `-t` - сортирует по времени последнего изменения;
- `-r` - инвертирует порядок сортировки;
- `-1` - выдавать в одноколоночном формате.

`pwd` - показать текущую директорию.

`cp <откуда>[ ...] <куда>` - копирует файлы, если `<куда>` - существующая директория, то копирует файлы в нее. Дополнительные параметры:
- `-a` - при копировании атрибуты файлов, их владельцы и права доступа;
- `-r` - рекурсивное копирование каталогов и их содержимого;
- `-u` - только файлы, которые отсутствуют или более новые, если они уже есть в каталоге;
- `-v` - включает вывод информационных сообщений.
`cp <файл>{,.copy}` - быстрое создание резервной копии файла.

`mv <откуда>[ ...] <куда>` - перемещает или переименовывает файлы, если `<куда>` - существующая директория, то перемещает файлы в нее.

`ln <имя> <файл>` - создает жесткую ссылку на файл. Таким образом, получается что файл присутствует в системе под несколькими разными именами. Файл существует до тех пор, пока с его инодом связано хотя бы одно имя. Понятия "*жесткая ссылка на файл*" и "*имя файла*" являются синонимами.

`ln -s <имя> <объект>` - создает символьную ссылку на любой объект (файл, директория, сокет...) любой файловой системы. *Симлинк* это специальный вид файла, который ссылается на другой файл по имени, а не напрямую на инод. Симлинки не предохраняют файл от удаления.

`rm <файл>[ ...]` - удаляет файлы. Опции:
- `-i` - запрашивает у пользователя подтверждение удаления каждого файла;
- `-f` - без подтверждения.

`rmdir <каталог>` - удаляет **пустой** каталог.  
`rm -rf <каталог>` - удаляет рекурсивно файлы и каталоги в указаном каталоге.

`touch <файл>` - изменяет временные метки файла или создает его, если его нет.  
`> <файл>` - очистка файла или его создание.

`mkdir [-p] <путь>` - производит создание директории [и всех вложенных директорий, если они отсутствуют].
> `mkdir -p my-app/{css,js}` - создание нескольких поддерикторий

`file <файл>` - выводит информацию о файле.

`basename <файл>` - удаляет начальную часть из пути к файлу, оставляя только базовое имя.

<a id="Команды-для-обработки-текста" href="#Команды-для-обработки-текста">Команды для обработки текста</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============================

`cat <файл_1>[ ...]` - вывод файлов в поток вывода. Основные флаги:
- `-A` - добавляет вывод непечатаемых символов;
- `-n` - добавляет вывод номеров строк;
- `-s` - не выводит подряд идущиее пустые строки.

Без передачи имен файлов, будет производится редактирование в консоли и запись в поток вывода.

Для вывода многострокового текста используется конструкция:
```bash
cat <<EOF [> <файл>]
...
EOF
```
```bash
cat << EOF > script.sh
printf "Hello\n"
printf "Wordl!\n"
EOF
```

`head [-n <количество_строк>] <файл>` - выводит 10 [только указаное количество] первых строк.

`tail [-n <количество_строк>] <файл>` - выводит 10 [только указаное количество] последних строк.  
`tail -n +<количество_строк> <файл>` - выводит с файла все строки, кроме `<количество_строк> - 1` первых строк.

Просмотр записи в текстовый файл в реальном времени:  
`tailf <файл>`  
`tail -f <файл>`

`sort <файл_1>[ ...]` - сортирует строки в файлах в соответствии в алфавитно-числовом порядке по возрастанию. Основные флаги:
- `-b` - с игнорированием начальных пробельных символов;
- `-f` - с игнорированием регистра;
- `-n` - в порядке следования чисел;
- `-r` - обратная сортировка;
- `-k <номер_поля>[n][b][r]` - сортировка по указанному полю по номеру (могут повторяться, тогда они добавляют внутреннюю сортировку),нумерация идет с 1, с модификаторами;
- `-k <номер_поля_от>,<номер_поля_до>` - сортировка по указанным полям по номеру от и до;
- `-k <номер_поля>.<номер_символа>` - сортировка по указанному полю по номеру, начиная с символа `<номер_символа>` и до разделителя;
- `-t '<символ_разделителя>'` - устанавливает разделитель для полей.
> `sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt`

`uniq <файл>` - удаляет подряд идущие повторяющиеся строки. Учитываются только подряд идущие одинаковые строки, поэтому часто данные сортируются перед тем как отправить их на вход программе. Основные флаги:
- `-d` - оставляет только уникальные;
- `-с` - выводит количество повторяющихся строк, предваряя их числом найденных дубликатов.

`cut <файл>` - извлекает фрагмент текста из строк в файле. Основные флаги:
- `-d '<разделитель>'` - устанавливает разделитель для полей;
- `-f <номер_поля_1>[,...]` - извлекает указанные поля, нумерация идет с 1;
- `-с <номер_символа_от>-<номер_символа_до>` - извлекает диапазон символов, нумерация идет с 1.
> `cat /etc/passwd | cut -d: -f1 | sort | uniq`

`paste <файл_1>[ ...]` - соединяет файлы построчно и выводит результат.

`join <файл_1>[ ...]` - соединяет файлы построчно по указанному ключевому полю, которое должно быть отсортировано, и выводит результат.

`comm [-[1][2][3]] <файл_1> <файл_2>` - построчно сравнивает два файла и выводит строки в три колонки [подавляет вывод указанной колонки]: в первой только те, что есть в первом файле, во второй только те, что есть во втором файле и в третьей общие.

`diff <файл_1> <файл_2>` - построчно сравнивает два файла и выводит группы изменений с предшествующими ей командами изменений в формате:
- `<номер_строки_файла_1>a<номер_строки_файла_2>` - указывает, что нужно добавить строки, находящиеся в диапазоне `<номер_строки_файла_2>` во втором файле, после строк в позиции `<номер_строки_файла_1>` в первом файле;
- `<номер_строки_файла_1>c<номер_строки_файла_2>` - указывает, что нужно изменить (заменить) строки в диапазоне `<номер_строки_файла_1>` в первом файле строками в диапазоне `<номер_строки_файла_2>` во втором файле;
- `<номер_строки_файла_1>d<номер_строки_файла_2>` - указывает, что нужно удалить строки в диапазоне `<номер_строки_файла_1>` в первом файле, которые находились бы в диапазоне `<номер_строки_файла_2>` во втором файле.

Флаг `-c` включает контекстный режим, где выводятся блоки строк в диапазонах `<строка_от>,<строка_до>` из файлов с модификаторами:
- ` ` - строка показана для контекста, различий нет в файлах;
- `-` - строка удалена, эта строка присутствует в первом файле и отсутствует во втором;
- `+` - строка добавлена, эта строка присутствует во втором файле и отсутствует в первом;
- `!` - строка изменена, эта строка изменена на указанную в обоих файлах.

Флаг `-u` включает унифицированный режим, где выводятся блоки строк в диапазонах `<строка_от>,<строка_до>` в результирующем файле с модификаторами:
- ` ` - строка, одинаковая в обоих файлах;
- `-` - строка отсутствует в первом файле;
- `+` - строка присутствует только в первом файле.

`patch < <diff_файл>` - применяет патч в указанном месте, который был создан командой: `diff -Naur <старый_файл> <новый_файл> > <diff_файл>`, где `<старый_файл>` и `<новый_файл>` могут быть каталогами.
> `diff -Naur file1.txt file2.txt > patchfile.txt`  
> `patch < patchfile.txt`

`tr "<строка_1>" "<строка_2>"` - заменяет каждый символ из входящего потока, который соответствует символу из `"<строка_1>"` на соответствующий ему символ по позиции из `"<строка_2>"`.

`tr -d "<строка>"` - удаляет все вхождения символов, указанных в `"<строка>"`.

<a id="Команды-для-форматирования-вывода" href="#Команды-для-форматирования-вывода">Команды для форматирования вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=================================

`nl <файл>` - нумерует строки в файле, начиная с 1 и выводит их в поток вывода. Опции:
- `-b <стиль>` - стиль нумерации, где `<стиль>` может быть:
    - `a` - нумеровать все строки;
    - `t` - нумеровать только не пустые (по умолчанию);
    - `n` - не нумеровать;
    - `<рег_выр>` - нумеровать только те строки, которые удолетворяют регулярному выражению.
- `-n <формат>` - формат номеров, где `<формат>` может быть:
    - `ln` - с выравниванием по левому краю, без ведущих нулей;
    - `rn` - с выравниванием по правому краю, без ведущих нулей (по умолчанию);
    - `rz` - с выравниванием по правому краю и с ведущими нулями.
- `-s <строка>` - добавляет указанную строку в конец каждого номера строки для отделения номера от текста (по умолчанию символ табуляции);
- `-w <ширина>` - ширина поля номера строки (по умолчанию 6 символов).

> `nl -w 3 -s ' ' patchfile.txt`

`fold <файл>` - разбивает строки из файла по определенному размеру и выводит их в поток вывода. Опции:
- `-w <ширина>` - устанавливает максимальную ширину строки;
- `-s` - устанавливает разбиение строки по последнему доступному пробелу перед достижением указанной ширины.

> `echo "The quick brown fox jumped over the lazy dog." | fold -w 12 -s`

`fmt <файл>` - форматирует файл, при это по умолчанию пустые строки, пробелы между словами и отступы сохраняются в выводе, последующие строки с разными отступами не объединяются, символы табуляции на входе заменяются соответствующим числом пробелов и выводятся в таком виде, и выводит их в поток вывода. Опции:
- `-w <ширина>` - устанавливает максимальную ширину строки;
- `-c` - устанавливает режим обработки края с сохранением отступа первых строк абзаца и выравниванием последующих по второй строке;
- `-p <строка>` - форматирует только строки, которые начинаются с указанного символа и после форматирования содержимое аргумента добавляется в начало каждой переформатированной строки;
- `-s` - устанавливает режим простой разбивки, когда короткие строки не объединяются;
- `-u` - устанавливает режим нормирования пробелов, то есть когда слова отделяются одним пробелом, а предложения - двумя.

> `fmt -w 50 -p '# ' fmt-code.txt`

`pr -l <количество_строк> -w <ширина> <файл>` - разбивает строки из файла по определенному размеру и по указанному количеству строк для страницы и выводит их в поток вывода.

> `pr -l 15 -w 65 distros.txt`

`printf "<формат>" <аргумент_1> [...]` - принимает строку с описанием формата, которая содержит спецификаторы, которая затем применяется к списку аргументов и выводит ее в поток вывода.

Спецификаторы имеют формат: `%[<флаги>][<ширина>][.<точность>]<спецификатор_преобразования>`.

Флаги:
- `#` - использовать альтернативный формат вывода. Для типа `o` добавляет префикс `0`, для `x` добавляет префикс `0x`, для `X` добавляет префикс `0X`;
- `0` - добавляет нули в начало вывода;
- `-` - выравнивание по левому краю;
- ` ` - добавляет ведущий пробел перед положительными числами;
- `+` - выводит знак перед положительными числами.

Спецификаторы типов данных:
- `d` - форматирует число как десятичное целое со знаком;
- `f` - форматирует и выводит вещественное число;
- `o` - форматирует целочисленное значение как восьмеричное число;
- `s` - форматирует строку;
- `x` - форматирует целочисленное значение как шестнадцатеричное число, с использованием букв `a-f` нижнего регистра, где это необходимо;
- `X` - то же, что и `x`, но использует буквы верхнего регистра;
- `%` - символ `%`.

> `printf "Line: %05d %15.3f Result: %+15d\n" 1071 3.14156295 32589`

<a id="Компиляция-программ" href="#Компиляция-программ">Компиляция программ</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===================

## <a id="configure" href="#configure">`configure`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Проверяет наличие необходимых внешних инструментов и компонентов для компиляции программы и создает файл `Makefile` для сборки.

## <a id="make" href="#make">`make`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Принимает файл сборки (обычно с именем `Makefile`), в котором описываются отношения и зависимости между компонентами, составляющими окончательную программу.

Структура файла `Makefile`:
- переменные для подстановки: `<переменная_1>= <значение>` и используется внутри с помощью `$(<переменная_1>)`:
    > `CC= gcc`
- цели:
    ```
    <цель_1>: <цель_зависимости_1>[ ...]
              <команда_1>
              [...]
    ```
    ```
    diction:    diction.o sentence.o misc.o getopt.o getopt1.o
                $(CC) -o $@ $(LDFLAGS) diction.o sentence.o misc.o \
                getopt.o getopt1.o $(LIBS)
    ```

`make` запускает и выполняет все инструкции в файле `Makefile`.

`make <target>` запускает и выполняет только инструкцию `<target>` в файле `Makefile`.

`make install` - проузводит установку собранной программы.

<a id="Другие-команды" href="#Другие-команды">Другие команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==============

`alias <алиас>="<список_команд>"` - задает алиас для спика команд. Используется как `<алиас>`. Для установки алиасов по умолчанию их добавляют в файл: `~/.bash_profile`.

`alias` - выводит список алиасов.

`unalias <алиас>` - удаляет алиас.

`<команда> | xargs <команда> [<начальный_аргумент>[ ...]]` - объединяет зафиксированный набор заданных в командной строке начальных аргументов с аргументами, прочитанными со стандартного ввода, и выполняет указанную команду.
> `ls -1 | xargs git diff`

`time <команда>` - выводит время выполнения команды.

`watch <команда>` - следит за изменениями в выводе команды.

`truncate -s <размер_в_байтах> <файл>` - усекает размер файла до `<размер_в_байтах>`.

`tee <файл>` - читает данные из стандартного ввода и пишет их одновременно в файл и в стандартный поток вывода.

`more <файл>` - вывод файла в поток вывода.

`less[ <файл>]` - постранично выводит содержимое файла или из стандартного потока ввода. Управление:
- `Пробел` - перемещение на следующий экран;
- `B` - перемещение на предыдущий экран;
- `Q` - выход;
- `N` - продолжение поиска. Поиск происходит вводом:
    - `/<строка_поиска>` - поиск в прямом направлении;
    - `?<строка_поиска>` - поиск в обратном направлении.

`man <команда>` - выводит информацию о команде.  
`man -k <ключевое_слово>` - производит поиск по онформации о командах по ключевому слову.

`md5sum <файл>` - возвращает md5-хеш для файла.

`wc <файл>` - выводящая число (количество) переводов строк, слов и байт для каждого указанного файла и итоговую строку, если было задано несколько файлов. Если входной файл не задан, или равен `-`, то данные считываются со стандартного ввода. Флаги:
- `-l` - только количество строк;
- `-c` - только количество байт;
- `-m` - только количество символов;
- `-L` - только длину самой длинной строки;
- `-w` - только количество слов.

> `ls | wc -l` - считает количество файлов.

`xxd -p <файл>` - выводит в hex-формате содержимое файла

> `xxd -p <файл> | tr -d '\n'` - то же самое, только в одну строку.

`date` - выводит текущую дату в консоль.  
`date +%s` - выводит текущую дату в консоль в секундах.  
`date +"%x %r %Z"` - выводит текущую дату в консоль в удобочитаемом формате.

`cal` - выводит календарь для текущего месяца.

`uptime` - выводит время работы сервера.

`type <команда>` - выводит тип команды и ее расположение.  
`type -t <команда>` - выводит только тип команды.  
`type -a <команда>` - выводит все расположение команды и ее алиасы.

`command -v <команда>` - возвращает путь к команде.  
`command -V <команда>` - возвращает только путь к команде.

`uname -or` - выводит версию Linux.  
`cat /proc/version` - выводит информацию о версии Linux.

`clear` - очищает терминал.

`sleep <количество_секунд>` - приостанавливает выполнение программы на определенное количество секунд.

## <a id="Разное" href="#Разное">Разное</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)` - записывает в переменную `script_dir` текущее местоположение скрипта.

Позволяет отображать текст цветными сиволами:
```bash
setup_colors() {
    if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
        NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
    else
        NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
    fi
}
msg() {
    echo >&2 -e "${1-}"
}
setup_colors
msg "This is a ${RED}very important${NOFORMAT} message, but not a script output value!"
```

`cat /dev/urandom | base64 | head -c <N>` - производит случайную генерацию пароля.