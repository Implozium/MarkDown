[Содержание](#Содержание)
==========

- [Инициализация, `canvas`](#Инициализация-canvas)
- [Цвет](#Цвет)
- [Система координат](#Система-координат)
    - [Матрица преобразования](#Матрица-преобразования)
        - [Матрица преобразования: вращение](#Матрица-преобразования-вращение)
        - [Матрица преобразования: перемещение](#Матрица-преобразования-перемещение)
        - [Матрица преобразования: масштабирование](#Матрица-преобразования-масштабирование)
- [Шейдер](#Шейдер)
    - [Код шейдеров](#Код-шейдеров)
        - [`attribute` переменные](#attribute-переменные)
        - [`uniform` переменные](#uniform-переменные)
        - [Вершинный шейдер](#Вершинный-шейдер)
        - [Фрагментный шейдер](#Фрагментный-шейдер)
- [Буферы](#Буферы)

<a id="Инициализация-canvas" href="#Инициализация-canvas">Инициализация, `canvas`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======================

WebGL-приложения состоят из программы на JavaScript, выполняемой браузером, и программ-шейдеров, выполняемых системой WebGL.

Для инициализации, необходимо поместить элемент `canvas` в html-страницу, он будет использоваться в качестве холста для отображения.

```html
<canvas id="webGL" width="400" height="400">
</canvas>
```

Получение контекста рисования:

```javascript
const canvas = document.getElementById('webGL');
const gl = canvas.getContext('webgl') || canvas.getContext("experimental-webgl");
```

Именование контекста `gl` используется для похожести на вызовы методов OpenGL.

`gl.clearColor(<R_цвет>, <G_цвет>, <B_цвет>, <альфа_канал>);` - устанавливает цвет для очистки области, где `<R_цвет>`, `<G_цвет>`, `<B_цвет>` принимают значения от `0.0` (0 - не интенсивен) и до `1.0` (255 - интенсивен), `<альфа_канал>`  принимает значения от `0.0` (0 - прозрачно) и до `1.0` (255 - не прозрачно).

`gl.clear({gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT});` - очищает указанный буфер:
- `gl.COLOR_BUFFER_BIT` - буфер цвета;
- `gl.DEPTH_BUFFER_BIT` - буфер глубины;
- `gl.STENCIL_BUFFER_BIT` - буфер трафарета.

<a id="Цвет" href="#Цвет">Цвет</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====

RGB компоненты цвета задаются в значениях от `0.0` (0 - не интенсивен) и до `1.0` (255 - интенсивен), и альфа канал также принимает значения от `0.0` (0 - прозрачно) и до `1.0` (255 - не прозрачно).

<a id="Система-координат" href="#Система-координат">Система координат</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=================

Оперирует тремя осями:
- **X** - простирается по горизонтали, слева направо;
- **Y** - простирается по вертикали, снизу вверх;
- **Z** - простирается по направлению от плоскости экрана к пользователю.

Является **правосторонней** системой координат.

Изначально пользователь находится в начале координат: **(0.0, 0.0, 0.0)** и смотрит вдоль оси **Z** в сторону отрицательных значений - за плоскость экрана.

По умолчанию размер области видимости квадрат ограниченный границами по горизонтали от **(-1.0, 0.0, 0.0)** и до **(1.0, 0.0, 0.0)**, по вертикали от **(0.0, -1.0, 0.0)** и до **(0.0, 1.0, 0.0)** и ценром в **(0.0, 0.0, 0.0)**.

## <a id="Матрица-преобразования" href="#Матрица-преобразования">Матрица преобразования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это прямоугольный массив чисел, расположенных строками и столбцами.
```
    |x'|   |a b c d|   |x|    x' = ax + by + cz + d
    |y'| = |e f g h| x |y|    y' = ex + fy + gz + h
    |z'|   |i j k l|   |z|    z' = ix + jy + kz + l
    |1 |   |m n o p|   |1|    1  = mx + ny + oz + p
```

### <a id="Матрица-преобразования-вращение" href="#Матрица-преобразования-вращение">Матрица преобразования: вращение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
    |x'|   |cos(B) -sin(B) 0 0|   |x|
    |y'| = |sin(B) cos(B)  0 0| x |y|
    |z'|   |0      0       1 0|   |z|
    |1 |   |0      0       0 1|   |1|
```

Где **B** - угол поворота по оси Z.

### <a id="Матрица-преобразования-перемещение" href="#Матрица-преобразования-перемещение">Матрица преобразования: перемещение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
    |x'|   |1 0 0 dx|   |x|
    |y'| = |0 1 0 dy| x |y|
    |z'|   |0 0 1 dz|   |z|
    |1 |   |0 0 0 1 |   |1|
```

Где:
- **dx** перемещение по оси X;
- **dy** перемещение по оси Y;
- **dz** перемещение по оси Z.

### <a id="Матрица-преобразования-масштабирование" href="#Матрица-преобразования-масштабирование">Матрица преобразования: масштабирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
    |x'|   |Sx 0  0  0|   |x|
    |y'| = |0  Sy 0  0| x |y|
    |z'|   |0  0  Sz 0|   |z|
    |1 |   |0  0  0  1|   |1|
```

Где:
- **Sx** коэффициент масштабирования по оси X;
- **Sy** коэффициент масштабирования по оси Y;
- **Sz** коэффициент масштабирования по оси Z.

<a id="Шейдер" href="#Шейдер">Шейдер</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Подразделяются:
- **вершинный шейдер** (*vertex shader*) - это программа, описывающая характеристики вершины (координаты, цвет и другие параметры) - точки в пространстве;
- **фрагментный шейдер** (*fragment shader*) - это программа, реализующая обработку фрагментов изображений - пикселей.

Порядок выполнения: **вершинный шейдер** -> **фрагментный шейдер**.

Все шейдеры состоят из текста указаной структуры на C-подобном языке **GLSL ES**:
```javascript
const <текст_шейдера> = `
<дополнительный_код>
void main() { // функция запуска
    <код_функции_запуска_шейдера>
}`
```

`const <шейдер> = gl.createShader({gl.FRAGMENT_SHADER | gl.VERTEX_SHADER});` - создает шейдер:
- `gl.FRAGMENT_SHADER` - фрагментный шейдер;
- `gl.VERTEX_SHADER` - вершинный шейдер.

`gl.shaderSource(<шейдер>, "<текст_шейдера>");` - передает исходный код шейдера в шейдер.  
`gl.compileShader(<шейдер>);` - компилирует шейдер.  
`gl.getShaderParameter(<шейдер>, gl.COMPILE_STATUS);` - возвращает `true` если шейдер успешно скомпилированный, иначе `false`.

```javascript
// пример создания
function createShader(gl, text, type) {
    const aShader = gl.createShader(type);
    gl.shaderSource(aShader, text);
    gl.compileShader(aShader);
    if (gl.getShaderParameter(aShader, gl.COMPILE_STATUS)) {
        return aShader;
    }
    console.log(text);
    throw new Error(`create shader error`);
}
```

`const <шейдерная_программа> = gl.createProgram();` - создает шейдерную программу.  
`gl.attachShader(<шейдерная_программа>, <шейдер>);` - присоединяет шейдер к шейдерной программе.  
`gl.linkProgram(<шейдерная_программа>);` - связывает шейдерную программу.  
`gl.getProgramParameter(<шейдерная_программа>, gl.LINK_STATUS);` - возвращает `true` если шейдерная программа успешно скомпилирована, иначе `false`.

```javascript
// пример создания
function createProgram(gl, arrayOfShaders) {
    const aShaderProgram = gl.createProgram();
    arrayOfShaders.forEach(aShader => gl.attachShader(aShaderProgram, aShader));
    gl.linkProgram(aShaderProgram);
    if (gl.getProgramParameter(aShaderProgram, gl.LINK_STATUS)) {
        return aShaderProgram;
    }
    throw new Error(`create program error`);
}
```

`gl.useProgram(<шейдерная_программа>);` - активирует шейдерную программу.

`gl.drawArrays({gl.POINTS | gl.LINES | gl.LINE_STRIP | gl.LINE_LOOP | gl.TRIANGLES | gl.TRIANGLE_STRIP | gl.TRIANGLE_FAN}, <номер_первой_вершины>, <количество_вершин>);` - выполняет вершинный шейдер количеством `<количество_вершин>` раз, чтобы нарисовать фигуры, определяемые первым параметром, где:
- `gl.POINTS` - группа точек, точки рисуются в координатах вершин: `v0, v1, v2, ..., vn`;
- `gl.LINES` - группа отдельных отрезков, отрезки рисуются парами вершин (если число вершин не точное, то последняя вершина игнорируется): `(v0, v1), (v2, v3), (v4, v5), ..., (vn-1, vn)`;
- `gl.LINE_STRIP` - группа связанных между собой отрезков, отрезки рисуются парами вершин: `(v0, v1), (v1, v2), (v2, v3), ..., (vn-2, vn-1), (vn-1, vn)`;
- `gl.LINE_LOOP` - группа связанных между собой отрезков, где последняя вершина соединена с первой, отрезки рисуются парами вершин: `(v0, v1), (v1, v2), (v2, v3), ..., (vn-1, vn), (vn, v0)`;
- `gl.TRIANGLES` - группа отдельных треугольников, треугольники задаются триадами вершин (если число вершин не кратно 3, то лишние игнорируются): `(v0, v1, v2), (v3, v4, v5), ..., (vn-2, vn-1, vn)`;
- `gl.TRIANGLE_STRIP` - группа треугольников, связанных между собой общими сторонами, первые три вершины образуют первый треугольник, а второй образуется из следующей вершины и двух предыдущих, входящих в состав первого треугольника, треугольники рисуются между тройками вершин: `(v0, v1, v2), (v2, v1, v3), (v2, v3, v4), ..., (vn-2, vn-1, vn)`;
- `gl.TRIANGLE_FAN` - группа треугольников, связанных между собой общими вершинами, первые три вершины образуют первый треугольник, а второй образуется из следующей вершины, одной стороны предыдущего треугольника и первой вершины, треугольники рисуются между тройками вершин: `(v0, v1, v2), (v0, v2, v3), (v0, v3, v4), ..., (v0, vn-1, vn)`.

## <a id="Код-шейдеров" href="#Код-шейдеров">Код шейдеров</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Переменные присваиваются оператором `=`, присваивать переменным можно только переменные одного типа:

`[{attribute | uniform}][<тип> ]<имя_переменной>[ = <значение>];` - объявление переменной.

Типы:
- `float` - вещественное число с плавающей точкой;
    > `0.1`
- `vec4` - вектор с четырьмя вещественными числами:
    - `vec4(<float>, <float>, <float>, <float>)` - создание;
    - `vec4(<float_X>, <float_Y>, <float_Z>, 1.0)` - создание для точек в пространстве.

    > `vec4(0.0, 0.0, 0.0, 1.0)`

- `mat4` - матрица с 4x4 вещественными числами.

Переменные одинакового типа можно складывать и на выходе будет тот же тип:  
`<vec4_1> + <vec4_2>` - обозначает что новый вектор будет равен: `vec4(<float_X_1> + <float_X_2>, <float_Y_1> + <float_Y_2>, <float_Z_1> + <float_Z_2>, <float_W_1> + <float_W_2>)`

Тип матрицы `mat4` можно умножать на тип вектор `vec4` и на выходе будет вектор:  
`<vec4_2> = <vec4_1> + <mat4>`

Спецификаторы класса хранения:
- `attribute` - внешние данные, уникальные для каждого вызова для вершинных шейдеров;
- `uniform` - внешние данные, общие для каждого вызова для вершинных и для фрагментных шейдеров.

Соглашение об именовании переменных:
- для `attribute` используется префикс `a_`: `a_<ИмяПеременной>`;
- для `uniform` используется префикс `u_`: `u_<ИмяПеременной>`.

`const <вектор> = new Float32Array([<значение0>, <значение1>, <значение2>, <значение3>]);` - создание вектора.

```javascript
const <матрица> = new Float32Array([
    <a>, <e>, <i>, <m>,
    <b>, <f>, <j>, <n>,
    <c>, <g>, <k>, <o>,
    <d>, <h>, <l>, <p>
]);
```
Создание матрицы, в WebGL элементы следуют в порядке расположения по столбцам.

Привила именования методов: `<имяМетода>{1 | 2 | 3 | 4}{f | i}[v](<параметр>[, <значение0>[, ...]])`, где:
- `{1 | 2 | 3 | 4}` - количество принимаемых значений;
- `{f | i}` - тип значений:
    - `f` - вещественный;
    - `i` - целочисленный.
- `[v]` - обозначает векторный тип значения указаного размера `{1 | 2 | 3 | 4}`.

### <a id="attribute-переменные" href="#attribute-переменные">`attribute` переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const <ссылка_на_переменную_атрибут> = gl.getAttibLocation(<шейдерная_программа>, "<имя_переменной>");` - получение ссылки на переменную атрибут или `-1` если переменная не найдена.  
`gl.vertexAttrib1f(<ссылка_на_переменную_атрибут>, <значение0>);` - задание значения переменной атрибута `(<значение0>, 0.0, 0.0, 1.0)`.  
`gl.vertexAttrib2f(<ссылка_на_переменную_атрибут>, <значение0>, <значение1>);` - задание значения переменной атрибута `(<значение0>, <значение1>, 0.0, 1.0)`.  
`gl.vertexAttrib3f(<ссылка_на_переменную_атрибут>, <значение0>, <значение1>, <значение2>);` - задание значения переменной атрибута `(<значение0>, <значение1>, <значение2>, 1.0)`.  
`gl.vertexAttrib4f(<ссылка_на_переменную_атрибут>, <значение0>, <значение1>, <значение2>, <значение3>);` - задание значения переменной атрибута `(<значение0>, <значение1>, <значение2>, <значение3>)`.

`gl.vertexAttrib4fv(<ссылка_на_переменную_атрибут>, <вектор>);` - задание значения переменной атрибута через вектор.

### <a id="uniform-переменные" href="#uniform-переменные">`uniform` переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const <ссылка_на_переменную_юниформ> = gl.getUniformLocation(<шейдерная_программа>, "<имя_переменной>");` - получение ссылки на uniform-переменную или `null` если переменная не найдена.  
`gl.uniform{1 | 2 | 3 | 4}f(<ссылка_на_переменную_юниформ>, <значение0>[, <значение1>[, <значение2>[, <значение3>]]]);` - задание значения uniform-переменной, все по аналогии с переменной атрибут.

`gl.uniformMatrix4fv(<ссылка_на_переменную_юниформ>, false, <матрица>);` - задание значения uniform-переменной значению матрицы.

### <a id="Вершинный-шейдер" href="#Вершинный-шейдер">Вершинный шейдер</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Глобальные переменные:
- `vec4 gl_Position` - определяет координаты вершины;
- `float gl_PointSize` - определяет размеры точки в пикселях.

### <a id="Фрагментный-шейдер" href="#Фрагментный-шейдер">Фрагментный шейдер</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`precision mediump float;` - объявление спецификатора точности представления значений переменными.

Глобальные переменные:
- `vec4 gl_FragColor` - определяет цвет фрагмента в формате RGBA (0.0 - 1.0).

<a id="Буферы" href="#Буферы">Буферы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Являются областью памяти, где хранятся вершины, которые требуется нарисовать. Используются для передачи в вершинный шейдер сразу несколько вершин через одну единственную переменную-атрибут.

`const <буферныйОбъект> = gl.createBuffer();` - создает буферный объект или `null` в случае ошибки.  
`gl.deleteBuffer(<буферныйОбъект>);` - удаляет буферный объект.  
`gl.bindBuffer({gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER}, <буферныйОбъект>);` - определяет тип буферного объекта. Где:
- `gl.ARRAY_BUFFER` - указывает, что буферный объект содержит информацию о вершинах;
- `gl.ELEMENT_ARRAY_BUFFER` - указывает, что буферный объект содержит значения индексов, ссылающихся на информацию о вершинах.

`const <массив_с_вершинами> = new Float32Array([<координата_x>, <координата_y>[, ...]]);` - пример массива с вершинами.  
`gl.bufferData({gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER}, <массив_с_вершинами>, {gl.STATIC_DRAW | gl.STREAM_DRAW | gl.DYNAMIC_DRAW});` - записывает данные в буферный объект, который был ранее определен, где `gl.STATIC_DRAW | gl.STREAM_DRAW | gl.DYNAMIC_DRAW` - описывают оптимизацию:
- `gl.STATIC_DRAW` - данные в буферном объекте будут определены один раз и использованы многократно для рисования фигур;
- `gl.STREAM_DRAW` - данные в буферном объекте будут определены один раз и использованы лишь несколько раз для рисования фигур;
- `gl.DYNAMIC_DRAW` - данные в буферном объекте будут определены многократно и использованы для рисования фигур так же многократно.

`gl.vertexAttribPointer(<ссылка_на_переменную_атрибут>, {1 | 2 | 3 | 4}, {gl.UNSIGNED_BYTE | gl.SHORT | gl.UNSIGNED_SHORT | gl.INT | gl.UNSIGNED_INT | gl.FLOAT}, {false | true}, <количество_байт_разделения_между_элементами>, <смещение_в_массиве>);` - присваивает буферный объект переменной атрибуту, где:
- `1 | 2 | 3 | 4` - число компонентов на вершину в буферном объекте, если отсутствуют некоторые элементы (их меньше 4), то дополняются до 4 и заполняются по умолчанию;
- `gl.UNSIGNED_BYTE | gl.SHORT | gl.UNSIGNED_SHORT | gl.INT | gl.UNSIGNED_INT | gl.FLOAT` - тип данных в массиве с вершинами;
- `false | true` - необходимость нормализации элементов массива к [-1, 1].

`gl.enableVertexAttribArray(<ссылка_на_переменную_атрибут>);` - включает разрешение присваивания переменной-атрибут буферного объекта и запрещает использовать методы `gl.vertexAttrib{1 | 2 | 3 | 4}f`.  
`gl.disableVertexAttribArray(<ссылка_на_переменную_атрибут>);` - выключает разрешение присваивания переменной-атрибут и разрешает использовать методы `gl.vertexAttrib{1 | 2 | 3 | 4}f`.