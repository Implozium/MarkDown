[Содержание](#Содержание)
==========

- [Микрофронтенды](#user-content-Микрофронтенды)
    - [Стратегии проектирования микрофронтендов](#user-content-Стратегии-проектирования-микрофронтендов)
        - [Стратегия вертикальной нарезки](#user-content-Стратегия-вертикальной-нарезки)
        - [Стратегия автономность команд](#user-content-Стратегия-автономность-команд)
        - [Стратегия изоляции](#user-content-Стратегия-изоляции)
    - [Методы интеграции микрофронтендов](#user-content-Методы-интеграции-микрофронтендов)
    - [Методы композиции микрофронтендов](#user-content-Методы-композиции-микрофронтендов)
    - [Инструменты для создания микрофронтендов](#user-content-Инструменты-для-создания-микрофронтендов)
        - [Module Federation](#user-content-Module-Federation)
        - [Single SPA](#user-content-Single-SPA)
    - [Стратегии управления состоянием](#user-content-Стратегии-управления-состоянием)
        - [Взаимодействие на основе API](#user-content-Взаимодействие-на-основе-API)
        - [Паттерн Pub/Sub](#user-content-Паттерн-PubSub)
        - [Библиотека глобального состояния](#user-content-Библиотека-глобального-состояния)
    - [Паттерн Backend for Frontend](#user-content-Паттерн-Backend-for-Frontend)
- [Архитектурные стили](#user-content-Архитектурные-стили)
    - [Монолитная архитектура](#user-content-Монолитная-архитектура)
    - [Модульный монолит](#user-content-Модульный-монолит)
    - [Микросервисная архитектура](#user-content-Микросервисная-архитектура)
- [Микросервисы](#user-content-Микросервисы)
    - [Особенности](#user-content-Особенности)
    - [Жизненный цикл микросервиса](#user-content-Жизненный-цикл-микросервиса)
    - [Паттерны проектирования микросервисов](#user-content-Паттерны-проектирования-микросервисов)
        - [Паттерны уровня приложений](#user-content-Паттерны-уровня-приложений)
            - [Паттерн Database per Service](#user-content-Паттерн-Database-per-Service)
            - [Паттерн Service per Team](#user-content-Паттерн-Service-per-Team)
            - [Паттерн Event Sourcing](#user-content-Паттерн-Event-Sourcing)
            - [Паттерн CQRS](#user-content-Паттерн-CQRS)
        - [Паттерны уровня инфраструктуры](#user-content-Паттерны-уровня-инфраструктуры)
            - [Паттерн Distributed Tracing](#user-content-Паттерн-Distributed-Tracing)
            - [Паттерн Audit Logging](#user-content-Паттерн-Audit-Logging)
        - [Паттерны уровня инфраструктуры](#user-content-Паттерны-уровня-инфраструктуры)
            - [Паттерн Service Discovery](#user-content-Паттерн-Service-Discovery)
            - [Паттерн Service Mesh](#user-content-Паттерн-Service-Mesh)
            - [Паттерн Service Registry](#user-content-Паттерн-Service-Registry)
    - [Паттерн Strangler Fig](#user-content-Паттерн-Strangler-Fig)
        - [Методы расстановки приоритетов](#user-content-Методы-расстановки-приоритетов)
            - [MoSCoW](#user-content-MoSCoW)
            - [Матрица Эйзенхауэра](#user-content-Матрица-Эйзенхауэра)
    - [Anti-Corruption Layer](#user-content-Anti-Corruption-Layer)
    - [Маршрутизация в микросервисах](#user-content-Маршрутизация-в-микросервисах)
        - [Техники маршрутизации между монолитом и новыми сервисами](#user-content-Техники-маршрутизации-между-монолитом-и-новыми-сервисами)
            - [Обратный прокси](#user-content-Обратный-прокси)
            - [API Gateway](#user-content-API-Gateway)
            - [Service Mesh](#user-content-Service-Mesh)
                - [Feature Toggling](#user-content-Feature-Toggling)
    - [Проектирования микросервисов](#user-content-Проектирования-микросервисов)
        - [Принципы 12-факторных приложений](#user-content-Принципы-12-факторных-приложений)
        - [Легковесные микросервисы](#user-content-Легковесные-микросервисы)
    - [Процесс взаимодействия между микросервисами](#user-content-Процесс-взаимодействия-между-микросервисами)
        - [Синхронное взаимодействие](#user-content-Синхронное-взаимодействие)
            - [REST](#user-content-REST)
            - [RPC](#user-content-RPC)
        - [Асинхронное взаимодействие](#user-content-Асинхронное-взаимодействие)
            - [Event-Driven Architecture](#user-content-Event-Driven-Architecture)
                - [Kafka](#user-content-Kafka)
        - [Выбор метода взаимодействия](#user-content-Выбор-метода-взаимодействия)
    - [Работа с данными](#user-content-Работа-с-данными)
        - [Распределенные транзакции](#user-content-Распределенные-транзакции)
            - [Протокол двухфазной фиксации (двухфазный коммит)](#user-content-Протокол-двухфазной-фиксации-двухфазный-коммит)
            - [Паттерн Saga](#user-content-Паттерн-Saga)
    - [Стратегии развертывания](#user-content-Стратегии-развертывания)
        - [Обновление на месте](#user-content-Обновление-на-месте)
        - [Сине-зеленые релизы (Blue-Green)](#user-content-Сине-зеленые-релизы-Blue-Green)
        - [Канареечные релизы (Canary)](#user-content-Канареечные-релизы-Canary)
        - [Скользящие релизы (Rolling)](#user-content-Скользящие-релизы-Rolling)
    - [Оркестрация контейнеров](#user-content-Оркестрация-контейнеров)
- [Масштабирование решения](#user-content-Масштабирование-решения)
    - [Нагрузка](#user-content-Нагрузка)
        - [Распространенные проблемы высоконагруженных приложений](#user-content-Распространенные-проблемы-высоконагруженных-приложений)
        - [Нагрузочное тестирование](#user-content-Нагрузочное-тестирование)
        - [Доступность](#user-content-Доступность)
            - [Фейловер-стратегии](#user-content-Фейловер-стратегии)
                - [Стратегия Active-Active](#user-content-Стратегия-Active-Active)
                - [Стратегия Active-Standby](#user-content-Стратегия-Active-Standby)
                - [Стратегия Cold Standby](#user-content-Стратегия-Cold-Standby)
                - [Георезервирование](#user-content-Георезервирование)
        - [Паттерн Backpressure](#user-content-Паттерн-Backpressure)
        - [Паттерн Curcuit Breaker](#user-content-Паттерн-Curcuit-Breaker)
        - [Паттерн Rate Limiting](#user-content-Паттерн-Rate-Limiting)
        - [Паттерн Bulkhead](#user-content-Паттерн-Bulkhead)
        - [Паттерн Transactional outbox](#user-content-Паттерн-Transactional-outbox)
    - [Репликация](#user-content-Репликация)
        - [Репликация master-slave](#user-content-Репликация-master-slave)
            - [Паттерн read-replica](#user-content-Паттерн-read-replica)
        - [Репликация multi-master](#user-content-Репликация-multi-master)
    - [Кэширование](#user-content-Кэширование)
        - [Паттерн Cache-Aside](#user-content-Паттерн-Cache-Aside)
        - [Паттерн Read-Through](#user-content-Паттерн-Read-Through)
        - [Паттерн Refresh-ahead](#user-content-Паттерн-Refresh-ahead)
        - [Паттерн Write-Through](#user-content-Паттерн-Write-Through)
        - [Паттерн Write-Behind](#user-content-Паттерн-Write-Behind)
        - [Способы инвалидации кэша](#user-content-Способы-инвалидации-кэша)
        - [Виды кэширования](#user-content-Виды-кэширования)
        - [Распределенный кэш](#user-content-Распределенный-кэш)
    - [Шардирование и партиционирование](#user-content-Шардирование-и-партиционирование)
        - [Методы шардирования](#user-content-Методы-шардирования)
        - [Способы реализации шардирования](#user-content-Способы-реализации-шардирования)
    - [Горизонтальное масштабирование приложения](#user-content-Горизонтальное-масштабирование-приложения)
        - [Способы сохранения состояний приложения](#user-content-Способы-сохранения-состояний-приложения)
        - [Балансировщик нагрузки](#user-content-Балансировщик-нагрузки)
            - [Стратегии балансировки нагрузки](#user-content-Стратегии-балансировки-нагрузки)
                - [Round Robin](#user-content-Round-Robin)
                - [Least](#user-content-Least)
                - [IP Hash (Sticky sessions)](#user-content-IP-Hash-Sticky-sessions)
                - [Weighted Round Robin](#user-content-Weighted-Round-Robin)
                - [Случайное распределение](#user-content-Случайное-распределение)
            - [Настройка балансировщика нагрузки](#user-content-Настройка-балансировщика-нагрузки)
                - [Паттерн API Gateway](#user-content-Паттерн-API-Gateway)
                - [Паттерн Service Discovery](#user-content-Паттерн-Service-Discovery)
    - [Гибридная архитектура](#user-content-Гибридная-архитектура)
        - [Распределенное облачное кэширование](#user-content-Распределенное-облачное-кэширование)
        - [Content Delivery Network](#user-content-Content-Delivery-Network)
            - [Методы разделения данных на основе DNS](#user-content-Методы-разделения-данных-на-основе-DNS)
- [Методы взаимодействия](#user-content-Методы-взаимодействия)
    - [Методы взаимодействий front-to-back](#user-content-Методы-взаимодействий-front-to-back)
        - [Паттерн client pull](#user-content-Паттерн-client-pull)
        - [Паттерн server push](#user-content-Паттерн-server-push)
    - [Методы взаимодействий back-to-back](#user-content-Методы-взаимодействий-back-to-back)
- [Observability](#user-content-Observability)
    - [Мониторинг](#user-content-Мониторинг)
        - [Основные подходы к мониторингу](#user-content-Основные-подходы-к-мониторингу)
        - [Модель "ключ - значение"](#user-content-Модель-ключ---значение)
    - [Логирование](#user-content-Логирование)
    - [Трейсинг](#user-content-Трейсинг)
- [Безопасность](#user-content-Безопасность)
    - [Угрозы](#user-content-Угрозы)
        - [Векторы угроз](#user-content-Векторы-угроз)
        - [Оценка угроз](#user-content-Оценка-угроз)
    - [Риски](#user-content-Риски)
    - [Архитектура информационной безопасности](#user-content-Архитектура-информационной-безопасности)
    - [Законодательный уровень информационной безопасности](#user-content-Законодательный-уровень-информационной-безопасности)
    - [Обфускация данных](#user-content-Обфускация-данных)
    - [Маскировка данных](#user-content-Маскировка-данных)
    - [Тегирование данных](#user-content-Тегирование-данных)
    - [Классификация данных](#user-content-Классификация-данных)
    - [Идентификация и аутентификация, управление доступом](#user-content-Идентификация-и-аутентификация-управление-доступом)
        - [Идентификация](#user-content-Идентификация)
        - [Аутентификация](#user-content-Аутентификация)
            - [SSO](#user-content-SSO)
                - [SAML](#user-content-SAML)
                - [OpenID Connect](#user-content-OpenID-Connect)
                - [Kerberos](#user-content-Kerberos)
        - [Авторизация](#user-content-Авторизация)
            - [Модель RBAC](#user-content-Модель-RBAC)
            - [Модель ABAC](#user-content-Модель-ABAC)
            - [LDAP](#user-content-LDAP)
            - [OAuth](#user-content-OAuth)
                - [Authorization Code Grant](#user-content-Authorization-Code-Grant)
                - [Implicit Grant](#user-content-Implicit-Grant)
                - [PKCE](#user-content-PKCE)
        - [Identity and Access Management](#user-content-Identity-and-Access-Management)
    - [Протоколирование, аудит](#user-content-Протоколирование-аудит)
    - [Целостность данных](#user-content-Целостность-данных)
    - [Средства защиты доступа к данным](#user-content-Средства-защиты-доступа-к-данным)
    - [Конфиденциальность](#user-content-Конфиденциальность)
        - [Privacy by Design](#user-content-Privacy-by-Design)
        - [Data Flow Management](#user-content-Data-Flow-Management)
            - [Data Flow Diagram](#user-content-Data-Flow-Diagram)
        - [Data Lineage и Data Minimization](#user-content-Data-Lineage-и-Data-Minimization)
        - [Слои данных](#user-content-Слои-данных)
            - [Состояние данных](#user-content-Состояние-данных)
        - [Коллективные знания](#user-content-Коллективные-знания)
- [Работа с большими данными](#user-content-Работа-с-большими-данными)
    - [Хранилище данных](#user-content-Хранилище-данных)
        - [Таблицы фактов и таблицы измерений](#user-content-Таблицы-фактов-и-таблицы-измерений)
    - [Подходы к обработке данных](#user-content-Подходы-к-обработке-данных)
    - [Подход Data Mesh](#user-content-Подход-Data-Mesh)
- [Облачные вычисления](#user-content-Облачные-вычисления)
    - [Подходы к миграции в облако](#user-content-Подходы-к-миграции-в-облако)
- [Проектирование](#user-content-Проектирование)
    - [Методология Domain-Driven Design (DDD)](#user-content-Методология-Domain-Driven-Design-DDD)
        - [Уровни проектирования](#user-content-Уровни-проектирования)
        - [Процесс выделения доменов и контекстов](#user-content-Процесс-выделения-доменов-и-контекстов)
- [Документирование](#user-content-Документирование)
    - [Модель C4](#user-content-Модель-C4)
        - [Уровень 1. Диаграмма контекста - Context diagram](#user-content-Уровень-1-Диаграмма-контекста---Context-diagram)
        - [Уровень 2. Диаграмма контейнеров - Container diagram](#user-content-Уровень-2-Диаграмма-контейнеров---Container-diagram)
        - [Уровень 3. Диаграмма компонентов - Component diagram](#user-content-Уровень-3-Диаграмма-компонентов---Component-diagram)
        - [Уровень 4. Диаграмма кода - Code/classes diagram](#user-content-Уровень-4-Диаграмма-кода---Codeclasses-diagram)
        - [Дополнительные диаграммы](#user-content-Дополнительные-диаграммы)
            - [Диаграммы последовательностей - Dynamic diagrams](#user-content-Диаграммы-последовательностей---Dynamic-diagrams)
            - [Диаграммы развертывания - Deployment diagrams](#user-content-Диаграммы-развертывания---Deployment-diagrams)
        - [Шаги создания](#user-content-Шаги-создания)
        - [Методы для анализа и интерпретации](#user-content-Методы-для-анализа-и-интерпретации)
        - [Методы для получения обратной связи](#user-content-Методы-для-получения-обратной-связи)
    - [Документация как код](#user-content-Документация-как-код)
    - [OpenAPI](#user-content-OpenAPI)
    - [AsyncAPI](#user-content-AsyncAPI)
- [Проработка решений](#user-content-Проработка-решений)
    - [Основные подходы к разработке решений](#user-content-Основные-подходы-к-разработке-решений)
    - [Технический роадмап](#user-content-Технический-роадмап)
        - [Модель TIME](#user-content-Модель-TIME)
        - [Технический долг](#user-content-Технический-долг)
        - [Технический радар](#user-content-Технический-радар)
- [DevOps](#user-content-DevOps)
    - [Pipeline as Code](#user-content-Pipeline-as-Code)
    - [CI/CD](#user-content-CICD)
        - [Continuous Integration (CI)](#user-content-Continuous-Integration-CI)
        - [Continuous Delivery (CD)](#user-content-Continuous-Delivery-CD)
        - [Continuous Deployment](#user-content-Continuous-Deployment)
    - [Infrastructure as Code](#user-content-Infrastructure-as-Code)
    - [MLOps](#user-content-MLOps)
- [Искусственный интеллект](#user-content-Искусственный-интеллект)
    - [NLP](#user-content-NLP)
    - [Работа с данными](#user-content-Работа-с-данными)
    - [ML-модели](#user-content-ML-модели)
        - [Виды моделей машинного обучения](#user-content-Виды-моделей-машинного-обучения)
    - [LLM](#user-content-LLM)
    - [Модульные диалоговые системы](#user-content-Модульные-диалоговые-системы)
- [Цифровая трансформация](#user-content-Цифровая-трансформация)
    - [Стратегия цифровой трансформации](#user-content-Стратегия-цифровой-трансформации)
    - [Бизнес-архитектура компании](#user-content-Бизнес-архитектура-компании)
        - [Карта IT-ландшафта](#user-content-Карта-IT-ландшафта)
        - [Планирование стратегических изменений](#user-content-Планирование-стратегических-изменений)
        - [Проектный подход](#user-content-Проектный-подход)
        - [Продуктовый подход](#user-content-Продуктовый-подход)
        - [Метрики бизнеса и продуктов](#user-content-Метрики-бизнеса-и-продуктов)
    - [Управление требованиями и определение бизнес-процессов](#user-content-Управление-требованиями-и-определение-бизнес-процессов)
        - [Планирование изменений](#user-content-Планирование-изменений)
        - [Требования к продукту](#user-content-Требования-к-продукту)
            - [Модель описания требований FURPS+](#user-content-Модель-описания-требований-FURPS)
        - [Пользовательские сценарии](#user-content-Пользовательские-сценарии)
            - [Описание бизнес-процессов](#user-content-Описание-бизнес-процессов)
        - [Проектирование архитектуры](#user-content-Проектирование-архитектуры)
            - [Architecture Design Record и Architecture Decision Log](#user-content-Architecture-Design-Record-и-Architecture-Decision-Log)
        - [Презентация архитектуры](#user-content-Презентация-архитектуры)
        - [План работ и роадмап реализации](#user-content-План-работ-и-роадмап-реализации)
        - [Управление изменениями](#user-content-Управление-изменениями)
    - [Дизайн-мышление](#user-content-Дизайн-мышление)
    - [Классы систем](#user-content-Классы-систем)

<a id="Микрофронтенды" href="#Микрофронтенды">Микрофронтенды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==============

**Микрофронтенд** - это концепция, которая распространяет принципы архитектуры микросервисов на мир фронтенда - фронтенд-приложения декомпозируют на части, которые можно разрабатывать, тестировать и развертывать независимо друг от друга.

Разбиение происходит по такой логике:
- каждый микрофронтенд отвечает за отдельную функцию или область приложения;
- микрофронтенды объединяют в целостный пользовательский опыт.

Основные преимущества микрофронтендов:
- **повышение организационной гибкости**, что позволяет различным командам работать параллельно, не завися друг от друга при развертывании;
- **можно использовать несколько технологических стеков** в зависимости от задач;
- **упрощение управления кодом**, так как каждая команда управляет только тем кодом, который относится к ее функциональности, что значительно облегчает сопровождение: обновление или исправление одного раздела не вызовет непредвиденных последствий в других частях приложения;
- **более управляемое масштабирование** из-за того, что каждый микрофронтенд развернут независимо от остальных;
- **повышение отказоустойчивости**, так как изоляция микрофронтендов повышает общую устойчивость приложения и в случае отказа микрофронтенда откажет только этот микрофронтенд;
- **ускорение времени выхода на рынок**  из-за того, что дает возможность разрабатывать, тестировать и внедрять обновления мелкими порциями, что позволяет больше экспериментировать и оперативно реагировать на изменения рынка.

Основные компоненты:
- **модули микрофронтенда** - это основные элементы архитектуры. Каждый модуль - это определенная бизнес-область или функциональность. Модули разрабатывают, тестируют и развертывают независимо друг от друга;
- **слой композиции** - отвечает за сборку различных модулей микрофронтенда в целостное приложение, а также управляет потоком данных и взаимодействием между клиентом и сервером. Компоновка модулей может происходить на стороне сервера, на стороне клиента или с помощью гибридного подхода;
- **маршрутизация** - отвечает за то, что запросы будут направляться к нужному микрофронтенду, что помогает сохранить модульность приложения (независимость микрофронтендов друг от друга) и при этом обеспечить плавную навигацию для пользователей;
- **коммуникационный слой** - управляет взаимодействием между микрофронтендами и остальной инфраструктурой приложения посредством API, шины сообщений или собственных систем событий.

## <a id="Стратегии-проектирования-микрофронтендов" href="#Стратегии-проектирования-микрофронтендов">Стратегии проектирования микрофронтендов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Стратегия-вертикальной-нарезки" href="#Стратегия-вертикальной-нарезки">Стратегия вертикальной нарезки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегия вертикальной нарезки** основана на *предметно-ориентированном проектировании* (Domain-Driven Design, DDD), что предполагает, что приложение делится на **домены** (domain) - предметные области, которые описывают разные цели бизнеса.

Суть вертикальной нарезки в том, чтобы спроектировать каждый микрофронтенд как самодостаточную систему, которая соответствует отдельной бизнес-функции. Тогда он будет включать всю необходимую внешнюю логику: от пользовательского интерфейса до уровня получения данных, который относится к его области.

Плюсы:
- каждый микрофронтенд предоставляет полный набор функций, который можно разрабатывать, тестировать и развертывать независимо от других;
- снижает зависимость между командами;
- упрощает управление проектами и масштабирование.

Минусы:
- тяжело определить границы каждого домена, так как на это влияет бизнес и тщательное планирование разработки.

Использование:
- когда есть **сложные пользовательские интерфейсы**, которые обслуживают разные бизнес-функции;
- когда есть **кросс-функциональные команды** вокруг бизнес-возможностей или клиентских путей, а не технологических стеков.

### <a id="Стратегия-автономность-команд" href="#Стратегия-автономность-команд">Стратегия автономность команд</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегия автономность команд** основана на том, что каждая команда имеет возможность выбрать технологический стек, который подходит под ее задачи и использовать сильные стороны технологий, чтобы достичь оптимальной производительности и удобства работы пользователей.

Плюсы:
- способствует росту инноваций;
- помогает создавать более адаптированные технические решения;
- ускоряет разработку и улучшает качество продукта.

Минусы:
- может привести к фрагментации и трудностям в управлении сквозными проблемами (стилизацией, доступностью и общей согласованностью пользовательского опыта).

Использование:
- когда есть **разные технологические потребности** из-за того, что разные части приложения выиграют от разных технологических стеков;
- когда есть **проекты, ориентированные на инновации и эксперименты**.

### <a id="Стратегия-изоляции" href="#Стратегия-изоляции">Стратегия изоляции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегия изоляции** основана на том, что у микрофронтендов нет общих зависимостей во время выполнения. То есть каждый микрофронтенд должен включать все свои зависимости. Они инкапсулируются в пакет развертывания микрофронтенда. Общие библиотеки в микрофронтендах будут дублироваться, но их можно совместить с помощью стратегического управления версиями на более широком уровне. Изоляция необходима, чтобы избежать конфликтов версий и облегчить обновление или замену отдельных микрофронтендов.

Плюсы:
- снижается риск того, что изменения в одном микрофронтенде повлияют на другие;
- упрощается обновление и сопровождение, так как не нужно подстраиваться под все приложение.

Минусы:
- общие библиотеки включены в несколько микрофронтендов, и из-за этого размер приложения увеличится.

Использование:
- когда есть **частые обновления и развертывания** в средах, где микрофронтенды должны обновляться часто и независимо друг от друга. Это гарантирует, что обновления не помешают друг другу;
- когда нужно **независимо масштабировать разные части приложения** у которых разные нагрузки и требования к производительности.

## <a id="Методы-интеграции-микрофронтендов" href="#Методы-интеграции-микрофронтендов">Методы интеграции микрофронтендов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Build time** - это объединение во время сборки - когда все компоненты помещаюся в контейнер. Мало отличается от монолитного фреймворка так как:
- нужно синхронизировать разные версии библиотек, иначе возникнут проблемы со сборкой;
- сложно использовать разные технологии;
- конечный бандл получится большим, ведь он содержит все зависимости;
- при появлении изменений в зависимостях, придется развертывать пакет заново;
- между контейнером и микрофронтендами будет тесная связь.

Подходит:
- когда нужно **упростить развертывание**, так как интеграция во время сборки ориентирована на единый механизм развертывания и единый исходный код, что дает на выходе единый пакет для развертывания;
- когда нужно **оставить тесное взаимодействие функций**, так как микрофронтенды тесно интегрированы с общими зависимостями;
- когда нужно **оптимизировать производительность**, так как интеграция во время сборки позволяет использовать разные техники оптимизации (tree-shaking, разделение кода), что способствует повышению производительности.

**Run time** - это объединение во время выполнения исполнения кода на стороне пользователя.

Подходит:
- когда нужно **развертывать модули независимо**, что позволит каждой команде развертывать свои изменения, не затрагивая другие части приложения;
- когда нужно **динамически обновлять отдельные модули** без переразвертывания всего приложения;
- когда нужно **сделать масштабирование гибким**, что позволит масштабировать разные части приложения независимо.

## <a id="Методы-композиции-микрофронтендов" href="#Методы-композиции-микрофронтендов">Методы композиции микрофронтендов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это процесс сборки нескольких микрофронтендов в единое целое.

**Серверная композиция** - когда все микрофронтенды собирают на сервере. Вся функциональность находится в бэкенде. Он решает, какой микрофронтенд собрать и загрузить. Сервер будет решать, к какому URL направить запрос.

Используется когда важен SEO и быстрый первоначальный отклик.

**Клиентская композиция** - когда браузер отвечает за динамическую загрузку каждого микрофронтенда во время выполнения.

Используется когда много интерактивного контента, который меняется в зависимости от взаимодействия с пользователем.

**Гибридная композиция** - состоит из серверной и клиентской композиции и использует для каждого микрофронтенда свой выделенный бэкенд *Backend for Frontend* (BFF). BFF обрабатывает все данные, взаимодействует с API и при необходимости предоставляет клиенту предварительно отрендеренный HTML. Это полезно для начальной загрузки страниц и SEO. Сервер передает клиенту полностью сформированную страницу.

## <a id="Инструменты-для-создания-микрофронтендов" href="#Инструменты-для-создания-микрофронтендов">Инструменты для создания микрофронтендов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Module-Federation" href="#Module-Federation">Module Federation</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это отдельный плагин Webpack.

Module Federation позволяет независимым приложениям использовать общий код во время выполнения. Он основан на функции **lazy loading**, которая позволяет приложению загружать фрагменты кода по требованию, что сокращает время первоначальной загрузки и помогает оптимизировать использование ресурсов.

Есть две роли:
- **хост** (host) - это основное приложение, которое при запуске динамически загружает удаленные модули;
- **удаленный модуль** (remote) - это отдельный микрофронтенд, который предоставляет часть своей функциональности хосту или другим удаленным модулям.

Хост и удаленные модули могут использовать **общие зависимости**, используя функцию **shared dependencies**, которая позволяет эффективно управлять версиями и гарантирует, что приложение загрузит одну версию библиотеки, если это возможно.

### <a id="Single-SPA" href="#Single-SPA">Single SPA</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это JavaScript-фреймворк. Он позволяет использовать несколько JavaScript-фреймворков на одной странице, не обновляя ее целиком. Он предназначен для управления маршрутизацией и координацией между различными микрофронтендами.

Основные особенности:
- **framework agnostic** (независимость от фреймворков) - приложение не зависит от какого-то конкретного фреймворка, поэтому можно поддерживать сразу нескольких фреймворков на одной странице;
- **lazy loading** (ленивая загрузка) - приложение загружает фрагменты кода по требованию, что улучшает время первоначальной загрузки и производительность;
- **независимая развертываемость** - каждый микрофронтенд может быть развернут независимо и из-за этого проще поддерживать большие приложения, над которыми работают несколько команд.

Состоит из:
- **root** (рут, корень) - основное приложение, которое подгружает разные микрофронтенды;
- **микрофронтендов**, которые подключают к руту.

## <a id="Стратегии-управления-состоянием" href="#Стратегии-управления-состоянием">Стратегии управления состоянием</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Взаимодействие-на-основе-API" href="#Взаимодействие-на-основе-API">Взаимодействие на основе API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Коммуникация на основе API подразумевает, что бэкенд и микрофронтенды взаимодействуют через HTTP-запросы. Для обмена данными используют RESTful или GraphQL API.

Подходит когда:
- **микрофронтенды должны взаимодействовать с бэкендом, а не напрямую друг с другом** - они в основном занимаются получением или обновлением данных из централизованного бэкенда;
- **есть простой обмен данными**, которые нужны только чтобы отобразить их в компоненте или отправить форму;
- **есть высокие требования к производительности и масштабируемости**, так как каждый микрофронтенд самостоятельно получает данные и обновляет свое состояние, что позволяет каждому микрофронтенду обеспечить независимое масштабирование и оптимальную производительность.

### <a id="Паттерн-PubSub" href="#Паттерн-PubSub">Паттерн Pub/Sub</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется паттерн проектирования **Pub/Sub**, при котором компоненты системы выступают в роли **издателей** (publisher) или **подписчиков** (subscriber). При таком подходе компоненты не знают о существовании друг друга, они взаимодействуют только с **событиями** - публикуют их или подписываются на них.

**Event Bus** (шина событий) - это система обмена сообщениями, которая основана на паттерне **Pub/Sub**. События публикуются в шине событий. Компоненты-подписчики регистрируются в шине и указывают список событий, которые они хотят получать. Шина событий разделяет микрофронтенды, убирает взаимозависимость и обеспечивает гибкость.

Подходит когда:
- **предпочтительно несвязанное соединение** между микрофронтендами, что позволяет им взаимодействовать без прямых зависимостей, что упрощает добавление, удаление или обновление микрофронтендов;
- **используется архитектура, управляемая событиями** (event-driven architecture, EDA) - действия или обновления в одной части приложения вызывают реакции в других частях и это эффективно для обновлений в реальном времени и асинхронных коммуникаций;
- **есть независимое развертывание**, так как помогает отделить логику взаимодействия от фактической реализации.

### <a id="Библиотека-глобального-состояния" href="#Библиотека-глобального-состояния">Библиотека глобального состояния</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При использовании библиотеки глобального состояния разные микрофронтенды могут получить доступ к общему состоянию и изменять его. Библиотека сама ходит в базу данных через API и обновляет данные на фронтенде.

Этот подход гарантирует, что все части приложения синхронизируются и последовательно взаимодействуют с пользователем.

Подходит когда:
- **есть тесная связь между разными частями приложения** и нужно, чтобы разные части приложения совместно использовали глобальное состояние и информация там всегда была актуальной, так как несколько микрофронтендов читают из одного состояния и записывают в него обновления;
- **важно поддерживать последовательный пользовательский опыт**, это получается благодаря общему состоянию, из-за которого поддерживается единообразие и согласованность в разных частях приложения;
- **есть сложные требования к управлению состояниями** и когда оно вложенное или иерархическое.

## <a id="Паттерн-Backend-for-Frontend" href="#Паттерн-Backend-for-Frontend">Паттерн Backend for Frontend</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Backend for Frontend** (бэкенд для фронтенда, BFF) - это подход к проектированию, при котором каждый фронтенд обслуживает специальный бэкенд - промежуточный слой между фронтендом и внутренними сервисами, для того чтобы абстрагировать фронтенд от сложностей бэкенда. BFF отвечает за сбор информации от разных микросервисов, ее обработку и доставку на фронтенд в удобном формате.

Используется при архитектурах когда есть:
- **монолитный фронтенд и микросервисы** - для того чтобы абстрагировать фронтенд от сложностей бэкенда;
- **несколько клиентов, которые используют разные технологии для передачи данных** - для того чтобы не усложнять бекенды поддержкой разных технологий;
- **микросервисы и микрофронтенды** - для организации взаимодействие между ними.

Этот подход позволяет:
- **подготавливать данные для конкретного фронтенда**, что снижает необходимость дополнительной обработки данных на стороне клиента;
- **упростить логику на стороне клиента**, так как обрабатывает сложные логические операции на стороне сервера - агрегацию, композицию и преобразованию данных, что снижает сложность кода фронтенда и улучшает его сопровождение;
- **увеличить производительность**, так как передается меньше данных по сети и выполняется меньше запросов из фронтенда;
- **усилить безопасность**, так как запросы пользователей на BFF могут аутентифицироваться и авторизовываться перед передачей внутренним службам.

<a id="Архитектурные-стили" href="#Архитектурные-стили">Архитектурные стили</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===================

## <a id="Монолитная-архитектура" href="#Монолитная-архитектура">Монолитная архитектура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Особенности:
- **развертывание и обновление**: изменения требуют перезапуск всего приложения;
- **масштабируемость**: масштабировать можно только все приложение целиком;
- **гибкость в выборе технологий**: все компоненты работают в единой технологической среде;
- **устойчивость к отказам**: отказ одной части системы может привести к отказу всего приложения;
- **управление командами**: трудно управлять большими командами, которые работают с одним кодом;
- **время разработки и внедрения**: длительные циклы разработки и внедрения;
- **тестирование**: трудно тестировать все компоненты вместе;
- **производительность**: может страдать из-за тесной связи компонентов;
- **масштаб проекта**: хорошо подходит для небольших и средних проектов;
- **риск изменений**: высокий риск сбоев при внесении изменений.

## <a id="Модульный-монолит" href="#Модульный-монолит">Модульный монолит</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Особенности:
- **развертывание и обновление**: изменения требуют перезапуск всего приложения;
- **масштабируемость**: масштабировать можно только все приложение целиком;
- **гибкость в выборе технологий**: все компоненты работают в единой технологической среде;
- **устойчивость к отказам**: отказ одной части системы может привести к отказу всего приложения;
- **управление командами**: модулями легче управлять, но все еще требуется координация;
- **время разработки и внедрения**: умеренные циклы разработки и внедрения;
- **тестирование**: отдельные модули легче тестировать, но все еще нужно тестировать весь монолит;
- **производительность**: может страдать из-за тесной связи компонентов;
- **масштаб проекта**: хорошо подходит для средних и больших проектов;
- **риск изменений**: умеренный риск сбоев, так как изменения затрагивают модули.

## <a id="Микросервисная-архитектура" href="#Микросервисная-архитектура">Микросервисная архитектура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Особенности:
- **развертывание и обновление**: каждый сервис можно обновлять и разворачивать независимо;
- **масштабируемость**: можно отдельно масштабировать сервисы, которые испытывают нагрузку;
- **гибкость в выборе технологий**: разные сервисы могут использовать разные технологии и языки;
- **устойчивость к отказам**: отказ одного сервиса не влияет на работу остальных сервисов;
- **управление командами**: команды могут работать независимо, что упрощает управление проектом;
- **время разработки и внедрения**: быстрые циклы разработки и внедрения;
- **тестирование**: отдельные сервисы легче тестировать;
- **производительность**: обычно выше благодаря независимой работе сервисов;
- **масштаб проекта**: подходит для больших и сложных проектов;
- **риск изменений**: низкий риск, так как изменения затрагивают только отдельные сервисы.

<a id="Микросервисы" href="#Микросервисы">Микросервисы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

## <a id="Особенности" href="#Особенности">Особенности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Плюсы**:
- **независимость компонентов**, так как микросервисы представляют собой отдельные блоки, которые можно разрабатывать, тестировать, развертывать и масштабировать независимо друг от друга, поскольку команды работают над своими задачами параллельно, не мешая друг другу, что позволяет быстро внедрять изменения;
- **модульность** из-за того, что приложение разбито на небольшие модули, каждый из которых отвечает за конкретную бизнес-функцию, что упрощает понимание кода, управление им и его повторное использование;
- **легковесные коммуникации** посредством общения друг с другом через легковесные протоколы - HTTP/HTTPS, REST или сообщения в очередях, что минимизирует накладные расходы и упрощает интеграцию сервисов;
- **автономность** из-за того, что каждый микросервис работает в своем собственном процессе и может быть развернут независимо от других, что снижает риски сбоев и повышает гибкость системы;
- **устойчивость к отказам** так как отказ одного микросервиса не приводит к отказу всей системы, что делает систему более надежной и устойчивой к ошибкам;
- **масштабируемость** так как микросервисы можно масштабировать независимо, что позволяет эффективно использовать ресурсы и справляться с увеличивающейся нагрузкой;
- **ориентация на бизнес** из-за того, что каждый микросервис ориентирован на конкретную бизнес-функцию и разрабатывается вокруг нее, что упрощает управление системой и ее развитие в соответствии с бизнес-требованиями.

**Минусы**:
- **более сложное управление**, потому что приходится отслеживать и поддерживать множество независимых сервисов и это требует более сложной инфраструктуры и использованию специализированных инструментах для мониторинга и логирования;
- **более сложная разработка**, так как нужно продумывать, как микросервисы будут взаимодействовать друг с другом, что приводит к тому, что нужно тщательно проектировать интерфейсы и взаимодействия между сервисами, а еще согласовывать между собой контракты API;
- **распределенные системы**, так как микросервисы работают в распределенной среде, что усложняет отладку и тестирование и проблемы становится сложнее диагностировать, потому что ошибки могут возникать в разных частях системы; в распределенной среде сложнее обеспечить согласованность данных и управлять транзакциями;
- **сетевые задержки и надежность**, из-за взаимодействия друг с другом через сеть, что может вызывать задержки и создавать дополнительные точки отказа, так как сетевые задержки могут ухудшить производительность системы;
- **более сложное управление конфигурацией**, так как нужно централизованое управление конфигурациями и секретами и необходимо обеспечивание согласованности конфигураций между разными окружениями;
- **повышенные требования к DevOps и инфраструктуре**, так как нужно автоматизировать развертывания, мониторинг и управление микросервисами с помощью контейнеров и оркестраторов;
- **повышение затрат**, так как разработка и поддержка выходит дороже, чем монолитная архитектура из-за затрат на разработку, тестирование, развертывание и инструментов с инфраструктурой для управления микросервисами.

## <a id="Жизненный-цикл-микросервиса" href="#Жизненный-цикл-микросервиса">Жизненный цикл микросервиса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Жизненный цикл микросервиса** - это этапы, которые микросервис проходит от первоначальной идеи до вывода из эксплуатации.

Состоит из этапов:
1. **Проектирование**:
    - определение бизнес-функции, которую будет выполнять микросервис;
    - определение границы микросервиса и его взаимодействия с другими сервисами;
    - выбор технологии и инструментов для реализации микросервиса.
2. **Разработка**:
    - написание исходного кода микросервиса;
    - тестирование кода - юнит-тесты и интеграционные тесты;
    - документирование API и внутренней логики микросервиса.
3. **Тестирование**:
    - проведение модульных тестов, чтобы проверить отдельные компоненты микросервиса;
    - проведение интеграционных тестов, чтобы проверить, как микросервис взаимодействует с другими микросервисами;
    - проведение нагрузочного тестирования, чтобы оценить производительность микросервиса.
4. **Развертывание**:
    - подготовка среды для развертывания - настройка серверов и контейнеров;
    - автоматизация процесса развертывания с помощью CI/CD-инструментов;
    - развертывание микросервиса в производственной среде.
5. **Мониторинг и поддержка**:
    - настройка мониторинга, чтобы отслеживать состояние и производительность микросервиса;
    - реагирование на инциденты и устранение неполадок;
    - обновление микросервиса и внедрение улучшений на основе собранных данных.
6. **Масштабирование**:
    - анализ метрик и логов, чтобы выявить потребность в масштабировании;
    - увеличение ресурсов (CPU, память) или количества экземпляров микросервиса;
    - обеспечивание балансировки нагрузки между экземплярами.
7. **Обновление и улучшение**:
    - сбор обратной связи от пользователей и анализ метрик, чтобы выявить области для улучшения;
    - разработка и тестирование новых функций;
    - обновление микросервиса в производственной среде.
8. **Вывод из эксплуатации**:
    - оповещение пользователей и других команд о том, что планируется вывод микросервиса из эксплуатации;
    - перенос данных и функций на другие сервисы;
    - отключение микросервиса и удаление его из производственной среды.

## <a id="Паттерны-проектирования-микросервисов" href="#Паттерны-проектирования-микросервисов">Паттерны проектирования микросервисов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерны проектирования микросервисов** - это лучшие практики и стандарты, которые используются для решения общих задач и проблем, возникающих при проектировании микросервисных систем.

**Язык паттернов** - это организованный и согласованный набор паттернов, каждый из которых описывает проблему и суть решения.

### <a id="Паттерны-уровня-приложений" href="#Паттерны-уровня-приложений">Паттерны уровня приложений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерны уровня приложений** (application patterns) фокусируются на управлении данными и организации микросервисов, помогают создавать независимые, изолированные и хорошо структурированные микросервисы, обеспечивая гибкость и масштабируемость системы.

#### <a id="Паттерн-Database-per-Service" href="#Паттерн-Database-per-Service">Паттерн Database per Service</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Database per Service** предполагает, что у каждого микросервиса есть своя собственная база данных для обеспечивания независимости и изоляции данных внутри микросервисов, чтобы каждый микросервис был полностью автономным. Это предотвращает проблемы, которые могут возникнуть из-за совместного использования одной базы данных несколькими микросервисами и упрощает управление данными.

Плюсы:
- **изоляция данных**, так как у каждого микросервиса своя база данных и им не нужно конкурировать за ресурсы;
- **автономность**, так как микросервисы можно развернуть и масштабировать независимо друг от друга;
- **гибкость** потому что можно использовать разные типы баз данных для разных микросервисов и ориентироваться на их потребности.

Минусы:
- **более сложное управление**, так как приходится управлять множеством баз данных, что усложняет администрирование;
- **сложно поддерживать согласованность** данных между микросервисами.

#### <a id="Паттерн-Service-per-Team" href="#Паттерн-Service-per-Team">Паттерн Service per Team</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Service per Team** предполагает, что каждая команда разработки отвечает за один или несколько микросервисов для распределения ответственности и улучшения управление проектом, чтобы каждая команда могла сосредоточиться на своей области и автономно принимать решения.

Плюсы:
- **четкие зоны ответственности**, так как каждая команда отвечает за свои микросервисы, что упрощает управление и улучшает качество;
- **гибкость** из-за того, что команды могут самостоятельно выбирать технологии и инструменты, которые лучше всего подходят для их задач;
- **улучшение коммуникаций**, поскольку в небольших командах проще выстраивать коммуникацию и еще можно быстрее принимать решения.

Минусы:
- **возможные конфликты** из-за несогласованности между командами, которые могут привести к проблемам в интеграции и взаимодействии микросервисов;
- **различия в технологиях**, поскольку использование разных технологий может усложнить интеграцию и поддержку системы.

#### <a id="Паттерн-Event-Sourcing" href="#Паттерн-Event-Sourcing">Паттерн Event Sourcing</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Event Sourcing** предполагает, что вместо того чтобы хранить текущее состояние объекта, система сохраняет последовательность событий, которые привели к этому состоянию, что обеспечивает гибкость и возможность воспроизводить историю изменений.

Плюсы:
- **полная история изменений** и из-за это можно воспроизвести любое состояние объекта в любой момент времени;
- **гибкость** так как легко добавлять такие функциональности, как аудит и аналитика;
- **повышенная согласованность**, так как все изменения фиксируются в виде событий.

Минусы:
- **сложность реализации**, так как требуется сложная логика для управления событиями и воспроизведения состояния;
- **рост объема данных** из-за сохранение всех событий.

Ключевые понятия:
- **события** - факт какого-то изменения в прошлом, при этом не допускается изменять сами события и их порядок. Используются для хранения данных, так как они обычно содержат уникальные метаданные, такие как временная метка, уникальный идентификатор субъекта и т. д. Данные внутри события могут использоваться и при записи новых событий для формирования и валидации состояния, и при формировании моделей для чтения;
- **хранилище событий** - журнал, который позволяет только добавлять записи о событиях в конец. События в журнале изменить нельзя, но их последствия могут быть изменены более поздними событиями;
- **потоки событий** - это события, относящиеся к определенному домену или объекту домена объединенные в поток с уникальным идентификатором, представляющий конкретный объект. Каждое событие имеет свою собственную уникальную позицию в потоке, которая обычно представлена числовым, инкрементным значением, которое может использоваться для определения порядка событий при извлечении состояния;
- **представления** - которые отражают состояние на текущий момент времени или на какой-то момент времени в прошлом. Представления строятся по принципу последовательного применения каждого события в порядке, в котором они расположены в журнале. Строятся для операций чтения или записи;
- **источники** - это компоненты приложения, которые при получении команды, то есть инструкции выполнить какое-то действие, порождают события, которые публикуются в хранилище событий;
- **подписчики** - это компоненты-подписчики для каждого потока событий.

**Snapshotting** - это паттерн, при котором регулярно создаются и хранятся снимки состояний объектов на определенный момент времени. Вместо восстановления состояния объекта через обработку всех событий с момента его создания система может загрузить последний снимок и применить только события, произошедшие после его создания, что значительно ускоряет процесс восстановления состояний и обращения к данным.

#### <a id="Паттерн-CQRS" href="#Паттерн-CQRS">Паттерн CQRS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Command Query Responsibility Segregation** (CQRS) разделяет операции чтения и записи данных в системе на два отдельных интерфейса.

Плюсы:
- **масштабируемость**, так как чтение и запись данных можно масштабировать независимо друг от друга, что улучшает производительность системы;
- **оптимизация запросов**, поскольку запросы на чтение могут быть оптимизированы для быстрого получения данных, а команды записи - для эффективного обновления данных;
- **улучшенная согласованность** при разделение операций на чтение и запись.

Минусы:
- **сложность реализации**, так как необходимо поддерживать два отдельных интерфейса и механизмы синхронизации данных;
- **увеличение объема кода** из-за разделения операций, который необходимо поддерживать.

При использовании паттерна операции чтения (запросы) и записи (команды) выполняются через разные модели данных и интерфейсы:
- **команды** (commands) используются для изменения состояния системы - изменяет состояние системы и генерирует соответствующие события;
- **запросы** (queries) используются для получения данных из системы - не изменяют состояние системы и оптимизированы для быстрого получения данных.

Ключевой характеристикой **события** является то, что поставщик напрямую не зависит от результата обработки события его потребителем, если процесс внутри поставщика события может быть завершен вне зависимости от результата обработки, то это событие. В случае, если для логического завершения процесса в системе-инициаторе нужно получить результат обработки сообщения, то это **команда**.

Основные этапы по реализации:
1. Определения команд для операций записи данных и разработки соответствующей модели данных для записи;
2. Создание модели данных для чтения, оптимизированная для быстрых операций чтения;
3. Реализация:
    - механизмов обработки команд - которые отвечают за обработку запросов, приводящих к изменению состояния сущности данных и по факту изменения состояния обработчик должен будет опубликовать событие в брокер сообщений;
    - механизмов обработки запросов - которые отвечают за предоставление данных, обращаясь к хранилищу данных и реплицирует нужные данные, опираясь на интересующие потоки событий, чтобы далее отдавать их при запросах на чтение данных;
    - настраивание системы для использования отдельных хранилищ данных, при необходимости;
4. Тестирование и отладка системы, чтобы убедиться в корректной работе разделенных операций чтения и записи.

### <a id="Паттерны-уровня-инфраструктуры" href="#Паттерны-уровня-инфраструктуры">Паттерны уровня инфраструктуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Паттерны уровня инфраструктуры приложений помогают управлять распределенными системами, обеспечивая их наблюдаемость и безопасность.

#### <a id="Паттерн-Distributed-Tracing" href="#Паттерн-Distributed-Tracing">Паттерн Distributed Tracing</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Distributed Tracing** позволяет отслеживать запросы и операции в распределенной системе - путь запроса через несколько микросервисов, что помогает диагностировать проблемы и улучшать производительность.

Плюсы:
- **улучшенная наблюдаемость**, поскольку можно проследить полный путь запроса - через все микросервисы, участвующие в обработке;
- **улучшенная диагностика проблем**, поскольку облегчается поиск и устранение проблем производительности и ошибок;
- **оптимизация производительности** из-за возможности выявлять и устранять узкие места в системе.

Минусы:
- **сложность реализации**, так как нужно настроить и интегрировать инструменты для отслеживания запросов;
- **дополнительные накладные расходы**, так как внедрение трейсинга может увеличить накладные расходы на обработку запросов.

#### <a id="Паттерн-Audit-Logging" href="#Паттерн-Audit-Logging">Паттерн Audit Logging</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Audit Logging** предполагает ведение журнала всех действий и изменений в системе, что помогает обеспечить безопасность системы и соответствие нормативным требованиям.

Плюсы:
- **безопасность и соответствие** нормативным требованиям и стандартам безопасности;
- **отслеживание изменений** для того, чтобы обеспечивать прозрачность всех изменений в системе.
- **решение инцидентов** безопасности и устранение их причин.

Минусы:
- **рост объема данных** из-за ведение журналов аудита;
- **организация управления и хранения** больших объемов данных.

### <a id="Паттерны-уровня-инфраструктуры" href="#Паттерны-уровня-инфраструктуры">Паттерны уровня инфраструктуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Паттерны уровня инфраструктуры помогают координировать взаимодействие микросервисов, обеспечивают автоматическое обнаружение микросервисов, их безопасность и управление коммуникациями между микросервисами - сетевыми взаимодействиями, что делает систему более устойчивой и управляемой.

#### <a id="Паттерн-Service-Discovery" href="#Паттерн-Service-Discovery">Паттерн Service Discovery</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Service Discovery** обеспечивает автоматическое обнаружение и подключение микросервисов, позволяет микросервисам динамически находить друг друга: не нужно жестко кодировать адреса и эндпоинты.

Плюсы:
- **автоматизация подключения** микросервисов, чтобы они автоматически находили друг друга, упрощая управление связями;
- **гибкость и масштабируемость**, так как легко добавлять и удалять микросервисы без изменения конфигурации;
- **устойчивость к сбоям**, так как в случае сбоя микросервиса обеспечивается возможность динамического переключения на доступные микросервисы.

Минусы:
- **сложно настроить** систему обнаружения и управлять ею;
- **задержки** в коммуникации из-за процесса обнаружения.

#### <a id="Паттерн-Service-Mesh" href="#Паттерн-Service-Mesh">Паттерн Service Mesh</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Service Mesh** обеспечивает управление сетью микросервисов, включая маршрутизацию, безопасность, наблюдаемость и политику управления, что позволяет отделить сетевые функции от логики приложения, улучшая управляемость и безопасность системы.

Плюсы:
- **безопасность** посредством обеспечивания сквозного шифрование и управления доступом между микросервисами;
- **наблюдаемость**, так как есть детализированные метрики, трассировки и логи для мониторинга и диагностики;
- **управляемость**, которая позволяет централизованно управлять политиками и конфигурациями сети микросервисов.

Минусы:
- **сложно внедрить**, так как нужно приложить много усилий, чтобы настроить Service Mesh и управлять им;
- **производительность** из-за добавления дополнительных накладных расходов на обработку сетевых запросов.

#### <a id="Паттерн-Service-Registry" href="#Паттерн-Service-Registry">Паттерн Service Registry</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Service Registry** предоставляет централизованный реестр, который хранит информацию - метаданные о каждом микросервисе, его местоположении и состоянии, для управления взаимодействием микросервисов.

Плюсы:
- **обеспечивание централизованного хранение и управление** информацией о микросервисах;
- **упрощение управления**, так как легко добавлять, удалять и обновлять микросервисы в реестре;
- **интеграция с другими системами** обнаружения сервисов и другими инструментами управления.

Минусы:
- **единая точка отказа**, если не обеспечить надежность реестра;
- **зависимость** микросервисов от доступности реестра.

## <a id="Паттерн-Strangler-Fig" href="#Паттерн-Strangler-Fig">Паттерн Strangler Fig</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Этот паттерн предлагает итеративный подход к миграции от монолита к микросервисам, когда новую систему постепенно создают по краям старой: компоненты по очереди извлекают из монолита и заменяют на микросервисы. При релизе каждого микросервиса запросы от монолита перенаправляют к новой системе. В итоге бэкенд отмирает по кусочкам, а команда может дорабатывать готовые микросервисы по отзывам пользователей.

Такой подход позволяет постоянно совершенствовать систему и минимизировать риски, которые связаны с большими изменениями.

Основные преимущества:
- **постепенная замена монолита**, что позволяет уменьшить количество сбоев и повысить адаптивность новой системы из-за того, что части монолита заменяются микросервисами итеративно;
- **снижение рисков и управление ими**, так как инкрементные изменения небольшие, то их легче тестировать, отслеживать и откатывать, что уменьшает количество сбоев. Микросервисы запускают параллельно с существующими монолитными компонентами, что позволяет в случае проблем перенаправить запросы обратно на компонент монолита с помощью маршрутизации;
- **инкрементная доставка новых функций в процессе миграции** из-за того, что приложение продолжает развиваться и новые функции и улучшения можно релизить по готовности не дожидаясь окончания миграции;
- **эффективное решение проблемы технического долга**, так как есть систематический рефакторинг вследствие того, что каждый микросервис можно спроектировать и разработать с использованием лучших практик и современных технологий, а также позволит разработать документацию и поддержать стандарты. В первую очередь замена начинается с устаревших компонентов, тогда каждое обновление будет повышать производительность системы и упрощать ее обслуживание.

Шаги по реализации паттерна Strangler Fig:
1. **Определение компонента, который нужно извлечь из монолита** - нужно определить и приоритизировать компоненты монолитного приложения, которые должны быть извлечены. Компонент выбирается с помощью техник:
    - **анализ домена бизнеса** - основан на Domain-Driven Design (DDD) и представляет из себя разделение приложения на домены, которые представляют собой ограниченный контекст бизнес-проблем и целей. Применяется когда монолитное приложение содержит сложную бизнес-логику и поддерживается крупными командами и эта техника помогает структурировать код так, чтобы он лучше отражал бизнес-процессы и был проще в сопровождении и развитии;
    - **технический анализ** - представляет из себя разделение приложения по части кода, который часто меняются или который сложно поддерживать - тесно связанные компоненты, помогает выявить скрытые зависимости и взаимодействия, которые не видны только при бизнес-анализе;
    - **анализ показателей производительности** - представляет из себя разделение приложения по компонентам, вызывающих проблемы с производительностью или требующих больших ресурсов. Применяется в приложениях, которым необходимо эффективное масштабирование.

2. **Проектирование и разработка нового микросервиса** с учетом принципов проектирования:
    - у микросервиса есть единственная, четко определенная зона ответственности;
    - микросервис должен минимально зависить от других сервисов;
    - связанная функциональность должна быть сгруппирована в рамках одного сервиса для поддержания высокой согласованности.

3. **Перенаправление запросов от монолита к микросервису** с помощью:
    - **маршрутизации на основе прокси**:
        - **обратный прокси-сервер**, который будет использоваться для маршрутизации запросов либо к монолиту, либо к новым микросервисам на основе определенных правил;
        - **API-шлюз** - реализуется для управления и маршрутизации трафика, обеспечивая единую точку входа для всех клиентских запросов;
    - **фича-тогглов** - (переключатели функций), которые нужны для управления развертыванием новых функций, чтобы постепенно перенаправлять трафик на новые сервисы;
    - **канареечных релизов**, которые постепенно переводят трафик на новые микросервисы, отслеживая производительность и стабильность перед полным развертыванием.

4. **Внедрения мониторинга и верификаци для микросервиса**. Для оценки производительности и надежности микросервисов используются количественные показатели - **метрики производительности** для каждого микросервиса с пороговым значением уровня производительности:
    - **ключевые показатели эффективности** (Key Performance Indicators, KPI), которые состоят из показателей:
        - времени отклика;
        - частоты ошибок;
        - пропускной способности;
        - количество запросов в секунду.
    - **цели уровня сервиса** (Service-Level Objectives, SLO) - это четко определенные цели в области производительности и доступности сервиса, которые ставятся на основе бизнес-требований, таких как время безотказной работы или время отклика;
    - **индикаторы уровня обслуживания** (Service Level Indicator, SLI) - это количественная оценка работы сервиса, показывающая, выполняются ли SLO, определяются для критических показателей и отслеживаются на соответствие с заданными SLO. К ним относят:
        - латентность - время, необходимое для обработки запроса;
        - доступность - доля времени, в течение которого сервис работает;
        - частота ошибок.

    Для отслеживания производительности, работоспособности и доступности сервисов используются **средства мониторинга**, которые собирают и анализируют данные, чтобы помочь обнаружить проблемы и обеспечить бесперебойную работу служб:
    - **мониторинг производительности приложений** (Application Performance Monitoring, APM), которые отслеживают производительность приложений и отдельных микросервисов в режиме реального времени, предоставляют информацию о времени отклика, количестве ошибок и взаимодействии с пользователями;
    - **централизованное логирование**, которые объединяют журналы различных служб в одном месте, что упрощает поиск, анализ и устранение проблем;
    - **мониторинг инфраструктуры**, которые следят за состоянием и производительностью базовой инфраструктуры (серверы, контейнеры, сетевые компоненты и т.п.).

    Для обеспечивания правильного функционирования новых микросервисов в соответствии с ожидаемым стандартом производительности и надежности используются **методы верификации**:
    - **автоматизированное тестирование** - юнит-тесты, интеграционные тесты, e2e-тесты, которые проверяет функциональность, производительность и интеграцию микросервисов на их соответствие заданным критериям при каждом коммите кода в системе контроля версий;
    - **А/B-тестирование** - для того чтобы сравнивать производительность и влияние на пользователей двух версий сайта, приложения или сервиса, чтобы определить, какая из них работает лучше с помощью перенаправления части запросов на новую версию, а остальную часть - на старую.

5. **Возвращение к шагу 1 до тех пор, пока весь монолит не будет заменен на микросервисы**. Состоит из:
    - **инкрементального извлечения**, которое предполагает разбиение монолитного приложения на более мелкие, управляемые компоненты и постепенную замену их микросервисами;
    - **непрерывного улучшения**, которое направлено на регулярное усовершенствование новых микросервисов с помощью рефакторинга и оптимизации (по мере необходимости) и всей системы в целом, на основе данных о производительности с помощью инструментов APM, анализу обратной связи и меняющихся потребностей бизнеса;
    - **координации работы команды** с помощью сотрудничества между кросс-функциональными командами - разработки, эксплуатации и бизнеса для согласования целей и прогресса, четкой коммуникации с помощью регулярных встреч которые необходимы для обсуждения прогресса, выявления препятствий и планирования следующих шагов, и последовательного документирование на протяжении всего процесса для обеспечения последовательности и обмена знаниями.

Распространенные проблемы:
- **недостаточное планирование** из-за слишком поспешной реализация миграции без четкого плана;
- **отсутствие поддержки заинтересованных сторон** из-за отсутствия понимания предполагаемых рисков;
- **недостаточный мониторинг и тестирование** из-за неспособности адекватно контролировать новые сервисы, что может привести к незамеченным проблемам, влияющим на производительность;
- **игнорирование зависимостей** между компонентами, которые приводят к сбоям или неожиданному поведению;
- **неполная документация** которая может привести к путанице и несогласованным реализациям;
- **игнорирование проблем управления и обмен данными** между монолитом и микросервисами, которые приводят к несогласованности и проблемам целостности данных.

### <a id="Методы-расстановки-приоритетов" href="#Методы-расстановки-приоритетов">Методы расстановки приоритетов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="MoSCoW" href="#MoSCoW">MoSCoW</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Метод приоритизации **MoSCoW** разделяет требования на четыре категории:
- **Must have** (обязательно);
- **Should have** (нужно);
- **Could have** (желательно);
- **Won't have** (можно перенести).

Используется когда у проекта есть четко определенные бизнес-цели, и необходимо тесно увязать технические задачи с приоритетами бизнеса и в процесс вовлечено множество заинтересованных сторон и их согласие крайне важно.

Используется для стратегического планирования.

#### <a id="Матрица-Эйзенхауэра" href="#Матрица-Эйзенхауэра">Матрица Эйзенхауэра</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Матрица Эйзенхауэра** - это инструмент управления временем, который помогает расставить приоритеты задач, разделяя их на четыре категории:
- **срочные и важные**;
- **важные, но не срочные**;
- **срочные, но не важные**;
- **не срочные и не важные**.

Используется когда необходимо учитывать срочность задач и где быстрое принятие решений имеет решающее значение.

Используется для повседневного планирования.

## <a id="Anti-Corruption-Layer" href="#Anti-Corruption-Layer">Anti-Corruption Layer</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Anti-Corruption Layer** (ACL) - это паттерн проектирования помогающий создать границу между новой системой и унаследованной. Через этот уровень проходят все данные, которые системы передают друг другу. ACL знает их форматы и модели данных. Он адаптирует информацию под требования получателя.

Создается с помощью паттернов **Facade** и **Adapter** и располагается в монолите.

Основные задачи ACL:
- **изоляция микросервисов от сложностей и проблем унаследованной системы** для того чтобы повысить шансы на то, что новые системы будут работать эффективно;
- **управление маршрутизацией запросов между монолитом и микросервисами**;
- **адаптация данных под требования разных систем**;
- **инкапсуляция монолитной системы**, чтобы микросервисы взаимодействовали с чистым и последовательным интерфейсом унаследованной системы, что упрощает разработку и сопровождение новых сервисов.

Принцип работы:
1. **Микросервис** взаимодействует с **монолитной системой** - он посылает запрос на **ACL**;
2. **ACL** передает запрос **адаптеру**, чтобы он перевел запрос микросервиса в формат и семантику монолитной системы;
3. **Адаптер** переводит запрос и отправляет его **монолитной системе**;
4. **Монолитная система** обрабатывает запрос и отправляет ответ **адаптеру**;
5. **Адаптер** переводит ответ в формат и семантику микросервиса, а затем передает запрос **ACL**;
6. **ACL** отправляет переведенные данные **микросервису**.

ACL используется только в процессе перехода, позволяя провести постепенную миграцию. ACL выводят из эксплуатации, когда все зависимые сервисы перенесли в архитектуру микросервисов.

Не используется когда:
- прямую интеграцию просто осуществить;
- разрабатывается краткосрочный проект или временное решение;
- критически важна производительность приложения;
- ограниченность ресурсов;
- при внедрении система станет слишком сложной.

Внедрение состоит из указанных шагов:
1. **Определение границ и зависимостей** между унаследованной системой и микросервисами - какие части унаследованной системы будут взаимодействовать с новыми сервисами и должны быть доступны и какие у них будут общие данные, процессы и функциональные возможности;
2. **Разработка интерфейса ACL**, который абстрагирует сложности унаследованной системы и должен быть чистым и четко определенным, а также согласованым с требованиями микросервисов;
3. **Внедрение ACL-компонентов**:
    - **адаптеров данных**, которые преобразуют форматы данных и обеспечивают совместимость унаследованной системы и микросервисов;
    - **шлюзов сервисов**, которые нужны для управления взаимодействием между старой системой и микросервисов - преобразованием протоколов, маршрутизацией запросов и преобразованием ответов;
    - **инкапсуляция бизнесс-логики** для того чтобы микросервисы могли взаимодействовать с упрощенным и согласованным интерфейсом.
4. **Тестирование ACL** чтобы убедиться что он правильно транслирует данные и протоколы между старой системой и новыми сервисами и не вносит значительных задержек или накладных расходов;
5. **Развертывание ACL и внедрение мониторинга**.

## <a id="Маршрутизация-в-микросервисах" href="#Маршрутизация-в-микросервисах">Маршрутизация в микросервисах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Маршрутизация** - это способы управления и направления потока трафика между различными частями системы.

Польза маршрутизации в период миграции:
- **безболезненное взаимодействие с пользователями** для обеспечения минимальных перебоев в работе пользователей и стабильную производительность при замене одной части системы на другую или ее обновлении;
- **непрерывность работы**, так как она позволяет старой и новой системам сосуществовать и работать одновременно;
- **инкрементное развертывание** что позволяет поддерживать поэтапное развертывание новых функций и сервисов;
- **управление рисками** за счет возможности отката или перенаправления трафика.

Основные проблемы:
- **сложность управления трафиком** из-за управления **множеством путей** трафика как к монолиту, так и к микросервисам, что повышает сложность и обеспечение **согласованности данных и состояния** как монолитного компонента, так и микросервиса, особенно при записи;
- **задержка и производительность** из-за наличия дополнительного уровня, который может стать узким местом;
- **обработка сбоев** при отказе сервисов и создания **механизмов аварийного восстановления** (fallback mechanisms) для перенаправления трафика с сервисов;
- **безопасность данных и управление доступом** между старой системой и новыми микросервисами;
- **полная видимость потока трафика и отладка проблем в гибридной среде**.

### <a id="Техники-маршрутизации-между-монолитом-и-новыми-сервисами" href="#Техники-маршрутизации-между-монолитом-и-новыми-сервисами">Техники маршрутизации между монолитом и новыми сервисами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="Обратный-прокси" href="#Обратный-прокси">Обратный прокси</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Обратный прокси-сервер** (reverse proxy) - это промежуточный сервер, который ретранслирует запросы клиентов из внешней сети на один или несколько серверов внутренней сети.

Правила и условия маршрутизации определяют на основе шаблонов URL, заголовков или других атрибутов запроса, которые обозначают назначение трафика.

Имеет такие преимущества:
- **упрощенная маршрутизация**, так как логика маршрутизации централизуется, что упрощает управление и обновление в процессе миграции;
- **балансировка нагрузки** из-за распределения входящего трафика между несколькими экземплярами службы, что повышает производительность и надежность;
- **безопасность**, так как действует в виде барьера между клиентами и внутренними серверами, что обеспечивает дополнительный уровень безопасности;
- **кэширование** для того, чтобы снизить нагрузку на внутренние службы и улучшить время отклика.

#### <a id="API-Gateway" href="#API-Gateway">API Gateway</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**API Gateway** выполняет функции прокси-сервера, принимая все клиентские запросы и маршрутизируя их к соответствующим микросервисам. Позволяет скрыть внутреннюю структуру микросервисов от клиентов, предоставляет единый интерфейс для взаимодействия с системой. Также может выполнять множество дополнительных задач, таких как трансформация запросов и ответов, кэширование, мониторинг, логирование, управление сессиями, аутентификацией и авторизацией.

Плюсы:
- **единая точка входа** так как клиенты взаимодействуют с системой через единый интерфейс, что упрощает управление и мониторинг;
- **управление аутентификацией и авторизацией**, проверяя учетные данные клиентов и контролируя доступ к различным микросервисам на основе ролей и прав доступа;
- **безопасность** - шифрование данных, защиту от DDoS-атак и ограничение скорости запросов (rate limiting) - для защиты системы от угроз и атак;
- **кэширование запросов** на часто запрашиваемые ресурсы, для того, чтобы уменьшить нагрузку на микросервисы и повысить производительность системы;
- **маршрутизация и балансировка нагрузки** к соответствующим микросервисам и балансировка нагрузки между ними;
- **мониторинг и логирование**, поскольку собираются и анализируются метрики и логи запросов, что помогает отслеживать производительность и обнаруживать проблемы.

Минусы:
- **единая точка отказа**, если не обеспечены механизмы высокой доступности;
- **сложность** в управлении и настройке: а также требование дополнительных ресурсов.

Основные подходы:
- **монолитный API Gateway** - для всех групп микросервисов он един:
    - плюсы:
        - единая точка управления всеми API запросами;
        - централизованное управление безопасностью и логированием.
    - минусы:
        - единая точка отказа;
        - возможная сложность управления при масштабировании системы.
- **распределенный API Gateway** - для каждой группы микросервисов есть свой:
    - плюсы:
        - уменьшение единой точки отказа;
        - улучшенная масштабируемость и производительность.
    - минусы:
        - повышенная сложность управления и настройки;
        - возможные проблемы с согласованностью данных.
- **многослойный API Gateway** - когда есть внешний и внутренний:
    - плюсы:
        - улучшенная безопасность;
        - улучшенная масштабируемость;
        - упрощенное управление и мониторинг;
        - повышенная производительность.
    - минусы:
        - повышенная сложность;
        - трудности настройки;
        - увеличение времени отклика;
        - затраты на инфраструктуру.
- **serverless API Gateway**:
    - плюсы:
        - высокая масштабируемость;
        - отсутствие необходимости управления инфраструктурой;
        - уменьшение затрат на ресурсы.
    - минусы:
        - возможные ограничения в функциональности и производительности;
        - зависимость от облачного провайдера.

Ключевые метрики анализа API Gateway:
1. **Метрики производительности**:
    1. **Запросы в секунду** (Requests per Second, RPS) - количество запросов, обрабатываемых API Gateway в секунду, которая помогает определить нагрузку на систему и выявить пиковые моменты активности;
    2. **Время отклика** (Response Time) - среднее время, затрачиваемое на обработку запросов. При этом важно отслеживать как среднее время отклика, так и 95-й и 99-й процентили для выявления долгих запросов;
    3. **Время до первого байта** (Time to First Byte, TTFB) - время, прошедшее от отправки запроса до получения первого байта ответа. Высокий TTFB может указывать на проблемы с сервером или сетью.
2. **Метрики ошибок**:
    1. **Количество ошибок** (Error Rate) - процент запросов, завершившихся ошибками (например, HTTP 4xx и 5xx). Высокий уровень ошибок может указывать на проблемы с API или инфраструктурой;
    2. **Виды ошибок** (Error Types) - распределение ошибок по типам (4xx - ошибки клиента, 5xx - ошибки сервера), которые помогает определить источник проблемы;
    3. **Ошибки авторизации и аутентификации** (Authentication and Authorization Failures) - количество запросов, не прошедших проверку аутентификации или авторизации. Высокий уровень таких ошибок может указывать на проблемы с безопасностью.
3. **Метрики безопасности**:
    1. **Неудачные попытки входа** (Failed Login Attempts) - количество неудачных попыток входа может свидетельствовать о возможных атаках;
    2. **IP-адреса с наибольшим количеством запросов** (Top Requesting IPs) - IP-адреса, с которых поступает наибольшее количество запросов. Это помогает выявить потенциальные DDoS-атаки;
    3. **Аномалии в трафике** (Traffic Anomalies) - внезапные изменения в объеме или характере трафика могут указывать на атаки или другие проблемы безопасности.
4. **Метрики использования ресурсов**:
    1. **Память** (Memory Usage) - объем памяти, используемой API Gateway. Высокое потребление памяти может привести к снижению производительности или сбоям;
    2. **Использование сети** (Network Usage) - объем входящего и исходящего трафика через API Gateway. Помогает определить нагрузку на сеть и выявить проблемы с пропускной способностью.
5. **Метрики отказоустойчивости**:
    1. **Время безотказной работы** (Uptime) - время, в течение которого API Gateway остается доступным и функционирующим для того, чтобы оценить надежность системы;
    2. **Частота отказов** (Failure Frequency) - количество отказов API Gateway за определенный период. Высокая частота отказов указывает на проблемы с надежностью.
6. **Метрики производительности кэша**:
    1. **Процент попаданий в кэш** (Cache Hit Rate) - процент запросов, которые обрабатываются из кэша. Высокий процент попаданий в кэш улучшает производительность и снижает нагрузку на сервер;
    2. **Процент промахов в кэше** (Cache Miss Rate) - процент запросов, которые не были найдены в кэше и потребовали обращения к исходному серверу.

#### <a id="Service-Mesh" href="#Service-Mesh">Service Mesh</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Service Mesh** - это выделенный инфраструктурный уровень для обработки взаимодействия между микросервисами. Он обеспечивает надежное и безопасное общение между сервисами, позволяя автоматизировать маршрутизацию запросов, балансировку нагрузки, управление трафиком и мониторинг.

Он предполагает, что рядом с каждым экземпляром микросервиса развертывается прокси-сервер **Sidecar** в рамках одного пода или контейнера, который управляет всеми сетевыми соединениями с микросервисом - координирует запросы к нему и от него.

Основные концепции:
- **Data Plane** (плоскость данных):
    - обработка и управление сетевыми запросами между микросервисами;
    - состоит из **Sidecar Proxy** (прокси-серверов), которые установлены рядом с каждым микросервисом, для перехватывания трафика;
    - реализация функций маршрутизации, балансировки нагрузки, шифрования и аутентификации.
- **Control Plane** (плоскость управления):
    - управляет и конфигурирует **Data Plane**;
    - предоставляет интерфейсы для настройки и управления политиками сетевого взаимодействия;
    - содержит компоненты для мониторинга, логирования и управления конфигурациями.
- **Sidecar Proxy**:
    - легковесный прокси-сервер, установленый рядом с каждым микросервисом;
    - перехватывает все входящие и исходящие запросы микросервиса, обеспечивает управление трафиком и безопасность.
- **Политики безопасности**:
    - определяют правила аутентификации и авторизации для взаимодействий между микросервисами;
    - содержит механизмы шифрования трафика и контроля доступа.
- **Политики маршрутизации**:
    - определяют правила маршрутизации трафика;
    - определяют пути прохождения запросов в зависимости от различных условий.
- **Мониторинг**:
    - сбор метрик производительности и доступности микросервисов.
- **Триссировка** (tracing):
    - отслеживает путь прохождения запрососв через микросервисы, выявляя узкие места и задержки.
- **Fault Injection** (введение ошибок):
    - позволяет тестировать устойчивость системы к отказам путем намеренного введения ошибок;
    - позволяет симулировать различные виды сбоев - задержки, отказ сервисов и нарушения сетевых взаимодействий;
    - помогает выявлять и устранять уязвимости в системе до их реального появления.
- **Ретрайлы и тайм-ауты**:
    - позволяет настраивать ретрайлы (повторные попытки) и тайм-ауты для взаимодействия между микросервисами;
    - обеспечивает устойчивость системы при временных сбоях и перегрузках.
- **Канареечные развертывания и A/B-тестирование**:
    - позволяет развертывать новые версии микросервисов на небольшую часть пользователей для тестирования;
    - позволяет минимизировать риски при внедрении изменений.

##### <a id="Feature-Toggling" href="#Feature-Toggling">Feature Toggling</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Feature Toggling** (Feature Flags) - это подход, который позволяет включать и отключать функциональные возможности приложения без необходимости развертывания нового кода, что особенно полезно для управления рисками при выпуске новых функций и проведения экспериментов.

Этот подход позволяет:
- **выпускать новые функции постепенно**, так как новые функции можно включать только для части пользователей, чтобы оценить их работу и устранить возможные проблемы;
- **проводить A/B-тестирование** версий функций на разных группах пользователей для оценки их эффективности;
- **управлять рисками**, поскольку есть возможность быстро отключить проблемную функцию, если она вызывает ошибки или негативные последствия для пользователей.

## <a id="Проектирования-микросервисов" href="#Проектирования-микросервисов">Проектирования микросервисов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из определения:
1. **Границ сервисов** - идентификации бизнес-доменов и субдоменов и обеспечения того, чтобы сервисы инкапсулировали конкретные бизнес-функции;
2. **Методов взаимодействия** между микросервисами с помощью:
    - **синхронного** взаимодействия чтобы обеспечить высокую производительность и быстрый отклик;
    - **асинхронного** взаимодействия, которое эффективнее для развязки и масштабируемости;
3. **Управления данными** которое должно обеспечивать в нескольких сервисах:
    - **согласованность данных** - чтобы изменение данных в одной системе предсказуемо влияло на другие системы;
    - **целостность данных** - поддержание корректности и надежности данных при их распределении;
    - **производительность** за счет масштабируемости, балансировки для уменьшения задержки;
    - **конкурентность** для одновременного доступа к данным и их обновления без конфликтов;
    - **доступность** для служб даже в случае сбоев.
4. **Стратегии развертывания** которые определяют, как новые версии микросервисов будут вводиться в эксплуатацию, минимизируя риски и обеспечивая непрерывность работы системы. А также совместимость новых версий микросервисов с текущими, возможность тестирования в реальной среде, механизмы для мониторинга состояния системы и быстрого отката в случае проблем;
5. **Балансировки нагрузки**, которая обеспечивает равномерное распределение трафика, для того чтобы входящие запросы равномерно распределялись между несколькими экземплярами сервиса, не позволяя какому-либо одному экземпляру стать узким местом. Способствует:
    - **повышению производительности и пропускной способности** из-за равномерного распределения запросов, чтобы каждый экземпляр службы обрабатывал управляемую нагрузку, обеспечивая более быстрое время отклика для пользователей;
    - **высокой доступности и надежности**, так как направляет трафик от отказавших или перегруженных экземпляров к исправным, что гарантирует, что приложение останется доступным, даже если некоторые экземпляры сервисов не работают или испытывают большую нагрузку;
    - **масштабируемости**, позволяя плавно добавлять новые экземпляры сервиса, что даст возможность по мере роста нагрузки подключить дополнительные экземпляры, на которые балансировщик нагрузки начнет направлять трафик, обеспечивая способность системы справляться с возросшим трафиком;
    - **устойчивости к сбоям** благодаря мониторингу состояния экземпляров сервисов, чтобы автоматически обнаруживать и удалять из пула нездоровые экземпляры, не позволяя им принимать трафик, что повышает отказоустойчивость системы, гарантируя, что сбои изолированы и не влияют на общую производительность.
6. **Устойчивости к сбоям**, которая обеспечивает проектировку микросервисов таким образом, чтобы легко справляться с отказами некоторых сервисов и не приводить к отказу всей системы благодаря внедрению механизмов повторных попыток, использованием прерывателей для предотвращения каскадных отказов и проектированию сервисов без состояний;
7. **Масштабируемости** в зависимости от нагрузки и проектированию сервисов без состояний;
8. **Безопасности** за счет внедрения сегментации сети из-за распределенной системы, которая ограничивает доступ между различными частями системы и внедрения **HTTPS** для защиты данных при передаче между микросервисами и внешними клиентами, и использование стандартов **OAuth2** / **OpenID Connect** для управления доступом и подтверждения личности пользователей и сервисов;
9. **Мониторинга и наблюдения** за состоянием и производительностью микросервисов для обеспечения надежности и доступности систем, а также агрегирование и анализ данных по всем сервисам;
10. **Хранения данных**, так как каждый микросервис может иметь уникальные требования к хранению данных и правильное разделение данных между микросервисами помогает минимизировать зависимости и улучшить управляемость системы, способствуя независимому масштабированию и развертыванию отдельных компонентов;
11. **API-менеджмента** для создания, публикации, мониторинга, управления и обеспечения безопасности интерфейсов прикладного программирования (API) в безопасной и масштабируемой среде, чтобы централизованно управлять доступом, маршрутизацией запросов, мониторингом и безопасностью API и обеспечивать балансировку нагрузки и защиту от атак. А также документирование API для того, чтобы обеспечить ясное описание функциональности и использования интерфейсов, чтобы разработчики могли быстро и правильно интегрировать API в свои приложения;
12. **Тестирования и валидации** чтобы проверять работоспособность и соответствие функциональных требований разрабатываемого продукта и убеждаться, что созданный продукт соответствует ожиданиям пользователей и бизнес-задачам;
13. **DevOps-практик** для обеспечивания быстрых итераций и непрерывных доставок, способствуя созданию гибкой среды разработки;
14. **Версионирования и совместимости** различных версий микросервисов друг с другом путем управление API и контрактами данных между сервисами, и обеспечивания обратной совместимости новых версий API с предыдущими.

### <a id="Принципы-12-факторных-приложений" href="#Принципы-12-факторных-приложений">Принципы 12-факторных приложений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные принципы:
1. **Кодовая база** (Codebase) - каждое приложение должно иметь одну кодовую базу, отслеживаемую в системе контроля версий, и множество развертываний;
2. **Зависимости** (Dependencies) - все зависимости должны быть явными и управляться через декларацию в манифесте;
3. **Конфигурация** (Config) - конфигурация приложения должна храниться в переменных окружения, а не в коде;
4. **Сторонние службы** (Backing Services) - все сторонние службы должны рассматриваться как внешние сервисы, которые могут быть легко заменены;
5. **Сборка, выпуск, запуск** (Build, Release, Run) - процесс сборки приложения, выпуска, где добавляются конфигурационные параметры, и запуска на сервере должен быть разделен на отдельные стадии;
6. **Процессы** (Processes) - приложение должно работать как одно или несколько stateless-процессов;
7. **Порт привязки** (Port Binding) - приложение должно быть самодостаточным и не зависеть от внешнего веб-сервера;
8. **Конкурентные процессы** (Concurrency) - приложение должно уметь масштабироваться путем запуска множества процессов или потоков;
9. **Утилизируемость** (Disposability) - процессы должны быть легкими для запуска и остановки, что позволяет легко масштабировать приложение в зависимости от нагрузки и быстро реагировать на изменения;
10. **Среды разработки и эксплуатации** (Dev/Prod Parity) - среда разработки должна максимально приближаться к среде эксплуатации;
11. **Логи** (Logs) - приложение должно писать свои логи в *stdout*;
12. **Административные процессы** (Admin Processes) - административные задачи должны выполняться как одноразовые процессы.

### <a id="Легковесные-микросервисы" href="#Легковесные-микросервисы">Легковесные микросервисы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Легковесные микросервисы** (Lightweight Microservices) - это подход к проектированию программных компонентов, при котором каждый микросервис минимален по своему размеру и функциональности, что позволяет ему быстро запускаться и эффективно использовать ресурсы.

Основная цель легковесных микросервисов - обеспечить гибкость, масштабируемость и независимость развертывания различных частей системы.

Основные принципы:
1. **Минимализм** - каждый микросервис должен выполнять одну конкретную задачу, что помогает уменьшить сложность кода и облегчает их тестирование и отладку, что способствует тому, что микросервисы имеют меньше зависимостей, что сокращает их размер и время запуска;
2. **Независимость** - микросервисы должны быть независимы друг от друга, что означает, что они могут разрабатываться, развертываться и масштабироваться независимо за счет четко определенных API для взаимодействия между микросервисами;
3. **Быстрое время запуска** - микросервисы должны быстро запускаться для автоматического масштабирования и развертывания, что позволяет быстрее реагировать на изменения нагрузки и быстро восстанавливаться после сбоев;
4. **Эффективное использование ресурсов** - микросервисы должны эффективно использовать ресурсы, такие как память и процессорное время, что достигается за счет оптимизации кода и использования легковесных библиотек и фреймворков;
5. **Упрощение зависимостей** - микросервисы должны иметь минимальное количество зависимостей, что снижает риск конфликтов версий и упрощает процесс обновления и развертывания;
6. **Обеспечение изоляции** - каждый микросервис должен быть изолирован от других, что позволяет избежать проблем с совместным использованием ресурсов и облегчает отладку, что достигается за счет использования контейнеров;
7. **Документирование и автоматизация** - каждый микросервис должен быть хорошо задокументирован и иметь автоматизированные процессы развертывания и тестирования, что позволяет быстрее внедрять изменения и уменьшает вероятность ошибок.

## <a id="Процесс-взаимодействия-между-микросервисами" href="#Процесс-взаимодействия-между-микросервисами">Процесс взаимодействия между микросервисами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Синхронное-взаимодействие" href="#Синхронное-взаимодействие">Синхронное взаимодействие</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Синхронное взаимодействие** - это подход к обмену данными между компонентами системы, при котором клиент (инициатор запроса) ожидает завершения операции и получения ответа от сервера (обработчика запроса) до продолжения своей работы.

Плюсы:
- простота реализации;
- предсказуемость времени отклика;
- легкость отладки и мониторинга запросов.

Минусы:
- высокая задержка в случае медленного ответа;
- увеличение зависимости между сервисами;
- ограниченная масштабируемость из-за блокирующих вызовов.

Ключевые концепции:
- **запрос-ответ** (request-response) - когда клиент отправляет запрос серверу и ожидает получения ответа. Сервер обрабатывает запрос и возвращает результат клиенту. Особенности:
    - **плюсы**: простой и понятный подход, обеспечивает четкую последовательность операций;
    - **минусы**: клиент блокируется, пока сервер не завершит обработку запроса, что может привести к задержкам и снижению производительности.
- **таймауты** (timeouts) - используются для ограничения времени ожидания ответа от сервера. Если сервер не отвечает в установленное время, клиент получает ошибку таймаута. Особенности:
    - **плюсы**: помогает избежать бесконечного ожидания и позволяет клиенту обработать ошибки;
    - **минусы**: таймауты могут быть сложны в настройке и управлении, особенно при высоких нагрузках и изменяющихся условиях сети.
- **блокировка** (blocking) - когда клиентский поток блокируется до получения ответа от сервера. В этот период клиент не может выполнять другие операции. Особенности:
    - **плюсы**: простота реализации и отладки;
    - **минусы**: может привести к снижению производительности и отзывчивости системы, особенно при высоких нагрузках.
- **зависимости** (dependencies) - когда операции часто зависят друг от друга. Если одна операция не завершена, последующие операции не могут быть выполнены. Особенности:
    - **плюсы**: позволяет легко отслеживать порядок выполнения операций и управлять им;
    - **минусы**: могут возникать узкие места и блокировки, особенно при сбоях или перегрузках в системе.
- **управление состоянием** (state management) - может быть сложным, поскольку состояние может изменяться в зависимости от результата каждого запроса. Особенности:
    - **плюсы**: легкость в управлении состоянием при небольших масштабах и простой архитектуре;
    - **минусы**: может стать сложным при увеличении масштабов системы и увеличении числа взаимодействующих компонентов.
- **изоляция ошибок** (error isolation) - когда ошибки, возникающие в одном компоненте, могут передаваться и влиять на другие компоненты, поскольку клиент ожидает завершения всей цепочки операций. Особенности:
    - **плюсы**: простота обработки ошибок при небольших системах;
    - **минусы**: ошибки могут распространяться по всей системе, что усложняет управление и отладку.
- **параллелизм** (parallelism) - ограничен, поскольку клиент блокируется до получения ответа. Особенности:
    - **плюсы**: упрощает поток выполнения операций в определенном порядке;
    - **минусы**: ограничивает возможности масштабирования и параллельного выполнения задач.

#### <a id="REST" href="#REST">REST</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**REST** (Representational State Transfer) - это архитектурный стиль, использующий стандартные методы HTTP (`GET`, `POST`, `PUT`, `DELETE`) для связи между сервисами. Он основан на связи без статических параметров и на архитектуре клиент-сервер, когда клиент отправляет запросы, а сервер отвечает соответствующими ресурсами.

**Принципы**:
- **отсутствие статуса у сервера** - когда каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для понимания и обработки запроса и сервер не хранит контекст клиента между запросами;
- **унифицированный интерфейс** - согласованный способ взаимодействия с ресурсами, обычно использующий стандартные методы HTTP;
- **Resource-Based** - когда сервисы моделируются как ресурсы, идентифицируются по URL и управляются с помощью форматов (JSON, XML и т.п.);
- **архитектура клиент-сервер** - когда клиент и сервер разделены, что позволяет им развиваться независимо друг от друга;
- **кэшируемость** - так как ответы могут определять, можно ли их кэшировать для повышения производительности.

**Преимущества использования**:
- **стандартизация** - обеспечивается стандартизированный способ доступа к ресурсам, что облегчает понимание и использование разработчиками;
- **масштабируемость** - из-за отсутствие статичности, что позволяет сервисам легко масштабироваться;
- **интероперабельность** - так как взаимодействие происходит на основе HTTP, что обеспечивает совместимость различных платформ и языков;
- **отсутствие специализированных фреймворков** - так как стандартная реализация есть в большинстве современных языков программирования.

**Используется для**:
- **общедоступных API** благодаря своей простоте и широкому распространению;
- **CRUD-операции** (create, read, update, delete) из-за ресурсного подхода;
- **связи микросервисов** в сценариях, в которых сервисы должны предоставить *endpoints* для доступа к данным или работы с ними.

#### <a id="RPC" href="#RPC">RPC</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**RPC** (Удаленный вызов процедур) - это метод связи между серверами в распределенной системе, который позволяет программе вызывать функции или процедуры, находящиеся на удаленном сервере, как если бы они были локальными.

RPC абстрагирует сетевую коммуникацию, предоставляя разработчикам более простой и понятный способ взаимодействия между компонентами распределенных систем.

**Основные характеристики**:
- **прозрачность** - так как вызов удаленной функции выглядит так же, как и вызов локальной функции;
- **синхронность** - когда клиент ожидает ответа от сервера для продолжения выполнения;
- **типизация** - что позволяет проверять корректность данных на этапе компиляции.

### <a id="Асинхронное-взаимодействие" href="#Асинхронное-взаимодействие">Асинхронное взаимодействие</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Асинхронное взаимодействие** - это подход к обмену данными между компонентами системы, позволяющее микросервисам общаться без необходимости немедленного ответа, что значительно улучшает масштабируемость и надежность системы.

Плюсы:
- высокая масштабируемость за счет немедленного освобождения ресурсов;
- устойчивость к сбоям благодаря очередям и повторной обработке сообщений;
- снижение зависимости между сервисами.

Минусы:
- сложность реализации и отладки;
- временная несогласованность данных;
- потребность в дополнительных компонентах для обеспечения доставки и хранения сообщений.

Основные концепции:
- **сообщения** - представляют собой единицы данных, которые отправляются от одного микросервиса к другому. Могут содержать информацию о событиях, данных или командах для выполнения определенных действий;
- **события** - это уведомления о произошедших изменениях в системе. Они позволяют микросервисам реагировать на изменения состояния системы;
- **очереди** - используются для временного хранения сообщений или событий до тех пор, пока получатель не будет готов их обработать. Очереди обеспечивают надежную доставку и помогают справляться с пиковыми нагрузками, распределяя обработку сообщений во времени.

Основные подходы:
- **push-подход** - когда отправитель данных (продюсер) активно отправляет данные получателю (консьюмеру). Подход часто используется в моделях **Publish/Subscribe** и **Event Sourcing**;
- **pull-подход** - когда получатель данных (консьюмер) активно запрашивает данные у отправителя (продюсера) или из хранилища (например, очереди сообщений). Подход часто используется в моделях **Message Queueing**.

Основные паттерны:
1. **Message Queueing** (Очередь сообщений) - это модель взаимодействия, при которой сообщения отправляются в очередь, где они хранятся до тех пор, пока получатель (консьюмер) не будет готов их обработать;
2. **Event Sourcing** (Хранение событий) - это паттерн, при котором состояние системы сохраняется как последовательность событий. Каждое изменение состояния записывается как событие, и текущее состояние системы можно восстановить путем проигрывания всех событий;
3. **Publish/Subscribe** (Публикация/Подписка) - это модель взаимодействия, при которой продюсеры отправляют сообщения в один или несколько топиков, на которые подписаны консьюмеры. Все подписчики получают сообщения асинхронно;
4. **Choreography** (Хореография) - это паттерн, при котором каждый микросервис реагирует на события и производит собственные события для других микросервисов. Взаимодействие координируется без центрального контроля;
5. **Orchestration** (Оркестрация) - это паттерн, при котором централизованный компонент (оркестратор) управляет взаимодействием между микросервисами, инициируя и контролируя выполнение задач.

#### <a id="Event-Driven-Architecture" href="#Event-Driven-Architecture">Event-Driven Architecture</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Event-Driven Architecture** (EDA, Архитектура, управляемая событиями) - это архитектурный подход, который основан на асинхронном взаимодействии между слабо связанными компонентами в системе посредством передачи событий.

EDA способствует свободному соединению, масштабируемости и обработке данных в реальном времени, позволяя сервисам реагировать на события асинхронно.

**Событие** - это значимое изменение в состоянии системы или внешней среды, которое может быть зарегистрировано и обработано системой.

Данных в событии должно быть достаточно всем потребителям для реакции на него, чтобы событие не было **триггером**.

Рекомендуется моделировать события и проектировать потребителей так, чтобы обработка могла выполняться идемпотентно.

Именовать события необходимо в прошедшем времени, а формулировать - с использованием бизнес-терминов, чтобы обеспечить самую низкую связанность между компонентами приложения. События могут отражать какое-то изменение в бизнес-домене.

Каждое событие должно быть записано в **поток событий** (event stream), которые объединяют события, которые относятся к одной доменной сущности.

События и потоки событий нельзя изменять: ни содержимое самих событий, ни их порядок в потоке. События долговечны и воспроизводимы - они сохраняются до тех пор, пока нужны. Журнал событий можно использовать для получения состояния объекта в любой интересующий момент времени.

**Базовые понятия**:
- **producer** (поставщик событий) генерирует сообщение с данными о событии и отправляет их в брокер событий при изменении состояния сущности данных;
- **consumer** (потребитель событий) подписывается на интересующие его потоки событий и реагирует на них, выполняя определенные действия, которые также могут породить публикацию события;
- **event broker** (брокер событий) - промежуточный компонент, который принимает события от поставщиков и передает их потребителям. При публикации и чтении компоненты оперируют очередями или топиками, которые представляют собой логическое разделение сообщений на группы.

**Топик** отличается от **очереди** тем, что в очереди после того как сообщение прочитано получателем, оно удаляется, а в топике сообщения хранятся до тех пор, пока они не устарели или пока не закончился заданный объем хранения данных на диске.

**Преимущества архитектуры**:
- **масштабируемость** - так как сервисы могут масштабироваться независимо в зависимости от нагрузки на события;
- **разделение** - сервисы могут работать независимо друг от друга, уменьшая взаимозависимость;
- **обработка в реальном времени**, которая обеспечивает аналитику в реальном времени и быстро реагирующие системы;
- **устойчивость к сбоям** - когда сообщения могут быть поставлены в очередь, что гарантирует, что они не будут потеряны и смогут быть обработаны, когда потребитель будет доступен.

**Системы обмена сообщениями** обеспечивают асинхронную связь между сервисами, позволяя им обмениваться сообщениями через инфраструктуру обмена сообщениями. Они помогают разделять сервисы, улучшать масштабируемость и повышать отказоустойчивость, предоставляя буфер, способный справиться с переменной нагрузкой и временной недоступностью сервисов. Являются основой для EDA.

Основные шаги проектирования:
1. **Анализ бизнес домена**, в рамках которого требуется определить основные бизнес-процессы, выявить сущности данных и все типы событий, которые с ними могут происходить;
2. **Описание доменной модели**, в рамках которого выделяются сущности данных с описанием их логического атрибутивного состава;
3. **Декомпозиция функциональности**, в рамках которого выделяются компоненты системы и разделяется функциональность между ними;
4. **Моделирование потоков событий**, в рамках которого определяется последовательность событий и взаимодействия между компонентами на их основе;
5. **Моделирование событий**, в рамках которого выделяются требуемые для публикации события и детально описывается структуры каждого события, включая данные, которые будут передаваться между компонентами;
6. **Выбор брокера событий**, в рамках которого выбирается подходящая система для обмена событиями в зависимости от требований к надежности, производительности и стоимости;
7. **Реализация и мониторинг**, в рамках которого разрабатывается система и внедряется система мониторинга для отслеживания состояния обработки событий и производительности системы в целом;
8. **Тестирование и валидация**, в рамках которого разрабатываются стратегии тестирования для проверки реакции системы на события, ее масштабируемости и производительности.

##### <a id="Kafka" href="#Kafka">Kafka</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Kafka** - это распределенная потоковая платформа, разработанная для публикации, подписки, хранения и обработки потоков данных в реальном времени.

Основные компоненты:
1. **Брокеры** (Brokers) - узлы в кластере, которые хранят и обрабатывают данные. Каждый брокер отвечает за управление одним или несколькими разделами (partitions) топиков. Применяются для хранения сообщений, репликации данных для обеспечения отказоустойчивости, обработки запросов от продюсеров и консьюмеров;
2. **Топики** (Topics) - логические каналы, по которым передаются сообщения. Каждый топик может состоять из нескольких **разделов** для параллельной обработки. Основное назначение разделов - организация сообщений по категориям, обеспечение параллельной обработки данных;
3. **Продюсеры** (Producers) - клиенты, которые публикуют сообщения в топики. Продюсеры могут отправлять данные в один или несколько топиков одновременно. Занимаются публикацией данных в топики, выбирают разделы для отправки сообщений (например, по ключу);
4. **Консьюмеры** (Consumers) - клиенты, которые читают сообщения из топиков. Консьюмеры могут объединяться в группы, чтобы обеспечить балансировку нагрузки. Выполняют функции чтения и обработки сообщений из топиков, управления смещениями (offsets) для отслеживания состояния обработки;
5. **Зоокипер** (ZooKeeper) - сервис для координации и управления кластером. Используется для хранения метаданных о топиках, брокерах и смещениях консьюмеров. Предназначен для управления конфигурацией кластера, координации работы брокеров, поддержки лидерства разделов.

### <a id="Выбор-метода-взаимодействия" href="#Выбор-метода-взаимодействия">Выбор метода взаимодействия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Осуществляется по ключевым факторам:
- **латентности** (время, необходимое для прохождения сообщения от отправителя к получателю и обратно):
    - синхронные методы для задач, где требуется немедленный ответ;
    - асинхронные методы для некритичных по времени операций, где задержка может быть терпимой или не требуется немедленного ответа на запрос.
- **консистентности данных** для обеспечения целостности данных в распределенных сервисах:
    - синхронные методы для операций, требующих немедленной согласованности;
    - асинхронные методы для сценариев, в которых допустима конечная согласованность.
- **масштабируемости** - способность справляться с растущими нагрузками путем добавления дополнительных ресурсов:
    - синхронные методы для более простых, тесно связанных взаимодействий;
    - асинхронные методы для сервисов, которые должны масштабироваться независимо друг от друга и обрабатывать всплески трафика.
- **отказоустойчивости** - способность системы продолжать работу в случае сбоя:
    - синхронные методы требуют надежной обработки ошибок и механизмов повторных попыток для достижения отказоустойчивости;
    - асинхронные методы для повышения отказоустойчивости и предотвращения потери сообщений при сбоях в работе служб.

## <a id="Работа-с-данными" href="#Работа-с-данными">Работа с данными</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Работа с данными должна подчиняться требованиям ACID:
- **Atomicity** - атомарность - все операции в транзакции либо завершаются успешно, либо откатываются;
- **Consistency** - целостность - любое изменение данных проходит через транзакционные контексты, которые следят за соблюдением всех ограничений;
- **Isolation** - изолированность - позволяет избежать конфликтов между параллельными транзакциями;
- **Durability** - надежность - все изменения, сделанные в рамках транзакции, применяются и сохраняются даже в случае сбоя системы.

Стратегии обеспечения согласованности данных:
- **конечная согласованность**, которая гарантирует, что при необходимом времени все реплики данных придут к одному и тому же значению. Используется в распределенных системах, где не требуется немедленная согласованность. Подходит для сценариев, в которых высокая доступность и устойчивость к разделениям более важны, чем немедленная согласованность;
- **строгая согласованность**, которая гарантирует, что все операции чтения возвращают последнюю запись. Используется когда требуется строгая точность данных. Подходит для критически важных операций, где точность данных не может быть нарушена;
- **партицирование данных**, которое подразумевает разделение большого набора данных на более мелкие и управляемые части (партиции), распределенные между несколькими узлами. Используется когда требуется сбалансировать нагрузку и повысить производительность. Подходит для крупномасштабных систем, где различные разделы могут управляться независимо друг от друга для обеспечения масштабируемости и производительности.

**Eventual Consistency** - согласованность в конечном итоге, - это модель согласованности, при которой гарантируется, что, если новых обновлений данных не происходит, все копии данных на узлах системы со временем придут к одному и тому же состоянию.

**Принцип "последний записанный побеждает"** (Last Write Wins, LWW) - это один из наиболее простых и распространенных подходов к разрешению конфликтов в распределенных системах, где различные узлы одновременно изменяют одни и те же данные, который заключается в том, что система сравнивает версии данных по времени изменения и считает актуальной последнюю версию.

Этот подход не учитывает семантику данных: он полагается только на время и проигнорирует более раннее изменение, даже если оно важнее с точки зрения бизнеса, что делает его удобным для систем с высокой частотой обновлений, где критично минимизировать задержки и количество конфликтов.

### <a id="Распределенные-транзакции" href="#Распределенные-транзакции">Распределенные транзакции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Распределенные транзакции координируют выполнение операций в нескольких сервисах, чтобы гарантировать, что все части транзакции либо зафиксируются, либо откатятся вместе.

#### <a id="Протокол-двухфазной-фиксации-двухфазный-коммит" href="#Протокол-двухфазной-фиксации-двухфазный-коммит">Протокол двухфазной фиксации (двухфазный коммит)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Протокол двухфазной фиксации** (2 Phase Commit, 2PC) - это подход к управлению распределенными транзакциями, которы включает в себя две фазы:
- **фаза подготовки** (Prepare Phase), когда координатор отправляет сообщение `prepare` всем участвующим сервисам с просьбой подготовиться к фиксации транзакции. На что каждый сервис отвечает голосованием (**зафиксировать** или **прервать**) в зависимости от того, сможет ли он успешно зафиксировать транзакцию;
- **фаза фиксации** (Commit or Abort Phase), когда все сервисы голосуют за фиксацию, координатор отправляет сообщение о фиксации всем сервисам, указывая им на фиксацию транзакции. Если какая-либо служба голосует за отказ, координатор посылает сообщение об **отказе**, предписывая всем службам откатить транзакцию.

**Проблемы**:
- **блокировка** - в случае если координатор не справляется, участники могут остаться в неопределенном состоянии, ожидая решения;
- **производительность**, так как протокол может вносить задержки из-за необходимости многократных обходов между координатором и участниками.

#### <a id="Паттерн-Saga" href="#Паттерн-Saga">Паттерн Saga</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Saga** - это архитектурный паттерн для управления распределенными транзакциями в микросервисных системах, который обеспечивает целостность данных и позволяет управлять ошибками при выполнении долговременных бизнес-процессов, которые включают несколько микросервисов. Это решается с помощью набора локальных транзакций и компенсирующих действий. Каждая транзакцию дробиться системой на шаги, которыми занимаются разные микросервисы. В случае ошибки система активирует отмену действия, которая распространяется на все вовлеченные микросервисы.

Подходы к координации шагов:
- **оркестрацию** - которая подразумевает наличие отдельного сервиса-оркестратора, который управляет последовательностью выполнения шагов и при необходимости инициирует компенсирующие действия. Применяется когда есть:
    - **сложные бизнес-процессы** с четкой последовательности действий;
    - **потребность в централизованном управлении** потоком операций и логикой обработки ошибок;
    - **координация транзакций** с обеспечением согласованности и возможности отката;
    - **сложная бизнес-логика и управление состоянием** которые реализуются в центральном оркестраторе.
- **хореографию** - когда микросервисы взаимодействуют через события и знают что делать после выполнения своего шага, а также сами инициируют компенсирующие действия. Применяется когда есть:
    - **простые взаимодействия** и не требуется сложная координации между ними;
    - **независимые микросервисы** и изменение одного сервиса не сильно влияет на другие;
    - **в приоритете гибкость и масштабируемость в системе**. чтобы изменения в одном микросервисе не требовали изменения в других;
    - **событийно-ориентированная архитектура**.

Требования ACID соблюдаются в:
- **атомарности** - так как транзакции разделяются на последовательные шаги, где каждый шаг - это локальная транзакция в отдельном микросервисе и атомарность достигается за счет независимого выполнения каждого шага и применения компенсирующих действий для отката изменений;
- **целостности** - которая обеспечивается через компенсирующие действия, которые откатывают предыдущие шаги в случае ошибки, так как микросервисы координируют между собой состояние транзакции, что иногда требует дополнительной логики;
- **изолированности** - только в конце транзакции, так как микросервисы работают независимо и пока все шаги Saga не завершатся, система может столкнуться с временной неконсистентностью данных;
- **надежности** - которая зависит от отдельных микросервисов и их способности сохранять состояние и поэтому компенсирующие действия должны быть надежными и обеспечивать сохранение состояния даже при сбоях.

**Компенсационные транзакции** - это действия, которые откатывают результаты уже выполненных шагов, если на любом из следующих шагов возникла ошибка.

Плюсы:
- **согласованность данных** в распределенных системах;
- **устойчивость к сбоям**, так как каждый шаг транзакции может быть компенсирован, что позволяет системе восстанавливаться после сбоев;
- **гибкость**, так как легко адаптировать к различным бизнес-процессам и сценариям.

Минусы:
- **сложность реализации** из-за требованиям тщательного планирования и реализации компенсирующих операций;
- **временная несогласованность** данных до завершения всех шагов транзакции.

**Процесс внедрения**:
1. **Анализ бизнес-процесса** и разделение его на последовательные шаги, которые будет выполнять отдельный микросервис. Для каждого шага определяется **основное действие** (do) и **компенсирующее действие** (undo), которое нужно выполнить в случае ошибки;
2. **Проектирование API у микросервисов** для выполнения действий и компенсирующих действий. Каждая операция для всех действий и компенсирующих действий должна быть **идемпотентной**, для этого используются уникальные идентификаторы транзакций и проверяется состояние перед выполнением операции, чтобы избежать повторного выполнения;
3. **Обеспечение хранения состояния** своей части транзакции в каждом микросервисе. Состояние должно включать уникальный идентификатор транзакции и текущий статус операции, чтобы избежать повторения уже совершенных действий. И выбора подхода к координации шагов;
4. **Реализация действий и компенсирующие действий** в каждом микросервисе, которые должны быть **идемпотентны**;
5. **Добавление логирования** для всех действий и компенсирующих действий, которые должны включать информацию о транзакциях, их статусе и любых ошибках. А также **настройка мониторинга** микросервисов (оркестратора);
6. **Тестирование** основных действий и компенсирующие действий в каждом микросервисе, а также цельной транзакции.

## <a id="Стратегии-развертывания" href="#Стратегии-развертывания">Стратегии развертывания</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Обновление-на-месте" href="#Обновление-на-месте">Обновление на месте</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Обновление на месте** - это когда новая версия приложения заменяет старую версию на той же инфраструктуре. Часто это делается путем остановки службы, развертывания нового кода и перезапуска службы.

### <a id="Сине-зеленые-релизы-Blue-Green" href="#Сине-зеленые-релизы-Blue-Green">Сине-зеленые релизы (Blue-Green)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Сине-зеленые релизы** - это когда поддерживаются два идентичных окружения - синее и зеленое. Пока одно работает и обслуживает продакшн, другое используется для развертывания и тестирования новой версии. Затем, когда новая версия прошла тестирование в новом окружении, трафик переключается на него. Так как старое теперь простаивает, то может быть использована для следующего обновления. И так далее.

**Основное преимущество**: отсутствие простоев и простой откат, так как при обнаружении проблем трафик можно быстро переключить на исходную среду.

**Основной недостаток**: нужно поддерживать две идентичные среды, что может быть дорогостоящим и ресурсоемким.

### <a id="Канареечные-релизы-Canary" href="#Канареечные-релизы-Canary">Канареечные релизы (Canary)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Канареечные релизы** - это когда при обновления новая версия разворачивается на каком-то количестве серверов (**канареечные серверы**) и затем туда направляется небольшой процент трафика. Развертывание отслеживается на предмет ошибок и, если проблем не обнаружено, туда направляется все больше трафика. В конце концов новая версия разворачивается на всех серверах.

**Основное преимущество**: позволяет проводить мониторинг и тестирование в реальных условиях с минимальным риском и ограничивает влияние потенциальных проблем небольшой базой пользователей.

**Основной недостаток**: требуются сложные механизмы маршрутизации и мониторинга трафика.

### <a id="Скользящие-релизы-Rolling" href="#Скользящие-релизы-Rolling">Скользящие релизы (Rolling)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Скользящие релизы** - это когда при релизе экземпляры приложения постепенно обновляются по одному или небольшими партиями без простоев, что обеспечивает постоянное обслуживание трафика одними экземплярами, в то время как другие находятся в процессе обновления.

**Основное преимущество**: обеспечивается постоянная доступность сервиса и снижается риск сбоев за счет обновления небольшими порциями.

**Основной недостаток**: необходимость тщательной координации, чтобы обеспечить бесперебойное обновление и механизмы отката.

## <a id="Оркестрация-контейнеров" href="#Оркестрация-контейнеров">Оркестрация контейнеров</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Оркестрация контейнеров** - это процесс автоматизации развертывания, управления, масштабирования и сетевого взаимодействия контейнеризированных приложений.

Основные задачи:
- **автоматическое развертывание контейнеров и управление их состоянием** на кластере серверов;
- **масштабирование контейнеров** в зависимости от нагрузки - добавление или удаление, чтобы эффективно использовать ресурсы и поддерживать производительность приложений;
- **обнаружение сервисов и балансировка нагрузки**, чтобы равномерно распределять запросы и обеспечивать высокую доступность приложений;
- **управление конфигурацией и секретами** для повышения безопасности и упрощения администрирования;
- **мониторинг состояния контейнеров и их восстановление** для обеспечивания непрерывности работы приложений.

<a id="Масштабирование-решения" href="#Масштабирование-решения">Масштабирование решения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======================

**Масштабирование решения** - это адаптация программного обеспечения к увеличению нагрузки или требований с сохранением высокой производительности и доступности.

**Вертикальное масштабирование** - это добавление ресурсов (оперативной памяти (RAM), мощности процессора (CPU), объема жесткого диска (HDD) и т.п.) к одному узлу на сервере. Имеет физические ограничения и часто стоит дорого.

**Горизонтальное масштабирование** - это добавление новых узлов в систему, что позволяет распределить нагрузку между ними. Это обеспечивает практически неограниченный рост и лучшую отказоустойчивость, но требует более сложной настройки и управления.

## <a id="Нагрузка" href="#Нагрузка">Нагрузка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Нагрузка** - это интенсивность взаимодействия пользователя с приложением. Чем более активны пользователи и чем их больше, тем выше нагрузка. Приложения с высокой нагрузкой называют **высоконагруженными** (high-load) приложениями.

Основные метрики:
- **DAU** (Daily Active Users) - количество пользователей в день;
- **MAU** (Monthly Active Users) - количество пользователей в месяц;
- **RPS** (Requests Per Second) - количество запросов, которые сервер приложения обрабатывает в секунду;
- **QPS** (Queries Per Second) - количество запросов в секунду к базе данных.

**Пиковая нагрузка**, как правило, превышает среднюю в два раза и на нее следует ориентироваться.

### <a id="Распространенные-проблемы-высоконагруженных-приложений" href="#Распространенные-проблемы-высоконагруженных-приложений">Распространенные проблемы высоконагруженных приложений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные проблемы:
- **неправильный выбор технологий**, которые не соответствуют задачам;
- **недооценка нагрузки и некорректное тестирование**, которая ведет к неожиданным сбоям в производственной среде;
- **неэффективное использование ресурсов**, которое ведет к избыточным расходам и снижению производительности, что становится дороже и менее полезным для бизнеса;
- **пренебрежение оптимизацией запросов к базе данных**, которые в итоге приводят к высоким задержкам и неэффективному использованию ресурсов;
- **игнорирование пользовательского опыта при проектировании API**, что приводит к снижению производительности клиентских приложений;
- **недооценка тестирования**, которое скрывает узкие места у приложения в производственной среде;
- **неверная декомпозиция системы**, из-за гранулярной декомпозиции, что приводит к высоким накладным расходам на обмен данными между компонентами.

### <a id="Нагрузочное-тестирование" href="#Нагрузочное-тестирование">Нагрузочное тестирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Нагрузочное тестирование** - это процесс проверки способности приложения справляться с различными уровнями активности со стороны пользователей или систем-потребителей API, обеспечивая при этом приемлемое время отклика без потери стабильности.

Методики тестирования:
- **smoke-тест** - это тест, который проверяет функционирование системы при минимальной нагрузке, в котором важно собрать базовые значения производительности, которые в дальнейшем могут использоваться как референсные значения при анализе результатов. Этот тип теста, как правило, предполагает имитацию работы всего нескольких пользователей и в течение короткого периода либо малого числа итераций, либо продолжительности от нескольких секунд до максимум нескольких минут;
- **тест средней нагрузки** - это тест, который имитирует количество одновременных пользователей и запросов в секунду, отражающих среднее поведение в производственной среде. Этот тип теста обычно постепенно увеличивает количество запросов и поддерживает эту среднюю нагрузку некоторое время. Иногда сценарии могут включать в себя некоторое переменное снижение нагрузки с последующим возвратом на прежний уровень;
- **стресс-тест** - это тест, который используется для проверки стабильности и надежности системы в условиях интенсивного использования (час пик). Этот тип теста максимально схож с тестом средней нагрузки, за исключением того, что уровень нагрузки задается сильно выше. В этом случае период нарастания занимает больше времени для получения желаемой нагрузки, и в целом он может длиться немного дольше, чем при тесте со средней нагрузкой;
- **тест всплеска нагрузки** - это тест, который проверяет поведение системы при внезапном и массовом увеличении нагрузки. Этот тип теста увеличивает нагрузку до чрезвычайно высоких значений за очень короткое или отсутствующее время нарастания. Таким образом, время снижения нагрузки очень быстрое или отсутствует, позволяя процессу повторяться только один раз;
- **тест точки отказа** - это тест, который позволяет определить уровень нагрузки, при которых система начинает терять стабильность или вовсе отказывает. Этот тип теста позволяет определить возможности системы, что важно для долгосрочного планирования, особенно в условиях развивающегося бизнеса;
- **длительное тестирование** - это тест, который является вариацией теста средней нагрузки с основным отличием - в продолжительности. Время тестирования может достигать нескольких часов и даже дней. Этот тип теста помогает выявить долгосрочные проблемы, такие как утечки памяти или сбои в работе базы данных.

Правильная стратегия нагрузочного тестирования сильно зависит от профиля нагрузки конкретной системы, которая основана на реальных показателях мониторинга с продакшн-среды или планируемыех показателях.

Основные метрики, которые используются при анализе производительности и для выявления потенциальных точек отказа системы:
- **время отклика** (Response Time) - время, необходимое для обработки запроса приложением;
- **время загрузки страниц на стороне пользователя** - время, которое требуется для загрузки страницы в браузере пользователя;
- **пропускная способность** (Throughput) - определяет количество обработанных запросов за единицу времени и измеряется в запросах в секунду (RPS) или транзакциях в секунду (TPS);
- **использование процессора** (CPU Usage) - показывает, какая часть вычислительной мощности процессора используется приложением;
- **использование памяти** (Memory Usage) - показывает, сколько оперативной памяти используется приложением;
- **ошибки** (Error Rate) - процент запросов, завершившихся с ошибкой, относительно общего количества запросов;
- **количество одновременных пользователей** (Concurrent Users).

### <a id="Доступность" href="#Доступность">Доступность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Доступность** - один из основных способов измерения отказоустойчивости. Она определяется как процент времени, в течение которого приложение доступно для использования.

`Доступность = (Согласованное время обслуживания – Время простоя / Согласованное время обслуживания) * 100%`
> `(8500 – 50 / 8500) * 100% = 99,412%`

Время обслуживания системы состоит из:
1. **MTBF** (mean time between failure) - продолжительность времени работы приложения без сбоев (временем между сбоями или временем между началом нормальной работы и следующим сбоем);
2. **MTTR** (mean time to recovery) - это время, которое потребовалось для восстановления после сбоя (период времени, когда рабочая нагрузка остается недоступна, а неисправная подсистема ремонтируется или возвращается в эксплуатацию). Складывается из:
    - **MTTD** (mean time to detect) - промежуток времени, который потребовался на обнаружение неисправности и начало работ по восстановлению;
    - **repair time** - промежуток времени, который потребовался на само восстановление приложения до рабочего состояния.

**RTO** (Recovery Time Objective) - время, необходимое для восстановления работоспособности системы.

#### <a id="Фейловер-стратегии" href="#Фейловер-стратегии">Фейловер-стратегии</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Фейловер-стратегия** (Failover Strategy) - это механизм обеспечения высокой доступности приложения, в рамках которого **основная** (primary) система в случае сбоя может быть заменена **резервной** (redundant).

Основные причины сбоев:
- аппаратный сбой;
- программный сбой;
- сбой в работе сети;
- ручное вмешательство.

Основные преимущества использования:
- **обеспечивает непрерывность обслуживания** - в случае отказа одного из узлов системы можно продолжать обслуживать клиентов и поддерживать работу бизнеса;
- **минимизирует время простоя** - позволяет бизнесу работать практически в обычном режиме за счет резервного узла системы, пока основной узел ремонтируется, что позволяет избежать затрат на простои: потерь производительности, данных, дохода и репутации;
- **снижает риски** - так как вероятность одновременного выхода из строя основной и резервной системы очень мала и поэтому риск полной недоступности приложения сильно ниже.

Классы критичности:
- Mission critical;
- Business critical;
- Business operational;
- Office productivity.

**Disaster Recovery Plan** (DRP) - это план аварийного восстановления после сбоя. Представляет собой документ, который включает в себя:
- детальное описание действий и их последовательности для устранения последствий аварии;
- роли и обязанности ответственных сотрудников.

DRP необходим, так как даже если фейловер-стратегия автоматизирована, все равно что-то может пойти не так.

DRP-планы должны обновляться сразу при внесении изменений в систему. Также важно проводить регулярные учения для проверки как работоспособности алгоритма, заложенного в план, так и самих сотрудников.

##### <a id="Стратегия-Active-Active" href="#Стратегия-Active-Active">Стратегия Active-Active</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегия Active-Active** - это стратегия, в которой приложение будет развернуто как минимум на двух узлах (серверах), которые одновременно обрабатывают запросы с балансировщиком нагрузки для равномерного распределения нагрузки по всем узлам. При этом индивидуальные настройки и конфигурации каждого из узлов должны быть идентичны, чтобы обеспечить избыточность и бесперебойную работу приложения.

Плюсы:
- улучшается отклик приложения благодаря равномерному распределению нагрузки;
- потенциальное время простоя стремится к нулю, так как оба узла постоянно активны и готовы к работе. Сильно зависит от конфигурации балансировщика: частоты проверки работоспособности экземпляра приложения и скорости ребалансировки трафика;
- сбой одного узла приводит только к частичной недоступности, так как работающии узлы все еще могут примнимать трафик;
- приложение проще масштабировать в случаях нехватки или неэффективности вертикального масштабирования ресурсов самих серверов.

Минусы:
- высокая стоимость конфигурации приложения;
- сложность имплементации для stateful-приложений;
- каждый из узлов должен быть способен обработать всю нагрузку самостоятельно, что подразумевает уменьшения утилизации в обычном состоянии для того, чтобы иметь возможность принимать дополнительную нагрузку;
- балансировщик не должен становиться точкой отказа, и для него также нужно предусмотреть фейловер-стратегию - он должен быть развернут на нескольких узлах.

Используется для высоконагруженных систем с высокими требованиями к доступности и отказоустойчивости: доступность >= 99,5% и/или RTO =< 30 минут.

##### <a id="Стратегия-Active-Standby" href="#Стратегия-Active-Standby">Стратегия Active-Standby</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегия Active-Standby** (Active-Passive) - это стратегия, аналогичная Active-Active, но в которой не все узлы активны, один активен, а другой в режиме ожидания (пассивном режиме). При этом резервный узел считается отказоустойчивым сервером, готовым функционировать в качестве резервного, если основной активный сервер перестанет функционировать по какой-либо причине.

Плюсы:
- меньшее потребление ресурсов резервными узлами в пассивном состоянии, что уменьшает затраты;
- простое администрирование, так как трафик должен идти всегда только на один узел;
- обеспечивает относительно короткое время восстановления за счет того, что приложение на резервном узле находится в рабочем состоянии.

Минусы:
- возможные задержки при переключении на резервный компонент из-за того, что приложению может быть необходимо время, чтобы адаптироваться под нагрузку;
- меньшее потребление ресурсов может привести к проблемам, так как фактически ресурсы для резервного узла закреплены за ним и "простаивают" и слишком низкая утилизация может трактоваться как неэффективное использование.

Используется для критически важных систем, в которых предпочтение отдается стабильности и простоте управления над временем переключения. Хорошо соответствует приложениям с низкими требованиями ко времени восстановления после сбоя: доступность =< 99,5% и RTO >= 30 минут.

##### <a id="Стратегия-Cold-Standby" href="#Стратегия-Cold-Standby">Стратегия Cold Standby</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегия Cold Standby** - это стратегия, аналогичная Active-Standby, но когда резервный узел не развернут и в случае сбоя основного узла, потребуется сначала его развернуть и только затем направить на него трафик. Такой подход отличается высокой степенью экономии, но в то же время гораздо более долгим временем простоя приложения.

##### <a id="Георезервирование" href="#Георезервирование">Георезервирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Георезервирование** используется для повышения отказоустойчивости приложения, путем развертывания резервных копий системы на различных площадках или ЦОД, которые находятся в различных географических локациях.

**GSLB** (Global Server Load Balancer) - это балансировщик нагрузки, который способен направлять трафик между несколькими центрами обработки данных. В то время как обычный балансировщик распределяет трафик по серверам, расположенным в одном ЦОД.

Алгоритм работы GSLB:
1. **Пользователь вводит URL** в своем браузере или приложении, начиная процесс обращения к веб-сервису;
2. **Запрос DNS**: устройство пользователя отправляет запрос на DNS-сервер для получения IP-адреса, ассоциированного с запрашиваемым доменным именем;
3. **Перенаправление запроса к GSLB**: запрос DNS может быть перенаправлен или изначально отправлен к DNS-серверу, который является частью инфраструктуры GSLB.
4. **Принятие решения GSLB**:
    1. GSLB применяет свои стратегии и правила для выбора подходящего ЦОД, которое может основываться на географии пользователя, текущей загрузке ЦОД, статусе здоровья серверов в каждом ЦОД и других параметрах;
    2. GSLB может также учитывать стратегии отказоустойчивости, например, переключаясь на резервные центры данных, если основной недоступен.
5. **Ответ DNS**: GSLB отправляет ответ DNS обратно устройству пользователя, указывая IP-адрес выбранного центра данных или конкретного сервера;
6. **Обращение к серверу**: устройство пользователя использует полученный IP-адрес для направления запроса к узлу приложения в выбранном ЦОД. После получения IP-адреса взаимодействие с сервером происходит напрямую;
7. **Обработка запроса приложением**: сервер принимает запрос от пользователя и обрабатывает его, предоставляя запрашиваемый контент или выполняя нужные операции.

### <a id="Паттерн-Backpressure" href="#Паттерн-Backpressure">Паттерн Backpressure</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Backpressure** позволяет ограничить давление или противодействовать потоку данных. Он обеспечивает обратную связь, с помощью которой регулируется скорость работы производителя данных в соответствии со скоростью работы потребителя. Без этой связи быстрый производитель может заполнить буфер потребителя или, если буфер неограничен, исчерпать всю оперативную память.

Механизм работы:
1. **Производитель данных** (producer), отправляет данные в очередь потребителя;
2. **Потребитель данных** (consumer), обрабатывает данные из очереди;
3. **Канал обратной связи** (feedback channel), обеспечивает коммуникацию между потребителем и производителем, чтобы у потребителя была возможность давать сигналы обратной связи производителю о способности обрабатывать поступающие данные;
4. **Механизм регулирования** (flow control mechanism), управляет потоком данных от производителя к потребителю на основе полученной обратной связи, чтобы производитель мог корректировать скорость или поведение передачи данных в соответствии с возможностями потребителя. Может включать такие методы, как ограничение скорости, буферизация или динамическая настройка обработки данных;
5. **Механизм сигнализации** (pressure signal mechanism) это средства, с помощью которых потребитель отправляет сигналы об обратном давлении производителю данных: сообщения, управляющие сообщения, сигнальные флаги или индикаторы доступности ресурсов.

### <a id="Паттерн-Curcuit-Breaker" href="#Паттерн-Curcuit-Breaker">Паттерн Curcuit Breaker</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Curcuit Breaker** позволяет снизить использования ресурсов (CPU, Memory) и предотвращение ошибок в работе приложения, путем быстрого отказа в выполнении запросов на раннем этапе к внешнему сервису и защищает от каскадных сбоев при сбое внешнего сервиса.

Может находиться в трех состояниях:
- **закрыт** - когда пропускаются все запросы к внешнему сервису;
- **открыт** - когда не пропускаются все запросы к внешнему сервису; переходит в это состояние если превышается определенный порог сообщений о сбое;
- **полуоткрыт** - когда пропускаются определенная часть запросов к внешнему сервису; переходит в это состояние через определенное время, а затем если запросы к внешнему сервису успешны, то переходит в состояние **закрыт**, а иначе в **открыт**.

Используется для того, чтобы предотвратить попытки приложения обратиться к удаленной службе или общему ресурсу, если высока вероятность сбоя операции.

### <a id="Паттерн-Rate-Limiting" href="#Паттерн-Rate-Limiting">Паттерн Rate Limiting</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Rate Limiting** осуществляет контроль количества запросов (нагрузку), с которой пользователи или другие системы обращаются к ресурсу (API, сервису или БД) и используется для защиты системных ресурсов и обеспечении равномерного использования ресурсов всеми пользователями.

Базовые понятия:
- **лимит** - определяет максимальное значение для количества запросов или действий в течение назначенного промежутка времени;
- **окно** - это период времени, в течение которого вступает в действие лимит - любой промежуток времени;
- **идентификатор** - это уникальный атрибут, который позволяет отличать потребителей ресурса, перед которым стоит **Rate limiter**, важно, чтобы он давал максимально точно идентифицировать потребителя, не затронув других потребителей.
Идентификатор лимита может быть составной (например, тип операции + идентификатор пользователя).

Типовые способы обработки превышения лимита:
- **блокировка**, когда в случае превышения **Rate limiter** просто не пропускает запрос с ответным сообщением об ошибке (**429** код - Too many requests);
- **троттлинг**, когда в случае превышения **Rate limiter** предполагает задержку или замедление запросов, которые выходят за пределы лимита. После завершения текущего окна запросы могут быть направлены на ресурс, если не истекло время ответа;
- **приоритизация**, когда в случае превышения **Rate limiter** запросы не блокируются и не откладываются, но этим запросам назначается более низкий приоритет, что гарантирует, что пользователи, соблюдающие лимиты, получат качественный сервис.

Алгоритмы лимитирования запросов:
- **счетчик фиксированного окна** делит временную шкалу на временные окна фиксированного размера и назначает счетчик для каждого окна. Каждый запрос увеличивает счетчик на некоторое значение. Как только счетчик достигает порогового значения, последующие запросы блокируются до начала нового временного окна. При этом есть проблема: невозможно контролировать лимит запросов, которые происходят на границах окон, и это позволяет пройти избыточным запросам;
- **журнал скользящего окна, или алгоритм счетчика фиксированного окна с определяемым пользователем началом** отслеживает временные метки отдельных запросов в пользователей и сохраняет их в журнал. Окна начинаются в момент, когда пользователь совершил первый запрос, и с каждым новым запросом журнал проверяется на наличие запросов в пределах окна. По мере устаревания из-за завершения временного окна метки удаляются из журнала и заменяются новыми;
- **счетчик скользящего окна** вычисляет взвешенный счетчик для предыдущего временного окна. Когда поступает новый запрос, счетчик корректируется на основе веса и запрос разрешается, если общая сумма ниже лимита. Используется такой алгоритм для следующего окна:
    1. Считается количество разрешенных запросов в предыдущем фиксированном окне;
    2. Считается количество разрешенных запросов в текущем фиксированном окне;
    3. Определяется вес запросов предыдущего окна, который пропорционален пересечению этого окна с плавающим окном, завершающимся в текущий момент;
    4. Суммируются взвешенные запросы из (3) с невзвешенными запросами из (2).
- **бакет токенов** содержащий токены, которые представляют собой разрешенное количество запросов, которые хранятся в бакете (ведре). Бакет изначально заполнен токенами, при этом с течением времени они добавляются в бакет с фиксированной скоростью. Когда поступает запрос, Rate limiter забирает токен из ведра. Если в бакете есть токены, то запрос пропускается, если нет - блокируется.

Может быть расположен:
- **на уровене приложения** для ограничения скорости в самом коде приложения;
- **на уровене балансировщика или шлюза API** чтобы избежать влияния на прикладные компоненты приложения;
- **на уровене Service mesh** чтобы он контролировал весь поступающий в приложение трафик, но при этом не дублирует функциональность на каждый отдельный экземпляр;
- **на уровене базы данных** для защиты базы данных от чрезмерной нагрузки.

Используется для:
- **лимитирования запросов от пользователей**;
- **лимитирования запросов на уровне API**, для контроля скорости запросов от клиентов, обеспечивая справедливый доступ к ресурсам и предотвращая злоупотребления;
- **лимитирования запросов к БД**, для предотвращения чрезмерной нагрузки на сервер базы данных и поддержания ее производительности;
- **ограничения количества логинов** - попыток входа на пользователя или IP-адрес.

### <a id="Паттерн-Bulkhead" href="#Паттерн-Bulkhead">Паттерн Bulkhead</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Bulkhead** подразумевает изоляцию различных компонентов системы так, чтобы сбои в одном компоненте не влияли на другие.

Используется для:
- **изоляция неисправностей**, чтобы сбои в определенных компонентах или модулях не распространялись на остальные;
- **оптимизации производительности** благодаря изоляции ресурсоемких задач или служб, системы избегают конфликтов и обеспечивают стабильную производительность между различными компонентами;
- **повышения безопасности**, так как уменьшается поверхность атаки и ограничивается распространение уязвимостей;
- **гибкости масштабирования**, так как позволяет независимо масштабировать изолированные компоненты.

Реализации:
- **разделение пулов соединений** чтобы сбои в работе одного сервиса не воздействовали на подключения к другим сервисам;
- **разделение ресурсов приложения** чтобы чрезмерное потребление ресурсов одним приложением не влиядо на работу другого приложения;
- **разделение пула тредов** для различных типов задач или операций;
- **разделение БД** чтобы сбои или замедления в одной базе данных не повлияли на работу других приложений;
- **разделение на уровне брокера сообщений** с помощью различных наборов очередей;
- **разделение на лругих уровнях**.

### <a id="Паттерн-Transactional-outbox" href="#Паттерн-Transactional-outbox">Паттерн Transactional outbox</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Transactional outbox** призван решить проблему двойной записи операций, которая возникает в распределенных системах.

Суть реализации заключается в том, что сервис, который должен отправить сообщение или событие, сначала сохраняет его в базе данных как часть транзакции, в рамках которой он создает, удаляет или обновляет бизнес-сущность. При этом сохранение этого сообщения происходит в отдельную outbox-таблицу. Из нее отдельный процесс потом их вычитывает и отправляет через брокер сообщений.

Основные компоненты:
- **отправитель** - сервис, который отправляет сообщение;
- **база данных** - база данных, которая хранит бизнес-сущности и исходящие сообщения;
- **таблица исходящих сообщений** (Outbox table) - таблица хранящая исходящие сообщения;
- **передатчик сообщений** - в рамках отдельного процесса вычитывает исходящие сообщения и отправляет их в брокер. Может быть:
    - **polling publisher** - предполагает периодическую вычитку записей из таблицы исходящих сообщений, и если в таблице были найдены новые сообщения, он отправляет их в брокер. Может быть отдельным компонентом или частью отправителя;
    - **transaction log tailing** - предполагает подписку на транзакционный лог БД и публикацию каждого изменения как сообщение в брокер сообщений.

## <a id="Репликация" href="#Репликация">Репликация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Репликация** - это создание и поддержание копий базы данных на нескольких серверах, что обеспечивает высокую доступность, повышенную производительность и отказоустойчивость.

**Преимущества**:
- **высокая доступность данных**, так как данные дублируются на нескольких серверах, что позволяет обеспечить непрерывность работы системы;
- **высокая производительность системы** из-за распределения нагрузки на чтение между несколькими узлами, что снижает нагрузку на основной сервер и улучшает производительность;
- **отказоустойчивость**, так как при сбое одного из серверов данные остаются доступными на других репликах, что минимизирует риск потери данных и простоев;
- **гибкость в распределении нагрузки**, так как запросы на чтение отправляются в улзы, которые ближе всего к пользователю географически, что снижает задержки и повышает скорость доступа к данным.

**Ограничения**:
- **сложности с консистентностью данных** (устареванию) на узлах в случае задержек репликации, что требует дополнительных механизмов синхронизации и управления конфликтами;
- **ресурсозатратность**, поскольку поддержание нескольких копий данных требует дополнительных вычислительных и дисковых ресурсов;
- **сложность управления** системой с несколькими репликами усложняется необходимостью мониторинга состояния каждой реплики, обеспечения их синхронизации и обработки сбоев.

### <a id="Репликация-master-slave" href="#Репликация-master-slave">Репликация master-slave</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Репликация master-slave** устраняет узкие места в производительности и обеспечивает доступность данных в условиях увеличения пользовательского трафика или сбоев оборудования.

Состоит из:
- **главного, первичного узла** (мастера, master) - ответственного за обработку всех операций записи и управление данными;
- **подчиненого, вторичного узла** (реплики, слейва, slave) - который пассивно реплицируешего данные от главного узла и обслуживает запросы на чтение в случае применения паттерна read-replica. Их может быть несколько.

Когда на главном узле происходит операция записи, он регистрирует изменения в журнале транзакций. Затем подчиненные узлы извлекают эти журналы и применяют изменения к своим копиям данных. В зависимости от требований к согласованности, ведомые узлы могут:
- приостановить свою работу до получения обновлений от главного;
- продолжать обслуживать возможно устаревшие данные, одновременно применяя последние изменения в фоновом режиме.

В случае *потери* мастера, следующим мастером становится кто-то из подчиненных узлов, в зависимости от настройки.

#### <a id="Паттерн-read-replica" href="#Паттерн-read-replica">Паттерн read-replica</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн read-replica** заключается в чтении только с подчиненных узлов, а записи только в главный узел.

При применении этого паттерна существует проблема - **задержка репликации**, когда данные в подчиненных могут отставать от главного узла. Для решения используется:
- считывания с учетом задержки отправляются в главный узел;
- чтения, за которыми сразу следуют записи, направляются в главный узел;
- проверка совпадения данных в главном узле и подчиненным и при не совпадении чтением из главного.

### <a id="Репликация-multi-master" href="#Репликация-multi-master">Репликация multi-master</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Репликация multi-master** - это репликация master-slave только когда несколько узлов выполняют роль главных узлов со своими подчиненными узлами. Данные синхронизируются между узлами, а запись может происходить на любом из главных узлов. В результате создается несколько копий данных. Система решает проблему конфликтов между одновременными изменениями.

**Преимущества**:
- в случае сбоя одного главного узла другой главный узел может обновить и вставить данные;
- главные узлы находятся в разных местах, поэтому вероятность сбоя всех главных узлов крайне мала;
- обновления данных возможны на нескольких серверах;
- приложению не нужно направлять трафик только на один главный узел.

**Недостатки**:
- сложность настройки и поддержки;
- потенциальные задержки в данных.

## <a id="Кэширование" href="#Кэширование">Кэширование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Кэширование** снижает нагрузку при большом количестве операций чтения одинаковых данных.

**Принцип работы**:
1. Приложение проверяет наличие нужных данных в кэше;
2. Если данных в кэше нет, то запрос направляется в хранилище;
3. На обратном пути данные передаются в кэш, а запрос возвращается пользователю.

**Используется**:
- при высокой нагрузке на чтение для текущих ресурсов;
- при наличии редко изменяемой информации, которую необходимо часто получать из хранилища.

**Основная сложность**: данными в кэше нужно управлять, чтобы поддерживать их согласованность.

### <a id="Паттерн-Cache-Aside" href="#Паттерн-Cache-Aside">Паттерн Cache-Aside</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Механизм работы:
1. Пользователь отправляет запрос на чтение данных;
2. Приложение проверяет кэш, если данные найдены, происходит попадание в кэш;
3. Если данные не найдены, происходит кэш-промах и приложение отправляет запрос к базе данных;
4. Приложение получает ответ;
5. Данные заносятся в кэш.

Плюсы:
- **устойчивость к сбоям кэша**, так как если сервер кэша выходит из строя, система все равно может работать, обращаясь напрямую к базе данных;
- **модель данных в кэше может отличаться от модели данных в БД**, что позволяет выполнить запрос к БД, объединяющий несколько таблиц, и сохранить его в кэше под одним ключом для того, чтобы избежать дальнейшего выполнения сложной логики.

Минусы:
- **низкая скорость обновления данных**, так как обрабатываются только операции чтения, а не записи, которые минуют кэш и выполняются непосредственно в базу данных, что считается медленной операцией;
- **несогласованность данных в кэше с базой данных**, так как запись делается в базу данных, но не в кэш и в нем остаются старые данные, и чтобы избавиться от этого можно вручную инвалидировать кэш, используя одну из стратегий инвалидации.

Лучше всего подходит для приложений с большим объемом запросов на чтение, где практически отсутствуют операции записи.

### <a id="Паттерн-Read-Through" href="#Паттерн-Read-Through">Паттерн Read-Through</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Механизм работы состоит в том, что актуальные данные из базы данных сразу кладутся в кэш и только потом возвращаются приложению и к базе данных обращается именно кэш, а не приложение.

Плюсы:
- **меньшая сложность приложения и низкая вероятность ошибок**, так как кэш не обновляется на стороне приложения, а является вспомогательным сервисом базы данных, которая его обновляет, и приложению не нужно обновлять кэш при чтении.

Минусы:
- **кэш-промах при первом запросе**, что влечет за собой дополнительное время на загрузку данных в кэш, что исправляется с помощью *"прогрева кэша"* - ручной отправки запросов на старте приложения, чтобы данные из базы данных успешно подгрузились в кэш;
- **ограничения на выбор модели данных в кэше**, так как модель данных в кэше должна быть идентична модели базы данных;
- **чувствительность к ошибкам** из-за того, что к базе обращается не приложение, а кэш, и в случае ошибки данные будет брать неоткуда.

Лучше всего подходит для приложений с большим объемом запросов на чтение, где практически отсутствуют операции записи.

### <a id="Паттерн-Refresh-ahead" href="#Паттерн-Refresh-ahead">Паттерн Refresh-ahead</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Механизм работы состоит в том, что часто используемые кэшированные данные принудительно асинхронно обновляются в кэше до истечения срока их действия, чтобы приложение не ощущало эффекта медленного чтения при извлечении объекта из хранилища данных в случае истечения срока его действия.

Плюсы:
- **низкая стоимость чтения данных из БД**;
- **согласованность записей кеша**, к которым часто обращаются пользователи;
- **высокая чувствительность к задержкам**.

Минусы:
- **кэш должен работать без ошибок**, поскольку в случае ошибки это будет не сразу определено и приведет к неконсистентности данных, работу с устаревшими данными или чтению из базы.

### <a id="Паттерн-Write-Through" href="#Паттерн-Write-Through">Паттерн Write-Through</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Механизм работы:
1. Приложение обновляет базу данных через кэш;
2. Кэш обновляет базу данных;
3. База данных возвращает результат запроса;
4. Кэш обновляется данными из БД;
5. Данные из БД возвращается клиенту.

Плюсы:
- **данные между кэшем и базой данных всегда будут синхронизированы**, что исключает возможность неконсистентности кэша и его инвалидацию.

Минусы:
- **необходимость ждать, пока кэш обновит базу данных**, так как эта операция синхронная, клиент не получит ответа, пока база не обновится.

### <a id="Паттерн-Write-Behind" href="#Паттерн-Write-Behind">Паттерн Write-Behind</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Механизм работы:
1. Приложение обновляет кэш;
2. Кэш возвращает клиенту ответ;
3. Кэш планирует асинхронную задачу на обновление базы данных;
4. База данных обновляется в соответствии с задачей.

Плюсы:
- **низкая стоимость**;
- **консистентность данных**;
- **высокая скорость передачи данных**.

Минусы:
- **потенциальные ошибки при обновлении базы данных**, так как эта операция асинхронная, и клиент не получит ответа что база не смогла обновить данные.

### <a id="Способы-инвалидации-кэша" href="#Способы-инвалидации-кэша">Способы инвалидации кэша</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные способы:
- **временная инвалидация**, когда устанавливается фиксированное время жизни данных в кэше;
- **инвалидация, основанная на запросах**, когда кэш инвалидируется каждый раз, когда приходит запрос на обновление данных;
- **инвалидация на основе изменений**, когда кэш инвалидируется каждый раз, когда происходят изменения в данных;
- **программная инвалидация**, когда кэш должен быть инвалидирован на основе определенных условий или событий в приложении;
- **инвалидация по ключу**, когда кэш может быть инвалидирован для конкретных данных или ключей.

### <a id="Виды-кэширования" href="#Виды-кэширования">Виды кэширования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Виды кэширования:
- **FIFO** - если искомый элемент не находится в кэше, он вставляется в хвост очереди. Если нужно освободить место, удаляются элементы из головы очереди. Таким образом вытесняется элемент, находящийся в кэше дольше всех.
- **LRU** - новый элемент вставляется в голову списка. При запроса из кэша элемент перемещается в голову списка. Если нужно освободить место, вытесняется элемент из хвоста списка.
- **MRU** - последний использованный вылетает из кэша.
- **LFU** - каждый элемент имеет счетчик обращений. Новый элемент вставляется в кэш со значением счетчика равным 1. При попадании в кэш счетчик найденного элемента увеличивается на 1. Если нужно освободить место, нужно найти элемент с самым маленьким значением счетчика.
- **SNLRU** (сегментированный LRU) - это N кэшей LRU. Новый элемент вставляется в нулевой LRU кэш. При попадании в кэш элемент перемещается в следующий LRU кэш, либо на MRU (Most Recently Used) позицию последнего LRU кэша, если выше уже идти некуда. При вытеснении элемента из k-го LRU кэша он перемещается в k-1 LRU кэш. По достижению нулевого LRU кэша элемент удаляется.
- **2Q** - кэш разделяется на три части:
    - **In** - FIFO кэш, в который попадают все новые элементы, запрошенные отсюда элементы никуда не перемещаются;
    - **Out** - FIFO кэш, в который попадают элементы, вытесненные из **In**. При этом этот кэш хранит ключ и не хранит значение, поэтому его можно сделать достаточно большим;
    - **Main** - главный LRU кэш, в который попадают новые элементы запрошенные из **Out**, в котором они удаляются. При вытеснении элемента из главного кэша он удаляется.
- **MQ** - сегментированный LRU в котором запоминается позиция с которой элемент вылетел - и при повторном запросе - возвращается туда, где был, если не вылетел из очереди запомненных позиций.

### <a id="Распределенный-кэш" href="#Распределенный-кэш">Распределенный кэш</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Распределенный кэш** - это система, в которой данные хранятся на нескольких узлах кластера и в нескольких кластерах в разных центрах обработки данных по всему миру.

Система распределенного кэша объединяет оперативную память нескольких сетевых компьютеров в единое хранилище данных в оперативной памяти, которое используется в качестве кэша для быстрого доступа к данным. Она позволяет постепенно расширять и масштабировать систему, добавляя новые компьютеры в кластер.

## <a id="Шардирование-и-партиционирование" href="#Шардирование-и-партиционирование">Шардирование и партиционирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Партиционирование** (секционирование) - метод разделения больших объемов данных на отдельные сегменты. **Шардирование** - это частный случай партиционирования.

**Вертикальное партиционирование** - это метод разделения одной большой таблицы на несколько меньших, которые физически хранятся отдельно и которые по структуре отличаются от исходной таблицы. Оно позволяет повысить производительность и доступность данных, поскольку операции выполняются над меньшим количеством данных.

**Горизонтальное партиционирование** (шардирование, сегментирование) - распределение данных по нескольким базам, чаще всего на отдельных физических серверах. Оно предполагает разделение данных на группы по определенным **критериям** и в результате разделения данных каждый **сегмент** (шард) включает одни и те же столбцы, но разные строки информации.

Преимущества горизонтального партиционирование:
- **преодолевание технических ограничений**, так как позволяет распределить данные по разным серверам;
- **повышение надежности**, так как шарды базы данных расположены на разных серверах, отказ одного из них не приведет к полной остановке работы;
- **ускорение доступа к данным с простыми запросами** из-за распредения нагрузки и увеличения объемов и скорости обработки данных.

Ограничения горизонтального партиционирование:
- **сложность реализации**;
- **риск снижения эффективности разработки** из-за необходимости управлять данными из нескольких сегментов вместо единой точки;
- **неравномерность загрузки серверов** из-за несбалансированности данных, когда одни серверы оказываются загружены больше, чем другие, что потребует повторного сегментирования;
- **снижение скорости обработки сложных запросов**, требующих обращения к нескольким шардам одновременно, что может привести к потере производительности и замедлению процесса получения данных по сравнению с обращением к одной таблице.

### <a id="Методы-шардирования" href="#Методы-шардирования">Методы шардирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Хэшированное шардирование** (key based sharding) - это разделение данных на шарды на основе хэш-функции, которая принимает входные данные и возвращает хэш-значение, которое определяет, в какой шард попадет каждая запись данных.

Особенности:
- риск потери данных: **низкий**, так как отсутствует единая точка отказа;
- распределение данных: **равномерное**;
- поиск данных: **средний**;
- реализуемость: **легкая**;
- масштабируемость хранилища: **высокая**;
- геораспределение данных: **отсутствует**.

Подходит для равномерного распределения данных.

**Диапазонное шардирование** (range based sharding) - разделение данных на шарды на основе диапазона значений (chunk). Значения разделяются не с помощью функции, а по ключу или другим атрибутам. Каждому фрагменту присваивается диапазон на основе значений ключа сегментирования. Ключи сегментов, чьи значения близки друг к другу, чаще всего оказываются в одном диапазоне. Это упрощает выполнение целевых операций.

Особенности:
- риск потери данных: **низкий**;
- распределение данных: **неравномерное**;
- поиск данных: **легкий**;
- реализуемость: **легкая**;
- масштабируемость хранилища: **высокая**;
- геораспределение данных: **отсутствует**.

Подходит для данных временных рядов или последовательных данных (журналы, события с временными метками, цены на товары и т. д.).

**Динамическое шардирование** (dynamic sharding) - автоматическое масштабирование хранилища в зависимости от текущей производительности и объема данных. Оно очень гибкое, но требует сложной балансировки нагрузки, надежного мониторинга и тщательно продуманной архитектуры базы данных.

Для определения местоположения записей используется **внешний поисковый сервис**, что помогает решать проблемы, возникающие при динамическом сегментировании. Внешний поиск предоставляет полную информацию о том, в каком сегменте находятся данные, что позволяет перемещать пользователей по отдельности, а не большими группами, из одного сегмента в другой. Это помогает снизить нагрузку на перегруженные сегменты. При этом поисковый сервис становится единственным местом взаимодействия с системой и потенциальным источником сбоев.

Особенности:
- риск потери данных: **высокий**;
- распределение данных: **неравномерное**;
- поиск данных: **сложный**;
- реализуемость: **сложная**;
- масштабируемость хранилища: **автоматическая**;
- геораспределение данных: **возможно**.

**Геошардинг** (geo sharding) - это хранение в разных сегментах информации, относящейся к определенной географической зоне. Его можно комбинировать с другими методами шардирования, если это необходимо.

Особенности:
- риск потери данных: **низкий**;
- распределение данных: **неравномерное**;
- поиск данных: **легкий**;
- реализуемость: **легкая**;
- масштабируемость хранилища: **средняя**;
- геораспределение данных: **реализована**.

Подходит для сервисов, которым важна локальность данных (для сетей доставки контента и мобильных приложений с учетом геолокации).

### <a id="Способы-реализации-шардирования" href="#Способы-реализации-шардирования">Способы реализации шардирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные способы реализации шардирование:
- **средствами базы данных**, которые могут автоматически распределять данные между своими экземплярами, что задается через конфигурацию баз данных;
- **с использованием надстроек к базе данных** - сторонние утилиты, которые выполняют шардирование;
- **с применением клиентских средств**, когда экземпляры базы данных не знают о существовании друг друга, а шардированием управляет сервис.

## <a id="Горизонтальное-масштабирование-приложения" href="#Горизонтальное-масштабирование-приложения">Горизонтальное масштабирование приложения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Способы-сохранения-состояний-приложения" href="#Способы-сохранения-состояний-приложения">Способы сохранения состояний приложения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Stateful** (с сохранением состояния) - подход, при котором система сохраняет информацию о предыдущих состояниях или взаимодействиях с клиентами. Применяется в ситуациях, когда экземпляров (инстансов) приложения несколько, но пользователю нужно всегда попадать на сервер, который владеет конкретным закрепленным за ним состоянием.

Приложения с состояниями обычно масштабируют не напрямую, а через масштабирование базы данных, распределенное кэширование и разделение на более независимые микросервисы, каждый из которых работает только над отдельными частями процесса независимо.

**Stateless** (без сохранения состояния) - подход, при котором архитектура приложения не сохраняет информацию о предыдущих состояниях или сеансах где-то отдельно от остальных сервисов. Каждый запрос рассматривается как изолированное взаимодействие.

Масштабируется горизонтально с помощью балансировщика нагрузки.

### <a id="Балансировщик-нагрузки" href="#Балансировщик-нагрузки">Балансировщик нагрузки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Сервис балансировки нагрузки** - это инструмент для распределения запросов между серверами внутри кластера.

Основные решаемые задачи:
- **обеспечивание непрерывной работы приложения** из-за автоматического направления трафика с проблемных серверов на здоровые, что позволит избежать простоя в работе приложения;
- **обеспечивание горизонтального масштабирования** для возможности добавления новых экземпляров приложения и равномерного распределения нагрузки между несколькими экземплярами приложения;
- **повышение безопасности** из-за анализа трафика, фильтрования запросов, а также направление их через брандмауэры и другие защитные механизмы.

Виды по устройству:
- **программные** - это сервисы, которые обычно работают на отдельном сервере;
- **виртуальные** - это решение работает на виртуальной машине (VM) или как экземпляр программного обеспечения в виртуализированной среде;
- **аппаратные** - это непосредственно физические устройства, работающие на 4 и 7 уровнях модели OSI, которые способны обрабатывать все виды трафика: HTTP, HTTPS, TCP и UDP.

Виды по функциям:
- **на 4, транспортном уровне** - когда балансировщик быстрее обрабатывает запросы, поскольку не анализирует содержимое пакетов и имеет возможность работать с адресами серверов. Особенности:
    - использует протоколы TCP и UDP;
    - распределяет трафик, опираясь на IP-адреса и номера портов;
    - может применять базовое преобразование сетевых адресов (NAT), скрывая таким образом адреса серверов.
- **на 7, уровне приложений** - когда балансировщик маршрутизирует контент с учетом содержимого и позволяет принимать сложные решения о маршрутизации, используя данные, специфические для конкретного приложения. Особенности:
    - работает на уровне приложений с протоколами HTTP и HTTPS;
    - способен закрывать SSL-соединения.

#### <a id="Стратегии-балансировки-нагрузки" href="#Стратегии-балансировки-нагрузки">Стратегии балансировки нагрузки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

##### <a id="Round-Robin" href="#Round-Robin">Round Robin</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Round Robin** - эта стратегия последовательно распределяет запросы между доступными экземплярами. Каждый экземпляр получает равную долю запросов в круговом порядке.

Применяется в системах, где все экземпляры имеют схожие характеристики мощности и производительности.

##### <a id="Least" href="#Least">Least</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Семейство стратегий особенность которых - это направлять запросы к экземплярам, по **особому критерию**, что помогает распределить нагрузку более равномерно, особенно когда есть экземпляры с разной производительностью. Бывают:
- **Least Connections** - когда критерий это наименьшее количество активных соединений;
- **Least Response Time** - когда критерий это наименьшее среднее время обработки ответа;
- **Least Bandwidth** - когда критерий это наименьший трафик.

Применяется в системах, где экземпляры могут обрабатывать запросы разной сложности и продолжительности.

##### <a id="IP-Hash-Sticky-sessions" href="#IP-Hash-Sticky-sessions">IP Hash (Sticky sessions)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**IP Hash** - эта стратегия использует хэш IP-адреса клиента, чтобы определить, какой экземпляр будет обрабатывать запрос, что гарантирует, что запросы от одного и того же клиента будут последовательно направляться к одному и тому же экземпляру.

Применяется в системах, в которых требуется сохранение сеанса (для продолжительных пользовательских сеансов в сервисе с состоянием).

##### <a id="Weighted-Round-Robin" href="#Weighted-Round-Robin">Weighted Round Robin</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Weighted Round Robin** - эта стратегия аналогична стратегии **Round Rrobin**, но с весами, присваиваемыми каждому экземпляру на основе его возможностей или характеристик производительности. Экземпляры с более высокими весами получают больше запросов.

Применяется в системах, где некоторые экземпляры более мощные и могут обрабатывать большую долю нагрузки.

##### <a id="Случайное-распределение" href="#Случайное-распределение">Случайное распределение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Случайное распределение** - эта стратегия случайным образом направляет запросы к экземплярам.

Применяется в системах, с равномерно распределенными экземплярами и когда другие стратегии могут не дать значительных преимуществ.

#### <a id="Настройка-балансировщика-нагрузки" href="#Настройка-балансировщика-нагрузки">Настройка балансировщика нагрузки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Реализуются направлением всех запросов в **API Gateway**, который обращаясь к **Service Registry** получает адреса микросервисов, которые в нем регистрируются при создании, а затем направляет по полученным адресам запросы в микросервисы.

##### <a id="Паттерн-API-Gateway" href="#Паттерн-API-Gateway">Паттерн API Gateway</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн API Gateway** - это единая точка входа для клиентских приложений, которая регламентирует коммуникации между клиентом и сервисами, убирая прямую привязку сервисов к клиентам, абстрагирует сервисы от клиентов.

Кроме основных функций имеет дополнительную функциональность: аутентификацию, походы в кэш, роутинг, логирование и другие функции и инструменты.

##### <a id="Паттерн-Service-Discovery" href="#Паттерн-Service-Discovery">Паттерн Service Discovery</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн Service Discovery** - это паттерн, который облегчает коммуникацию между приложениями, даже если меняется количество их инстансов или сетевое расположение.

В основе лежит **Service Registry** - реестр (маленькая база данных), в котором хранится метаинформация о микросервисах, их экземплярах и сетевом расположении.

## <a id="Гибридная-архитектура" href="#Гибридная-архитектура">Гибридная архитектура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Гибридная архитектура** - это когда часть архитектуры лежит в публичном облаке, а часть внутри компании - либо тоже в облаке, но частном, либо просто на "железе".

Преимущества:
- **гибкость в поддержке**, так как доступ к данным возможен в любое время из любой точки мира и можно быстро заказать нужные ресурсы;
- **сокращение расходов**, которое происходит благодаря экономии на капитальных вложениях в расширение инфраструктуры;
- **улучшение масштабируемости** из-за использования ресурсов облачного провайдера, что позволяет адаптироваться к взлетам и падениям нагрузки;
- **быстрый выход на рынок**, который увеличивается за счет повышения производительности IT и гибкости;
- **непрерывность бизнеса** благодаря тому что гарантируется созданием резервных копий критически важных данных и масштабированием в случае увеличения спроса;
- **сохраняется безопасность** благодаря контролю над данными и ограничению доступа;
- **оптимизация скорости и увеличение отказоустойчивости за счет увеличения географии**, так как облачная инфраструктура, как правило, находится в разных ЦОДах и в разных регионах, что облегчает доступ к данным пользователям из определенных близких к этим ЦОДам регионам - получается что-то вроде геошардирования. В случае аварии в каком-то регионе остальные продолжают работать.

Недостатки:
- **сложность интеграции** внутренней инфраструктуры и публичного облака, которая требует сложной настройки мониторинга и инструментов управления инфраструктурой;
- **недостаточная безопасность** из-за строгих требований к безопасности, которые не допускают хранения многих данных в публичном облаке.

### <a id="Распределенное-облачное-кэширование" href="#Распределенное-облачное-кэширование">Распределенное облачное кэширование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Преимущества:
- **высокая доступность данных** (high availability) благодаря репликации данных и механизмам аварийного переключения, так как даже если один узел выйдет из строя, другие узлы смогут взять на себя его функции без потери данных;
- **высокая скорость работы и производительности приложений** за счет хранения часто используемых данных в памяти на нескольких серверах, расположенных близко к пользователям;
- **проще масштабирование** из-за того, что легко добавлять новые узлы кэша по мере увеличения нагрузки;
- **ниже затраты** за счет снижения нагрузки на основные базы данных и оптимизации использования ресурсов, так как базы данных в обслуживании и настройке сильно дороже кэширования.

Ограничения:
- **зависимость от сети**, так как для эффективной работы необходимо надежное и быстрое сетевое соединение между серверами кэша и клиентами - облаком и локальной инфраструктурой;
- **сложность настройки и управления**, так как необходимо умение настраивать балансировку нагрузки, репликацию данных и механизмы аварийного переключения;
- **меньшая безопасность данных** из-за того что все, что в облаке, в большей опасности, чем внутри локального контура. Данные, хранящиеся в кэше, могут быть уязвимы для атак, если не приняты надлежащие меры безопасности;
- **риск потери данных** в случае сбоя в работе одного из узлов кэша данные, хранящиеся на этом узле, могут быть потеряны. Репликация данных помогает снизить этот риск, но не устраняет его полностью;
- **необходимость обучения персонала**, чтобы эффективно управлять системой и минимизировать риски;
- **влияние на производительность** из-за дополнительной нагрузки на сеть и сервера;
- **сложности интеграции** с существующими системами, так как требует тщательного планирования и тестирования.

### <a id="Content-Delivery-Network" href="#Content-Delivery-Network">Content Delivery Network</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Content Delivery Network** (CDN) - это распределенные узлы хранения и доставки информации. Сервис представляет собой систему, которая в ответ на запросы от клиента запрашивает, получает и кэширует данные от источника и отдает их клиенту. Использование CDN значительно снижает нагрузку на источники хранения информации в интернете и ускоряет ее доставку пользователю.

Когда пользователь заходит на сайт, запрос направляется к ближайшему CDN-серверу. Если запрашиваемая информация кэширована на нем, данные сразу отдаются пользователю. Если данные запрашиваются впервые или они устарели, CDN-сервер сначала загружает их с сервера-источника, а затем отдает клиенту.

Преимущества:
- **улучшает SEO**, поскольку сайты загружаются быстрее, что улучшает их видимость в поисковых системах;
- **позволяет избежать дополнительных расходов на инфраструктуру**, так как не требуется покупать новое оборудование или увеличивать мощность сервера-источника;
- **повышает доступность сайта** за счет резервирования серверов друг другом, что гарантирует непрерывность работы сайта;
- **открывает доступ к подробной статистике о трафике** в реальном времени;
- **делает сайт доступным из любой точки мира** благодаря глобальному покрытию CDN;
- **снижает нагрузку на сервер-источник**.

Ограничения:
- **проблемы с динамическим контентом** из-за того, что он должен обрабатываться на сервере источнике;
- **задержки при обновлении контента** после обновления контента на основном сервере прежде чем изменения отобразятся на серверах CDN, что временно 
замедлит доступ к новому контенту;
- **блокировка по IP-адресам** что может привести к недоступности множества сайтов;
- **зависимость от CDN-провайдера**, так как технические проблемы у него могут повлиять на доступность сайта.

#### <a id="Методы-разделения-данных-на-основе-DNS" href="#Методы-разделения-данных-на-основе-DNS">Методы разделения данных на основе DNS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**GeoDNS** (solitary traffic directors, global traffic directors) - это метод географических доменных имен, который использует алгоритм определения геокоординат по IP-адресу пользователя. Клиент отправляет запрос, DNS-сервер определяет местоположение пользователя по IP-адресу и находит ближайшую **точку присутствия** (пограничный узел, Point of presence, PoP) - базовый компонент CDN, где находятся копии или кэшированные версии контента, полученного от основного источника. Их количество и географическое расположение влияет на эффективность использования CDN. Чем ближе они к пользователям интернет-ресурса, тем быстрее доставляется им контент. Чем больше их количество, тем меньше нагрузка на исходный сервер.

GeoDNS позволяет:
- оптимизировать трафик и обеспечить надежную балансировку нагрузки;
- блокировать посетителей веб-сайта по странам;
- выдавать контент адресно в зависимости от геоположения посетителя.

**Anycast** - это метод сетевой адресации и маршрутизации, при котором один IP-адрес присваивается нескольким серверам в сети, которые при этом находятся в разных точках присутствия. В зависимости от местоположения источника запросов данные отправляются на ближайший сервер, что позволяет уменьшить количество сетевых переходов и задержку в передаче данных. Запрос DNS-клиента будет отправляться от одной точки присутствия к другой, пока не достигнет первого авторитетного сервера имен.

<a id="Методы-взаимодействия" href="#Методы-взаимодействия">Методы взаимодействия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====================

## <a id="Методы-взаимодействий-front-to-back" href="#Методы-взаимодействий-front-to-back">Методы взаимодействий front-to-back</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для интеграций фронтенда с бэкендом (front-to-back) важно проработать клиентский путь. Это можно сделать с опорой на вопросы для выяснения функциональных требований (ФТ):
- из каких шагов состоит клиентский путь?
- как пользователь взаимодействует с UI на каждом из шагов?
- на каких этапах потребуется обращение к бэкенд-приложению?
- должен ли пользователь ожидать результат выполнения операции?
- какие данные потребуется передавать?

И на вопросы для выяснения нефункциональных требований (НФТ):
- сколько пользователей может быть одновременно онлайн?
- какой RPS они будут генерить?
- в каком объеме потребуется передавать данные?

### <a id="Паттерн-client-pull" href="#Паттерн-client-pull">Паттерн client pull</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн client pull** предполагает, что инициатором всегда выступает клиент (фронтенд-приложение). Клиент осуществляет отправку сообщения и получает какой-то результат в момент своего обращения к серверу. Ответ от сервера может быть положительным, отрицательным или уведомлять, что результат еще не готов.

Для обновления данных на клиенте используется **паттерн Polling**, который подразумевает, что клиент периодически и регулярно отправляет запросы на сервер, чтобы проверить наличие обновленных данных или событий. При этом есть две его типовые реализации:
- **short polling** - когда клиент запрашивает данные с сервера, и ответ сервер возвращает сразу же: если данные есть, то возвращает их, если нет, то отдает либо пустой ответ, либо содержащий какой-то статус, либо промежуточный результат. И это повторяется через регулярные интервалы до тех пор, пока не появятся данные или это не перестанет быть актуально клиенту;
- **long polling** - когда клиент отправляет запрос на сервер, и если ответ недоступен, сервер удерживает запрос, пока данные не появятся. Также сервер может вернуть ответ в случае достижения максимальной продолжительности соединения: тогда ответ также вернется пустой или со статусом, обозначающим, что данные еще не готовы.

### <a id="Паттерн-server-push" href="#Паттерн-server-push">Паттерн server push</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Паттерн server push** предполагает, что сервер (бэкенд-приложение) - может выступать инициатором передачи данных.

## <a id="Методы-взаимодействий-back-to-back" href="#Методы-взаимодействий-back-to-back">Методы взаимодействий back-to-back</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Виды back-to-back взаимодействий можно разделить на две категории. Их определяет:
- **характер взаимодействия**:
    - **паттерн точка-точка** - когда при взаимодействиях система-инициатор (отправитель сообщения) обращается к конкретной системе за конкретным действием. Система, которая получает сообщение, должна вернуть какие-то данные или выполнить команду;
    - **паттерн публикация-подписка** - когда при взаимодействиях систему, которая отправляет сообщение, не интересует, кем это сообщение будет прочитано, как оно будет обработано и будет ли оно обработано вообще и такое сообщение может быть получено несколькими приложениями;
- **способ взаимодействия**:
    - **синхронные взаимодействия** - когда при взаимодействиях система-инициатор ожидает, что результат обращения ей вернут в рамках того же сетевого подключения;
    - **асинхронные взаимодействия** - когда при взаимодействиях результаты или ответы от системы могут быть получены асинхронно, в рамках другого сетевого подключения, а на стороне системы, получающей ответ, сообщение будет обработано в рамках нового процесса.

<a id="Observability" href="#Observability">Observability</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=============

**Observability** (наблюдаемость) - это свойство системы, которое подразумевает, что можно получать информацию о внутренних процессах.

Основные источники информации:
- **мониторинг** - сбор бизнесовых и инфраструктурных метрик (metrics);
- **логирование** - сбор логов (logs);
- **трейсинг** - сбор трейсов внутренних вызовов (traces).

Основные преимущества:
- **улучшение видимости и повышение безопасности системы** для того, чтобы можно было получать полное представление о работе системы, так как чем выше видимость, тем проще обеспечить безопасность;
- **более быстрое решение проблем и повышение надежности системы** из-за инструментов наблюдения, которые могут помочь быстрее определить корень проблемы, чтобы его было проще устранить и предотвратить в будущем;
- **повышение быстродействия системы и распределение ресурсов** так как с помощью инструментов наблюдения можно выявлять узкие места, что помогает оптимизировать производительность и проанализировать, как система работает под разными нагрузками;
- **ускорение рабочего процесса и DevOps**, поскольку наблюдаемость способствует оптимизации процессов и сокращению количества ошибок, что в свою очередь, помогает ускорить рабочий процесс и улучшить взаимодействие между командами;
- **ценные бизнес-инсайты** из-за накопления данных благодаря наблюдаемости системы, которые могут привести к бизнес-инсайтам, что может помочь принимать стратегические решения более обоснованно;
- **повышение удовлетворенности пользователей** из-за своевременного решение проблем, которые связаны с производительностью и функциональностью приложения.

## <a id="Мониторинг" href="#Мониторинг">Мониторинг</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Метрика** - это агрегированные или одиночные данные о том, как себя чувствуют сервисы, которые выражаются одним числом, которое отслеживают в динамике.

**Мониторинг** - это отслеживание метрик.

Основные метрики:
- **показатели системного уровня** - потребление ресурсов процессора, памяти и диска и т.п.;
- **показатели производительности** - время отклика системы, количество ошибок и т.п.;
- **бизнес-метрики** - количество уникальных пользователей за день, возвращаемость пользователей и т.п.

Этапы мониторинга:
1. **Определение данных для сбора** - подготовительный этап;
2. **Сбор данных** - настраивание агентов, фреймворков и стороннего ПО для отправки метрик;
3. **Отправка данных на хранение** в хранилище, которое будет агрегировать данные для мониторинга, по модели *push* или *pull*;
4. **Анализ данных**, чтобы обнаружить тенденции, закономерности и проблемы;
5. **Формирование отчетов, сводных таблиц или оповещений** для оценки производительности и поведения системы, чтобы выявить проблему до того, как она станет критической.

### <a id="Основные-подходы-к-мониторингу" href="#Основные-подходы-к-мониторингу">Основные подходы к мониторингу</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Метод USE**, который состоит в том, чтобы для каждого ресурса проверять три ключевых показателя:
- **utilization** (утилизация) - это среднее время, которое ресурс занят работой. Измеряется в процентах;
- **saturation** (насыщенность) - объем работы, которую ресурс не может выполнить и вынужден откладывать (например, в очередь), чтобы сохранять работоспособность. Насыщенность можно измерить как длину очереди;
- **errors** (ошибки) - количество ошибок.

Метод USE лучше всего работает с ресурсами, производительность которых снижается при интенсивном использовании.

**Метод четырех золотых сигналов**, который состоит в проверке показателей:
- **задержка** - это время, которое уходит на доставку запроса по сети от отправителя к получателю;
- **трафик** - это показатель активности пользователей в приложении, который можно измерить с помощью любого высокоуровневого системного показателя (в веб-приложениях трафик обычно считают как количество HTTP-запросов в секунду);
- **ошибки** - это частота неудачных запросов, к которым относятся как явные ошибки (например, ошибки с кодом 500), так и неявные (например, статус запроса 200, но контент доставили неправильно);
- **насыщенность** - это показатель насколько "заполнена" система и напрямую связана с показателем использования системы.

Метод золотых сигналов в целом подойдет любой системе, которая связана с предоставлением API, так как он позволяет заметить аномалии в работе заранее и быстро среагировать на ситуацию.

**Метод RED**, который состоит в проверке показателей:
- **requests rate** (частота запросов) - это количество запросов, которые обслуживает сервис в секунду, что дает представление о пропускной способности сервиса;
- **errors** (ошибки) - это количество неудачных запросов в секунду;
- **duration** (длительность) - это количество времени, которое уходит на выполнение одного запроса.

Метод RED эффективен только для сервисов, которые управляются запросами.

### <a id="Модель-ключ---значение" href="#Модель-ключ---значение">Модель "ключ - значение"</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для описания метрики. Имеет структуру: `<ключ_метрики>{<метка_1>="<значение>", ..., <метка_N>="<значение>"} <значение_метрики>`, Где:
- `<ключ_метрики>` - это сама метрика;
- `<метка_1>="<значение>"` - это дополнительные метки, которые добавляют детали метрике;
- `<значение_метрики>` - это число, которое отражает измеренную величину за определенный период времени.
> `up{instance="localhost:8000", job="sample"} 1`

Обычно добавляют дополнительные метки времени - `timestamp` в формате UNIX.

## <a id="Логирование" href="#Логирование">Логирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Лог** - это запись в хранилище (например, в файле или в базе данных), которая содержит информацию о состоянии системы в конкретный момент времени.

**Логирование** - это ведение журнала логов, который фиксирует, как состояние системы изменяется с течением времени.

Уровни логов:
- **FATAL** - отказ сервиса или оборудования;
- **ERROR** - ошибочное состояние (например "пользователь заблокирован");
- **WARN** - состояние, которое близко к нестандартному поведению системы (например "пользователь неправильно ввел пароль");
- **INFO** - это штатное поведение, которое используют для записи обычных сообщений (например "данные загружены");
- **DEBUG** - это отладочное сообщение;
- **TRACE** - это отладочное сообщение в среде разработки и для отладки в тестовом окружении.

## <a id="Трейсинг" href="#Трейсинг">Трейсинг</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Трейсинг** - это метод отслеживания запросов в приложении.

Трейсинг начинается с точки входа запроса в приложение: он запускается для запроса и имеет уникальный идентификатор, сгенерированный для этого запроса. По мере того как трафик переходит от сервиса к сервису, каждый сервис добавляет информацию (например, время поступления запроса в сервис и время, затраченное на его обработку).

По итогу получается список вызовов, представленных в виде дерева, по которым можно понять, где и чем оборвалась цепочка вызовов.

<a id="Безопасность" href="#Безопасность">Безопасность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

## <a id="Угрозы" href="#Угрозы">Угрозы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Угроза в сфере информационной безопасности** - это возможное негативное воздействие на информационную систему, ее отдельные части, процессы, которые в системе выполняются, а также данные, которые обрабатываются и хранятся в системе.

**Уязвимость** - это конкретный недостаток в безопасности информационной системы, который делает воздействие возможным.

Угрозы по месту:
- **внутренние** - это уже заложенные уязвимости в программных и аппаратных компонентах, которые используются в информационной системе и существуют без участия человека;
- **внешние** - это атаки, которые выполняются из внешней относительно атакуемой информационной системы среды, которые зачастую происходят через каналы связи.

Угрозы по видимости:
- **активные** - этот вид угроз предполагает явное внедрение вредоносного кода, изменение конфигурации системы, повреждение данных, при этом реализация угрозы явно видима, ее реализуют открыто и активно, поэтому и обнаруживается она достаточно быстро;
- **пассивные** - этот вид угроз не имеет явного внедрения злоумышленниками извне, с главной опасностью, которая заключается в том, что отследить его по журналам или аудиту сложно или даже невозможно, так как видимых изменений в информационной системе не происходит.

Угрозы по доступу:
- **с несанкционированным доступом** - когда доступ к информационной системе выполняется в обход штатных средств аутентификации, без разрешения или авторизации для того чтобы получить доступ к информационной системе с полномочиями, достаточными для нанесения вреда;
- **с утечкой или нарушением целостности данных** - когда данные компрометируются или пропадают в результате неправомерных или ошибочных действий с доступом сотрудника компании, что вызывает утечку или повреждение данных либо всей системы.

Угрозы по цели:
- **угрозы данным** - которые возникают в результате несанкционированного доступа с целью кражи данных, нарушение их целостности, включая удаление;
- **угрозы компонентам, информационным сервисам** с целью внедрения вредоносного ПО или изменения программных компонентов системы;
- **угрозы аппаратному обеспечению** - физическое повреждение оборудования, кража или неправомерный доступ к аппаратным компонентам;
- **угрозы обеспечивающей инфраструктуре** - атаки на сетевую инфраструктуру, серверы, кластеры оркестрации сервисов (Kubernetes), базы данных и так далее.

Угрозы по объективности:
- **объективные** - угрозы, связаные с реальными и конкретными факторами, они не зависят от действий пользователя или случайных событий, их можно предсказать или учесть заранее:
    - **активируемые угрозы** - вредоносное ПО и бэкдоры, программные "закладки" и "закладки" аппаратуры;
    - **особенности объекта** - его расположение, наличие контролируемой зоны, каналов обмена информацией (например, выход ЦОДа из строя при размещении инфраструктуры в облаке).
- **субъективные** - угрозы, связанные с человеческим фактором, неправильной эксплуатацией или ошибками в процессе работы с системой:
    - **ошибки при установке ПО и в процессе эксплуатации**;
    - **повреждение данных или ненадлежащая работа с ними** - неправильная работа с личными данными, нарушение режима защищенности, преобразование или уничтожение данных.
- **случайные** - угрозы, не зависящие от человеческого фактора и которые могут быть вызваны случайными сбоями или неисправностями в работе системы или инфраструктуры:
    - **сбои и отказы в работе корпоративной инфраструктуры**;
    - **неисправность, повреждения сетевых коммуникаций или систем киберзащиты**.

### <a id="Векторы-угроз" href="#Векторы-угроз">Векторы угроз</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Векторы атак** описывают, как именно возможна реализация угрозы, и помогают компаниям систематизировать знания об угрозах, оценивать угрозы, выявлять уязвимости и строить эффективные системы защиты от киберугроз.

### <a id="Оценка-угроз" href="#Оценка-угроз">Оценка угроз</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Оценка угроз** помогает определить, какие угрозы могут затронуть ключевые компоненты системы, насколько вероятно их возникновение и какое влияние они могут оказать на бизнес. Состоит из шагов:
1. **Выявление ресурсов и компонентов информационной системы** для построения активов IT-ландшафта и определения **объектов воздействия** - информационных ресурсов и компонентов информационной системы, которые имеют ценность и могут подвергаться рискам;
2. **Соотнесение объектов воздействия с вероятными векторами угроз**;
3. **Оценка вероятности угрозы**;
4. **Анализ влияния угрозы и принятие решения** в виде документа **Architecture Decision Records** (ADR).

## <a id="Риски" href="#Риски">Риски</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Риск** - это сочетание вероятности эксплуатации уязвимости и последствий этого события.

`Величина риска = Вероятность события * Размер ущерба`, где:
- `Вероятность события = Вероятность угрозы * Величина уязвимости`, где:
    - `Вероятность угрозы` - это частота или вероятность, с которой злоумышленник может попытаться совершить атаку;
    - `Величина уязвимости` - это вероятность того, что при попытке эксплуатировать уязвимость атака будет успешной, которая определяет, насколько легко найти и использовать уязвимость.

Основные виды рисков:
- **прямые риски** - это риски, которые приводят к негативным последствиям, прямому ущербу для работы информационных систем и компании;
- **косвенные риски** - это риски, которые приводят к негативным последствиям, но ущерб от них косвенный.

Подходы к анализу рисков:
- **качественный анализ рисков** - предполагает, что компания привлекает экспертов для оценки рисков;
- **количественный анализ рисков** - основывается на статистических данных и математических методах:
    - **количественные показатели рисков** `ALE = SLE * ARO`, где:
        - **Annual Loss Expectancy** (ALE) - ожидаемые годовые потери, то есть "стоимость" всех инцидентов за год;
        - **Single Loss Expectancy** (SLE) - ожидаемые разовые потери, то есть "стоимость" одного инцидента;
        - **Exposure Factor** (EF) - фактор открытости перед угрозой, то есть какой процент активов пострадает при успешной реализации угрозы;
        - **Annualized Rate of Occurrence** (ARO) - среднее количество инцидентов в год в соответствии со статистическими данными.

        > SLE = 100 000 рублей, ARO = три раза в год, ALE = SLE × ARO= 100 000 * 3 = 300 000 рублей в год

    - **методы статистического анализа**:
        - **анализ тенденций** (Trend Analysis) - это метод, позволяющий выявлять изменения в частоте инцидентов, что помогает определить, улучшается или ухудшается ситуация со временем;
        - **регрессионный анализ** - позволяет выявлять зависимости между разными факторами и угрозами;
        - **анализ временных рядов** - это метод, позволяющий выявлять закономерности в исторических данных, что можно использовать для оценки вероятности повторения инцидентов и их периодичности;
        - **байесовский анализ** - это метод, позволяющий обновлять оценки рисков на основе поступающих данных, что особенно полезно в динамически меняющейся среде, где текущие данные об инцидентах могут существенно влиять на пересмотр рисков.

    - **метод Монте-Карло** - это способ оценки рисков с использованием случайных значений для моделирования различных сценариев, что позволяет многократно проводить расчеты, чтобы определить возможные исходы и их вероятности в ситуациях, где много неопределенности.

- **комбинированный анализ рисков** состоит в использовании качественного анализа для первичной идентификации и классификации рисков и количественный анализ для наиболее критичных угроз.

## <a id="Архитектура-информационной-безопасности" href="#Архитектура-информационной-безопасности">Архитектура информационной безопасности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Архитектура информационной безопасности** - это комплекс мер и решений, который определяет стратегию, технологии и процессы для защиты информационных активов организации. В нее входят такие элементы:
- механизмы контроля доступа;
- системы мониторинга и управления угрозами;
- меры по защите данных;
- меры для соблюдения нормативных требований.

Проект архитектура информационной безопасности состоит из шагов:
1. **Анализ и приоритизация угроз**;
2. **Определение пороговых значений рисков** - границ, которые показывают, какой уровень риска компания готова принять без существенного ущерба для своей деятельности;
3. **Формирование списка необходимых мер** (roadmap) - "дорожная карта" развития архитектуры, состоящая из списка согласованных и приоритизированных технических и организационных мер безопасности с шагами состоящими из:
    - сроков реализации:
    - ответственных лиц:
    - необходимых ресурсов:
    - контрольных точек для оценки прогресса;
    - критерев успешного выполнения.
4. **Мониторинг изменений**, который заключается в постоянной адаптации под изменения.

## <a id="Законодательный-уровень-информационной-безопасности" href="#Законодательный-уровень-информационной-безопасности">Законодательный уровень информационной безопасности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Законодательный уровень информационной безопасности** - это совокупность правовых норм, которые определяют, какие данные в информационных системах и как должны быть защищены.

**Основная цель обезличивания данных** - удалить или скрыть идентифицирующую информацию, чтобы конкретный человек не мог быть идентифицирован на основе обрабатываемых данных.

Основные методы обезличивания:
- **шифрование**, которое гарантирует, что данные нельзя прочитать их без соответствующего ключа, и используется, когда необходимо защитить данные при передаче или хранении, особенно в случае если есть риск перехвата или кражи данных;
- **токенизация**, которая подразумевает, что персональные данные меняются на уникальные токены, которые связываются с исходными данными только в защищенной среде, когда необходимо безопасно хранить и обрабатывать персональные данные, не сохраняя их в исходном виде. Подходит для систем, обрабатывающих платежную информацию или идентификаторы клиентов и помогает исключить риск утечки исходных данных;
- **псевдонимизация**, которая подразумевает, что персональные данные меняются псевдонимами, которые могут быть связаны с реальной личностью только через дополнительную информацию. Полезна, когда нужно работать с данными, сохраняя их связь с конкретными личностями, но без прямого указания на них и применяется в анализе данных, исследованиях, где сохранение конфиденциальности личности критично, но при этом обратная идентификация возможна при наличии дополнительных данных;
- **удаление идентифицирующей информации**, что позволяет анализировать поведение пользователей или обрабатывать статистические данные без привязки к конкретным лицам. Используется, когда, например, нужно анализировать поведение пользователей и нет необходимости привязывать полученные данные к конкретным личностям.

## <a id="Обфускация-данных" href="#Обфускация-данных">Обфускация данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Обфускация данных** (obfuscate) - это способ сделать данные труднодоступными для понимания или интерпретации, преобразовав их в другой формат или представление. С целью - скрыть смысл исходных данных, не прибегая к алгоритмам шифрования, требующим ключей для расшифровки. Обфускация часто включает в себя изменение данных обратимым или необратимым способом, в зависимости от предполагаемого использования.

Механизмы обфускации данных:
1. **Токенизация** - метод, при котором чувствительные данные заменяются токенами - уникальными идентификаторами, не несущими смысловой нагрузки. Оригинальные данные хранятся отдельно в защищенном репозитории, а токены используются для операций;
2. **Перемешивание** - когда элементы данных переставляются случайным образом, чтобы в итоге нарушились их исходные взаимосвязи;
3. **Зануление или подмена** - замена чувствительных данных на нулевые значения (например, "0", "null") или стандартные заполнители (например, "XXXX");
4. **Скремблирование символов** - замена символов в данных случайными, с сохранением длины и формата.

## <a id="Маскировка-данных" href="#Маскировка-данных">Маскировка данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Маскировка данных** подразумевает скрытие исходных данных с измененным содержимым (символами или другими данными) при сохранении формата и типа данных. С целью - создать структурно похожую, но не оригинальную версию данных, которая может быть использована для таких целей, как тестирование, обучение или анализ, не раскрывая реальную конфиденциальную информацию.

Механизмы маскировки данных:
1. **Статическая маскировка данных** - это метод, который применяется для необратимой маскировки данных, когда необходимо передать данные в среду разработки, тестирования или анализа без риска раскрытия конфиденциальной информации. Реальные данные заменяются маскированными значениями, а оригинальная база данных остается нетронутой;
2. **Динамическая маскировка данных** - данные маскируются в реальном времени, когда пользователь пытается получить к ним доступ. Исходные данные остаются неизменными, а политика доступа определяет, какие данные пользователь может видеть;
3. **Детерминированное маскирование** - это метод, когда использует одно и то же замаскированное значение для одного и того же исходного значения. Это полезно, если нужно сохранить связь между данными в разных системах или таблицах;
4. **Недетерминированное маскирование** - данные заменяются случайными значениями, не сохраняющими связь с исходными. Этот метод предоставляет максимальную защиту, но нарушает взаимосвязи между данными.

## <a id="Тегирование-данных" href="#Тегирование-данных">Тегирование данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Тегирование данных** - это способ присваивать метки, или теги, данным, чтобы сделать их более понятными, организованными и удобными в управлении. Оно работает как система маркировки, которая помогает понять, что это за данные, откуда они взялись, как с ними работать и кто может их использовать.

## <a id="Классификация-данных" href="#Классификация-данных">Классификация данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Классификация данных** - это процесс систематизации информации и назначения ей соответствующего уровня защиты, что позволяет компаниям управлять рисками и рационально распределять ресурсы на обеспечение безопасности.

**Международный стандарт ISO/IEC 27001** классифицирует данные на следующие категории:
- **публичные данные** - информация, которая не подлежит ограничению и данные могут быть свободно распространены и не представляют угрозы для компании;
- **внутренние данные** - информация для внутреннего использования в организации (например, внутренние инструкции, отчеты или данные о работе внутренних систем);
- **конфиденциальные данные** - информация, которая имеет высокую ценность и ограничена в распространении (например, персональные данные, финансовая информация или коммерческая тайна);
- **секретные данные** - информация, утечка которой может привести к самым серьезным последствиям для организации или нарушению законодательства (например, платежные данные или государственная тайна).

**NIST SP 800-53 и NIST SP 800-60** классифицируют данные в зависимости от того, какие проблемы или риски могут возникнуть, если что-то пойдет не так и выделяют категории:
- **низкое воздействие** - утечка или компрометация данных не приведет к значительным финансовым или репутационным потерям (например, расписание работы);
- **умеренное воздействие** - компрометация данных может вызвать заметные финансовые или репутационные потери (например, личные данные клиентов без конфиденциальной информации);
- **высокое воздействие** - утечка данных может привести к серьезным финансовым потерям, нарушить работу критически важных служб или нанести значительный ущерб репутации (например, информация о кредитных картах).

**152-ФЗ "О персональных данных"** - это федеральный закон устанавливает требования к классификации и обработке персональных данных в России. В рамках него данные делятся на обобщенные категории:
- **общедоступные персональные данные** - данные, предоставленные субъектом для всеобщего доступа;
- **персональные данные** - информация, относящаяся к конкретному человеку, которая требует защиты;
- **специальные категории персональных данных** - данные о расовой, национальной принадлежности, состоянии здоровья и прочие. Их обработка строго регулируется законом.

Основные рекомендации по проектированию систем:
- **сегментирование сети для изоляции важных данных**;
- **шифрование данных для защиты конфиденциальности** на уровне баз данных и файловых систем для всех данных с пометкой "конфиденциальные" или "критически важные";
- **ограничение привилегий для контроля доступа** пользователей только теми правами и доступами, которые необходимы для выполнения их задач и обязанностей;
- **внедрение управлением метаданными для отслеживания данных**, что позволяют отслеживать жизненный цикл данных, фиксировать изменения в их статусе и управлять уровнями доступа;
- **внедрение контроля доступа и видимости данных на основе классификации** на уровне файловых систем и интегрированных средств защиты - Digital Rights Management (DRM), которая помогает управлять правами на использование цифрового контента и защищать их.

**Security Information and Event Management** (SIEM) - система управления событиями безопасности, обеспечивающая сбор, обработку, анализ и корреляцию данных, поступающих с устройств и приложений, - для выявления угроз и реагирования на них в реальном времени и автоматического присваивания новых уровеней классификации данных.

**GRC-системы** (Governance, Risk Management, and Compliance) - инструменты, которые объединяют управление деятельностью компании, рисками и соответствием требованиям, которые важны в автоматизации процессов информационной безопасности, особенно в контексте анализа результатов аудита и управления уязвимостями.

## <a id="Идентификация-и-аутентификация-управление-доступом" href="#Идентификация-и-аутентификация-управление-доступом">Идентификация и аутентификация, управление доступом</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Идентификация" href="#Идентификация">Идентификация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Идентификация** - процесс определения пользователя, в ходе которого система узнает, кто пытается получить доступ к ресурсу, что является первым рубежом обеспечивающим безопасность системы.

На этом этапе система еще не проверяет подлинность пользователя, но может определить какие-либо вспомогательные данные, например IP-адрес, местоположение или тип устройства.

Основные угрозы:
- **подмена идентификатора** (ID Spoofing), которая происходит, когда злоумышленник пытается заменить идентификатор пользователя на другой, чтобы получить доступ к чужим данным или ресурсам;
- **сбор информации** (Information Harvesting) о системе или пользователях для последующих атак (например перечисления пользователей (Username enumeration), сбор публичных идентификаторов, раскрытие структуры URL или API и так далее);
- **атака на перехват идентификационных данных** (Session Hijacking) - сессионных идентификаторов (кук) для взаимодействия с клиентом чтобы использовать для выдачи себя за другого пользователя;
- **подбор идентификатора** (Identifier Guessing) когда система использует легко предсказуемые идентификаторы (например, последовательные целые числа), что позволяет угадать идентификаторы других пользователей или ресурсов;
- **"человек посередине"** (Man-in-the-Middle, MITM) для перехвата идентификационных данных, которые передаются по незащищенному каналу (например публичные Wi-Fi сети).

### <a id="Аутентификация" href="#Аутентификация">Аутентификация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Аутентификация** - это процесс подтверждения личности пользователя или системы перед предоставлением доступа к ресурсу. После идентификации система запрашивает подтверждение с помощью пароля, одноразового кода, биометрии или других факторов.

Только после успешной аутентификации пользователь получает возможность взаимодействовать с системой.

**Факторы аутентификации** - независимый признак, который используется для подтверждения подлинности личности. Делятся на три основные категории:
- **что-то, что вы знаете** (knowledge) - это парольная аутентификация. Она предполагает использование секретного вопроса, пароля или PIN-кода - информации, которой владеет только пользователь. Требует внедрения сложных политик управления паролями для защиты от подбора;
- **что-то, что у вас есть** (possession) - одноразовые пароли (OTP) - генерация уникальных токенов, отправляемых на мобильные устройства, которые упрощают защиту доступа при высоком уровне безопасности. Или аппаратные токены - физические устройства (например, YubiKey) для подтверждения аутентификации;
- **что-то, что вы представляете собой** (inherence) - это биометрическая аутентификация с использованием биометрических данных: отпечатков пальцев, распознавания лица, - для подтверждения личности пользователя.

**Многофакторная аутентификация** (MFA) - описывает использование нескольких факторов аутентификации, независимо от их категории.

#### <a id="SSO" href="#SSO">SSO</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**SSO** (Single Sign-On, служба единого входа) - это система, обеспечивающая единый вход сразу в несколько систем. Пользователю нужно запомнить только один набор учетных данных (логин и пароль), чтобы получить доступ ко всем связанным сервисам.

**Протоколы аутентификации** - это стандарты и наборы правил, которые определяют, как пользователи могут безопасно подтвердить свою личность для получения доступа к информационным системам, сервисам или приложениям, которые обеспечивают передачу учетных данных, защиту от несанкционированного доступа и подделок, гарантируя, что только авторизованные пользователи смогут получить доступ к данным.

##### <a id="SAML" href="#SAML">SAML</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**SAML** (Security Assertion Markup Language, или язык разметки утверждений безопасности) - это XML-документ, который генерируется **Identity Provider** в отношении пользователя, предоставившего свои аутентификационные данные (креды).

Процесс аутентификации:
1. Неизвестный клиент запрашивает доступ к провайдеру ресурса;
2. Если такой запрос не может быть предоставлен клиенту без аутентификации, провайдер перенаправляет клиента на провайдера идентификаций - **Identity Provider**;
3. **Identity Provider** идентифицирует и аутентифицирует пользователя;
4. На основании аутентификационных данных, которые предоставил пользователь, **Identity Provider** генерирует документ - XML-assertion (XML-утверждение) - и отдает его клиенту в формате SAML. В этом документе указываются те утверждения, которые получилось проверить в отношении тех параметров, которые ожидает ресурс (например, ресурсу, чтобы аутентифицировать пользователя, надо получить от сервера аутентификации email и уникальный ID). В SAML указывается значение того, что удалось подтвердить;
5. Клиент берет XML и идет с ним к ресурсу;
6. Ресурс читает XML, проверяет, что ему можно доверять (так как каждый XML подписан), аутентифицирует клиента и выдает свой **access_token**;
7. Клиент сохраняет **access_token** и использует его для работы с этим ресурсом.

##### <a id="OpenID-Connect" href="#OpenID-Connect">OpenID Connect</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**OpenID Connect** (OIDC) - это совместимый протокол аутентификации, основанный на структуре спецификаций OAuth 2.0 (IETF RFC 6749 и 6750), который позволяет пользователям безопасно входить в веб-приложения и мобильные приложения через социальные или другие известные сервисы.

Процесс аутентификации:
1. Клиент обращается к ресурсу;
2. Ресурс понимает, что клиент не прошел аутентификацию, и пересылает его на IdP;
3. Пользователь через клиент предоставляет свои креды;
4. Клиенту возвращают **id_token**, в котором зашифрована информация о пользователе (примерно как в SAML - список утверждений) - это часть аутентификации. Еще часто возвращают access_token, но это уже часть авторизации;
5. Ресурс может сделать REST-запрос в аутентификационный сервис за дополнительной информацией о пользователе с использованием выданного токена либо временного кода;
6. Клиент использует токен для аутентифицированных запросов.

##### <a id="Kerberos" href="#Kerberos">Kerberos</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Kerberos** - это сетевой протокол аутентификации, разработанный для обеспечения безопасной аутентификации пользователей и сервисов в незащищенных сетях (таких как локальная сеть или интернет). Он использует метод "билетной" аутентификации, при котором пользователи получают временные токены (билеты) от сервера аутентификации, которые затем используются для доступа к различным сервисам без повторного ввода паролей.

Процесс аутентификации:
1. Пользователь вводит свои учетные данные (логин и пароль), и Kerberos аутентифицирует его через центральный сервер (Key Distribution Center, KDC);
2. KDC проверяет учетные данные клиента и, если они верны, генерирует два билета:
    - **билет предоставления** (Ticket Granting Ticket, TGT) - билет, который позволяет клиенту в дальнейшем получать доступ к другим сервисам без повторной аутентификации;
    - **сессионный ключ** - секретный ключ, используемый для шифрования сообщений между клиентом и сервером.
3. Когда пользователь хочет получить доступ к какому-либо сервису, он использует TGT для запроса сервисного билета. KDC проверяет TGT и, если он действителен, генерирует новый билет - **сервисный**, который уже позволяет пользователю аутентифицироваться и взаимодействовать с нужным сервисом;
4. Когда срок действия TGT истекает, клиент должен повторно пройти процесс аутентификации, чтобы получить новый TGT.

### <a id="Авторизация" href="#Авторизация">Авторизация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Авторизация** - это процесс определения какие именно действия в системе может совершать пользователь.

Доступы в системе должны быть четко определены и соотноситься с бизнес-процессами, а само распределение этих разрешений соответствовало принципам информационной безопасности.

Доступ может предоставляться на основе роли пользователя - **role-based access control** (RBAC), на основе атрибутов пользователя, объекта и среды - **attribute-based access control** (ABAC) или в зависимости от контекста пользователя - **contextual access**.

Основные принципы:
- **принцип наименьших привилегий** (Least Privilege) предполагает, что пользователи и системы должны иметь доступ только к тем ресурсам и функциям, которые необходимы для выполнения их задач, и не больше;
- **принцип разделения обязанностей** (Separation of Duties) предполагает, что ключевые задачи распределяются между разными сотрудниками, чтобы ни один человек не контролировал весь процесс целиком (например, один человек не должен иметь возможность и инициировать, и утверждать финансовую транзакцию);
- **принцип доверия с осторожностью** (Zero Trust) предполагает, что никто не считается безопасным по умолчанию - все пользователи и устройства постоянно проверяются и подтверждаются;
- **принцип открытой безопасности** (Security in the Open) предполагает, что разработчики должны учитывать потенциальные уязвимости в своем коде, применять безопасные методы кодирования, тестировать ПО и сотрудничать с экспертами по безопасности для обеспечения безопасности конечного продукта.

#### <a id="Модель-RBAC" href="#Модель-RBAC">Модель RBAC</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Role-based access control** (RBAC) - модель разделения доступов к данным на основе ролей.

Состоит из таких сущностей:
- **subject** - субъект, к которому применяется модель;
- **role** - название роли пользователя, для которой определяется уровень доступа;
- **permissions** - действия, которые выполняет пользователь в системе;
- **session** - состояние, в рамках которого действует разрешение.

#### <a id="Модель-ABAC" href="#Модель-ABAC">Модель ABAC</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Attribute-based access control** (ABAC) - модель разделения доступов к данным на основе их атрибутов - объектов, действий, контекста.

Категории атрибутов:
- **атрибуты субъекта**: возраст, роль, департамент, должность;
- **атрибуты действия**: читать, просматривать, удалять, подтверждать.
- **атрибуты объекта** (то, в отношении чего делается запрос): запись в медкнижке, банковский аккаунт, локация.

Состоит из таких сущностей:
- **policy enforcement point** (PEP) - ответственный за защиту приложений и данных, к которым применяется модель, который проверяет запрос и генерирует авторизационный запрос, который отсылается в PDP;
- **policy decision point** (PDP) - "мозг" архитектуры, который проверяет входящий запрос на соответствие утвержденным политикам и возвращает положительный или отрицательный ответ для допуска. И если нужны дополнительные данные, то PDP может обращаться к PIP;
- **policy information point** (PIP) - источник информации для политики. Соединяет PDP с информацией из внешних источников (например, с базой данных);
- **policy administration point** (PAP) - точка управления политиками.

#### <a id="LDAP" href="#LDAP">LDAP</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**LDAP** - это один из стандартов, с помощью которого можно реализовывать модель доступа.

Оосновные понятия:
- **корневой элемент** (Root) - это наивысший уровень иерархии, который представляет всю директорию;
- **DC** (Domain Component) - это компоненты домена, которые указывают на доменные имена (например, `dc=example` и `dc=com`);
- **OU** (Organizational Unit) - это организационные единицы, которые используют для группировки объектов внутри домена (например, `ou=sale, dc=example, dc=com` может представлять отдел продаж в домене example.com) и могут быть вложенными друг в друга;
- **CN** (Common Name) - это общие имена, которые используют для идентификации объектов в каталоге, за которыми скрываются пользователи или ресурсы (например, в записи `cn=John Doe, ou=marketing, dc=example, dc=com` общее имя - это `cn=John Doe`);
- **DN** (Distinguished Name) - это полный путь к объекту (например, `cn=John Smith,ou=Developers,ou=IT,dc=example,dc=com`). Порядок компонентов в полном пути имеет значение и должен быть всегда уникален в рамках дерева - такой полный путь один на всю директорию;
- **RDN** (Relative Distinguished Name) - это относительное имя объекта, которое является частью **DN** (полного пути к объекту) и уникален только в рамках родительского элемента;
- **атрибуты** (Attributes) - это характеристики объекта (например, имя, email, телефон) и регистр для атрибутов не имеет значения;
- **объектные классы** - это шаблоны с набором атрибутов, которые определяют, какие атрибуты может или должен иметь объект.

#### <a id="OAuth" href="#OAuth">OAuth</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**OAuth** - открытый протокол авторизации, используемый для возможности сторонним приложениям получать ограниченный доступ к ресурсным серверам от имени пользователя или от имени этого стороннего приложения.

Участники:
- **клиент** - это могут быть веб-приложения на серверах; приложения, исполняемые в user-agent (например PWA); нативные приложения, когда клиент работает на девайсе пользователя (телефоне или десктопе);
- **владелец ресурса** - конечный пользователь, который владеет данными на ресурсе;
- **авторизационный сервер** - сервер, который предоставляет механизм авторизации;
- **сервер ресурсов** - это тот ресурс, с которым клиент хочет взаимодействовать.

Шаги авторизации:
1. **Клиент** (стороннее приложение) делает запрос авторизации к **владельцу ресурса** (пользователю). Это может происходить напрямую или через **авторизационный сервер**, что является более предпочтительным;
2. Пользователь позволяет авторизацию, предоставляя креды. Это делается тем из способов, который используется на клиенте и поддерживается сервером (например, Authorization Code Grant, Implicit, PKCE);
3. **Клиент** запрашивает токен у **авторизационного сервера**, аутентифицируясь у авторизационного сервера и предоставляя разрешение авторизации от пользователя. Другими словами, через **клиент** передаются креды в **авторизационный сервер**, который может выступать одновременно и аутентификационным сервером, передавая креды от клиента (например, пользователь вводит креды в почту (авторизационный сервер), вводя их через браузер (клиент));
4. **Авторизационный сервер** аутентифицирует клиента, валидирует разрешение пользователя и, если все хорошо, выпускает **access_token**. В практической реализации авторизационный сервер выпускает JSON Web Token (JWT) - токен, который может содержать в себе и *id_token*, и *access_token*, и *refresh_token*, и другую дополнительную информацию;
5. **Клиент** идет к **серверу ресурсов** и запрашивает защищенные ресурсы, предоставляя **access_token**, аутентифицируя себя через токен;
6. Сервер валидирует токен и решает, можно ли авторизовать запрашиваемого на предоставление ресурсов. Как правило, ресурсный сервер анализирует роли пользователя и, если их достаточно для получения запрашиваемой информации, - предоставляет эти ресурсы.

**Scope** (область действия) - это механизм для ограничения доступа приложения к данным пользователя. Значение параметра позволяет определять, к каким ресурсам и действиям приложение может получить доступ от имени пользователя.

**Local state** (state-параметр) - это параметр безопасности, который помогает предотвратить CSRF (Cross-Site Request Forgery) атаки и обеспечивает соответствие между запросом и ответом.

**Refresh token** - это токен, который используется для получения нового **access token** после истечения его срока действия, не требуя повторной аутентификации пользователя.

**JWT** (JSON Web Token) - это стандарт предоставления информации в компактном виде, подтверждаемый подписью, который кодирует JSON-файл. Состоит из трех частей, разделенных точкой:
- **заголовок** (header) - эта часть содержит информацию о типе токена и алгоритме, который использовался для его подписи;
- **полезная нагрузка** (payload) - содержит утверждения о пользователе (например, идентификатор, роли и т. д.);
- **подпись** (signature) - используется для проверки подлинности токена и целостности данных. JWS (JSON Web Signature) содержит информацию о том, как токен был подписан, включая алгоритм подписи и саму подпись. Подпись позволяет удостовериться, что данные не были изменены в процессе передачи.

JWT также может содержать дату выпуска, обозначаемую полем **iat**, а также дату истечения срока действия, обозначаемую полем **exp**, после истечения срока действия токен становится невалидным.

**Зашифрованная JWE** (JSON Web Encryption) - дополнение, которое может быть использовано для защиты содержимого JWT, что обеспечивает конфиденциальность, шифруя данные токена, означающее, что даже если кто-то получит доступ к токену, он не сможет прочитать его содержимое без соответствующего ключа для расшифровки.

##### <a id="Authorization-Code-Grant" href="#Authorization-Code-Grant">Authorization Code Grant</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Authorization Code Grant** (Code Grant) - это один из флоу аутентификации в OAuth 2.0, предназначенный для приложений, у которых есть серверная часть (клиенты с возможностью безопасного хранения секретов).

Участники:
- **клиент** - это приложение, которое запрашивает доступ к защищенным ресурсам от имени пользователя. Клиент может быть нативным приложением (например, мобильным) или веб-приложением (например, одностраничное приложение, SPA). Сам по себе клиент не имеет доступа к ресурсам, пока не получит разрешение от пользователя через сервер авторизации;
- **user-agent** - это программное обеспечение, которое взаимодействует с пользователем и клиентом. Обычно это браузер либо другое приложение, которое играет роль посредника, через который пользователь взаимодействует с сервером авторизации и клиентом;
- **владелец ресурса** - конечный пользователь, владеющий ресурсами, доступ к которым запрашивает клиент;
- **сервер авторизации**.

Процесс авторизации:
1. **Клиент** инициализирует флоу, направляя **владельца ресурса** на **сервер авторизации**. Он передает свой идентификатор (`client_id`), указывает скоупы (`scopes`), локальное состояние (`state`) для защиты от CSRF-атак и redirect URI, на который сервер должен вернуть пользователя после авторизации;
2. **Авторизационный сервер** аутентифицирует владельца ресурса через **user-agent** и запрашивает разрешение у владельца ресурса на доступ для клиента;
3. Если пользователь успешно аутентифицирован и дал разрешение **клиенту**, **сервер авторизации** редиректит **user-agent** пользователя на redirect URI, который указал клиент. В этот URI добавляется **авторизационный код** и переданный ранее локальный `state` для проверки целостности данных (синхронизации сессии);
4. **Авторизационный код** передается клиенту. Время жизни этого кода настраивается в авторизационном сервере, которое должно быть достаточно, чтобы клиент мог отправить его на сервер для обмена на **токен**, но ограниченно - для предотвращения злоупотреблений;
5. **Клиент** отсылает **код** на **авторизационный сервер** и получает взамен **токен** (как правило, JWT);
6. **Клиент** анализирует **токен**, забирает необходимую информацию, в том числе `access_token`, и сохраняет его для последующего использования;
7. **Клиент** запрашивает данные у **ресурсного сервера**, включая в запрос `access_token`;
8. **Ресурсный сервер** получает запрос, читает `access_token`, валидирует его. Если токен валидный и информация в токене позволяет осуществить действие - осуществляет запрашиваемое действие;

Чтобы клиенты работали, их надо сначала зарегистрировать в авторизационном сервере и настроить следующую информацию:
- **client_id** - идентификатор клиента, который использует способ авторизации;
- **client_secret** - эта информация генерируется авторизационным сервисом при настройке, и ее надо безопасно предоставить клиенту и сохранить для использования;
- **redirection endpoint URI** - то, куда авторизационный пользователь будет переводить **user-agent** после успешной аутентификации. К этому же адресу добавляется **авторизационный код**. Это надо указывать, чтобы авторизационный сервер сверял **redirect_URL**, указанный в **user-agent**, с тем, который указан для этого сервиса, чтобы избежать подстановки **redirect_URL**.

##### <a id="Implicit-Grant" href="#Implicit-Grant">Implicit Grant</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Implicit Grant** (Implicit Flow) - один из флоу аутентификации в OAuth 2.0, предназначенный для клиентских приложений, таких как одностраничные приложения (SPA) или мобильные приложения, которые не могут безопасно хранить конфиденциальные данные.

Это упрощенный Code Grant Flow, оптимизированный для работы с клиентом. В нем авторизационный сервер выпускает не код, а токен и предоставляет его напрямую клиенту.

Процесс авторизации:
1. **User-agent** (браузер) инциирует работу, заходя в **авторизационный сервис** c добавлением **redirect URL**;
2. Пользователь аутентифицируется на этом сервере;
3. **Авторизационный сервер** возвращает **redirect URL** с добавлением во фрагмент URI информации, содержащей **access token**;
4. **User-agent** заходит на ресурс, указанный в redirect URL, но без **access token**;
5. **User-agent** скачивает скрипт работы локально;
6. **User-agent** выполняет скрипт для экстракции информации из фрагмента URI и получения из него **access token**;
7. **User-agent** передает токен клиенту для последующего использования.

##### <a id="PKCE" href="#PKCE">PKCE</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**PKCE** (Proof Key for Code Exchange) - это метод безопасности, используемый в процессах авторизации OAuth 2.0 для предотвращения атаки подмены кода на клиентских приложениях.

Протокол добавляет требование клиенту доказать, что он - это он. Для этого используется `code_verifier`, который, по сути, - еще один код. Авторизационный сервер знает, какой функцией будет хешироваться код (она даже может предоставляться при авторизационном реквесте).

Процесс авторизации:
1. Когда **клиент** идет на **авторизационный сервер**, он предоставляет еще хеш от `code_verifier`. **Авторизационный сервер** запоминает этот хеш;
2. **Клиент** получает **код** от **авторизационного сервера**;
3. **Клиент** отсылает **авторизационный код** + *`code_verifier`;
4. **Авторизационный сервер** хеширует `code_verifier`, сравнивает результат с тем, что отослалось на первом шаге;
5. Если верификация прошла, сервер отсылает **access_token**.

### <a id="Identity-and-Access-Management" href="#Identity-and-Access-Management">Identity and Access Management</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Identity and Access Management** (IAM) - это комплекс технологий, процессов и политик для управления идентификацией пользователей и их доступом в систему.

Основные решаемые задачи:
- **работа с учетными записями** - создание, удаление пользовательских и сервисных учетных записей, управление ими;
- **управление доступом пользователей и сервисов** - настройка ролей, их доступов и пользователей, аутентификации, авторизации пользователей, работа со cлужбой единого входа - SSO;
- **федеративное управление идентификацией** (Federation Identity) - использование IAM с другими системами идентификации пользователей;
- **аудит и мониторинг** - выявление подозрительной активности и узких мест в работе системы.

## <a id="Протоколирование-аудит" href="#Протоколирование-аудит">Протоколирование, аудит</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Аудируемость** - это способность системы или процесса подвергаться аудиту означающее, что система спроектирована так, чтобы фиксировать все необходимые данные и события, что позволяет потом провести анализ и оценку ее состояния.

**Аудит** - это процесс анализа и проверки данных и событий в системе для определения их соответствия требованиям безопасности, стандартам и политике организации.

**Логирование** - это процесс записи информации о событиях и действиях, происходящих в системе. Логи служат основой для аудируемости, поскольку фиксируют все значимые действия, которые могут быть впоследствии проанализированы в ходе аудита.

Цель аудита - обеспечить прозрачность и контроль над действиями внутри информационной системы.

Основные принципы аудита:
- **полнота данных** - логирование должно фиксировать все значимые действия, включая операции аутентификации, авторизации, доступ к данным и изменения конфигурации без избыточного протоколирование данных, которое может перегрузить систему и усложнить анализ данных;
- **сегментация данных** - разделение событий по категориям (например, аутентификация, доступ к данным, административные действия), что улучшает читаемость логов и повышает эффективность последующего анализа;
- **централизация и анализ** - обеспечение механизма передачи данных в централизованное хранилище для их анализа, которые позволяют эффективно анализировать информацию, помогая выявлять потенциальные угрозы в режиме реального времени;
- **безопасность** - защита данных аудита, которые могут содержать чувствительную информацию;
- **масштабируемость** - для учета будущего роста системы;
- **автоматизация анализа** - через интеграцию в подсистему автоматизированные инструментов анализа и корреляции данных и добавление оповещение об инцидентах в реальном времени (алертинг).

Процессы, подлежащие аудиту, зависят от специфики системы, с базовыми категорями процессов, которые необходимо учитывать:
- **аутентификация и управление доступом**:
    - попытки входа;
- **доступ к данным и ресурсам**:
    - операции с данными;
    - доступ к конфиденциальным ресурсам;
- **административные действия**:
    - изменение учетных записей;
    - управление привилегиями;
- **события безопасности и инциденты**:
    - попытки сканирования уязвимостей;
    - обнаружение вредоносной активности;
- **бизнес-транзакции и операции**:
    - финансовые операции;
    - изменение данных клиентов.

Записи в логах должны быть:
- **структурированы** с единым форматом и всегда содержать ключевые поля:
    - **метка времени** (timestamp) - время, когда событие произошло;
    - **идентификатор события** (event_id) - уникальный идентификатор (UUID), чтобы легко ссылаться на конкретные события и отслеживать их корреляцию;
    - **тип события** (event_type) - для анализа и фильтрацию логов;
    - **идентификатор пользователя** (user_id) - уникальный идентификатор пользователя, который инициировал это событие;
    - **результат** (result) - результат выполнения действия (успех, ошибка, отклонение);
    - **детализация лог-сообщения** (details) - дополнительные сведения о событии: IP-адрес, местоположение, устройство, использованные привилегии;
- **информативные** для каждого типа события должны содержать дополнительные поля с достаточным уровнем детализации;
- **классифицируемые** по категориям;
- **автоматизируемые для анализа**;
- **иметь политику хранения и ротации**;
- **документируемы**.

## <a id="Целостность-данных" href="#Целостность-данных">Целостность данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Целостность данных** - это фундаментальный аспект безопасности и надежности информационных систем. Отсутствие контроля целостности может привести к утрате или искажению данных, что ставит под угрозу как бизнес-процессы, так и безопасность пользователей.

Основные угрозы:
- **атаки на целостность** посредством атаки типа "человек посередине" (Man-in-the-Middle), которые позволяют украсть или изменить передаваемые данные получив нелегитимный доступ к каналу связи между двумя сторонами общения;
- **инсайдерские угрозы** которые исходят от инсайдеров - сотрудников компании, ее партнеров или подрядчиков, у которых есть доступ к объектам IT-инфраструктуры организации и критическим данным.

**Принцип нулевой потери** данных предполагает, что данные ни при каких обстоятельствах не должны теряться или повреждаться.

**Метаданные** - это один из механизмов, который помогает реализовать принцип нулевой потери данных, с помощью которых можно гарантировать, что даже при сбоях или ошибках можно определить, что данные были изменены или потеряны, а при необходимости - восстановить их из резервных копий или пересчитать. Могут содержать:
- **контрольные суммы** (хеш-суммы, хеш), которые позволяют определить, были ли данные изменены;
- **версионные метаданные** (например, метка времени последнего изменения), чтобы определить, какая версия данных актуальна в текущий момент.

Метаданные можно хранить вместе с основными данными или отдельно. В реляционных базах данных их можно хранить в отдельных столбцах таблиц. А в распределенных системах - в журналах транзакций.

Лучшие практики для обеспечения целостности данных:
- **контроль версий данных** через версии данных или контрольные суммы, чтобы обнаружить несогласованность данных между различными компонентами системы, что поможет определить, какие версии данных являются последними и корректными;
- **регулярные аудиты целостности** для проверки соответствия текущих данных ожидаемым, используя механизмы автоматизированного мониторинга, которые отслеживают состояние данных и отправляют алерты в случае обнаружения нарушений;
- **end-to-end шифрование** при передаче, так и при хранении с использованием современных стандартов шифрования, что предотвратит несанкционированный доступ и подделку данных во время их перемещения между сервисами;
- **логирование и мониторинг**, что позволяет быстро выявлять и проанализировать возможные нарушения целостности и при необходимости восстановить исходное состояние;
- **тестирование на отказоустойчивость** (например, с помощью Chaos Engineering), чтобы проверить, как система справляется с различными видами сбоев и сохраняет целостность данных;
- **проверка на идемпотентность**, чтобы при обнаружении неидемпотентных операций был механизм контроля, для того чтобы исключить их негативное влияние на целостность данных.

## <a id="Средства-защиты-доступа-к-данным" href="#Средства-защиты-доступа-к-данным">Средства защиты доступа к данным</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Гомоморфное шифрование** - это передовой метод, позволяющий выполнять вычисления над зашифрованными данными без их предварительной расшифровки, что полезно в ситуациях, когда необходимо передать данные стороннему сервису для обработки, но не хочется раскрывать саму информацию.

**Токенизация** - это процесс замены важных данных (например, номеров кредитных карт, идентификационных номеров) на случайные значения или токены. Токены могут храниться в хранилище, но при этом сопоставление оригинальных данных и токенов осуществляется отдельно.

**Дифференциальная приватность** - это метод обработки данных, который позволяет собирать и анализировать агрегированные данные и при этом обеспечивает защиту конфиденциальной информации отдельных пользователей. Заключается в добавлении "шума" к данным, чтобы статистические выводы нельзя было использовать для идентификации отдельных лиц, что затрудняет определение конкретных действий конкретного лица, но сохраняет при этом общую статистику.

**Обнаружение и предотвращение утечек данных** (DLP) - это набор инструментов и методик, которые используются для обнаружения, контроля и предотвращения несанкционированного доступа, утечки или передачи конфиденциальной информации за пределы защищенной среды, что помогает организациям защищать данные при хранении, передаче или обработке.

## <a id="Конфиденциальность" href="#Конфиденциальность">Конфиденциальность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Privacy-by-Design" href="#Privacy-by-Design">Privacy by Design</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Privacy by Design** (PbD) - это подход, который выступает за включение мер по соблюдению требований конфиденциальности и защиты данных в разработку технологий, систем и методов ведения бизнеса с самого начала.

Основные принципы:
1. **Проактивный, а не реактивный; превентивный, а не только устранение последствий** (Proactive not Reactive; Preventative not Remedial) - заключается в:
    - **оценке рисков** - выявление и оценка потенциальных рисков конфиденциальности на этапе планирования;
    - **оценке воздействия на частную жизнь** (Privacy Impact Assessment (PIA)) - систематическое изучение того, как обрабатываются персональные данные, для обеспечения соответствия и выявления рисков;
    - **постоянном мониторинге** - регулярный пересмотр и обновление мер по защите конфиденциальности для адаптации к новым угрозам и изменениям в среде обработки данных;
    - **моделировании угроз** - выявление потенциальных уязвимостей и планирование мер противодействия;
    - **разработка политик и процедур конфиденциальности с самого начала**.

2. **Конфиденциальность по умолчанию** (Privacy as the Default Setting) - заключается в:
    - **минимизации данных** - так как собирать нужно только те данные, которые необходимы для достижения поставленной цели;
    - **настройках по умолчанию** - так как системы должны быть настроены таким образом, чтобы по умолчанию были включены наиболее благоприятные для конфиденциальности опции;
    - **механизмах оптинга** - необходимо требовать явное согласие пользователя перед сбором или обработкой персональных данных.

3. **Конфиденциальность, заложенная в дизайн** (Privacy Embedded into Design) - заключается в:
    - **интегрированных мерах безопасности** - включение методов шифрования, анонимизации и псевдонимизации в процессах обработки данных;
    - **паттернах проектирования** - использование архитектурных паттернов, поддерживающих конфиденциальность (например, безопасных потоков данных и модульной архитектуры);
    - **управлении жизненным циклом** - учет влияния конфиденциальности на всех этапах жизненного цикла системы, от разработки до вывода из эксплуатации.

4. **Полная функциональность без компромиссов** (Full Functionality – Positive-Sum, not Zero-Sum) - заключается в:
    - **сбалансированных решениях** - разработка систем, которые не вынуждают искать компромисс между конфиденциальностью и другими функциональными возможностями;
    - **инновационных технологиях** - использование технологий, которые повышают уровень конфиденциальности без ущерба для удобства пользователей;
    - **сотрудничестве с заинтересованными сторонами** - работа со всеми заинтересованными сторонами, чтобы понять их потребности и найти взаимовыгодные решения.

5. **Комплексная безопасность** (End-to-End Security – Full Lifecycle Protection) - заключается в:
    - **безопасном хранении** - использование шифрования и контроля доступа для данных, хранящихся на серверах и в базах данных;
    - **безопасной передачи** - внедрение безопасных протоколов связи (например, TLS/SSL) для данных, находящихся в пути;
    - **утилизации данных** - разработка процедур безопасного удаления или анонимизации данных, которые больше не нужны.

6. **Наглядность и прозрачность** (Visibility and Transparency) - заключается в:
    - **публикации четких и доступных политик конфиденциальности**;
    - **контроле пользователями** - предоставления пользователям доступа к их данным и возможности управлять настройками конфиденциальности;
    - **проверяемости** - внедренных процессов протоколирования и мониторинга для проведения аудита практики обработки данных.

7. **Уважение к конфиденциальности пользователей** (Respect for User Privacy) - заключается в:
    - **механизмах согласия** - получение информированного согласия пользователей перед сбором или обработкой их данных;
    - **удобном для пользователя дизайне** - разработка интерфейсов, облегчающих пользователям понимание и управление настройками конфиденциальности;
    - **отзывчивой поддержке** - каналы для пользователей, по которым они могут задавать вопросы или высказывать опасения по поводу своей конфиденциальности.

Основные шаги по проектированию:
1. **Инвентаризация данных** - когда проводят всестороннюю инвентаризацию данных: идентифицируют и каталогизируют все типы персональных данных, обрабатываемых в организации и составляют карту потоков данных, на которой визуализированы следующие процессы:
    - **внутреннее движение данных** - помогает понять, как данные перемещаются внутри организации;
    - **внешние потоки данных** - определяют данные, передаваемые внешним партнерам или службам;
    - **этапы жизненного цикла данных** - которые важны для понимания того, как данные собираются, используются, хранятся и утилизируются.
2. **Анализ IT-области в соответствии с принципами конфиденциальности данных** - когда анализируют, кто и почему имеет доступ к персональным данным и проводят анализ шифрования, аутентификации, способов получения и регистрации согласия пользователя;
3. **Определение четких целей конфиденциальности и реализация Privacy by Design** - когда на базе законов разрабатывается организационная политика, которая описывает процессы защиты данных, включает принципы минимизации и анонимизации данных, управления рисками и мониторинга:
    - сбор только тех данных, которые строго необходимы;
    - защита личности при обработке данных;
    - настройка систем по умолчанию на самые высокие параметры конфиденциальности;
    - использование надежного шифрования для данных в состоянии покоя и при передаче;
    - внедрение управления доступом на основе ролей и принципов наименьших привилегий;
    - ведение журналов доступа к данным и их изменения для обеспечения подотчетности.

### <a id="Data-Flow-Management" href="#Data-Flow-Management">Data Flow Management</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Data Flow Management** (DFM) - это процесс управления потоками данных, который включает в себя процессы и технологии для сбора, обработки, хранения и передачи данных. Решает задачи:
- **по обеспечиванию конфиденциальности и безопасность данных**, что помогает защищать конфиденциальные данные и выполнять требования законодательства;
- **по оптимизации процессов обработки данных**, что повышает производительность системы и сокращает избыточность, что обеспечивает точность и согласованность данных в разных системах;
- **по повышению прозрачности и подотчетности**, так как обеспечивает прозрачный журнал аудита движения данных, что способствует подотчетности.

#### <a id="Data-Flow-Diagram" href="#Data-Flow-Diagram">Data Flow Diagram</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Диаграммы потоков данных** представляют данные в виде графической схемы и наглядно показывают, как они перемещаются внутри систем и между ними. Состоят из:
- **источников данных** - это исходные точки, в которых собираются данные (например, формы ввода данных пользователем, датчики). Их представляют в виде начальных узлов на диаграмме;
- **процессов** - это действия, которые выполняют с данными (например, хранение, преобразование, анализ). Процессы изображают в виде узлов или блоков обработки;
- **хранилищ данных** - это места, где хранятся данные (например, базы данных или облачные хранилища). Изображаются в виде символов хранилищ (например, цилиндров или репозиториев);
- **потоков данных** - это движение данных между источниками, процессами и хранилищами. Потоки данных изображают в виде стрелок, которые указывают направления движения данных;
- **внешних субъектов** - это системы или организации за пределами основной системы, которые взаимодействуют с данными (например, к ним относятся сторонние службы и регулирующие органы). Внешние субъекты представляют в виде отдельных узлов, которые соединяются потоками данных.

### <a id="Data-Lineage-и-Data-Minimization" href="#Data-Lineage-и-Data-Minimization">Data Lineage и Data Minimization</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Data Lineage** ("линия данных") - это путь перемещения данных от места их происхождения до конечного пункта назначения. Так же называют и сам процесс отслеживания, документирования и визуализации этого пути.

Алгоритм внедрения состоит из шагов:
1. **Определение масштаба и планирование**, который заключается в определение доменов данных, систем или процессов;
2. **Выявление и инвентаризация данных**, который заключается в составлении **каталога всех активов данных** - источники данных, их типы, форматы и взаимосвязи между наборами данных;
3. **Составление карты потоков данных**, который заключается в разработке **схемы движения данных в компании**, которая должна отвечать на вопросы:
    - как данные попадают в систему?
    - каким преобразованиям или обработке они подвергаются?
    - какие системы или приложения получают доступ к данным или изменяют их?
    - где хранятся данные на каждом этапе?
    - как данные выходят из системы или достигают конечного состояния?
4. **Документирование преобразований данных**, который заключается по включению в документацию:
    - логики или алгоритмов, которые применяются в ходе преобразований;
    - последовательности преобразований;
    - обоснования каждого преобразования;
    - персонала или систем, которые отвечают за преобразования.
5. **Управление метаданными**, который заключается в фиксации метаданных:
    - определения метаданных и схемы данных;
    - происхождение данных и их историю;
    - политики использования данных и права доступа;
    - метрики качества и правила проверки.
6. **Выбор и применение инструментов**;
7. **Обеспечение соответствия нормативным требованиям**, который заключается в:
    - **правах субъектов данных** - предоставление пользователю доступ к его персональным данным, исправление их или удаление;
    - **управление согласием** на использование данных пользователя;
    - **локализация данных**;
    - **аудиторский журнал** - подробные записи о действиях по доступу к данным и их обработке, чтобы при проведении аудита продемонстрировать соответствие требованиям, нужно вести.
8. **Создание системы управления и политики**, который заключается в:
    - **ролях и обязанностях** - назначение тех, кто будет отвечать за поддержание информации о линии данных, обновление метаданных и обеспечение качества данных;
    - **стандартах и руководствах** - установка стандартов для документации данных, соглашений об именовании и процедур обработки данных;
    - **управлении изменениями** - внедрение процессов, которые позволят поддерживать актуальность Data Lineage по мере развития систем и процессов;
    - **обучении и повышении осведомленности** - объяснение сотрудникам, зачем используется Data Lineage и почему это важно и как они могут помочь поддерживать точность записей.
9. **Постоянное улучшение и мониторинг**, который заключается в:
    - **оценке качества данных** - выявление и устранение проблемы с качеством данных, которые могут повлиять на точность информации о линии;
    - **обновление карты родословной** - отражение изменений в потоках данных, системах или бизнес-процессах;
    - **оценке эффективности инструментов** - чтобы можно было обеспечить соответствие инструментов Data Lineage потребностям компании и адаптироваться к технологическому прогрессу;
    - **измерение пользы** - отслеживание ключевых показателей эффективности (KPI), чтобы оценить, насколько успешно Data Lineage помогает достигать целей - обеспечивать соответствие нормативным требованиям и управлять рисками.

**Data Minimization** ("минимизация данных") - это принцип работы с данными, который предполагает, что компания собирает, обрабатывает и хранит только те данные, которые абсолютно необходимы для достижения ее конкретных целей.

### <a id="Слои-данных" href="#Слои-данных">Слои данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Слои данных** описывают этапы, которые информация проходит внутри организации, включают **сырые данные**, **обработанные размеченные наборы** и так называемый **золотой источник** - проверенное состояние.

**Сырые данные** - это данные в их исходном виде, собранные из различных источников без какой-либо обработки или манипуляций, которые неструктурированы, не отфильтрованы и часто содержат неточности, избыточную или неактуальную информацию.

**Обработанные данные** - это исходные данные, прошедшие очистку, преобразование и организацию, чтобы сделать их пригодными для анализа. Тегирование включает в себя маркировку данных метаданными для обеспечения контекста, облегчения поиска и улучшения управления данными.

**Золотой источник** (golden source) - это главный и самый надежный набор данных, который используется всеми в организации. Его основная задача - стать единым ориентиром, которому могут доверять сотрудники, системы и процессы. Он помогает избежать путаницы и гарантирует, что вся организация работает с актуальной и согласованной информацией.

#### <a id="Состояние-данных" href="#Состояние-данных">Состояние данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Данные в состоянии покоя** - это данные, хранящиеся на физических носителях или в цифровых системах хранения. К ним относятся данные на жестких дисках, в базах данных, файловых системах, облачных хранилищах, резервных копиях и портативных устройствах, таких как USB-накопители.

**Данные в процессе передачи** (транзитные данные) - это данные, которые передаются по сетям. К ним относятся данные, передаваемые через интернет, частные сети, беспроводные коммуникации, а также между устройствами или системами.

**Данные в процессе использования** - это данные, которые активно обрабатываются приложениями или системами. К ним относятся данные, загруженные в системную память (RAM), редактируемые, просматриваемые или подвергаемые другим манипуляциям.

### <a id="Коллективные-знания" href="#Коллективные-знания">Коллективные знания</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Коллективные знания** - это информация, опыт и знания сотрудников, которые официально не документируются и не хранятся в структурированных базах данных. Они включают неписаные процедуры, неформальные рабочие процессы, методы решения проблем и культурные традиции, которые влияют на выполнение задач.

Способы сбора знаний:
- **опросы и анкеты** - сбор информации от широкой аудитории - о ее опыте, практике и восприятии. Позволяет выявить общие темы и практики множества людей.

    Нужно разработать вопросы и получить подробные ответы на них. При необходимости обеспечивается анонимность респондентов, что способствует честности ответов;

- **интервью и фокус-группы** - изучение индивидуальных или групповых мнений по конкретным темам. Полезно, когда нужны богатые качественные данные и знания о нюансах практики.

    Проводятся углубленные дискуссии один на один или групповые занятия. Используются открытые вопросы, на которые нельзя ответить "да" или "нет", которые стимулируют подробный рассказ;

- **воркшопы и мозговые штурмы** - объединение заинтересованных сторон для совместного выявления и документирования коллективных знаний, что позволяет повысить кросс-функциональное взаимопонимание и сформировать культуру обмена знаниями.

    Проводятся сессии для составления схемы рабочих процессов и методов работы с данными. Поощряется участие представителей различных отделов и уровней;

- **наблюдение и слежка** - выявление негласных правил работы и расхождений между документированными процедурами и реальной практикой.

    Во время наблюдения за сотрудниками в рабочей среде фиксируются неформальные процессы и взаимодействия с данными.

- **системы управления знаниями** - создание централизованного хранилища и поддержка непрерывного обмена.

    Внедряются инструменты или программное обеспечение для совместной работы (например вики, Confluence). Поощряется стремление сотрудников делиться соображениями, советами и опытом;

- **анализ потоков данных и оргструктуры** - выявление потоков данных, обходящих официальные системы компании, что помогает минимизировать риски конфиденциальности.

    Проводится анализ диаграммы DFD и оргструктуры компании. Определяется, какие потоки данных могут идти в обход систем компании. Выдвигаются и проверяются гипотезы.

<a id="Работа-с-большими-данными" href="#Работа-с-большими-данными">Работа с большими данными</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========================

Исходя из типа нагрузки на систему, выделяют два типа архитектур:
- **OLTP** (Online Transaction Processing) - используют для приложений или сервисов, которые ориентированы на транзакции в режиме реального времени, что значит, что им важно гарантировать транзакционную целостность операций по изменению данных в БД;
- **OLAP** (Online Analytical Processing) - предназначена для выполнения сложных аналитических запросов, которые включают агрегирование данных из нескольких источников и выполнение углубленного анализа данных и бизнес-аналитики.

Характеристики баз данных, реализованных на OLTP-архитектуре:
- **быстрая обработка запросов** - что гарантирует, что транзакции выполняются сразу после их получения, практически без задержек, которые как правило, короткие и простые, включающие в себя вставку, обновление и удаление данных, а также простые запросы и базовые задачи поиска данных;
- **параллелизм** - для транзакций, чтобы они выполнялись независимо от других и в правильном порядке;
- **свойства ACID** (Atomicity, Consistency, Isolation, Durability):
    - **атомарность** - транзакции обрабатываются как единая, неделимая единица работы и если какая-либо часть транзакции завершается сбоем, выполняется откат всей транзакции и база данных остается в исходном состоянии;
    - **согласованность** - каждая транзакция изменяет таблицы предопределенными и предсказуемыми способами, и база данных всегда будет находиться в допустимом состоянии, несмотря на сбои или ошибки;
    - **изоляция** - транзакции изолированы друг от друга, что гарантирует, что изменения, внесенные одной транзакцией, не будут влиять на изменения, внесенные другими;
    - **надежность** - когда транзакция успешно выполняется, то изменения в данных являются постоянными и сохраняются при любых последующих сбоях или ошибках;
- **свойства BASE** (Basically Available, Soft state, Eventually consistent):
    - **базовая доступность** — с основным фокусом на максимальной доступности базы данных для всех пользователей в любое время не ожидая завершения параллельных транзакций, прежде чем внести свои изменения;
    - **мягкое состояние** - означающее что данные могут находиться в промежуточных или временных состояниях перед тем, как попасть в базу данных, и возможно их неоднократное изменение в соответствии с бизнес-логикой перед финальным сохранением в базе данных учитывая многопользовательский режим работы с данными. Финальное значение для такой записи будет в конечном итоге определено при завершении всех транзакций;
    - **согласованность в конечном счете** - означающая, что запись в базе данных достигнет согласованности (consistancy в ACID) не сразу, а после завершения всех одновременных обновлений и тогда все сервисы, работающие с этой записью, увидят одно и то же значение.

В OLAP есть два основных варианта архитектуры внутреннего хранения данных:
- **колоночное хранение** - данные хранятся в колонках, колонки записаны на диск непрерывно;
- **строчное хранение** - данные хранятся в строке, строка записывается на диск целиком и непрерывно.

## <a id="Хранилище-данных" href="#Хранилище-данных">Хранилище данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Хранилище данных** - специальный тип систем, предназначенный для централизованного хранения, объединения данных и предоставления их пользователям.

Архитектура состоит из таких блоков:
- **блок поставки данных** - как пакетных, так и потоков данных;
- **блок физического хранения данных** - инфраструктура, в которой хранятся данные;
- **блок архитектуры данных** - методики и инструменты, определяющие структуру и архитектуру хранения данных в хранилище;
- **блок представления данных** - то, что дает возможность доступа к данным хранилища для внешних потребителей - **витрины** (представления), доступ к которым осуществляется как к табличным данным или через API.

**Data Warehouse** (хранилище данных) - это единый источник "правды", в который сохраняют исторические данные путем объединения наборов реляционных данных из нескольких источников, включая прикладные, бизнес-данные и транзакционные данные, которые извлекаются из нескольких источников, преобразуются и очищаются перед загрузкой в систему хранения так, чтобы их можно было считать единым источником правды.

**Data Lake** (озера данных) - это централизованное, обладающее высокой гибкостью хранилище, в котором большие объемы структурированных и неструктурированных данных хранятся в их необработанном, оригинальном и неотформатированном виде, так как схема или данные не определяются при захвате данных, а вместо этого данные извлекаются, загружаются и преобразуются (ELT) для целей анализа.

**Raw Data Store** (хранилище необработанных данных) - это недорогое постоянное хранилище, способное хранить данные в больших объемах.

**Data Lakehouse** (дом для данных) - это архитектура хранения больших объемов данных, которая сочетает в себе лучшие возможности как хранилищ данных, так и озер данных, обеспечивающая единое хранилище для всех типов данных: структурированных, полуструктурированных и неструктурированных.

Состоит из:
- **хранилища** - масштабируемое и гибкое решение для работы со структурированными(например, csv), частично структурированными (например, json) и неструктурированными данными (например, текстовый файл);
- **уровеня метаданных** - единый каталог, который предоставляет метаданные для всех объектов в хранилище и позволяет управлять данными (транзакции, версионирование, управление схемой и другое).

Метрики баз данных:
- **метрики объема по объектам хранения** - контроль размеров хранимой сущности: таблицы, группы таблиц, слоя хранения;
- **метрики загрузки данных** - контроль выполнения ETL-процессов и обработки потоков, включая контроль основных параметров по CPU и RAM;
- **метрики хранилища** - контроль процессов чтения и записи данных хранилища на диски, выборки данных для определения медленных или самых ресурсоемких запросов.

**Модель Инмона** - использует подход сверху вниз, где хранилище данных строится как централизованный корпоративный репозиторий с нормализованной структурой (3NF) и является единым источником правды, а для анализа данных создаются специализированные витрины данных (Data Marts). Для минимизации избыточности используется высокая степень нормализации, с основным фокусом на долгосрочной устойчивости и масштабируемости.

**Модель Кимбалла** - использует подход снизу вверх. где хранилище данных проектируется как совокупность витрин данных, которые объединяются для формирования интегрированной структуры и данные обычно хранятся в денормализованной форме (звездная схема).

**Модель Data Vault** и ее развитие - **Anchor** (якорная модель) - разработаны для гибкости при изменении структуры данных и интеграции новых источников и ориентированы на быстрое изменение структур. Основные компоненты модели:
- **hub** - бизнес-ключи сущностей;
- **satellite** - атрибуты сущностей;
- **link** - определяют отношения между **hub**.

### <a id="Таблицы-фактов-и-таблицы-измерений" href="#Таблицы-фактов-и-таблицы-измерений">Таблицы фактов и таблицы измерений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Схема "Звезда"** - представляет собой простую структуру данных, в которой одна центральная **таблица фактов** окружена **таблицами измерений**. Таблица фактов содержит ключевые числовые показатели (например доход или количество продаж), а таблицы измерений описывают контекст этих показателей (например дату, продукт или клиента).

**Схема "Снежинка"** представляет собой **таблицы измерений**, которые нормализованы, то есть разделены на более мелкие таблицы, что уменьшает дублирование данных и экономит место в базе данных. Но сложность запросов возрастает из-за необходимости соединять большее количество таблиц, что может сказаться на производительности.

**Таблица фактов** - отражает бизнес-процесс - запись в таблице представляет бизнес-событие, на основе выделения бизнес-процессов, которые определяют таблицы фактов.

**Таблица измерений** - предоставляет контекстную информацию, дополняет данные в таблице фактов и уточняет бизнес-процессы.

**Срезы** - один способ представления данных в OLAP-системах, применяемый к многомерным кубам - выборка данных из OLAP-куба, основанную на одном или нескольких измерениях.

## <a id="Подходы-к-обработке-данных" href="#Подходы-к-обработке-данных">Подходы к обработке данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**ETL** (Extract, Transform, Load) и **ELT** (Extract, Load, Transform) - это два подхода к пакетной загрузке данных в хранилище, которые состоят из:
- **extract** (извлечение) - это процесс извлечения исходных данных из базы источника, при:
    - использовании **ETL** - данные отправляются во временную промежуточную область хранение;
    - использовании **ELT** - данные сразу отправляются в хранилище данных или систему хранения данных хранилища данных;
- **transform** (преобразование) - это процесс изменения структуры и формата данных для интеграции данных с целевой системой, куда они загружаются, и остальными данными в этой системе;
- **load** (загрузка) - это процесс записи данных в слой хранилища.

**ETL** используют, когда данные нужно преобразовать перед загрузкой в хранилище.

**ELT** используют, когда данные не нужно преобразовать перед загрузкой в хранилище, а процесс преобразования данных происходит после того, как они загружены в хранилище.

## <a id="Подход-Data-Mesh" href="#Подход-Data-Mesh">Подход Data Mesh</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Подход Data Mesh** подход основан на предположении, что те, кто ближе всего к бизнес-контексту, лучше всего подходят для управления данными и извлечения из них пользы.

Состоит из компонентов:
1. **Владения доменом** - бизнес-подразделения, которые управляют своими собственными информационными продуктами для того, чтобы было улучшенное качество данных и согласованность бизнеса;
2. **Инфраструктуры самообслуживания** - стандартизированные платформы и инструменты для того, чтобы была меньшая зависимость от IT, большая гибкость;
3. **Продуктового мышления** - данные, рассматриваемые как бизнес-продукт для того, чтобы было повышение удовлетворенности пользователей и внедрение;
4. **Федеративного управления** - сбалансированная автономность с контролем для того, чтобы были последовательные стандарты с гибким внедрением.

Принципы:
1. **Разделение контекстов бизнеса** в соответствии с DDD-подходом;
2. **Выстраивание единой инфраструктурной платформы**, которая обеспечит потребности команд в части интеграций данных и должна удовлетворять потребностям пользователей в части обнаружения данных, облегчения поиска и так далее;
3. **Продуктовое мышление** означающий работу с данными как с продуктом, которые должны быть:
    - **доступны для поиска**: насколько легко новому сотруднику пройти онбординг;
    - **доступны по адресу**: сколько тысяч лет сотруднику нужно ждать, чтобы получить права на данные, и у кого их вообще получать;
    - **достоверны и правдивы**: можно ли верить этим данным;
    - **документированы**: можно ли не изучать всю структуру данных и их происхождение, а увидеть это в "карточке товара";
    - **взаимодействовать друг с другом и соответствовать глобальным стандартам**: насколько данные соответствуют правилам комплаенса компании и не дублируются ли они другими данными;
    - **безопасными и управляемые глобальным доступом**: есть ли возможность безопасного доступа к данным (например, с помощью определения политики RBAC).
4. **Обеспечение управления данными через единые политики**, которые автоматизируются на уровне платформы данных:
    - каждый продукт данных (data product, DP) имеет границы по DDD, собирает операционные данные, использует аналитические данные и публикует контракт, который может использовать другой продукт;
    - продукт данных использует платформу самообслуживания - единую инфраструктуру для данных.

<a id="Облачные-вычисления" href="#Облачные-вычисления">Облачные вычисления</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===================

Виды облачных вычислений:
1. **По модели развертывания** (Deployment Model) - определяет, каким образом и где разворачивается решение:
    - **частное облако** (Private Cloud) - это среда, предназначенная исключительно для одной организации, где есть четкая грань между программным обеспечением и аппаратным, при этом может находиться как на территории самой организации, так и у стороннего провайдера. Имеет подтипы:
        - **локальное** - когда решения и приложения разворачиваются на инфраструктуре организации и управляется самой организацией;
        - **управляемое** - когда решения и приложения управляется сторонней компанией, которая специализируется на обслуживании программного и аппаратного обеспечения;
        - **виртуальное** - когда решения и приложения клиента развернуты на инфраструктуре облачного провайдера, который предоставляет изолированную среду для организации клиента.
    - **публичное облако** (Public Cloud) - это среда, в которой виртуальные ресурсы разворачиваются на инфраструктуре облачного провайдера и предоставляются организации клиента по требованию, при этом аппаратная инфраструктура провайдера может использоваться другими клиентами;
    - **гибридное облако** (Hybrid Cloud) - это среда, когда часть решений находится в публичном облаке, а часть в частном или на "железе".
2. **По модели услуги** (Service Model) - определяет, какие именно и на каком уровне сервисы предоставляются клиенту:
    - **SaaS** (Software as a Service, SaaS) - программное обеспечение как услуга - это способ предоставления услуги, когда приложения предоставляются клиенту по подписке, при этом клиент не имеет доступа ни к настройке инфраструктуры, ни к конфигурации платформы или окружения;
    - **PaaS** (Platform as a Service) - платформа как услуга - это способ предоставления услуги - платформенных ресурсов со своей средой исполнения, API-интерфейсами и окружением, при этом клиенту не нужно управлять инфраструктурой или поддерживать платформу, что позволяет ему сосредоточиться на разработке, тестировании и развертывании своих приложений;
    - **IaaS** (Infrastructure as a Service) - инфраструктура как услуга - это способ предоставления услуги - аппаратных вычислительных ресурсов, при этом клиент получает полный контроль над операционной системой и приложениями, а провайдер берет на себя управление сетью, хранилищем данных и виртуализацией.

**Динамическое масштабирование** - это процесс автоматического управления вычислительными ресурсами в облачной инфраструктуре, при котором количество ресурсов может автоматически увеличиваться или уменьшаться в ответ на изменения в нагрузке. Бывает:
- **вертикальным** - изменение мощности существующих ресурсов;
- **горизонтальным** - добавление или удаление ресурсов (например, серверов или контейнеров).

## <a id="Подходы-к-миграции-в-облако" href="#Подходы-к-миграции-в-облако">Подходы к миграции в облако</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Концепция миграции 6R** (6R Migration Strategy) - состоит из подходов:
1. **Retain** - когда выделяются отдельные компоненты решения, которые остаются в текущем on-premise окружении, часто используется в контексте других подходов к миграции;
2. **Retire** - вывод решения или его компонента из эксплуатации после пропажи необходимости в его функционале, часто происходит в рамках другого подхода к миграции, когда используются иные методы для перехода на новые технологии, упрощения инфраструктуры и снижения затрат на поддержку;
3. **Rehost** (Lift and Shift) - наименее затратный подход к миграции решения, без изменений в окружении или в архитектуре (все переносится "как есть"). Состоит из таких ключевых аспектов:
    - **непрерывности**, который заключается в сохранение и поддержание текущего состояния виртуальной и системной среды при миграции;
    - **данных**, который заключается в переносе данных;
    - **управления пользовательским трафиком**, который заключается в переадресации трафика;
4. **Repurchase** (Drop and Shop) - подразумевает отказ использования существующего решения и полную замену на облачный сервис (например, SaaS), это становится релевантно, когда старое решение устарело и миграция экономически нецелесообразна;
5. **Replatform** (Lift and Reshape) - минимальное изменение в коде или архитектуре с подключением дополнительных сервисов провайдера, чтобы воспользоваться преимуществами облачной платформы;
6. **Refactor** (Re-architect) - самый ресурсоемкий и продолжительный подход с глубокой переработкой решения под облачную среду, когда меняется не только окружение, но и сама архитектура приложения.

Могут комбинироваться.

<a id="Проектирование" href="#Проектирование">Проектирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==============

## <a id="Методология-Domain-Driven-Design-DDD" href="#Методология-Domain-Driven-Design-DDD">Методология Domain-Driven Design (DDD)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Домен** - это область знаний или деятельности, которая представляет собой основную часть работы компании - охватывает все понятия, связанные с данной областью, и описывает ее поведение и правила.

**Поддомен** - это логически выделенная часть домена, которая выполняет определенную функцию или решает конкретную задачу. В домене может быть несколько поддоменов, каждый из которых важен для общей картины.

**Контекст** - это область, внутри которой определенные термины и правила имеют четкое значение - помогают избежать путаницы, определяя границы использования понятий.

### <a id="Уровни-проектирования" href="#Уровни-проектирования">Уровни проектирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегическое проектирование** позволяет определить высокоуровневую структуру системы, а **тактическое проектирование** - детализировать каждый контекст, обеспечивая реализацию бизнес-логики.

**Стратегическое проектирование** - это когда определяется общая структура системы и взаимодействие между различными частями домена, с основной задачей - разделить систему на поддомены и очертить границы контекстов. Основные элементы:
- **Bounded Context**: определяет границы, в пределах которых терминология и правила имеют четкое значение;
- **Context Map**: диаграмма, показывающая взаимодействие между различными контекстами.

**Тактическое проектирование** - это когда определяются детали реализации внутри каждого контекста, с основной задачей - создать модель, которая точно отражает бизнес-логику и поведение домена. Основные элементы:
- **Entities** (сущности): объекты, которые имеют уникальный идентификатор и состояние, изменяющееся со временем;
- **Value Objects** (объекты-значения): объекты, которые не имеют уникального идентификатора и полностью определяются своими атрибутами;
- **Aggregates** (агрегаты): группы связанных сущностей и объектов-значений, которые обрабатываются как единое целое;
- **Repositories** (репозитории): интерфейсы для доступа к агрегатам из хранилища данных;
- **Services** (сервисы): операции, которые не относятся к какой-либо сущности, но важны для домена.

### <a id="Процесс-выделения-доменов-и-контекстов" href="#Процесс-выделения-доменов-и-контекстов">Процесс выделения доменов и контекстов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из шагов:
1. **Анализ бизнеса и требований**:
    - проведение интервью с ключевыми бизнес-экспертами;
    - сбор и анализ бизнес-требований и сценариев использования;
    - определение основных бизнес-целей и приоритетов.
2. **Выделение доменов**:
    - определение границ домена;
    - идентификация основных функций и процессов внутри домена;
    - документирование ключевых понятий и терминов, используемых в домене.
3. **Разделение на поддомены**:
    - идентификация поддоменов на основе функциональных требований;
    - определение взаимодействий между поддоменами;
    - документирование поддоменов и их границ.
4. **Определение контекстов**:
    - определение границ контекстов внутри поддоменов;
    - создание контекстных карт (Context Maps) для визуализации взаимодействий;
    - документирование терминов и правил внутри каждого контекста.
5. **Создание контекстных карт (Context Maps)**:
    - создание диаграмм, отображающих контексты и их взаимодействия;
    - определение типов взаимодействий (например, интеграция, антипаттерны);
    - документирование зависимостей и договоренностей между контекстами.
6. **Итеративное уточнение**:
    - регулярный пересмотр и обновление доменов и контекстов;
    - внедрение изменений на основе обратной связи от пользователей и команды;
    - обеспечение согласованности между всеми частями системы.

<a id="Документирование" href="#Документирование">Документирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
================

## <a id="Модель-C4" href="#Модель-C4">Модель C4</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это многоуровневая модель для описания архитектуры.

### <a id="Уровень-1-Диаграмма-контекста---Context-diagram" href="#Уровень-1-Диаграмма-контекста---Context-diagram">Уровень 1. Диаграмма контекста - Context diagram</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Показывает, как система выглядит в целом, предоставляет общий обзор системы и ее границ. Показывает систему в окружении, выделяя основные внешние системы и пользователей, которые взаимодействуют с ней.

Ее используют:
- **бизнес-аналитики** для демонстрации взаимодействия системы с внешними системами и пользователями;
- **проектные менеджеры** для определения основных стейкхолдеров и их взаимодействия с системой;
- **архитекторы** для общего представления системы и ее окружения.

Основные компоненты:
- **пользователь**;
- **система**;
- **границы системы**;
- **существующие системы (внешние)**;
- **взаимоотношение**.

### <a id="Уровень-2-Диаграмма-контейнеров---Container-diagram" href="#Уровень-2-Диаграмма-контейнеров---Container-diagram">Уровень 2. Диаграмма контейнеров - Container diagram</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Показывает высокоуровневые технические строительные блоки - приложения и хранилища данных. Показывает основные высокоуровневые контейнеры системы и взаимодействия между ними (например, веб-приложения, базы данных, микросервисы).

Ее используют:
- **архитекторы** для определения основных контейнеров системы и их взаимодействия;
- **разработчики** для понимания высокоуровневой структуры системы;
- **DevOps-инженеры** для планирования развертывания контейнеров и их взаимодействия.

Основные компоненты:
- **пользователь**;
- **контейнер**;
- **границы контейнера**;
- **существующие системы (внешние)**;
- **взаимоотношение**.

### <a id="Уровень-3-Диаграмма-компонентов---Component-diagram" href="#Уровень-3-Диаграмма-компонентов---Component-diagram">Уровень 3. Диаграмма компонентов - Component diagram</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Показывает уровень отдельного контейнера и показывают компоненты внутри него. Углубляется в один из контейнеров, показывая, из каких компонентов он состоит и как эти компоненты взаимодействуют друг с другом.

Ее используют:
- **разработчики** для детального понимания внутренних структур контейнеров и их взаимодействий;
- **архитекторы** для проектирования внутренней структуры контейнеров;
- **тестировщики** для планирования тестирования компонентов и их взаимодействий.

Основные компоненты:
- **компонент**;
- **контейнер**
- **границы компонента**;
- **существующие системы (внешние)**;
- **взаимоотношение**.

### <a id="Уровень-4-Диаграмма-кода---Codeclasses-diagram" href="#Уровень-4-Диаграмма-кода---Codeclasses-diagram">Уровень 4. Диаграмма кода - Code/classes diagram</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Показывает, как реализован отдельный компонент. Отображает структуру кода в рамках одного из компонентов. Показывая классы или файлы и их взаимодействие.

Ее используют:
- **разработчики** для детального проектирования и рефакторинга кода;
- **тестировщики** для понимания логики работы классов и планирования юнит-тестирования;
- **архитекторы** для верификации соответствия кода архитектурным требованиям.

### <a id="Дополнительные-диаграммы" href="#Дополнительные-диаграммы">Дополнительные диаграммы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="Диаграммы-последовательностей---Dynamic-diagrams" href="#Диаграммы-последовательностей---Dynamic-diagrams">Диаграммы последовательностей - Dynamic diagrams</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Показывает взаимодействие объектов в определенном временном порядке, акцентируя внимание на порядке сообщений между объектами.

Ее используют:
- **разработчики** для понимания последовательности взаимодействий между объектами при выполнении операций;
- **тестировщики** для планирования тестирования сценариев взаимодействий;
- **бизнес-аналитики** для демонстрации функциональных требований и сценариев использования.

#### <a id="Диаграммы-развертывания---Deployment-diagrams" href="#Диаграммы-развертывания---Deployment-diagrams">Диаграммы развертывания - Deployment diagrams</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Показывают физическое размещение программных артефактов на узлах развертывания.

Ее используют:
- **DevOps-инженеры** для планирования и управления развертыванием системы;
- **архитекторы** для проектирования архитектуры развертывания;
- **системные администраторы** для настройки и поддержки инфраструктуры развертывания.

### <a id="Шаги-создания" href="#Шаги-создания">Шаги создания</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Шаги:
1. **Сбор требования и определение границ системы**:
    - определение основных функций и компонентов системы;
    - определение внешних систем и пользователей, которые будут взаимодействовать с системой.
2. **Создание диаграммы контекста**:
    - описание системы и ее окружения;
    - указание внешних систем и пользователей, которые взаимодействуют с системой.
3. **Создание диаграммы контейнеров**:
    - определение основных контейнеров внутри системы - приложений и хранилищ данных;
    - указание взаимодействий между контейнерами и внешними системами.
4. **Создание диаграммы компонентов**:
    - детализация контейнеров и их внутренних структур;
    - определение основных компонентов внутри контейнеров и их взаимодействие.
5. **Создание диаграммы кода**:
    - детализация кода компонентов;
    - указание основных классов или файлов компонентов и их взаимодействие.

### <a id="Методы-для-анализа-и-интерпретации" href="#Методы-для-анализа-и-интерпретации">Методы для анализа и интерпретации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные методы:
1. **Метод по проверки полноты и ясности**:
    - проверка, что все основные элементы системы и их взаимодействия отражены на диаграммах;
    - проверка, что диаграммы понятны всем стейкхолдерам, включая тех, кто не имеет технического образования.
2. **Метод по выявления узких мест и потенциальных проблем**:
    - определение компонентов, которые могут стать узкими местами (например, контейнеры с высокой нагрузкой);
    - оценка взаимодействия между компонентами на предмет потенциальных проблем (например, задержек или сбоев в коммуникации).
3. **Метод по анализу безопасности**:
    - проверка диаграммы на предмет потенциальных уязвимостей, связанных с доступом к данным и авторизацией пользователей;
    - проверка, что критически важные компоненты защищены соответствующими механизмами безопасности.
4. **Метод по оценки масштабируемости**:
    - определение, какие компоненты системы могут требовать масштабирования при увеличении нагрузки;
    - оценка возможности горизонтального и вертикального масштабирования компонентов.

### <a id="Методы-для-получения-обратной-связи" href="#Методы-для-получения-обратной-связи">Методы для получения обратной связи</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные методы:
1. **Метод по ревью команды** когда участники команды отмечают непонятные моменты, потенциальные проблемы и вносят предложения по улучшению;
2. **Метод по привелечению стейкхолдеров** когда проводят презентации диаграмм для бизнес-экспертов и стейкхолдеров для сбора их мнения о том, насколько диаграммы понятны и какие аспекты можно улучшить;
3. **Метод по использованию инструментов для комментариев** когда участники команды оставляют свои замечания и предложения прямо на диаграммах в онлайн-инструментах;
3. **Метод по анализу инцидентов и проблем**, чтобы выявить недостатки в архитектуре для обновления диаграмм, чтобы учитывать полученные уроки и улучшения.

## <a id="Документация-как-код" href="#Документация-как-код">Документация как код</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Документация как код** (Documentation as Code) - это подход, при котором документация создается, обновляется и управляется так же, как и исходный код.

## <a id="OpenAPI" href="#OpenAPI">OpenAPI</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**OpenAPI** - это спецификация для описания RESTful API, которая позволяет документировать эндпоинты, методы, параметры и ответы API.

## <a id="AsyncAPI" href="#AsyncAPI">AsyncAPI</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**AsyncAPI** - это спецификация для документирования и проектирования асинхронных API, которая позволяет описывать структуры сообщений, каналы и взаимодействия между компонентами в асинхронной системе.

<a id="Проработка-решений" href="#Проработка-решений">Проработка решений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==================

Метрики для выявления узких мест:
1. **Частота развертывания** (Deployment Frequency) - измеряет, как часто команда выпускает обновления и новые функции в продукт. Высокая частота развертываний свидетельствует о гибкости и способности команды быстро адаптироваться к изменениям. Если частота развертываний низкая, это может указывать на проблемы в процессе разработки или тестирования, которые тормозят выход новых релизов. Узкое место здесь может быть связано с техническими или организационными ограничениями, такими как сложность инфраструктуры, недостаток автоматизации или плохая координация между командами;
2. **Время ожидания изменений** (Lead Time for Changes) - измеряет, сколько времени проходит с момента запроса на изменение до его фактического развертывания в продакшн. Чем меньше это время, тем быстрее команда может реагировать на потребности пользователей или на изменения в бизнес-требованиях. Долгое время ожидания изменений может свидетельствовать о блокировках в процессе разработки, например, из-за сложных зависимостей, долгих циклов тестирования или перегруженности команд;
3. **Количество ошибок** - показывает, сколько инцидентов или багов возникло за определенный период и **MTTR** (среднее время на исправление) - среднее время, необходимое для устранения этих проблем. Высокий уровень ошибок и долгий MTTR говорят о том, что система не только ошибочна, но и медленно восстанавливается, что ухудшает пользовательский опыт;
4. **Метрики производительности** измеряют скорость выполнения критически важных операций для пользователя, таких как обработка запросов, время отклика системы, задержки при загрузке страниц или при генерации отчетов;
5. **Показатели RTO** (Recovery Time Objective) - это время, за которое необходимо восстановить работу системы после сбоя, оценивающее, сколько времени бизнес может быть недоступен, и включает анализ систем и приложений, и **RPO** (Recovery Point Objective) - допустимое количество данных, которое компания может потерять с момента последнего резервного копирования, определяющее, насколько свежими будут данные после восстановления, и измеряется временем от последнего бэкапа.

## <a id="Основные-подходы-к-разработке-решений" href="#Основные-подходы-к-разработке-решений">Основные подходы к разработке решений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**High-Level Design** - высокоуровневое проектирование в реальных средах согласует сервисы, базы данных и системы интеграции с бизнес-доменами и целями. С помощью сегментирования ответственности, определения границ и проектирования с ориентацией на домен (DDD) компании заменяют монолиты гибкими экосистемами сервисов.

**Parallel Run** - параллельный запуск старой и новой систем обеспечивает безопасность. Компания проверяет производительность, соответствие и удобство новой архитектуры до отключения старой. Обе системы получают входные данные, а их выходные данные сверяются.

**Branch by Abstraction** - включает добавление слоя абстракции для унаследованной системы и поэтапную замену компонентов без ущерба для потребителей. Это снижает риск "большого взрыва" и обеспечивает плавный рефакторинг.

## <a id="Технический-роадмап" href="#Технический-роадмап">Технический роадмап</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Технический роадмап** предусматривает действия, которые направлены на сохранение работоспособности систем, поддержку бизнес-стратегии и в конце концов вывод систем из эксплуатации. Он помогает понять что, когда и почему будет происходить с IT-системами.

Основные направления для краткосрочного планирования:
- **обновление технологий** - снижение технических инцидентов;
- **влияние на пользователей** - это действия, которые убирают боли пользователей, возникшие по нашей вине;
- **повышение продуктивности** - улучшения, которые будут явно влиять на продажи;
- **уменьшение технических потерь** - обновление технического стека которое может явно увеличить продуктивность.

Каждое направление изменений в техническом роадмапе должно быть напрямую связано с бизнес-целями компании.

Чтобы обосновать запланированные работы в роадмапе, нужно расписать для бизнеса конкретное влияние того, что нужно исправить, на цели, которые стоят. Человеческие ресурсы измеряем в часах, а железо - в рублях в месяц.

В роадмап вносят не конкретные задачи, а только их собирательный образ.

Основные направления для долгосрочного планирования:
- **инвентаризация существующих инструментов** - определение всего программного обеспечение, аппаратного обеспечение и ИТ-систем, которые используются в настоящее время, что поможет выделить то, что действительно заслуживает внимания в условиях ограниченности ресурсов;
- **оценка эффективности инструментов** - анализ, какие инструменты приносят пользу, а какие неэффективны, через опросы разработчиков, инженеров поддержки и других заинтересованных ролей;
- **масштабируемость инструментов** - анализ того, что существующие технологии могут масштабироваться в соответствии с планами развития компании.

Для долгосрочного планирования нужно хорошо представлять как IT-ландшафт, так и цели бизнеса.

### <a id="Модель-TIME" href="#Модель-TIME">Модель TIME</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Модель TIME** - это метод оценки и классификации приложений на основе их технической и функциональной пригодности для организации.

**Техническая пригодность** относится к качеству приложения, его поддерживаемости и совместимости с другими системами.

**Функциональная пригодность** означает, насколько хорошо приложение соответствует бизнес-возможностям компании и поддерживает их.

Модель TIME построена на четырех квадрантах:
- **T - Tolerate** - приложения, которые имеют высокую техническую пригодность, но низкую функциональную пригодность. Стратегически они не имеют высокой ценности, но остаются технически пригодными. Их удаление или изменение - это не приоритет. Такие приложения зачастую остаются в текущем состоянии, несмотря на их ограниченный вклад в достижение бизнес-целей.

    Решение о том, стоит ли использовать приложение, часто зависит от затрат и усилий, которые необходимы для его замены или обновления. Если эти факторы перевешивают преимущества от изменений, приложение используется до тех пор, пока не наступит более подходящее время для работы над ним.

- **I - Invest** - это самые полезные приложения. У них высокая техническая и функциональная пригодность. Такие приложения являются неотъемлемой частью деятельности организации и вносят значительный вклад в достижение бизнес-целей.

    Решения об инвестициях в такие приложения принимают на основе их потенциала для повышения ценности бизнеса. Это может быть повышение эффективности, расширение функциональности или возможность поддерживать новые бизнес-инициативы. Инвестиции могут включать в себя обновление приложения, расширение его использования в организации или более тесную интеграцию с другими системами.

- **M - Migrate** - это приложения с низкой технической совместимостью, но высокой функциональной совместимостью. Типичный легаси, на котором исторически строится весь бизнес.

    Решение о переносе приложения обычно принимается из-за необходимости повысить техническую производительность, сократить расходы или лучше соответствовать IT-стратегии организации.

- **E - Eliminate** - это приложения, которые попадают в категорию "удалить". У них низкий уровень технической и функциональной совместимости. Такие приложения плохо работают и больше не соответствуют бизнес-процессам. Их необходимо удалить из портфеля приложений.

```
4-5 |   T    |    I
3-4 |        |
    |--------+--------
2-3 |   E    |    M
1-2 |        |
    +--------+--------
     1-2 2-3   3-4 4-5
```

Где:
- `4-5` - полностью подходит;
- `3-4` - подходит;
- `2-3` - нецелесообразно / неэфффективно;
- `1-2` - не подходит.

По вертикали располагается оценка по техническим категориям:
- **поддержка**;
- **стек**;
- **найм**;
- **масштабируемость**;
- **расширяемость**.

По горизонтали располагается оценка по бизнес показателям:
- **Time To Market**;
- **функциональность**;
- **планируется развивать функционал**;
- **приносит прибыль**;
- **сложно адаптировать похожие решения**.

Каждая оценивается от 0 до 50 и затем их сумма делится на 50 и округляется в большую сторону, что дает результат от 1 до 5.

### <a id="Технический-долг" href="#Технический-долг">Технический долг</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Технический долг**, или техдолг, - это компромисс, который может быть явным или неявным - устаревшие технологии, неэффективные методы управления разработкой, низкий уровень тестирования.

Виды технического долга:
- **архитектурный долг** - когда сознательно придумали, как сделать "на коленке", чтобы успеть;
- **долги по кодовой базе** - которые возникают из-за недостатка знаний, инструментария, стандартов и политик;
- **инфраструктурный долг** - который возникает отчасти из-за архитектурного долга и долгов по кодовой базе, отчасти - из-за отсутствия наблюдаемости;
- **долги по качеству программного обеспечения** - когда отсутствуют нужные инструменты;
- **процессный долг** - который возникает, когда команда пропускает несколько менее важных этапов бизнес или технического процесса;
- **дефектная задолженность** - которая возникает, когда на этапе тестирования вроде бы незначительные ошибки заносятся в бэклог, а потом про них забывают;
- **задолженность по документации** - когда технические процессы (например, траблшутинг) не описаны и их приходится изобретать каждый раз заново;
- **известная или преднамеренная задолженность** - этот вид долга вводят специально для ускорения выпуска, который, обычно впоследствии забывают;
- **неизвестный устаревший или случайный долг** - это неявная задолженность, которая может возникнуть на стороне разработчиков, дизайнеров и других заинтересованных сторон. Иногда этот вид долга возникает из-за регрессии в коде, который связан с вашим, то есть в коде независимых приложений и библиотек;
- **технический долг, вызванный "битовой гнилью" или "костылями"** из-за чего компонент или система постепенно усложняются, так как шаг за шагом в них вносят множество изменений, что постепенно ухудшает качество систем и модулей может, если над ними работают люди, которые не до конца понимают исходный дизайн. На практике множество инженеров, работающих над одним и тем же кодом модуля, могут переписывать и изменять его, не знаюя его предыстории, что может привести к проблемам с регрессией. Такой технический долг постепенно подтачивает системы, словно гниение, которое выедает деревянные дома.

Оценка технического долга:
1. **Оценка стоимости**:
    - оценка проблем через инцидент-менеджмент;
    - оценка времени, которое команда потратит на инцидент в человеко-часах;
2. **Оценка критичности**:
    - коэффициент технической задолженности (TDR, Technical Debt Ration) = `(<стоимость_устранения> / <стоимость_разработки>) * 100%`, где `<стоимость_устранения>` измерется в человеко-днях, `<стоимость_разработки> = <время_разработки_одной_строчки_кода> * <количество_строчек>`, если получилось больше 5%, то это проблема.

### <a id="Технический-радар" href="#Технический-радар">Технический радар</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Технический, или технологический, радар** - это визуальное представление, которое классифицирует технологии по таким критериям, как зрелость, актуальность и потенциальное влияние.

Технический радар использует два элемента классификации - квадранты и кольца.

**Квадранты** представляют различные виды точек и представляют собой классификацию по различным граням технического ландшафта:
- **языки программирования и фреймворки** - это инструменты, которые используются для написания программ;
- **инструменты** - дополнительные "помощники", которые помогают в работе (например, базы данных, системы для написания кода, системы управления версиями или инструменты автоматизации);
- **платформы** - то, на чем создается и работает программное обеспечение (например, мобильные платформы, виртуальные машины или облачные сервисы);
- **методы** - к ним относятся элементы процесса разработки программного обеспечения (например микросервисы или Data Mesh).

**Кольца** указывают, на какой стадии находится жизненный цикл внедрения той или иной технологии и отражают жизненный путь технологий от появления до вывода из эксплуатации:
- **adopt** - устоявшиеся технологии, которые используются в проде, имеют низкий уровень риска и рекомендуются к широкому применению;
- **trial** - "пробные" технологии или "технологии на подъеме", которые успешно работают и проверены на реальной проблеме, но у которых, возможно, выявлены еще не все ограничения. У таких технологий степень риска пока выше в силу небольшого применения;
- **asset** - "оценочные" технологии, которые являются многообещающими и имеют явную потенциальную ценность для организации - те самые инвестиции. Они подходят для создания прототипов в целях выявления ограничений и возможностей;
- **hold** - по факту технологии, которые больше нежелательны для применения в новых проектах. Они с большой вероятностью будут постепенно выводится из ландшафта.

<a id="DevOps" href="#DevOps">DevOps</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

**DevOps** - это культурная и профессиональная методология, которая направлена на интеграцию и взаимодействие разработчиков программного обеспечения (Dev) и специалистов по эксплуатации и обслуживанию (Ops).

Основная задача DevOps - ускорить разработку, повысить качество и надежность программного обеспечения за счет автоматизации и улучшения процессов.

## <a id="Pipeline-as-Code" href="#Pipeline-as-Code">Pipeline as Code</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Pipeline as Code** (PaC) - это подход, при котором конвейеры CI/CD описываются с помощью кода и управляются ими тоже через код.

Этот подход обеспечивает:
- **повторяемость**, так как автоматизированные конвейеры гарантируют, что каждый процесс сборки, тестирования и развертывания выполняется одинаково, поэтому риск человеческих ошибок минимизирован;
- **гибкость**, так как определение конвейеров в виде кода позволяет легко изменять их и настраивать под нужды проекта, где требования могут часто меняться;
- **версионирование**, так как конвейеры хранятся в системе контроля версий, поэтому любые изменения при необходимости можно отследить и восстановить;
- **прозрачность**, так как кодовые конвейеры предоставляют четкую документацию процессов CI/CD, что позволяет понимать процессы и поддерживать их;
- **масштабируемость** благодаря тому, что сочетание CI/CD и PaC позволяет бизнесу быстрее адаптироваться к изменениям и легко масштабировать систему;
- **подверженность ошибкам**, так как автоматизация развертывания и тестирования снижает риск человеческих ошибок, что делает развертывания более предсказуемыми и безопасными.

## <a id="CICD" href="#CICD">CI/CD</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**CI/CD** - это набор практик и методологий, который направлен на автоматизацию процессов разработки, тестирования и развертывания программного обеспечения.

### <a id="Continuous-Integration-CI" href="#Continuous-Integration-CI">Continuous Integration (CI)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Continuous Integration** - это процесс непрерывной интеграции, который предполагает регулярное интегрирование изменений в общую кодовую базу и автоматические проверки нового кода на наличие ошибок и конфликтов.

Состоит из шагов:
1. **Работа с системой контроля версий** (Code) - фиксация изменений кода в системе контроля версий, что позволяет отслеживать изменения, управлять различными ветками разработки и координировать работу нескольких разработчиков;
2. **Сборка** (Build) - после внесения изменений в код, эти изменения автоматически интегрируются в центральный репозиторий, после интеграции система CI автоматически запускает процесс сборки проекта, что нужно для того, чтобы убедиться о том, что новый код компилируется и работает вместе с остальной кодовой базой;
3. **Автоматическое тестирование** (Automated Testing) - когда после сборки система CI запускает автоматические тесты, чтобы проверить корректность новых изменений (юнит-тесты, интеграционные тесты и другие виды тестирования), для того, чтобы помогают выявить ошибки и дефекты на ранних этапах разработки.

### <a id="Continuous-Delivery-CD" href="#Continuous-Delivery-CD">Continuous Delivery (CD)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Continuous Delivery** - это процесс непрерывной доставки, который предполагает автоматизацию развертывания и тестирования, что помогает добиться того, чтобы каждая версия программного обеспечения была готова к выпуску в любое время.

Состоит из шагов:
1. **Подготовка к развертыванию** (Release) - дополнительная проверка качества и создание сборки и пакетов, которые нужны для развертывания;
2. **Развертывание в тестовые среды** (Staging/Pre-production Deployment) - готовое приложение развертывается в тестовых средах, где выполняются дополнительные проверки и тесты, что помогает убедиться, что приложение работает корректно в условиях, близких к продакшн-среде.

### <a id="Continuous-Deployment" href="#Continuous-Deployment">Continuous Deployment</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Continuous Deployment** - это процесс непрерывного развертывания, который предполагает что каждое успешное изменение автоматически развертывается в рабочую среду.

Состоит из шагов:
1. **Автоматическое развертывание** (Production Deployment) - после прохождения процессов CI и CD, система автоматически доставляет его конечным пользователям.

## <a id="Infrastructure-as-Code" href="#Infrastructure-as-Code">Infrastructure as Code</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Infrastructure as Code** (IaC) - это подход управлением инфраструктурой, через код.

Основные подходы:
- **декларативный** (функциональный) - когда описывается конфигурация целевого состояния инфраструктуры или окружения, которое требуется, но при этом не указывается последовательность исполнения такой настройки IaC-инструментом;
- **императивный** (процедурный) - подразумевает детальное описание шагов развертывания или настройки инфраструктуры в конфигурационном файле.

## <a id="MLOps" href="#MLOps">MLOps</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**MLOps** (Machine Learning Operations) - это набор практик, который объединяет разработку моделей машинного обучения (ML) и DevOps-процессы.

Основная задача MLOps - автоматизация и управление всем жизненным циклом моделей машинного обучения, от их разработки и обучения до развертывания и эксплуатации в продакшн-среде.

**ModelOps** (Model Operations) - это практика, направленная на эксплуатацию моделей машинного обучения и других статистических моделей в продакшн-среде.

<a id="Искусственный-интеллект" href="#Искусственный-интеллект">Искусственный интеллект</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======================

**Искусственный интеллект** - это технология, реализованная в информационных системах и имитирующая человеческий интеллект с помощью методов машинного обучения.

## <a id="NLP" href="#NLP">NLP</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**NLP** (Natural Language Processing) - обработка естественного языка - это класс задач по распознанию, генерации, обработке голоса и письменной речи человека, используемых при разработке информационных систем.

Состоит из аспектов:
1. **Токенизации** - декомпозиции текста на отдельные слова, фразы или предложения - **токены**;
2. **Стоп-слов** - часто встречающихся знаков и слов ("и", "в", "на", "этот"), которые обычно не несут полезной информации для анализа, которые часто удаляются, чтобы сократить объем данных и сосредоточиться на значимых словах;
3. **Лемматизации** - приводения слова к его базовой (лемматической) форме, то есть преобразование слова в их исходную форму;
4. **Стемминга** - нахождение основы слова, убирая приставки, окончания;
5. **Мешка слов** (bag of words) - сложенных в массив набор всех токенов, где каждый токен заносится в общий словарь, и каждому присваивается число, которое отражает, сколько раз каждое слово встречается в этом документе;
6. **TF-IDF** (term frequency-inverse document frequency) - числового показателя, который оценивает важность слов во всем тексте;
7. **Распознавания намерений** - определение цели или намерения пользователя на основе текста с использованием машинного обучения.

## <a id="Работа-с-данными" href="#Работа-с-данными">Работа с данными</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из шагов:
1. **Формирование бизнес-требований и технологического стека**, который заключается в определении критериев успеха, функциональных требований и согласование технологического стека, инструментов компетенций, которые будут использоваться;
2. **Сбор данных**, который заключается в определении данных с полезной информацией, обработки и интеграции данных из различных источников, создания пайплайнов данных, которые автоматизируют процесс извлечения данных и их загрузку в хранилища;
3. **Подготовка данных**, который заключается в очистке данных, преобразования их в нужный формат и подготовки их к использованию в моделях машинного обучения;
4. **Анализ данных**, который заключается в выявлении закономерностей, трендов и взаимосвязей в данных, которые могут быть полезны для дальнейшего моделирования и принятия решений;
5. **Моделирование**, который заключается в создании, обучении и тестировании моделей, которые будут использоваться для решения задач прогнозирования;
6. **Оценка модели и решения**, который заключается в оценке производительности обученной модели, используя различные метрики качества;
7. **Принятие решений**, который заключается в применении моделей в реальной среде;
8. **Мониторинг**, который заключается в наблюдении за производительностью и корректностью работы модели после ее развертывания в продакшн-среде.

**CRISP-DM** (CRoss-Industry Standart Process for Data Mining) - межотраслевой стандартный процесс исследования данных, который особенно используется в моделях исследования данных. Состоит из фаз:
1. **Определения бизнес-целей** (business understanding);
2. **Начального изучения данных** (data understanding);
3. **Подготовки данных** (data preparation);
4. **Моделирования** (modeling);
5. **Оценки** (evaluation);
6. **Внедрения** (deployment).

## <a id="ML-модели" href="#ML-модели">ML-модели</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Модель** - это математическая функция, которая может принимать на вход новые данные и делать на их основе прогнозирование и многое другое. Модель включает в себя настройки (параметры), которые были получены в процессе обучения, и определяют, как модель интерпретирует входные данные. Модель - это то, что будет развернуто в продакшн-среде и с чем будут взаимодействовать другие компоненты будущего решения.

**Алгоритм машинного обучения** - это то, благодаря чему модель будет учиться выполнять более точное прогнозирование.

**Нормализация данных** - это преобразование входящих данных в рамках одного диапазона значений.

**Масштабирование данных** - это преобразование входящих данных к одному размеру для консистентности на входе модели.

**Тензор** - это многомерный массив чисел.

### <a id="Виды-моделей-машинного-обучения" href="#Виды-моделей-машинного-обучения">Виды моделей машинного обучения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Обучение с учителем** (Supervised Learning) - это метод, при котором модель обучается на размеченных данных. Каждому входному набору данных соответствует правильный выход или "метка" (целевой признак). Модель должна научиться предсказывать правильные метки для новых данных на основе того, что она выучила из обучающего набора.

Алгоритм работы:
1. Модель получает набор данных, где каждый элемент состоит из входных характеристик (например, признаки объекта) и известного результата (метки);
2. Модель анализирует эти данные и настраивает свои внутренние параметры так, чтобы минимизировать разницу между предсказанными и реальными результатами.

**Обучение без учителя** (Unsupervised Learning) - это метод, при котором модель обучается на неразмеченных данных. В этом случае у модели нет правильных ответов или меток для данных и задача модели - самостоятельно выявить скрытые структуры или паттерны в этих данных.

Алгоритм работы:
1. Модель получает только входные данные, без известных меток или результатов;
2. Модель анализирует данные и пытается найти в них закономерности - группы (кластеры), связи между признаками или важные характеристики данных.

**Обучение с подкреплением** (Reinforcement Learning, RL) - это метод машинного обучения, в котором агент взаимодействует с окружающей средой для выполнения определенной задачи, обучаясь на основе обратной связи в виде вознаграждений или наказаний.

Основные элементы:
- **Агент** (Agent) - это сервис или алгоритм, который принимает решения о том, какое действие предпринять в каждом состоянии среды, может быть программой, роботом или любым другим интеллектуальным объектом, который учится на основе взаимодействия с миром;
- **Среда** (Environment) - это внешний мир или ситуация, в которой действует агент, которая предоставляет агенту информацию о текущем состоянии и выдает вознаграждения на основе действий агента;
- **Состояние** (State) - текущее описание среды, в которой находится агент, которое включает всю доступную информацию о мире, с которой агент может работать для принятия решений;
- **Действие** (Action) - выбор действия агента, который влияет на состояние среды, который происходит на каждом шаге на основе своей стратегии;
- **Вознаграждение** (Reward) - обратная связь от среды после того, как агент совершает действие, которое может быть положительным (если действие привело к желаемому результату) или отрицательным (если действие оказалось неудачным). Цель агента - максимизировать совокупное вознаграждение;
- **Политика** (Policy) - (необязательный элемент) стратегия или правило, по которому агент выбирает действия на основе состояния среды, которая может быть статичной или динамически изменяющейся в зависимости от опыта агента;
- **Функция ценности** (Value Function) - (необязательный элемент) это оценка ожидаемого вознаграждения для каждого состояния, которая помогает агенту предсказывать, насколько выгодно попадание в определенное состояние.

## <a id="LLM" href="#LLM">LLM</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**LLM** (Large Language Models) - это общий термин, который охватывает целый класс больших языковых моделей, обладающих миллиардами параметров и выполняющих задачи, связанные с обработкой текста, которые могут генерировать связные тексты, переводить языки, анализировать текстовые данные и писать код.

## <a id="Модульные-диалоговые-системы" href="#Модульные-диалоговые-системы">Модульные диалоговые системы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модульные диалоговые системы взаимодействуют с пользователем на естественном языке в тексте или речи через различные интерфейсы на основе моделей машинного обучения.

Состоит из:
- **модуля NLU** (Natural Language Understanding), который отвечает за анализ и интерпретацию входящего текста в диалоговых системах, и который принимает запрос через API от приложения, который послал пользователь. С главной задачей - извлечь из текста намерения пользователя и основные элементы;
- **модуля Dialog Management** (DM, Core), который отслеживает текущее состояние диалога, включая информацию о предыдущих намерениях и выполненных действиях, что позволяет системе сохранять контекст и делать правильные предсказания о следующем шаге на основе накопленной информации. И отвечает за выбор следующего шага в зависимости от контекста, намерений пользователя, сущностей и состояния диалога.
Состоит из:
    - **политик** - которые ответствены за принятия решений о том, как должна реагировать система. Имеет типы:
        - **rule-based** - реализуются на правилах, где требования к диалогу ограничены и предсказуемы и подходит для обработки часто задаваемых вопросов (FAQ), где ответы формируются на основе правил без необходимости сложной обработки естественного языка;
        - **data-driven** - реализация таких решений основана на управлении данными и имеет два механизма:
            - **retrieval-based** - когда используется заранее созданный набор данных для извлечения наиболее подходящего ответа и при запросе система сопоставляет введенный текст с существующими ответами и выбирает наилучший вариант на основе схожести. Используется в базах знаний, где нужен точный ответ из большого объема данных;
            - **generating** - когда используются нейронные сети, которые позволяют генерировать уникальные ответы на данных, на которых была обучена модель, что позволяет генерировать ответы даже для сильно нетипичных запросов, что делает это подходящим в сложных сценариях, но требует объема данных для обучения и мощных вычислительных ресурсов, а также могут выдавать слишком общие или непредсказуемые ответы, если не оптимизированы должным образом.
    - **слотов** (slot filling) - которые хранят важные данные из текстов пользователя, которые могут использоваться на следующих шагах диалога для предоставления более контекстно ориентированных ответов;
    - **действий** - которые могут быть вызваны по каким-то условиям.
- **модуля NLG** (Natural Language Generation), который отвечает за генерацию и формирование исходящего текста, который передается через API приложению для отображения пользователю. С главной задачей - последовательно сформировать текстовый ответ на основе внутренних данных системы и выявленных намерений пользователя, обеспечивая естественность и понятную коммуникацию.

<a id="Цифровая-трансформация" href="#Цифровая-трансформация">Цифровая трансформация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======================

**IT-ландшафт** - это совокупность всех информационных технологий и систем в организации, включая оборудование, программное обеспечение и их взаимодействие, поддерживающие бизнес-процессы.

**Цифровая трансформация** - это комплексное внедрение цифровых технологий в деятельность компании. Это не просто обновление оборудования или программного обеспечения, а глубокое изменение процессов, взаимодействия с клиентами и в результате всей бизнес-модели.

При **автоматизации** часть бизнес-процессов в компании проходит через информационные системы, а часть может работать по-старому. В этом случае бизнес не зависит от цифровых технологий и может легко работать без них, если, например, в какой-то системе случится сбой.

При **цифровизации** компания постепенно отказывается от аналоговых процессов и переводит данные о клиентах и ведении бизнеса в цифровую форму. Бизнес уже не сможет обойтись без цифровых инструментов в случае сбоя.

При **цифровой трансформации** компания напрямую зарабатывает на цифровых продуктах. Продажи становятся невозможными без сайта и мобильного приложения. Анализ поведения клиентов помогает формировать персонализированные предложения и маркетинговые кампании. Процессы автоматизируются, все данные о ведении бизнеса переведены в цифровой формат. Новые технологии могут создавать источники дохода, которые невозможны без цифровой трансформации.

Основные проблемы, которые решает цифровая трансформация:
- **увеличение конкурентоспособности, повышение гибкости и адаптивности, расширение рынка**, что позволяет компаниям быстрее адаптироваться к изменениям на рынке и предлагать новые продукты и услуги, создавать новые каналы обслуживания;
- **повышение эффективности**, так как автоматизация процессов снижает затраты и увеличивает производительность, позволяя сосредоточиться на стратегически важных задачах;
- **улучшение клиентского опыта, получение данных для аналитики** посредством цифровых инструментов, которые помогают лучше понимать потребности клиентов и предлагать персонализированные решения;
- **внедрения новых технологий** что способствует разработке инновационных продуктов и услуг, что может создать новые источники дохода;
- **устойчивость к рискам**, так как цифровая трансформация помогает управлять рисками и обеспечивает непрерывность бизнес-процессов.

## <a id="Стратегия-цифровой-трансформации" href="#Стратегия-цифровой-трансформации">Стратегия цифровой трансформации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из шагов:
1. **Определение целей трансформации** - бизнес-стратегии, которые формулируются как улучшение бизнес-показателей к какому-то сроку или как выполнение конкретных проектов и задач через анализ рынка и конкурентов, исследование компании и мировых трендов в отрасли, рекомендации консалтинговых компаний, у которых есть опыт и экспертиза в отрасли;
2. **Описание текущей и целевой бизнес-модели**, что позволит сохранять фокус на цели, когда структура бизнеса начнет меняться.

    **Бизнес-модель** - это описание того, как организация создает ценность для рынка и извлекает прибыль. Она определяет:
    - ключевых партнеров (key partners);
    - ключевых действий для заработка (key activities);
    - ключевых ресурсов для работы (key resources);
    - ценностное предложение для рынка (value propositions);
    - взаимоотношения с клиентами (customer relationships);
    - деление клиентов по сегментам (customer segments);
    - каналы продаж (channels);
    - структуры издержек (cost);
    - потоки дохода (revenue streams).

3. **Описание текущей и целевой архитектуры**, что поможет понять, что именно нужно изменить в IT-ландшафте для достижения целей;
4. **Планирование изменений**.

## <a id="Бизнес-архитектура-компании" href="#Бизнес-архитектура-компании">Бизнес-архитектура компании</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Бизнес-архитектура компании** - это связь между структурой бизнеса, стратегией развития и архитектурой информационных систем.

Обычно строится в виде пирамиды:
```
[Бизнес-архитектура] <-- стратегия - выполнение миссии --- [Бизнес-цели]
 |
 | - управляет
 v
[Информационная архитектура]                                   <-
 |                                                              |
 | - предписывает                                               |
 v                                                              |
[Архитектура приложений]                                        | <-- тактика - повышение автоматизации --- [IT-архитектура]
 |                                                              |
 | - поддерживается посредством                                 |
 v                                                              |
[Техническая архитектура (аппаратное ПО и коммуникации)]       <-
```

**Информационная архитектура** (архитектура данных) - отражает взаимодействие с данными: с какими данными работает компания, какие есть правила и политики работы с данными и как они распределяются по системам внутри компании.

**Архитектура приложений** - показывает, какие есть приложения, как они взаимодействуют друг с другом.

**Техническая архитектура** - подразумевает аппаратное обеспечение, то есть инфраструктуру, центры обработки данных, серверы, на которых работают приложения.

**Бизнес-возможности** - это способность бизнеса осуществлять определенные действия. Бизнес-возможности описывают, что делает или может делать бизнес. Этим они отличаются от **бизнес-процессов**, в которых описаны именно шаги по достижению целей.

**Карта бизнес-возможностей** (business capability map) - описывает все возможности, которые уже есть в компании, и те, которые будут в ее целевом состоянии. С помощью карты получается взглянуть на бизнес на более высоком уровне абстракции.

Бизнес-возможности организации можно определить двумя путями:
- **сверху вниз** - когда бизнес-возможности определяют на уровне топ-менеджмента, а далее их детализируют до уровня частей бизнеса;
- **снизу вверх** — когда на уровне частей бизнеса собираются их бизнес-возможности, а потом объединяются в более высокий уровень, при этом важно правильно расставить приоритеты для руководителей структурных подразделений.

**Поток создания ценности** (value stream) - это последовательность действий, или этапов создания ценности, которые организация выполняет для удовлетворения потребности клиента. Клиентом может быть как внешний, так и внутренний заинтересованный субъект, отвечающий за поддержку создания ценности в организации.

### <a id="Карта-IT-ландшафта" href="#Карта-IT-ландшафта">Карта IT-ландшафта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Карта IT-ландшафта** - это инструмент визуализации архитектуры в виде кластерной карты, где в колонках указываются бизнес-подразделения, в строках - бизнес-возможности, а на пересечении - IT-системы.

### <a id="Планирование-стратегических-изменений" href="#Планирование-стратегических-изменений">Планирование стратегических изменений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Планирование изменений состоит из шагов:
1. Планирование этапов реализации и общих задач;
2. Определение сроков этапов;
3. Определение ответственных подразделений компании;
4. Оценка предварительной стоимости трансформации на стратегическом горизонте планирования.

Для визуализации изменений можно создать дорожную карту цифровой трансформации - **Digital Transformation Roadmap**, на которой указывают шаги и сроки реализации - без детализации работ.

### <a id="Проектный-подход" href="#Проектный-подход">Проектный подход</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Проект** - это временное предприятие, предназначенное для создания уникальных продуктов, услуг или результатов. В частности, **IT-проект** - это проект в сфере создания, внедрения или применения информационных технологий.

У проекта есть характеристики - он:
- ограничен во времени;
- приводит к заранее определенному результату по изначально определенным требованиям;
- состоит из последовательных шагов;
- требует ограниченных ресурсов (например людей и денег на реализацию), где центральным ресурсом проекта является бюджет;
- состоит из трех этапов:
    1. Планирования;
    2. Исполнения;
    3. Управления.

**Проектное управление и проектный подход** отвечают на вопрос: *"Как реализовать заданный результат к определенной дате в рамках доступного бюджета и ресурсов?"*.

Проектом управляет менеджер проекта - **Project Manager** (PM), который отвечает за достижение результатов проекта.

Ключевые участники:
- **команда проекта** - люди, которые будут реализовывать проект;
- **спонсор** - подразделение или человек, которые предоставляют ресурсы для проекта;
- **заказчик** - подразделение или человек, которые будут использовать результат проекта;
- **заинтересованные стороны** (**стейкхолдеры**) - люди и организации, которые заинтересованы в изменениях и могут прямо или косвенно оказывающие влияние на ход проекта и его результаты. Бывают:
    - **внутренними** - это сотрудники компании, заинтересованные в проекте;
    - **внешними** - это государственные органы и другие участники рынка, которые проявляют интерес к проекту.

**План проекта** включает требования, сроки, риски, бюджет, ресурсы, работы и заинтересованные стороны. **План программы проектов** содержит ту же информацию, но учитывает несколько проектов.

### <a id="Продуктовый-подход" href="#Продуктовый-подход">Продуктовый подход</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Продукт** - это результат деятельности компании, который предназначен для удовлетворения потребностей пользователей или рынка. Он может быть материальным или нематериальным и имеет свой жизненный цикл.

**Продуктовый подход** рассчитан на улучшение продукта в течение всего жизненного цикла, в котором важна адаптивность и постоянное развитие продукта.

**Продуктовый подход** предполагает создание в компании структуры, которая сможет относительно автономно развивать продукт (например команда), которая развивается параллельно с продуктом и зависит от его жизненного цикла - с организационной точки зрения команда равнозначна самому продукту.

**Управление продуктом** (Product Management) - это процесс планирования, разработки, маркетинга и поддержки продукта на всех этапах жизненного цикла, который включает разработку стратегии, анализ рынка, выявление потребностей пользователей и координацию команд. **С целью** - создать продукт, который удовлетворит потребности пользователей и компании.

За управление продуктом отвечает менеджер продукта - **Product Manager** (PM) - это специалист, который отвечает за стратегию, планирование и развитие продукта в компании.

**CustDev** (Customer Development) - это процесс выявления потребностей с помощью интервью у потенциальных пользователей приложения.

### <a id="Метрики-бизнеса-и-продуктов" href="#Метрики-бизнеса-и-продуктов">Метрики бизнеса и продуктов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Инвестиционные метрики** - это метрики, отражающие объем вложений в бизнес и эффективность использования средств. С которыми работают акционеры, финансовые менеджеры или IT-директора - топ-менеджмент компании. Бывают:
- **CAPEX** (Capital Expenditure) - это затраты предприятия на приобретение крупных активов на срок больше года и их модернизацию - **капитальные инвестиции**. Они нужны для наращивания прибыли и могут влиять на оценку компании;
- **OPEX** (Operational Expenditure) - это операционные расходы - затраты на обеспечение текущей деятельности, а не инвестиции в будущее.

**Бизнес-метрики** - это метрики, которые могут быть важны для роста бизнеса и его продуктов. С которыми работают руководители бизнес-направлений, проектные и продуктовые менеджеры. Бывают:
- **финансовые метрики**:
    - **выручка** (Revenue) - поток денег, который получает компания еще до налогообложения и издержек;
    - **прибыль** (Profit) - это деньги, которые остаются из выручки после всех издержек, которые можно инвестировать в бизнес или выплачивать акционерам. Прибыль делится на **чистую** (Net Profit) и **валовую** (Gross Profit).
- **метрики продаж**, которые помогают оценить объемы продаж и могут быть актуальными для жизненного цикла продукта.

**Метрики продукта** - позволяют оценивать продукт в ходе его жизненного цикла, могут косвенно или прямо влиять на метрики других категорий. Бывают:
- **метрики активности пользователей** (User Activity) - показывают, насколько активно пользователь работает в приложении;
- **метрики выручки на пользователя** - позволяют выявить траты пользователей и впоследствии управлять экономикой продукта.

## <a id="Управление-требованиями-и-определение-бизнес-процессов" href="#Управление-требованиями-и-определение-бизнес-процессов">Управление требованиями и определение бизнес-процессов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Планирование-изменений" href="#Планирование-изменений">Планирование изменений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для планирования изменений нужно:
1. Выявить стейкхолдеров и определить их требования;
2. Определить степень вовлеченности стейкхолдеров в проект и их влияние на основе групп:
    - **высокая вовлеченность, высокое влияние** - это стейкхолдеры, с которыми команда взаимодействует постоянно, получает обратную связь, и часто именно эта группа инициирует проект;
    - **высокая вовлеченность, низкое влияние** - это стейкхолдеры, которые участвуют в проекте, но не принимают важных решений;
    - **низкая вовлеченность, высокое влияние** - это стейкхолдеры, которые могут сильно повлиять на проект, но напрямую они в нем не заинтересованы;
    - **низкая вовлеченность, низкое влияние** - это внешние стейкхолдеры - СМИ или конкуренты.
3. Регулярно подвергать анализу и переоценке интересы стейкхолдеров.

Для удобства можно составить матрицу стейкхолдеров, где в колонках будут стейкхолдеры, а в сторках:
- **должность**;
- **контакты**;
- **руководитель**;
- **роль в проекте**;
- **ожидания и требования**;
- **вовлеченность и влияние**;
- **задачи в проекте**.

### <a id="Требования-к-продукту" href="#Требования-к-продукту">Требования к продукту</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Требования к продукту** - это набор полезных для пользователя характеристик, которые он ожидает от продукта. Требования делятся:
- **функциональные требования** описывают то, что система должна делать, то есть конкретные функции;
- **нефункциональные требования** (атрибуты качества) описывают то, как система будет реализовывать функции при работе. Это могут быть требования, которые влияют на производительность, надежность, удобство использования системы.

#### <a id="Модель-описания-требований-FURPS" href="#Модель-описания-требований-FURPS">Модель описания требований FURPS+</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Модель описания требований FURPS+** применяется в заказной разработке, когда набор функциональных и нефункциональных требований заранее согласуется с заказчиком и включается в план реализации проекта.

Состоит из:
- **функциональность** (Functionality , F) - то, что система должна выполнять на релизе;
- **удобство использования** (Usability, U) - правила, по которым система взаимодействует с пользователем. Это могут быть UX/UI-дизайн, правила работы интерфейса для людей с ограниченными возможностями, справочная информация по работе с системой;
- **надежность** (Reliability, R) - все, что относится к работоспособности системы: время простоя в случае сбоя, режим работы, график обслуживания. Так как невозможно сделать систему устойчивой в любой ситуации, поэтому сразу важно заложить ограничения;
- **производительность** (Performance, P) - все, что относится к быстродействию и потреблению ресурсов: время отклика, масштабирование системы, число одновременных пользователей;
- **поддерживаемость** (Supportability, S) - возможность и правила тестирования, параметры расширения и доработки системы;
- **ограничения** (остальное со знаком +) - это дополнительные ограничения (архитектурно-значимые требования), которые накладываются на систему:
    - **ограничения проектирования**: средства разработки, технологии;
    - **ограничения реализации**: стандарты разработки кода или требования к архитектуре;
    - **требования к интерфейсам**: форматы взаимодействия компонентов, протоколы или способы взаимодействия, например, синхронные или асинхронные;
    - **физические ограничения** - накладываются на аппаратные средства и окружение системы (например температура, влажность, условия эксплуатации оборудования).

**Архитектурно значимые требования** - это требования, которые оказывают влияние на архитектуру системы. Это могут быть как требования к программному обеспечению, так и к оборудованию.

При описании удобно использовать одну или несколько таблиц, а также нумеровать требования (например U1, S2) или делать ссылки, чтобы потом их можно было использовать в тексте документации и описывать пользовательские сценарии.

### <a id="Пользовательские-сценарии" href="#Пользовательские-сценарии">Пользовательские сценарии</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Пользовательские сценарии** (Use Cases) - описывают, какие действия совершает пользователь и как система на них реагирует - варианты использования системы.

**User Story** - это обычно небольшая задача с фокусом на действиях пользователя в продукте.

Сценарии можно описывать от общего к частному, то есть определять, какие есть **Use Cases**, как они связаны и потом детализировать описание каждого из них. Это можно сделать в виде диаграммы, на которой отражаются:
- **действующие лица** (пользователи);
- **варианты использования**;
- (при необходимости) **другие системы**, которые участвуют в процессе.

Каждый сценарий можно детализировать:
- **заголовок** - название варианта использования;
- **участники варианта использования** - действующие лица;
- **предусловие** - в каком состоянии должен находиться каждый участник кейса, чтобы ситуация произошла;
- **триггер** - что провоцирует выполнение этого сценария;
- **результат или гарантии успеха** - что будет результатом успешного выполнения сценария;
- **описание** (основной сценарий) - что должно произойти, чтобы пользователь пришел от триггера к результату;
- **расширения** (альтернативный сценарий) - строится из основного сценария и предполагает разветвление процесса.

**Поток варианта использования** (Use Case Flow) - это последовательность выполнения пользовательского сценария. **Основной поток** (Basic Flow) - это основная последовательность, которая приводит к целевому результату, а различные ветвления — **альтернативные потоки** (Alternative Flow).

#### <a id="Описание-бизнес-процессов" href="#Описание-бизнес-процессов">Описание бизнес-процессов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для описания процессов используется **нотация EPC**, которая визуально похожа на алгоритмическую последовательность действий: имеет логические операторы, описание функций в процессе и событий, которые к ним приводят, которая предполагает, что к действиям (функциям) всегда приводят события, что хорошо позволяет описывать даже сложные процессы, но не акцентирует внимание на инициаторах событий.

Для удобного описания взаимодействий существует **нотация BPMN**, которая позволяет детально описывать процессы со всеми взаимодействиями, потому что они выделяются на отдельные "дорожки" (swimline). Эта нотация позволяет описывать как ручные процессы, так и автоматизированные за счет большого числа различных объектов в ней.

### <a id="Проектирование-архитектуры" href="#Проектирование-архитектуры">Проектирование архитектуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Архитектура решения** (solution architecture) - это результат планирования структуры и взаимодействия компонентов программного обеспечения для достижения целей и соответствия требованиям. Которое можно оформить в концептуальный документ с описанием, схемами, допущениями и ограничениями, чтобы далее определить конкретный план изменений - **архитектурное видение** (architecture vision).

#### <a id="Architecture-Design-Record-и-Architecture-Decision-Log" href="#Architecture-Design-Record-и-Architecture-Decision-Log">Architecture Design Record и Architecture Decision Log</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Architecture decision record** (ADR) - это явное описание принятых и непринятых в ходе разработки ПО решений, которые затрагивают архитектуру, выбранные технологии и отвечают определенным функциональным или нефункциональным требованиям. Фиксируется:
- **контекст** - то, при каких условиях принимается решение;
- **решение** - в чем суть принятого решения;
- **последствия** - к чему приведет решение.

Каждая запись ADR фиксируется в журнале **Architecture decision log** (ADL). Ведение ADL позволяет отслеживать значимые архитектурные изменения внутри проекта или продукта, их историю и накапливать знания для всех участников. Это особенно полезно на долгой дистанции, когда продукт развивается годами: начальная команда может расформироваться, а знания и культура ведения ADL останется и поможет в развитии продукта.

**Шаблон Y-statement** используется для формирования ADR. Состоит из следующих элементов:
1. **Контекст** (context) - на что решение влияет и в каких условиях принято. Это могут требования или условия работы конкретного компонента;
2. **Причина** (facing) - проблема, которую нужно решить, или определенные нефункциональные требования;
3. **Принято** (we decided for) - принятое решение, аргументация и причины;
4. **Отклонено** (neglected) - альтернативы, которые рассмотрели, но не стали выбирать;
5. **Чтобы достичь** (to achieve) - преимущества решения и ожидаемый результат;
6. **Нужно учесть** (accepting that) - недостатки, или то, как решение повлияет на другие элементы.

Первичный ADR описывается с помощью шагов:
1. **Определение функциональных требований**. Формулирование **Use Cases**, исходя из функциональных требований, которые обсуждаются вместе с менеджером продукта или бизнес-заказчиком.

    При проектировании решения **Use Cases** помогут определить, достигается ли результат решения, если пройти **Use Case** по этапам на основе архитектурной схемы. При определении **Use Cases** важно понять, какие системы и пользователи будут задействованы, акцент делается только на основном потоке **Use Case** без альтернативных, так как важно понять архитектуру для достижения основной цели создания системы.

2. **Определение нефункциональных требований** категорий `R`, `P` и `+`, так как эти требования могут влиять на архитектуру решения.

3. **Принятие решения**. Построение схемы взаимодействия компонентов решения, исходя из определенных **Use Cases** и с учетом нефункциональных требований.

    Диаграмма C4 первого уровня позволяет определить, что функциональные требования удовлетворяются. Так можно понять, какие системы будут задействованы в решении и можно даже определить, какие задачи потребуется реализовать и где именно это нужно сделать, чтобы все решение заработало. На ней отображаются:
    - все действующие лица и системы из **Use Cases**;
    - отражаются взаимодействия так, чтобы каждый **Use Case** достигал своей цели, на стрелках можно подписать названия **Use Cases** или конкретные взаимодействия, которые выявляются, если пройти каждый шаг из **Use Case**.

    Диаграмма C4 второго уровня позволяет определить нефункциональные требования `R`, `P` и `+` и на ней отображают:
    - все действующие лица и системы из **Use Cases**;
    - отражаются взаимодействия так, чтобы каждый **Use Case** достигал своей цели, на стрелках можно подписать названия **Use Cases** или конкретные взаимодействия, которые выявляются, если пройти каждый шаг из **Use Case**;
    - детализацию контейнеров, учитывая нефункциональные требования.

Используется нотация C4 от общего к частному: сначала описывают схему первого уровня и при необходимости детализируем до второго уровня.

4. **Описание альтернативных решений**, а также недостатков, ограничений и рисков.

### <a id="Презентация-архитектуры" href="#Презентация-архитектуры">Презентация архитектуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из шагов:
1. Пояснение о проблеме, которая решается;
2. Фокусировка на решении бизнес-задачи с акцентированием внимания стейкхолдеров не на описании элементов схемы, технологиях и принятых допущениях, а на том, как решается исходная бизнес-задача, ради которой нужно спланировать изменения и определить архитектуру. Для этого можно рассмотреть основные Use Cases, которые были определены в решении и пройти каждый из них с пояснением того, какие элементы решения в нем участвуют;
3. При описании решения фокусироваться на Use Cases основного потока выполнения, не уходя в детали и ветвления процессов;
4. Озвучивание альтернатив и почему они не рассматриваются в итоговом решении;
5. Озвучивание ограничений и рисков;
6. Получение обратной связи, ответов на возражения. В этом поможет детальный анализ альтернатив, ограничений и заранее определенные требования.

### <a id="План-работ-и-роадмап-реализации" href="#План-работ-и-роадмап-реализации">План работ и роадмап реализации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**План работ** определяется для достаточно крупных задач в рамках системы, а также задач, которые касаются взаимодействия разных систем на основе диаграммы C4 второго уровня, которые называются **эпиками**.

Далее определяется порядок выполнения в виде **роадмапа**, где продолжительность задач пока может быть произвольной на выбранном горизонте планирования. После того, как команды проведут оценку задач и детальное планирование, детализируется роадмап и конечные сроки реализации.

### <a id="Управление-изменениями" href="#Управление-изменениями">Управление изменениями</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Управление изменениями** (change management) - это процесс планирования, внедрения и контроля изменений проекта. Для этого нужно минимизировать негативные последствия и достичь поставленных целей.

Методы работы с изменениями:
- **предиктивный** - когда заранее держат в голове риск того, что случится какое-то изменение и имеют план на этот счет;
- **реактивный** - мгновенная реакция на случившееся изменение. В этом случае снизить риски уже не получится, но на него можно оперативно отреагировать;
- **последовательный** - это систематический подход к работе с изменениями, который помогает фокусироваться на исходной цели создания продукта, а если условия изменились - поможет верно учесть все риски при появлении новых требований. Состоит из:
    1. **Идентификация изменений**;
    2. **Документирование** - когда детали изменений фиксируются и на каждую инициативу по изменениям создают специальный документ - **запрос на изменения** (change request). В котором фиксируется вся информация по изменению, что поможет лучше понять, почему команда отклонилась от первоначальных планов по проекту, если будет решено принять изменения;
    3. **Оценка** - определение, насколько сложно будет реализовать изменения и стоит ли рассматривать такой вариант. Этот этап не отличается от начального планирования изменений при создании проекта, то есть надо определить требования, архитектуру, провести планирование и оценку для этой локальной задачи;
    4. **Авторизация**. Когда есть оценка и понятен план работ, то можно принять решение, идти таким путем или нет и важно согласовать этот этап с заказчиком проекта: может оказаться, что стоит рассмотреть другой вариант или немного сдвинуть срок запуска;
    5. **Контроль**. Реализация изменений по плану.

## <a id="Дизайн-мышление" href="#Дизайн-мышление">Дизайн-мышление</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Дизайн-мышление** - это нелинейная методология создания решений, в основе которой лежит необходимость осознать проблему клиента и предложить, возможно нестандартное, решение. Так создаются удобные и адаптивные системы, эффективно решающие задачи благодаря ориентации на реальный пользовательский опыт.

Работа над проблемой через дизайн-мышление состоит из нескольких шагов:
1. **Эмпатия** - когда участники встречи пытаются определить источник проблемы клиента, встать на его место. Для начала нужно задать вопрос: *"Зачем это нужно реализовать, и какую проблему мы решаем?"*;
2. **Анализ и синтез** - когда после сбора информации о возникающих проблемах нужно проанализировать, систематизировать информацию и убрать все лишнее. С одной стороны, проблему выявили, но стоит еще раз убедиться, что эта проблема - верная;
3. **Генерация идей** - когда рассматривают разные варианты решения проблемы, даже неожиданные;
4. **Прототипирование** - когда моделируют решение проблемы любым способом, (например рисование на доске);
5. **Тестирование** - когда прототип готов, и кажется, что он может решить задачу, его надо попытаться проверить и устранить недостатки;
6. **Сторителлинг** - когда обобщают информацию об итоговом решении и формируют итоговую историю, чтобы точно убедиться, что проблема будет решена.

Метод дизайн-мышления не является линейным, ничего не мешает возвращаться на прошлые шаги, менять исходную проблему и предлагать другие варианты решения.

## <a id="Классы-систем" href="#Классы-систем">Классы систем</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Универсальные системы** - это системы, которык охватывают ключевые бизнес-процессы, такие как управление ресурсами и аналитика, которые необходимы для эффективного функционирования любой организации независимо от ее отрасли. Гибкость настройки и возможность интеграции с другими системами позволяют адаптировать их к конкретным требованиям компании. Имеются:
- **ERP** (Enterprise Resource Planning) - это системы для планирования ресурсов предприятия и управления ими, которые включают в себя практически все бизнес-процессы компании или в значительной степени замыкают процессы на себя. Основная идея - в одном месте обеспечить управление производством, трудовое планирование, логистику, бухгалтерию, финансовый менеджмент, управление активами и множество других функций;
- **BPMS** (Business Process Management System) - это системы управления бизнес-процессами, которые позволяют визуализировать бизнес-процессы в какой-то нотации, например BPMN, и обеспечивать их автоматизацию;
- **CRM** (Customer Relationship Management) - это системы продаж, которые отвечают за организацию взаимодействия с клиентами и все этапы продажи - от поиска клиента до заключения сделки;
- **MDM** (Master Data Management) - это системы данных, которые обеспечивают общие правила и единый источник истины, в которых данные всегда находятся в наиболее правильном состоянии для других систем компании;
- **BI** (Business Intellegence) - это системы сбора и обработки аналитической информации о работе компании, которые помогают собирать данные из различных систем, обрабатывающих бизнес-процессы, формировать отчеты и анализировать данные для принятия решений о ведении бизнеса.

**Специфичные системы** - это системы, которык специфичны для различных отраслей. Имеются:
- **PLM** (Product Lifecycle Management) - это система управления жизненным циклом продукта - от конструирования до производства и утилизации, которым актуально большое число взаимодействий с системами управления предприятием и производственными процессами;
- **PDM** (Product Data Management) - это система управления данными об изделии, которая позволяет работать с автоматизированным проектированием для сбора информации о версиях узлов изделия и вести разработку изделия полностью в цифровом виде, чтобы впоследствии превратить модели в готовые изделия на следующих этапах жизненного цикла;
- **MES** (Manufacturing Execution Eystem) - это системы для управления самим процессом производства на заводах и фабриках, которые позволяют настраивать и моделировать технологические процессы для производства изделий;
- **SCADA** (Supervisory Control and Data Acquisition) - это системы для сбора данных с различных устройств в процессе производства и управления линиями, станками с ЧПУ и так далее;
- **АБС** (Автоматизированная банковская система) - это системы, которые отвечают за работу с транзакциями по счетам, за учет по банковских продуктам и специализированную бухгалтерию банка.