[Содержание](#Содержание)
==========

- [Микрофронтенды](#user-content-Микрофронтенды)
    - [Стратегии проектирования микрофронтендов](#user-content-Стратегии-проектирования-микрофронтендов)
        - [Стратегия автономность команд](#user-content-Стратегия-автономность-команд)
        - [Стратегия изоляции](#user-content-Стратегия-изоляции)
    - [Методы интеграции микрофронтендов](#user-content-Методы-интеграции-микрофронтендов)
    - [Методы композиции микрофронтендов](#user-content-Методы-композиции-микрофронтендов)
    - [Инструменты для создания микрофронтендов](#user-content-Инструменты-для-создания-микрофронтендов)
        - [Module Federation](#user-content-Module-Federation)
        - [Single SPA](#user-content-Single-SPA)
    - [Стратегии управления состоянием](#user-content-Стратегии-управления-состоянием)
        - [Взаимодействие на основе API](#user-content-Взаимодействие-на-основе-API)
        - [Паттерн Pub/Sub](#user-content-Паттерн-PubSub)
        - [Библиотека глобального состояния](#user-content-Библиотека-глобального-состояния)
    - [Паттерн Backend for Frontend](#user-content-Паттерн-Backend-for-Frontend)
- [Микросервисы](#user-content-Микросервисы)
    - [Паттерн Strangler Fig](#user-content-Паттерн-Strangler-Fig)

<a id="Микрофронтенды" href="#Микрофронтенды">Микрофронтенды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==============

**Микрофронтенд** - это концепция, которая распространяет принципы архитектуры микросервисов на мир фронтенда - фронтенд-приложения декомпозируют на части, которые можно разрабатывать, тестировать и развертывать независимо друг от друга.

Разбиение происходит по такой логике:
- каждый микрофронтенд отвечает за отдельную функцию или область приложения;
- микрофронтенды объединяют в целостный пользовательский опыт.

Основные преимущества микрофронтендов:
- **повышение организационной гибкости** - это позволяет различным командам работать параллельно, не завися друг от друга при развертывании;
- **можно использовать несколько технологических стеков** - в зависимости от задач;
- **упрощение управления кодом** - так как каждая команда управляет только тем кодом, который относится к ее функциональности, что значительно облегчает сопровождение: обновление или исправление одного раздела не вызовет непредвиденных последствий в других частях приложения;
- **более управляемое масштабирование** - так как каждый микрофронтенд развернут независимо от остальных;
- **повышение отказоустойчивости** - так как изоляция микрофронтендов повышает общую устойчивость приложения и в случае его отказа откажет только этот микрофронтенд;
- **ускорение времени выхода на рынок** - так как дает возможность разрабатывать, тестировать и внедрять обновления мелкими порциями, что позволяет больше экспериментировать и оперативно реагировать на изменения рынка.

Основные компоненты:
- **модули микрофронтенда** - это основные элементы архитектуры. Каждый модуль - это определенная бизнес-область или функциональность. Модули разрабатывают, тестируют и развертывают независимо друг от друга;
- **слой композиции** - отвечает за сборку различных модулей микрофронтенда в целостное приложение, а также управляет потоком данных и взаимодействием между клиентом и сервером. Компоновка модулей может происходить на стороне сервера, на стороне клиента или с помощью гибридного подхода;
- **маршрутизация** - отвечает за то, что запросы будут направляться к нужному микрофронтенду, что помогает сохранить модульность приложения (независимость микрофронтендов друг от друга) и при этом обеспечить плавную навигацию для пользователей;
- **коммуникационный слой** - управляет взаимодействием между микрофронтендами и остальной инфраструктурой приложения посредством API, шины сообщений или собственных систем событий.

## <a id="Стратегии-проектирования-микрофронтендов" href="#Стратегии-проектирования-микрофронтендов">Стратегии проектирования микрофронтендов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегии вертикальной нарезки** - основана на *предметно-ориентированном проектировании* (Domain-Driven Design, DDD), что предполагает, что приложение делится на **домены** (domain) - это предметные области, которые описывают разные цели бизнеса.

Суть вертикальной нарезки в том, чтобы спроектировать каждый микрофронтенд как самодостаточную систему, которая соответствует отдельной бизнес-функции. Тогда он будет включать всю необходимую внешнюю логику: от пользовательского интерфейса до уровня получения данных, который относится к его области.

Плюсы:
- каждый микрофронтенд предоставляет полный набор функций, который можно разрабатывать, тестировать и развертывать независимо от других;
- снижает зависимость между командами;
- упрощает управление проектами и масштабирование.

Минусы:
- тяжело определить границы каждого домена, так как на это влияет бизнес и тщательное планирование разработки.

Использование:
- когда есть **сложные пользовательские интерфейсы**, которые обслуживают разные бизнес-функции;
- когда есть **кросс-функциональные команды** вокруг бизнес-возможностей или клиентских путей, а не технологических стеков.

### <a id="Стратегия-автономность-команд" href="#Стратегия-автономность-команд">Стратегия автономность команд</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегия автономность команд** - основана на том, что каждая команда имеет возможность выбрать технологический стек, который подходит под ее задачи и использовать сильные стороны технологий, чтобы достичь оптимальной производительности и удобства работы пользователей.

Плюсы:
- способствует росту инноваций;
- помогает создавать более адаптированные технические решения;
- ускорение разработки и улучшение качества продукта.

Минусы:
- может привести к фрагментации и трудностям в управлении сквозными проблемами (стилизацией, доступностью и общей согласованностью пользовательского опыта).

Использование:
- когда есть **разные технологические потребности** - потому что разные части приложения выиграют от разных технологических стеков;
- когда есть **проекты, ориентированные на инновации и эксперименты**.

### <a id="Стратегия-изоляции" href="#Стратегия-изоляции">Стратегия изоляции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стратегия изоляции** - основана на том, что у микрофронтендов нет общих зависимостей во время выполнения. То есть каждый микрофронтенд должен включать все свои зависимости. Они инкапсулируются в его пакет развертывания. Общие библиотеки в микрофронтендах будут дублироваться, но их можно совместить с помощью стратегического управления версиями на более широком уровне. Изоляция необходима, чтобы избежать конфликтов версий и облегчить обновление или замену отдельных микрофронтендов.

Плюсы:
- снижается риск того, что изменения в одном микрофронтенде повлияют на другие;
- упрощение обновления и сопровождения, так как не нужно подстраиваться под все приложение.

Минусы:
- общие библиотеки включены в несколько микрофронтендов, и из-за этого размер приложения увеличится.

Использование:
- когда есть **частые обновления и развертывания** в средах, где микрофронтенды должны обновляться часто и независимо друг от друга. Это гарантирует, что обновления не помешают друг другу;
- когда нужно **независимо масштабировать разные части приложения** - у которых разные нагрузки и требования к производительности.

## <a id="Методы-интеграции-микрофронтендов" href="#Методы-интеграции-микрофронтендов">Методы интеграции микрофронтендов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Build time** - это объединение во время сборки - когда все компоненты помещаюся в контейнер. Мало отличается от монолитного фреймворка так как:
- нужно синхронизировать разные версии библиотек, иначе возникнут проблемы со сборкой;
- сложно использовать разные технологии;
- конечный бандл получится большим, ведь он содержит все зависимости;
- при появлении изменений в зависимостях, придется развертывать пакет заново;
- между контейнером и микрофронтендами будет тесная связь.

Подходит:
- когда нужно **упростить развертывание**, так как интеграция во время сборки ориентирована на единый механизм развертывания и единый исходный код, что дает на выходе единый пакет для развертывания;
- когда нужно **оставить тесное взаимодействие функций**, так как микрофронтенды тесно интегрированы с общими зависимостями;
- когда нужно **оптимизировать производительность**, так как интеграция во время сборки позволяет использовать разные техники оптимизации (tree-shaking, разделение кода), что способствует повышению производительности.

**Run time** - это объединение во время выполнения исполнения кода на стороне пользователя.

Подходит:
- когда нужно **развертывать модули независимо**, что позволит каждой команде развертывать свои изменения, не затрагивая другие части приложения;
- когда нужно **динамически обновлять отдельные модули** без переразвертывания всего приложения;
- когда нужно **сделать масштабирование гибким**, что позволит масштабировать разные части приложения независимо.

## <a id="Методы-композиции-микрофронтендов" href="#Методы-композиции-микрофронтендов">Методы композиции микрофронтендов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это процесс сборки нескольких микрофронтендов в единое целое.

**Серверная композиция** - когда все микрофронтенды собирают на сервере. Вся функциональность находится в бэкенде. Он решает, какой микрофронтенд собрать и загрузить. Сервер будет решать, к какому URL направить запрос.

Используется когда важен SEO и быстрый первоначальный отклик.

**Клиентская композиция** - когда браузер отвечает за динамическую загрузку каждого микрофронтенда во время выполнения.

Используется когда много интерактивного контента, который меняется в зависимости от взаимодействия с пользователем.

**Гибридная композиция** - состоит из серверной и клиентской композиции и использует для каждого микрофронтенда свой выделенный бэкенд Backend for Frontend (BFF). BFF обрабатывает все данные, взаимодействует с API и при необходимости предоставляет клиенту предварительно отрендеренный HTML. Это полезно для начальной загрузки страниц и SEO. Сервер передает клиенту полностью сформированную страницу.

## <a id="Инструменты-для-создания-микрофронтендов" href="#Инструменты-для-создания-микрофронтендов">Инструменты для создания микрофронтендов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Module-Federation" href="#Module-Federation">Module Federation</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это отдельный плагин Webpack.

Module Federation позволяет независимым приложениям использовать общий код во время выполнения. Он основан на функции **lazy loading**. Она позволяет приложению загружать фрагменты кода по требованию. Это сокращает время первоначальной загрузки и помогает оптимизировать использование ресурсов.

Есть две роли:
- **хост** (host) - это основное приложение, которое при запуске динамически загружает удаленные модули;
- **удаленный модуль** (remote) - это отдельный микрофронтенд, который предоставляет часть своей функциональности хосту или другим удаленным модулям.

Хост и удаленные модули могут использовать **общие зависимости**, используя функцию **shared dependencies**, которая позволяет эффективно управлять версиями и гарантирует, что приложение загрузит одну версию библиотеки, если это возможно.

### <a id="Single-SPA" href="#Single-SPA">Single SPA</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это JavaScript-фреймворк. Он позволяет использовать несколько JavaScript-фреймворков на одной странице, не обновляя ее целиком. Он предназначен для управления маршрутизацией и координацией между различными микрофронтендами.

Основные особенности:
- **framework agnostic** (независимость от фреймворков) - приложение не зависит от какого-то конкретного фреймворка, поэтому можно поддерживать сразу нескольких фреймворков на одной странице;
- **lazy loading** (ленивая загрузка) - приложение загружает фрагменты кода по требованию, что улучшает время первоначальной загрузки и производительность;
- **независимая развертываемость** - каждый микрофронтенд может быть развернут независимо и из-за этого проще поддерживать большие приложения, над которыми работают несколько команд.

Состоит из:
- **root** (рут, корень) - основное приложение, которое подгружает разные микрофронтенды;
- **микрофронтендов**, которые подключают к руту.

## <a id="Стратегии-управления-состоянием" href="#Стратегии-управления-состоянием">Стратегии управления состоянием</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Взаимодействие-на-основе-API" href="#Взаимодействие-на-основе-API">Взаимодействие на основе API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Коммуникация на основе API подразумевает, что бэкенд и микрофронтенды взаимодействуют через HTTP-запросы. Для обмена данными используют RESTful или GraphQL API.

Подходит когда:
- **микрофронтенды должны взаимодействовать с бэкендом, а не напрямую друг с другом** - они в основном занимаются получением или обновлением данных из централизованного бэкенда;
- **есть простой обмен данными**, которые нужны только чтобы отобразить их в компоненте или отправить форму;
- **высокие требования к производительности и масштабируемости** - что позволит каждому микрофронтенду обеспечить независимое масштабирование и оптимальную производительность. Это позволит каждому микрофронтенду самостоятельно получать данные и обновлять свое состояние.

### <a id="Паттерн-PubSub" href="#Паттерн-PubSub">Паттерн Pub/Sub</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется паттерн проектирования **Pub/Sub**, при котором компоненты системы выступают в роли **издателей** (publisher) или **подписчиков** (subscriber). При таком подходе компоненты не знают о существовании друг друга, они взаимодействуют только с **событиями** - публикуют их или подписываются на них.

**Event Bus** (шина событий) - это система обмена сообщениями, которая основана на паттерне **Pub/Sub**. События публикуются в шине событий. Компоненты-подписчики регистрируются в шине и указывают список событий, которые они хотят получать. Шина событий разделяет микрофронтенды, убирает взаимозависимость и обеспечивает гибкость.

Подходит когда:
- **предпочтительно несвязанное соединение** между микрофронтендами, что позволяет им взаимодействовать без прямых зависимостей, что упрощает добавление, удаление или обновление микрофронтендов;
- **используется архитектура, управляемая событиями** (event-driven architecture, EDA) - действия или обновления в одной части приложения вызывают реакции в других частях и это эффективно для обновлений в реальном времени и асинхронных коммуникаций;
- **есть независимое развертывание**, так как помогает отделить логику взаимодействия от фактической реализации.

### <a id="Библиотека-глобального-состояния" href="#Библиотека-глобального-состояния">Библиотека глобального состояния</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При использовании библиотеки глобального состояния разные микрофронтенды могут получить доступ к общему состоянию и изменять его. Библиотека сама ходит в базу данных через API и обновляет данные на фронтенде.

Этот подход гарантирует, что все части приложения синхронизируются и последовательно взаимодействуют с пользователем.

Подходит когда:
- **есть тесная связь между разными частями приложения** и нужно, чтобы разные части приложения совместно использовали глобальное состояние, а информация там всегда была актуальной, так как несколько микрофронтендов читают из одного состояния и записывают в него обновления;
- **важно поддерживать последовательный пользовательский опыт**, это получается благодаря общему состоянию, из-за которого поддерживается единообразие и согласованность в разных частях приложения;
- **есть сложные требования к управлению состояниями** когда оно вложенное или иерархическое.

## <a id="Паттерн-Backend-for-Frontend" href="#Паттерн-Backend-for-Frontend">Паттерн Backend for Frontend</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Backend for Frontend** (бэкенд для фронтенда, BFF) - это подход к проектированию, при котором каждый фронтенд обслуживает специальный бэкенд - промежуточный слой между фронтендом и внутренними сервисами, для того чтобы абстрагировать фронтенд от сложностей бэкенда. BFF отвечает за сбор информации от разных микросервисов, ее обработку и доставку на фронтенд в удобном формате.

Используется при архитектурах когда есть:
- **монолитный фронтенд и микросервисы** - для того чтобы абстрагировать фронтенд от сложностей бэкенда;
- **несколько клиентов, которые используют разные технологии** для передачи данных, для того чтобы не усложнять бекенды поддержкой разных технологий;
- **микросервисы и микрофронтенды** для организации взаимодействие между ними.

Этот подход позволяет:
- **подготавливать данные для конкретного фронтенда**, что снижает необходимость дополнительной обработки данных на стороне клиента;
- **упростить логику на стороне клиента**, так как обрабатывает сложные логические операции на стороне сервера - агрегацию, композицию и преобразованию данных, что снижает сложность кода фронтенда и улучшает его сопровождение;
- **увеличить производительность**, так как передается меньше данных по сети и выполняется меньше запросов из фронтенда;
- **усилить безопасность**, так как запросы пользователей на BFF могут аутентифицироваться и авторизовываться перед передачей внутренним службам.

<a id="Микросервисы" href="#Микросервисы">Микросервисы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

## <a id="Паттерн-Strangler-Fig" href="#Паттерн-Strangler-Fig">Паттерн Strangler Fig</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Этот паттерн предлагает итеративный подход к миграции от монолита к микросервисам, когда новую систему постепенно создают по краям старой: компоненты по очереди извлекают из монолита и заменяют на микросервисы. При релизе каждого микросервиса запросы от монолита перенаправляют к новой системе. В итоге бэкенд отмирает по кусочкам, а команда может дорабатывать готовые микросервисы по отзывам пользователей.

Такой подход позволяет постоянно совершенствовать систему и минимизировать риски, которые связаны с большими изменениями.

Основные преимущества:
- **постепенная замена монолита** - позволяет уменьшить количество сбоев и повысить адаптивность новой системы из-за того, что части монолита заменяются микросервисами итеративно;
- **снижение рисков и управление ими**, так как инкрементные изменения небольшие, то их легче тестировать, отслеживать и откатывать, что уменьшает количество сбоев. Микросервисы запускают параллельно с существующими монолитными компонентами, что позволяет в случае проблем перенаправить запросы обратно на компонент монолита с помощью маршрутизации;
- **инкрементная доставка новых функций в процессе миграции** из-за того, что приложение продолжает развиваться и новые функции и улучшения можно релизить по готовности не дожидаясь окончания миграции;
- **эффективное решение проблемы технического долга**, так как есть систематический рефакторинг из-за того, что каждый микросервис можно спроектировать и разработать с использованием лучших практик и современных технологий, а также позволит разработать документацию и поддержать стандарты. И при этом замена начинается с устаревших компонентов в первую очередь и в этом случае каждое обновление будет повышать производительность системы и упрощать ее обслуживание.

Шаги по реализации паттерна Strangler Fig:
1. **Определение компонента, который нужно извлечь из монолита** - нужно определить и приоритизировать компоненты монолитного приложения, которые должны быть извлечены. Компонент выбирается с помощью техник:
    - анализ домена бизнеса;
    - технический анализ;
    - анализ показателей производительности.

2. **Проектирование и разработка нового микросервиса** с учетом принципов проектирования:
    - у микросервиса есть единственная, четко определенная зона ответственности;
    - микросервис должен минимально зависить от других сервисов;
    - связанная функциональность должны быть сгруппирована в рамках одного сервиса для поддержания высокой согласованности.

3. **Перенаправление запросов от монолита к микросервису** с помощью:
    - **маршрутизации на основе прокси**:
        - **обратный прокси-сервер**, который будет использоваться для маршрутизации запросов либо к монолиту, либо к новым микросервисам на основе определенных правил;
        - **API-шлюз** - реализуется для управления и маршрутизации трафика, обеспечивая единую точку входа для всех клиентских запросов;
    - **фича-тогглов** - переключатели функций нужны для управления развертыванием новых функций, чтобы постепенно перенаправлять трафик на новые сервисы;
    - **канареечных релизов**, которые постепенно переводят трафик на новые услуги, отслеживая производительность и стабильность перед полным развертыванием.

4. **Внедрения мониторинга и верификаци для микросервиса**. Для оценки производительности и надежности микросервисов используются количественные показатели - **метрики производительности** для каждого микросервиса с пороговым значением уровня производительности:
    - **ключевые показатели эффективности** (Key Performance Indicators, KPI), которые состоят из показателей:
        - времени отклика;
        - частоты ошибок;
        - пропускной способности;
        - количество запросов в секунду.
    - **цели уровня сервиса** (Service-Level Objectives, SLO) - это четко определенные цели в области производительности и доступности сервиса, которые ставятся на основе бизнес-требований, таких как время безотказной работы или время отклика;
    - **индикаторы уровня обслуживания** (Service Level Indicator, SLI) - это количественная оценка работы сервиса, показывающая, выполняются ли SLO, определяются для критических показателей и отслеживаются на соответствие с заданными SLO. К ним относят:
        - латентность - время, необходимое для обработки запроса;
        - доступность - доля времени, в течение которого сервис работает;
        - частота ошибок.

    Для отслеживания производительности, работоспособности и доступности сервисов используются **средства мониторинга**, которые собирают и анализируют данные, чтобы помочь обнаружить проблемы и обеспечить бесперебойную работу служб:
    - **мониторинг производительности приложений** (Application Performance Monitoring, APM), которые отслеживают производительность приложений и отдельных микросервисов в режиме реального времени, предоставляют информацию о времени отклика, количестве ошибок и взаимодействии с пользователями;
    - **централизованное логирование**, которые объединяют журналы различных служб в одном месте, что упрощает поиск, анализ и устранение проблем;
    - **мониторинг инфраструктуры**, которые следят за состоянием и производительностью базовой инфраструктуры (серверы, контейнеры, сетевые компоненты и т.п.).

    Для обеспечивания правильного функционирования новых микросервисов в соответствии с ожидаемым стандартом производительности и надежности используются **методы верификации**:
    - **автоматизированное тестирование** - юнит-тесты, интеграционные тесты, e2e-тесты, которые проверяет функциональность, производительность и интеграцию микросервисов на их соответствие заданным критериям при каждом коммите кода в системе контроля версий;
    - **А/B-тестирование** - для тго чтобы сравнивать производительность и влияние на пользователей двух версий сайта, приложения или сервиса, чтобы определить, какая из них работает лучше с помощью перенаправления части запросов на новую версию, а остальную часть - на старую.

5. **Возвращение к шагу 1 до тех пор, пока весь монолит не будет заменен на микросервисы**. Состоит из:
    - **инкрементального извлечения**, которое предполагает разбиение монолитного приложения на более мелкие, управляемые компоненты и постепенную замену их микросервисами;
    - **непрерывного улучшения**, которое направлено на регулярное усовершенствование новых микросервисов с помощью рефакторинга и оптимизации (по мере необходимости) и всей системы в целом на основе данных о производительности с помощью инструментов APM, анализу обратной связи и меняющихся потребностей бизнеса;
    - **координации работы команды** с помощью сотрудничества между кросс-функциональными командами - разработки, эксплуатации и бизнеса для согласования целей и прогресса, четкой коммуникации с помощью регулярных встреч которые необходимы для обсуждения прогресса, выявления препятствий и планирования следующих шагов, и последовательного документирование на протяжении всего процесса для обеспечения последовательности и обмена знаниями.

Распространенные проблемы:
- **недостаточное планирование** из-за слишком поспешной реализация миграции без чёткого плана;
- **отсутствие поддержки заинтересованных сторон** из-за отсутствия понимания предполагаемых рисков;
- **недостаточный мониторинг и тестирование** из-за неспособности адекватно контролировать новые сервисы, что может привести к незамеченным проблемам, влияющим на производительность;
- **игнорирование зависимостей** между компонентами, которые приводят к сбоям или неожиданному поведению;
- **неполная документация** которая может привести к путанице и несогласованным реализациям;
- **игнорирование проблем управления и обмен данными** между монолитом и микросервисами, которые приводят к несогласованности и проблемам целостности данных.