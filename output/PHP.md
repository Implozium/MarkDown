[Содержание](#Содержание)
==========

- [Основы PHP](#Основы-PHP)
    - [Код PHP](#Код-PHP)
    - [Оператор echo](#Оператор-echo)
    - [Синтаксис HEREDOC](#Синтаксис-HEREDOC)
    - [Комментарии в скриптах](#Комментарии-в-скриптах)
    - [Переменные](#Переменные)
    - [Ссылки](#Ссылки)
    - [Константы в PHP](#Константы-в-PHP)
        - [Поддержка массивов в объявлениях `define` (PHP7)](#Поддержка-массивов-в-объявлениях-define-PHP7)
    - [Типы данных](#Типы-данных)
        - [Скалярные типы (PHP7)](#Скалярные-типы-PHP7)
    - [Математические операторы и математические функции](#Математические-операторы-и-математические-функции)
    - [Операторы присвоения](#Операторы-присвоения)
    - [Увеличение и уменьшение](#Увеличение-и-уменьшение)
    - [Приоритет операторов](#Приоритет-операторов)
    - [Оператор исполнения](#Оператор-исполнения)
    - [Строковые операторы](#Строковые-операторы)
    - [Условные операторы](#Условные-операторы)
        - [Условный оператор if](#Условный-оператор-if)
        - [Операторы сравнения](#Операторы-сравнения)
        - [Логические операторы](#Логические-операторы)
        - [Тернарный оператор](#Тернарный-оператор)
        - [Объединенный оператор сравнения (PHP7)](#Объединенный-оператор-сравнения-PHP7)
        - [?? - Оператор null coalescing (PHP7)](#---Оператор-null-coalescing-PHP7)
        - [Оператор switch](#Оператор-switch)
    - [Цикл for](#Цикл-for)
    - [Цикл while](#Цикл-while)
    - [Цикл do ... while](#Цикл-do--while)
    - [Цикл foreach](#Цикл-foreach)
        - [foreach (PHP7)](#foreach-PHP7)
    - [Оператор break](#Оператор-break)
    - [Оператор continue](#Оператор-continue)
    - [Альтернативный синтаксис](#Альтернативный-синтаксис)
    - [Оператор include](#Оператор-include)
    - [Оператор require](#Оператор-require)
    - [Исключения](#Исключения)
    - [Оператор управления ошибками `@`](#Оператор-управления-ошибками-)
- [Тип данных: строка](#Тип-данных-строка)
    - [Поддержка юникод управляющих (escape-) последовательностей (PHP7)](#Поддержка-юникод-управляющих-escape--последовательностей-PHP7)
    - [Функции для обработки строк](#Функции-для-обработки-строк)
    - [Кодировки](#Кодировки)
- [Регулярные выражения](#Регулярные-выражения)
    - [Модификаторы](#Модификаторы)
    - [Функция `preg_replace_callback_array()` (PHP7)](#Функция-pregreplacecallbackarray-PHP7)
- [Массивы](#Массивы)
    - [Функции для работы с массивами](#Функции-для-работы-с-массивами)
    - [Дополнительные методы](#Дополнительные-методы)
    - [JSON](#JSON)
    - [URL](#URL)
- [Работа с файловой системой](#Работа-с-файловой-системой)
    - [Функции для работы с файлами](#Функции-для-работы-с-файлами)
    - [Функции для работы с каталогами](#Функции-для-работы-с-каталогами)
- [Дата](#Дата)
    - [Функции для работы с датой](#Функции-для-работы-с-датой)
    - [Объект DateTime](#Объект-DateTime)
    - [Объект DateInterval](#Объект-DateInterval)
- [Сессии](#Сессии)
- [Функции](#Функции)
    - [Объявления типов](#Объявления-типов)
    - [Объявления возвращаемых типов (PHP7)](#Объявления-возвращаемых-типов-PHP7)
    - [Методы доступные в функции](#Методы-доступные-в-функции)
    - [Генераторы](#Генераторы)
        - [Возврат выражений в генераторах (PHP7)](#Возврат-выражений-в-генераторах-PHP7)
        - [Делегирование генераторов (PHP7)](#Делегирование-генераторов-PHP7)
    - [callable](#callable)
- [Взаимодействие с HTML](#Взаимодействие-с-HTML)
    - [Загрузка файлов на сервер](#Загрузка-файлов-на-сервер)
    - [Выгрузка файла](#Выгрузка-файла)
- [ООП](#ООП)
    - [Основные термины и понятия](#Основные-термины-и-понятия)
    - [Классы](#Классы)
        - [Анонимные классы (PHP7)](#Анонимные-классы-PHP7)
    - [Интерфейсы](#Интерфейсы)
    - [Перегрузка свойств](#Перегрузка-свойств)
    - [Перегрузка методов](#Перегрузка-методов)
    - [Метод `__toString`](#Метод-toString)
    - [Метод `__invoke`](#Метод-invoke)
    - [Клонирование объектов](#Клонирование-объектов)
    - [Метод `__clone`](#Метод-clone)
    - [Контроль типа](#Контроль-типа)
    - [Трейты](#Трейты)
    - [Сериализация](#Сериализация)
- [Пространства имен](#Пространства-имен)
    - [Группировка объявлений `use` (PHP7)](#Группировка-объявлений-use-PHP7)
- [PDO](#PDO)
- [SimpleXML](#SimpleXML)
- [Шаблоны Smarty](#Шаблоны-Smarty)
    - [Подключение](#Подключение)
    - [Строение шаблонов](#Строение-шаблонов)
    - [Встроенные функции](#Встроенные-функции)
        - [Функция `config_load`](#Функция-configload)
        - [Функция `capture`](#Функция-capture)
        - [Функция `section`](#Функция-section)
        - [Функция `foreach`](#Функция-foreach)
        - [Оператор `if, elseif, else`](#Оператор-if-elseif-else)
        - [Функция `include`](#Функция-include)
        - [Функция `literal`](#Функция-literal)
        - [Функция `assign`](#Функция-assign)
    - [Функция php](#Функция-php)
    - [Модификаторы](#Модификаторы)
    - [Конфигурационные файлы](#Конфигурационные-файлы)
    - [Использование шаблонов](#Использование-шаблонов)
- [PHP 7](#PHP-7)
    - [Метод `call()` у замыканий Closure (PHP7)](#Метод-call-у-замыканий-Closure-PHP7)
    - [Ожидания - Expectations (PHP7)](#Ожидания---Expectations-PHP7)
    - [Целочисленное деление `intdiv()` (PHP7)](#Целочисленное-деление-intdiv-PHP7)
    - [Функции CSPRNG (PHP7)](#Функции-CSPRNG-PHP7)
    - [Целочисленная семантика (PHP7)](#Целочисленная-семантика-PHP7)

<a id="Основы-PHP" href="#Основы-PHP">Основы PHP</a>
==========

## <a id="Код-PHP" href="#Код-PHP">Код PHP</a>

```php
<?php <php_код>?>
```

```php
<?<php_код>?>
```
если включена опция `short_open_tag` в **php.ini**.

`@<функция>(...)` - подавление предупреждений или ошибок.

## <a id="Оператор-echo" href="#Оператор-echo">Оператор echo</a>

`echo {'<строка>' | <значение>}[, ...];` - вывод текста на экран.  
`<?=<строка>?>` - сокращенная запись.

## <a id="Синтаксис-HEREDOC" href="#Синтаксис-HEREDOC">Синтаксис HEREDOC</a>

Используется для отображения большого количества текста. Он начинается с символов `<<<`, после которых может быть записан произвольный идентификатор. После располагаемого текста стоит указать тот самый идентификатор, что и в начале кода.

```php
<<<<идентификатор>
<текст>
<идентификатор>
```

## <a id="Комментарии-в-скриптах" href="#Комментарии-в-скриптах">Комментарии в скриптах</a>

```php
/*<многострочный_комментарий>*/
//<однострочный_комментарий>
#<однострочный_комментарий>
```

## <a id="Переменные" href="#Переменные">Переменные</a>

**Переменная** - контейнер c данными. Каждая переменная содержит определенное значение. Синтаксис переменной состоит из знака доллара - `$` и "*свободного*" идентификатора которому присваивается какое-нибудь значение:  
`$<переменная> = <значение>;`

Имя (идентификатор) переменной не может начинаться с цифр и пробела. Имя переменной чувствительно к регистру.

Переменная создается тогда, когда ей присваивают какое-нибудь значение. Для присвоения значения переменной используют оператор присвоения, который состоит из знака равенства `=`.

Если значение переменной заключено в двойные (не одинарные) кавычки `"`, то переменная **интерполируется**. Для этого нужно взять имя переменной в фигурные скобки:  
`{$<переменная>}`

> `'Hello, my name is ${name}'`

И таким образом ее можно использовать в строках, просто вставляя ее, если она отделена пробелами, то можно просто:  
`$<переменная>`.

Также возможно размещать в значении переменных не только обычные значения, но и имена других переменных:  
`$<переменная1> = <значение>;`  
`$<переменная2> = "<переменная1>";`  
`$$<переменная2>` - берет значение переменной и рассматривает его как имя переменной, содержит тоже значение, что и `<переменная1>`.  
`${$<переменная2>}` - для интерполирования внутри строк.

Вызов функции через переменную:  
`$<переменная> = "<имя_функции>";`  
`$<переменная>(...)` - вызов функции.

Управление и проверка переменных:  
`isset($<переменная>)` - возвращает `true`, если переменная установлена.  
`empty($<переменная>)` - проверяет, пуста ли переменная - если она не существует или её значение равно `false`, то возвращает `true`. Является точным эквивалентом конструкции: `!isset($<переменная>) || $<переменная> == false`.  
`unset($<переменная>)` - удаляет переменную, присваивает ей значение `NULL`.

## <a id="Ссылки" href="#Ссылки">Ссылки</a>

`$<переменная1> = &$<переменная2>;` - присвоение по ссылке, теперь `$<переменная1>` ссылается на `$<переменная2>`, и любые изменения `$<переменная1>` будут изменять ту переменную на которую она ссылается.

## <a id="Константы-в-PHP" href="#Константы-в-PHP">Константы в PHP</a>

`define("<константа>", <значение>[, true]);` - определение константы [с нечувствительностью к регистру].  
`<константа> `- возвращает результат константы.  
`constant("<константа>")` - возвращает результат константы.  
`defined("<константа>")` - возвращает `true`, если константа определена.

Стандартные константы:
- `__LINE__` - номер текущей строки скрипта;
- `__FILE__` - полное имя файла текущего скрипта;
- `__FUNCTION__` - имя текущей исполняемой функции;
- `__CLASS__` - имя текущего класса;
- `__METHOD__` - имя текущего метода класса;
- `PHP_VERSION` - версия PHP;
- `PHP_OS` - операционная система под управлением которой работает PHP;
- `DEFAULT_INNCLUE_PATH` - список путей, в которых PHP ищет подключаемые файлы.



### <a id="Поддержка-массивов-в-объявлениях-define-PHP7" href="#Поддержка-массивов-в-объявлениях-define-PHP7">Поддержка массивов в объявлениях `define` (PHP7)</a>

`define('<объявление>', <массив>);`

## <a id="Типы-данных" href="#Типы-данных">Типы данных</a>

PHP является языком динамической типизации, тип переменной определяется на основе её значения.

Основные типы, которые можно использовать в PHP:
- `Boolean` - логический тип, который содержит значение `TRUE` или `FALSE` (`true` или `false`);
- `Integer` - содержит значения целого числа из множества целых чисел *Z = {..., -2, -1, 0, 1, 2, ...}*, по желанию с предшествующим знаком `-` или `+`. Для восьмеричной системы счисления, необходимо предварить число `0` (нулем), для использования шестнадцатеричной системы нужно поставить перед числом `0x`;
- `String` - содержит значение текста произвольной длины, может быть определена тремя различными способами: с помощью одинарных кавычек (при этом переменные и управляющие последовательности для специальных символов не обрабатываются); с помощью двойных кавычек; heredoc-синтаксисом (-текст ведет себя так же, как и строка в двойных кавычках, при этом их не имея);
- `Float` - вещественное число;
- `Object` - объект;
- `Array` - массив;
- `Resource` - ресурс - это специальная переменная, содержащая ссылку на внешний ресурс. Ресурсы создаются и используются специальными функциями;
- `NULL` - значение `NULL`, говорит о том, что переменная не имеет значения. Переменная считается `NULL`, если: ей была присвоена константа `NULL`; ей еще не было присвоено какое-либо значение; она была удалена с помощью `unset()`.

Для предотвращения появления ошибок рекомендуется не смешивать разные типы данных. Чтобы явно изменить тип данных переменной, то для этого нужно слева от имени переменной в круглых скобках указать нужный тип:  
`(<тип>)$<переменная>`

### <a id="Скалярные-типы-PHP7" href="#Скалярные-типы-PHP7">Скалярные типы (PHP7)</a>

Теперь в объявлениях переменных можно указывать их тип, даже если они являются скалярными (числа и строки).

По умолчанию используется преобразование для приведения к заданному типу. Типы:
- строки (`string`)
- целые (`int`)
- числа (`float`)
- логические (`bool`) 
- типы аргументов 
- названия классов
- интерфейсы
- массив `array`
- выполняемые `callable` аргументы

Режим строгой типизации распространяется на вызовы функций совершенные из файла, в котором этот режим включен, а не на функции, которые в этом файле объявлены. Если файл без строгой типизации вызывает функцию, которая объявлена в файле с включенным режимом, значения аргументов будут приведены к нужным типам и ошибок не последует.

Чтобы включить строгий `strict` режим проверки, нужно в начале (каждого) файла, обязательно 1-ой строкой добавить вызов:  
`declare(strict_types=1);`

## <a id="Математические-операторы-и-математические-функции" href="#Математические-операторы-и-математические-функции">Математические операторы и математические функции</a>

- `+` - сумма двух чисел;
- `-` - разность чисел;
- `/` - частное от деления двух чисел;
- `%` - остаток от деления.

Математические функции:
- `abs` - модуль числа;
- `sin` - синус;
- `sinh` - гиперболический синус;
- `cos` - косинус;
- `cosh` - гиперболический косинус;
- `acos` - арккосинус;
- `acosh` - гиперболический арккосинус;
- `asin` - арксинус;
- `asinh` - гиперболический арксинус;
- `atan2` - арктангенс частного двух переменных;
- `tan` - тангенс;
- `tanh` - гиперболический тангенс;
- `atan` - арктангенс;
- `atan` - гиперболический арктангенс;
- `base_convert` - преобразование числа в строковом представлении из одной системы счисления в другую;
- `decoct` - преобразование числа в восьмеричное представление в виде строки;
- `bindec` - преобразование строки, предоставленной в двоичном числе, в целое значение;
- `octdec` - преобразование строки, представляющей восьмеричное число, в целое число;
- `hexdec` - преобразование строки, которая представляет шестнадцатеричное число, в целое число;
- `ceil` - округление числа в большую сторону;
- `floor` - округление числа в меньшую сторону;
- `deg2rad` - градусы в радианы;
- `exp` - вычисление экспоненты числа;
- `fmod` - остаток от деления двух чисел;
- `getrandmax` - макс. значение, которое получают функцией `rand()`;
- `hypot` - вычисление гипотенузы по двум катетам;
- `is_finite` - проверка, является ли число конечным вещественным числом;
- `is_infinite` - проверка, является ли число бесконечностью;
- `is_nan` - проверка, является ли значение не числом (not-a-number);
- `lcg_value` - генератор случайных чисел;
- `log10` - десятичный логарифм;
- `log` - натуральный логарифм;
- `max` - максимум заданных чисел;
- `min` - минимум заданных чисел;
- `mt_getrandmax` - макс. значение, которое можно получить функцией `mt_rand`;
- `mt_rand` - генератор псевдослучайных чисел по алгоритму;
- `pi` - значение числа *π*;
- `pow` - возведение в степень;
- `round` - округляет число типа float;
- `sqrt` - квадратный корень.

## <a id="Операторы-присвоения" href="#Операторы-присвоения">Операторы присвоения</a>

Основным оператором присвоения является знак равенства `=`. Он присваивает значение определенной переменной. В одной строке можно присвоить одно значение сразу нескольким переменным:  
`$<переменная1> = $<переменная2> [= ...] = <значение>;`

Комбинированные операторы, которые вычисляют и одновременно присваивают значение переменной:  
`+=`, `-=`, `/=`, `.=`, `%=`, `&=`, `|=`, `^=`, `<=`, `>=`

`$<переменная> <комбинированный_оператор> <дельта_значение>;`

## <a id="Увеличение-и-уменьшение" href="#Увеличение-и-уменьшение">Увеличение и уменьшение</a>

Оператор `++` называют инкрементом, а `--` декрементом. Они возвращают значение и присваивают новое измененное значение.

- `++$<переменная>` - пре-инкремент. Увеличивает значение на единицу;
- `$<переменная>++` - пост-инкремент. Возвращает текущее значение, после чего увеличивает его на единицу;
- `--$<переменная>` - пре-декремент. Уменьшает значение на единицу;
- `$<переменная>--` - пост-декремент. Возвращает текущее значение, после чего уменьшает его на единицу.

## <a id="Приоритет-операторов" href="#Приоритет-операторов">Приоритет операторов</a>

Таблица операторов по убыванию приоритета (операторы с одним приоритетом выполняются слева на право):
1. `new`
2. `[`
3. `!` `~` `++` `--` `(int)` `(float)` `(string)` `(array)` `(object)`
4. `@`
5. `*` `/` `%`
6. `+` `-` `.`
7. `<` `>`
8. `<` `<=` `>` `>=`
9. `&`
10. `^`
11. `|`
12. `&&`
13. `||`
14. `? :`
15. `=` `+=` `-=` `*=` `/=` `.=` `%=` `&=` `|=` `^=` `<=` `>=`
16. `print`
17. `and`
18. `xor`
19. `or`
20. `,`

Для изменения порядка выполнения операторов необходимо использовать круглые скобки.

## <a id="Оператор-исполнения" href="#Оператор-исполнения">Оператор исполнения</a>

Любая строка, которая заключена в обратные апострофы - `` ` `` считаются как команда ОС, т. е. выполняет команды ОС и возвращает результат этого выполнения:  
``$<переменная> = `<команда_ОС>`;``

## <a id="Строковые-операторы" href="#Строковые-операторы">Строковые операторы</a>

Оператор конкатенации `.` - который объединяет две строки в одну.  
Конкатенирующий оператор присвоения `.=` - добавляет к строке нужное значение.

## <a id="Условные-операторы" href="#Условные-операторы">Условные операторы</a>

### <a id="Условный-оператор-if" href="#Условный-оператор-if">Условный оператор if</a>

```php
if (<условие>) {
   <код_при_истинном_условии>
}[ else if (<условие1>) { // или elseif
   <код_при_истинном_условии1>
}]
[...]
[ else {
   <код_при_ложном_условии>
}]
```

Где `<условие>`: `<левая_часть> <оператор> <правая_часть>`

### <a id="Операторы-сравнения" href="#Операторы-сравнения">Операторы сравнения</a>

- `==` - *равенство* - истина, если `<левая_часть>` равна `<правая_часть>`;
- `===` - *идентичность* - истина, если `<левая_часть>` равна `<правая_часть>`, и они одного и того же типа;
- `!=` - *неравенство* - истина, если `<левая_часть>` не равна `<правая_часть>`;
- `<>` - *неравенство* - истина, если `<левая_часть>` не равна `<правая_часть>`;
- `!==` - *неидентичность* - истина, если `<левая_часть>` не равна `<правая_часть>`, или они не одного типа;
- `<` - *меньше* - истина, если `<левая_часть>` меньше `<правая_часть>`;
- `>` - *больше* - истина, если `<левая_часть>` больше `<правая_часть>`;
- `<=` - *меньше или равно* - истина, если `<левая_часть>` меньше или равна `<правая_часть>`;
- `>=` - *больше или равно* - истина, если `<левая_часть>` больше или равна `<правая_часть>`.

### <a id="Логические-операторы" href="#Логические-операторы">Логические операторы</a>

- `and` - *логическое "И"* - истина, если истинно `<левая_часть>` и `<правая_часть>`;
- `&&` - *логическое "И"* - истина, если истинно `<левая_часть>` и `<правая_часть>`;
- `or` - *логическое "ИЛИ"* - истина, если истинно `<левая_часть>` или `<правая_часть>`;
- `||` - *логическое "ИЛИ"* - истина, если истинно `<левая_часть>` или `<правая_часть>`;
- `xor` - *логическое "Исключающее ИЛИ"* - истина, если истинно `<левая_часть>` или `<правая_часть>`, но не оба одновременно;
- `!` - *логическое "НЕ"* - истина, если `<левая_часть>` ложь.

### <a id="Тернарный-оператор" href="#Тернарный-оператор">Тернарный оператор</a>

`<условие>?<выражение1>:<выражение2>` - если условие выполняется, то возвращает результат вычисления `<выражение1>`, иначе `<выражение2>`.

`<выражение1>?:<выражение2>` - если `<выражение1>` задано и не равно `null`, то возвращает `<выражение1>`, иначе `<выражение2>`.

### <a id="Объединенный-оператор-сравнения-PHP7" href="#Объединенный-оператор-сравнения-PHP7">Объединенный оператор сравнения (PHP7)</a>

Объединенный оператор сравнения - используется для операция трехстороннего сравнения двух операндов.
Записывается в форме `x = a <=> b`. Возвращает одно из трех значений:
- `1` - если a > b;
- `0` - если a = b;
- `-1` - если a < b.

Оператор имеет одинаковый приоритет с операциями сравнения (`==`, `!=`, `===`, `!==`) и работает также как и операторы (`<`, `>=`, ...)

Также он не ассоциативен.

Можно сравнивать массивы. Объекты данным оператором сравнивать нельзя.

### <a id="---Оператор-null-coalescing-PHP7" href="#---Оператор-null-coalescing-PHP7">?? - Оператор null coalescing (PHP7)</a>

Оператор является сокращенным вариантом вызова `isset` в тернарном операторе `?:`.
> `isset($<переменная>) ?: <значение>`

`$<переменная> ?? <значение_если_NULL>` - если значение будет равно `NULL`, то вернет `<значение_если_NULL>`, иначе вернет самого себя.

### <a id="Оператор-switch" href="#Оператор-switch">Оператор switch</a>

```php
switch (<условие>) {
    case <выражение1>:
        [<код_при_условии_равном_выражению1>]
    [break;]
    [...]
    [default:
        <код_по_умолчанию>
    break;]
}
```

Сначала записывается ключевое слово `switch`, после которого в скобках записывается некоторое выражение. Далее после слова `case` нужно перечислить возможные варианты значений, если значение Истина, то выполняется оператор вплоть до оператора `break`. Если ни одно условие не походит, то выполняется оператор `default` (если оператор `default` не записывать, то при не совпадении значений ничего не будет выполнятся).

## <a id="Цикл-for" href="#Цикл-for">Цикл for</a>

```php
for (<инициализация_начала_цикла>; <условие>; <выражение_после_итерации>) {
    <код_итерации_цикла>
}
```

## <a id="Цикл-while" href="#Цикл-while">Цикл while</a>

Условие проверяется перед выполнением цикла, если оно будет *ложным* в начале, то цикл не выполнится ни разу. В теле цикла должна быть переменная которая будет оказывать влияние на условие, чтобы предотвратить зацикливание.

```php
while (<условие>) {
    <код_итерации_цикла>
}
```

## <a id="Цикл-do--while" href="#Цикл-do--while">Цикл do ... while</a>

Главное отличие цикла `do ... while` от `while` в том, что первый сначала выполняется тело цикла, а потом проверяет условие. Т.е., если условие сразу *Ложь*, то цикл выполнится один раз.

```php
do {
    <код_итерации_цикла>
} while (<условие>)
```

## <a id="Цикл-foreach" href="#Цикл-foreach">Цикл foreach</a>

Цикл `foreach` представлен для упрощения работы с массивами. Массивы состоят из отдельных элементов, цикл `foreach` предназначен для перебора этих элементов без счетчика, где на каждой итерации в переменные `$<ключ>`, `$<значение>` помещаются последовательно все элементы массива.

```php
foreach ($<массив> as [$<ключ> =>] $<значение>) {
    <код_итерации_перебора>
}
```

### <a id="foreach-PHP7" href="#foreach-PHP7">foreach (PHP7)</a>

`foreach` может итерировать:
- **по значению**
    > `foreach ($a as $v)`;
- **по ссылке**
    > `foreach ($a as &$v)`.

`foreach` может перебирать:
- **массив**
    > `$x = [1,2,3]; foreach ($x as $v)`;
- **простой объект**
    > `$x = new SomeClass(); foreach ($x as $v)`;
- **итератор**
    > `$x = new SomeIteratorClass(); foreach ($x as $v)`.

**Итерация массива по значению** - никогда не использует и не меняет внутренний указатель массива. Не делает копию массива, а закрывает оригинальный массив. Модификации оригинального массива игнорируются.

**Итерация массива по ссылке** - изменяет внутренний указатель (передвигает его на следующий элемент). Модификация внутреннего указателя функциями `next()`, `reset()`, `end()` не отражаются на указателе `foreach`, при следующей итерации `foreach` восстановит свой указатель. Удаление следующего элемента (указателя `foreach`) удалит его из перебора. Добавление новых элементов после указателя, добавит их в перебор. Добавление новых элементов после указателя (когда мы находимся в конце массива), все равно добавит их в перебор. Возможно изменение массива, итерируемого в ссылочном `foreach` используя функции `array_pop()`, `array_push()`, `array_shift()`, `array_unshift()` - эти функции сохраняют указатель массива `foreach` или передвигают его к следующему элементу, если текущий удален.

## <a id="Оператор-break" href="#Оператор-break">Оператор break</a>

Оператор `break` заканчивает выполнение текущего цикла, будь то `for`, `foreach`, `while`, `do ... while` или `switch`. `break` может использоваться с числовым аргументом, который говорит, работу скольких управляющих структур, содержащих его, нужно завершить.

## <a id="Оператор-continue" href="#Оператор-continue">Оператор continue</a>

Оператор `continue` позволяет пропустить дальнейшие инструкции из блока выполнения любого цикла и продолжить выполнение с нового круга. `continue` можно использовать с числовым аргументом, который указывает, сколько содержащих его управляющих конструкций должны завершить работу.

## <a id="Альтернативный-синтаксис" href="#Альтернативный-синтаксис">Альтернативный синтаксис</a>

PHP предлагает альтернативный синтаксис для некоторых своих управляющих структур, а именно для `if`, `while`, `for`, `foreach` и `switch`. В каждом случае открывающую скобку нужно заменить на двоеточие `:`, а закрывающую - на `endif;`, `endwhile;`, `endfor;`, `endforeach;` и `endswitch;` соответственно:  
`<управ_конструкция>: <блок_выполнения> end<управ_конструкция>;`

Использование такого синтаксиса полезно при встраивании php в html-код.

## <a id="Оператор-include" href="#Оператор-include">Оператор include</a>

Оператор `include` позволяет включать код, содержащийся в указанном файле, и выполнять его столько раз, сколько программа встречает этот оператор. Включение может производиться любым из перечисленных способов:  
`include '<имя_файла>';`  
`include $<имя_файла>;`  
`include ("<имя_файла>");`

Использование оператора `include` эквивалентно простой вставке содержательной части файла в код программы. В момент вставки файла происходит переключение из режима обработки PHP в режим HTML. Поэтому код внутри включаемого файла, который нужно обработать как PHP-скрипт, должен быть заключен в соответствующие теги.

`include_once` - аналогично `include`, только включается один раз, для предупреждения возникновения дубликатов.

## <a id="Оператор-require" href="#Оператор-require">Оператор require</a>

Подобно `include`, `require` также позволяет включать в программу и исполнять какой-либо файл. Основное отличие `require` и `include` заключается в том, что ошибка в `require` вызывает фатальную ошибку работы скрипта и прекращает его выполнение.

`require_once` - аналогично `include_once`, только включается один раз, для предупреждения возникновения дубликатов.

## <a id="Исключения" href="#Исключения">Исключения</a>

Генерация исключения: `throw new <Exception>("<сообщение>");`  
Переброска дальше: `throw $<Exception>;`  
Обработка исключения:

```php
try {
    ...
}[ catch(<ExceptionType1> $e) {
    $e->getMessage(); // возвращает сообщение исключения
    ...
}[...]]
[finally {
    ...
}]
```

Для создания собственного исключения, необходимо наследовать его от `Exception`.

## <a id="Оператор-управления-ошибками-" href="#Оператор-управления-ошибками-">Оператор управления ошибками `@`</a>

Если знак `@` предшествует какому-либо выражению в PHP-коде, любые сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.

<a id="Тип-данных-строка" href="#Тип-данных-строка">Тип данных: строка</a>
==================

Строки являются изменяемыми.

## <a id="Поддержка-юникод-управляющих-escape--последовательностей-PHP7" href="#Поддержка-юникод-управляющих-escape--последовательностей-PHP7">Поддержка юникод управляющих (escape-) последовательностей (PHP7)</a>

Теперь в "строках" и объявлениях heredoc можно использовать `\uXXXX` последовательности для описания символов юникод (ведущие ноли можно опустить):  
`"\u{XXXX}"`

## <a id="Функции-для-обработки-строк" href="#Функции-для-обработки-строк">Функции для обработки строк</a>

- `chr(<код_символа>)` - возвращает символ по его коду ASCII;
- `chunk_split` - разбивает строку на подстроки заданной длины;
- `crypt` - зашифровывает строку с использованием одного из алгоритмов;
- `echo` - выводит одну или несколько строк;
- `explode("<строка_разделитель>", $<строка>)` - разбивает строку на подстроки, ограниченные заданным разделителем, и форматирует из них массив;
- `html_entity_decode` - декодирует все html-представления в соответствующие символы. Функция обратно по отношению к `htmlentites`;
- `htmlentites` - кодирует все специальные символы в их html-представление;
- `htmlspecialchars($<строка>[, <стиль_кавычек>[, <кодировка>]])` - кодирует специальные символы, такие как `<`, `>`, `&`, `"` , `'` в такие сущности языка html, как `&lt;`, `&gt;`, `&amp;`, `&quot`;, `&#039;` соответственно. [стиль кавычек определяет, как должны интерпретироваться двойные и одинарные кавычки. он может иметь одно из трех значений:
    - `ent_compat` означает, что двойные кавычки должны быть переведены в спецсимволы, а одинарные должны остаться без изменений;
    - `ent_quotes` говорит, что должны конвертироваться и двойные и одинарные кавычки;
    - `ent_noquotes` оставляет и те и другие кавычки без изменений.  
    [в параметре кодировка могут быть заданы такие кодировки, как `utf-8`, `iso-8859-1` и другие.]];
- `implode("<строка_разделитель>", $<массив>)` - формирует строку из элементов массива;
- `ltrim` - удаляет начальные пробелы из строки;
- `rtrim` - удаляет конечные пробелы из строки;
- `number_format` - представляет число в виде строки в различных форматах;
- `ord("<символ>")` - возвращает ASCII-код символа;
- `parse_str` - разбивает строку `url` и присваивает значение переменным;
- `print` - выводит строку;
- `printf` - выводит строку с форматированием;
- `sprintf` - возвращает строку с форматированием;
- `setlocale` - устанавливает информацию о кодовой странице;
- `similar_text` - вычисляет степень похожести двух строк;
- `sscanf` - разбивает строку по шаблону и присваивает полученные значения переменным;
- `str_ireplace` - то же самое, что и `str_replace`, но без учета различий в регистре символов;
- `str_pad` - дополняет строку до заданной длины другой строкой;
- `str_repeat` - повторяет строку заданное количество раз;
- `str_replace($<искомое_значение_или_их_массив>, $<значение_для_замены_или_их_массив>, $<строка_или_массив_строк>[, &$<количество_замен>])` - ищет в строке все вхождения подстроки и меняет на заданную строку и возвращает измененную строку. если искомое значение и значение для замены - массивы, то берется по одному значению из каждого массива и производится их поиск и замена в объекте. если значений для замены меньше, чем значений для поиска, то в качестве новых значений используется пустая строка;
- `str_shuffle` - случайным образом перемешивает все символы в строке;
- `str_split` - формирует массив из символов строки;
- `str_word_count` - подсчитывает количество слов в строке;
- `strcasecmp` - выполняет побайтовое сравнение строк без учета регистра символов;
- `strcht` - то же самое что `strstr`;
- `strcmp` - выполняет побайтовое сравнение строк с учетом регистра символов;
- `strip_tags($<строка>[, '<теги>']) `- удаляет из строки все `html`-и `php`-теги [, кроме указанных: `<<тег>>` которые не будут удалены из строки. список из нескольких тегов вводится без каких-либо знаков разделителей];
- `stripslashes($<строка>)` - удаляет экранирование символов;
- `stripos` - ищет первое вхождение подстроки в строке без учета регистра символов;
- `stristr` - то же самое что `strstr`, но без учета регистра символов;
- `strlen($<строка>)` - возвращает длину строки;
- `strnatcasecmp` - то же самое что `strnatcmp`, но без учета регистра символов;
- `strncmp` - выполняет побайтовое сравнение первых n символов строк;
- `strpos($<строка>, $<подстрока>, [<отступ>])` - ищет первое вхождение подстроки в строке и возвращает позицию первого вхождения или `false`, если искомая строка не найдена. Для многобайтовых кодировок `mb_strpos`;
- `strrchr` - ищет последнее вхождение символа в строке;
- `strrev` - инвертирует строку - прочитывает ее справа налево;
- `strripos` - ищет последнее вхождение подстроки в строке без учета регистра символов;
- `strrpos($<строка>, $<подстрока>)` - ищет последнее вхождение подстроки в строке;
- `strspn` - возвращает длину участка строки, состоящего из заданных символов;
- `strstr($<строка>, $<подстрока>)` - возвращает часть строки от первого вхождения подстроки до конца;
- `strtolower` - преобразует прописные буквы в строчные;
- `strtoupper` - преобразует строчные буквы в прописные;
- `strtr` - преобразует заданные символы в строке;
- `substr_compare` - сравнивает две строки, начиная с заданного смещения;
- `substr_count` - подсчитывает, сколько раз заданная подстрока встречается в строке;
- `substr_replace($<строка>, $<строка_для_замены>, <позиция_начального_символа>[, <длина>])` - ищет в заданном участке строки все вхождения подстроки и меняет на другую строку. заменяется та часть строки (т.е. подстрока), которая начинается с позиции, указанной параметром позиции начального символа. с помощью дополнительного аргумента длины можно ограничить число заменяемых символов. то есть, фактически, мы не указываем конкретно строку, которую нужно заменить, мы только описываем, где она находится и, возможно, какую длину имеет;
- `substr($<строка>, <нач_идекс>, [<кон_индекс>])` - возвращает заданную часть исходной строки, если начальный индекс отрицательный, то возвращаемая подстрока будет иметь значение от конца строки до позиции начального индекса с конца строки. Для многобайтовых кодировок используется функция `mb_substr`;
- `trim($<строка>)` - удаляет начальные и конечные пробелы из строки;
- `ucfirst` - преобразует первую букву строки в прописную;
- `$<строка>{<номер_символа>}` - возвращает символ из строки;
- `urlencode($<строка>)` - возвращает строку, в которой все не цифробуквенные символы, кроме `-_`. должны быть заменены знаком процента `%`, за которым следует два шестнадцатеричных числа, а пробелы кодируются как знак сложения `+`;
- `urldecode($<строка>)` - возвращает строку, в которой декодирует любые `%##` кодированные последовательности в данной строке и символ "плюс" `+` декодируется в символ пробела;
- `bin2hex($<строка>)` - возвращает ASCII-строку, содержащую шестнадцатеричное представление аргумента `$<строка>`, преобразование производится побайтно, начиная с верхнего полубайта;
- `hex2bin($<строка>)` - возвращает декодированную строку данных из шестнадцатеричного представления аргумента `$<строка>`.

## <a id="Кодировки" href="#Кодировки">Кодировки</a>

`mb_convert_encoding($<строка>, "<кодировка_выходящая>"[, "<кодировка_строки>"])` - возвращает строку преобразованную к указанной кодировке.

<a id="Регулярные-выражения" href="#Регулярные-выражения">Регулярные выражения</a>
====================

`preg_match('/<шаблон>/<флаги>', '<строка>'[, &$<возвращаемый_массив>[, <флаги> = 0[, <отступ> = 0 ]]]) `- осуществляет поиск в строке по шаблону и возвращают информацию о том, сколько раз произошло совпадение, это 0 (нет совпадений) или 1, поскольку поиск прекращается, как только найдено первое совпадение [и записывает данные в массив результатов (нулевой элемент массива содержит соответствие всему шаблону, первый - первому "захваченному" подшаблону и т.д.)].
`preg_match_all('/<шаблон>/<флаги>', '<строка>'[, &$<возвращаемый_массив>[, <флаги> = 0[, <отступ> = 0 ]]])` - осуществляет поиск в строке по шаблону и возвращают информацию о том, сколько раз произошло совпадение [и записывает данные в массив результатов (нулевой элемент массива содержит соответствие всему шаблону, первый - первому "захваченному" подшаблону и т.д.)].
`preg_replace('/<шаблон>/<флаги>', '<строка_замены>', '<строка>'[, <флаги> = 0[, <отступ> = 0 ]]])` - выполняет поиск совпадений в строке с шаблоном и заменяет их на строку замены и возвращает новую строку.

## <a id="Модификаторы" href="#Модификаторы">Модификаторы</a>

- `i` - (*PCRE_CASELESS*) - если указан этот модификатор, то буквы в шаблоне совпадают с буквами и верхнего, и нижнего регистра в строке;
- `m` - (*PCRE_MULTILINE*) - по умолчанию строка, подающаяся на вход интерпретатору РВ, рассматривается как состоящая из одной линии. Этот модификатор включает поддержку многострокового режима;
- `s` - (*PCRE_DOTALL*) - если установлен этот модификатор, то метасимвол точка `.` совпадает с любым символом, **ВКЛЮЧАЯ** символ перевода строки;
- `x` - (*PCRE_EXTENDED*) - заставляет интерпретатор игнорировать пробелы между символами в шаблоне, за исключением пробелов, экранированных обратным слэшем или находящихся внутри символьного класса, а также между неэкранированным символом `#` вне символьного класса и символом новой строки;
- `U` - (*PCRE_UNGREEDY*) - этот модификатор инвертирует "жадность" квантификаторов, т.е. они становятся "нежадными" по умолчанию и "жадными" если предшествуют символу `?`.

Обратная ссылка в регулярном выражении - `\<номер_объединения_с_1>`.

`preg_replace('/<шаблон>/<флаги>', '<строка_замены_или_их_массив>', '<строка_или_их_массив>'[,'<макс_количество>'])` - выполняет поиск в строке совпадения с шаблоном и заменяет их на указанную строку замены (может содержать ссылки вида `\\n` либо `$n`. Каждая такая ссылка, будет заменена на подстроку, соответствующую `n`'нной заключенной в круглые скобки подмаске. `n` может принимать значения от 0 до 99, подмаски нумеруются слева направо, начиная с единицы) [если параметр макс_количество указан, будет произведена замена указанного количества вхождений шаблона (`-1` - все)]. Возвращает новую измененную строку.

## <a id="Функция-pregreplacecallbackarray-PHP7" href="#Функция-pregreplacecallbackarray-PHP7">Функция `preg_replace_callback_array()` (PHP7)</a>

`preg_replace_callback_array(<массив>, <строка>)` - альтернатива `preg_replace_callback`, когда требуется обработать несколько условий в коллбеке.

Позволяет передать в качестве обратной функции - массив `['/<regex>'/ => <функция_обратного_вызова>, ...]`.

<a id="Массивы" href="#Массивы">Массивы</a>
=======

**Массив** - это набор данных, которые объединены под одним именем. Массив состоит из нескольких элементов, которые имеют свой определенный индекс. Массивы создаются при помощи оператора присвоения, также как и переменная. Имена массивов начинаются со знака `$`, после которого следует произвольный идентификатор, далее идут квадратные скобки:  
`$<массив>[0] = <значение>;` - создает массив в переменной и присваивает его элементу с индексом 0 указанное значение.

В качестве индекса элементов массива можно использовать строки.

`$<массив>[<индекс>]` - доступ к элементу массива.
`$<массив>[] = <значение>;` - добавление нового элемента.

Создание массива:  
`$<массив> = array(<значение1>[, ...]);`  
`$<массив> = [<значение1>[, ...]];`  
`$<массив> = array(<ключ1> => <значение1>[, ...]);`

Для перебора используется цикл `foreach`.

`unset($<массив>[<индекс>]);` - удаляет элемент массива.

Складывают массивы с помощью стандартного оператора `+`.

## <a id="Функции-для-работы-с-массивами" href="#Функции-для-работы-с-массивами">Функции для работы с массивами</a>

- `array_chunk($<массив>, <размер>, [true])` - разбивает массив на несколько меньших массивов заданного размера [с сохранением ключей];
- `array_combine` - создает массив из двух заданных массивов - массива индексов элементов и массива значений;
- `array_count_values` - формирует массив, индексами которого являются значения заданного массива, а значениями - число повторений соответствующего значения в заданном массиве;
- `array_diff($<массив1>, $<массив2>[, ...]) `- формирует массив из тех элементов первого заданного массива, которые отсутствуют в остальных заданных в качестве аргументов функции массива, чтобы сравнивать еще и строковый индекс массивов, то нужно использовать функцию `array_diff_assoc`;
- `array_fill` - заполняет массив заданным значением;
- `array_intersect($<массив1>, $<массив2>[, ...])` - формирует массив из элементов, которые присутствуют во всех заданных массивах, чтобы сравнивать еще и строковый индекс массивов, то нужно использовать функцию `array_intersect_assoc`;
- `array_key_exists($<ключ>, $<массив>)` - проверяет наличие заданного индекса (ключа) в массиве и возвращает true, если в массиве присутствует указанный ключ.;
- `array_keys($<массив>[, $<значение_для_поиска>])` - возвращает массив из индексов заданного массива;
- `array_merge($<массив1>, $<массив2>[, ...])` - объединяет несколько массивов в один и возвращает его;
- `array_multisort` - выполняет сортировку многомерного массива или нескольких одномерных массивов;
- `array_pad` - дополняет массив до заданного количества элементов заданным значением;
- `array_pop($<массив>)` - возвращает последний элемент массива, одновременно удаляя элемент из массива;
- `array_push($<массив>, $<элемент1>[, ...])` - добавляет заданные элементы в конец массива;
- `array_rand` - выбирает один или несколько случайно взятых элементов из массива;
- `array_reduce` - осуществляет последовательное применение заданной функции к элементам массива, формируя итоговое значение;
- `array_reverse` - производит обращение массива - первый элемент становится последним, второй - предпоследним и т.д.;
- `array_search($<искомое_значение>, $<массив>[, true])` - ищет заданный элемент в массиве и возвращает соответствующим ему индекс, иначе `false` [с ограничением на тип];
- `array_shift` - возвращает первый элемент массива, одновременно удаляя его из массива с перенумерацией числовых индексов;
- `array_slice($<массив>, <нач_идекс>[, <количество>])` - вырезает из массива подмассив заданной длины, начиная с указанного элемента положительный `<нач_идекс>` указывает на порядковый номер элемента относительно начала массива, отрицательный - на номер элемента с конца массива [заданного количества, если в эту функцию передан отрицательный параметр `<количество>`, в последовательность войдут все элементы исходного массива, начиная с позиции `<нач_идекс>` и заканчивая позицией, отстоящей на `<количество>` элементов от конца массива.];
- `array_sum($<массив>)` - вычисляет сумму всех элементов массива;
- `array_unique($<массив>)` - возвращает новый массив, в котором повторяющиеся элементы фигурируют в одном экземпляре;
- `array_unshift` - добавляет один или несколько элементов в начало массива с перенумерацией числовых индексов;
- `array_values($<массив>)` - возвращает переиндексированный массив;
- `array_walk($<массив>, <функция>[, <данные>])` - вызывает заданную функцию последовательно для каждого элемента массива и возвращает `true` в случае успешного выполнения операции и `false` - в противном случае. пользовательская функция, как правило, имеет два аргумента, в которые поочередно передаются значение и ключ каждого элемента массива. при этом функция передается как `"<функция>"` в функцию. но если при вызове функции `array_walk` указан третий аргумент, то он будет рассмотрен как значение третьего аргумента пользовательской функции, смысл которого определяет сам пользователь.;
- `array` - создает массив из заданных значений или пар индекс - значение;
- `arsort($<массив>[, <флаги>])` - сортирует массив по убыванию его значений, сохраняя индексы неизменными;
- `asort($<массив>[, <флаги>])` - сортирует массив по возрастанию его значений, сохраняя индексы неизменными;
- `krsort($<массив>[, <флаги>])` - сортирует массив по убыванию его индексов;
- `ksort($<массив>[, <флаги>])` - сортирует массив по возрастанию его индексов;
- `sort($<массив>[, <флаги>])` - сортирует массив по возрастанию значений его элементов с перенумерацией его индексов, в случае успешного завершения работы она возвращает `true`, иначе - `false`, где флаги могут быть:
    - `SORT_REGULAR` - автоматический выбор метода;
    - `SORT_NUMERIC` - сравнивать элементы массива как числа;
    - `SORT_STRING` - сравнивать элементы массива как строки.
- `usort($<массив>[, <сортирующая_функция>])` - сортирует массив с использование заданной функции сравнения элементов массива, при этом функция должна: во-первых, иметь два аргумента. в них интерпретатор будет передавать пары значений элементов для функции `usort()` или ключей массива для функции `uksort()`, во-вторых, сортирующая функция должна возвращать:
    - целое число, меньшее нуля, если первый аргумент меньше второго;
    - число, равное нулю, если два аргумента равны;
    - число большее нуля, если первый аргумент больше второго.  
    При этом функция передается как `"<функция>"` в функцию сортировки;
- `uksort($<массив>[, <сортирующая_функция>])` - сортирует массив с использование заданной функции сравнения ключей массива;
- `rsort($<массив>[, <флаги>])` - сортирует массив по убыванию значений его элементов с перенумерацией его индексов;
- `natcasesort($<массив>)` - сортирует массив естественным образом без учета регистра массива;
- `natsort($<массив>)` - сортирует массив естественным образом с учетом регистра символов;
- `count($<массив>[, COUNT_RECURSIVE])` - возвращает количество элементов в массиве [включая подмассивы];
- `current($<массив>)` - возвращает значение текущего элемента массива;
- `each` - возвращает текущие индекс и значение элемента массива и продвигает указатели на следующий элемент;
- `in_array($<искомое_значение>, $<массив>[, true])` - проверяет, присутствует ли заданное значение в массиве [с ограничением на тип];
- `key` - возвращает индекс текущего элемента массива;
- `list` - присваивает значения из массива списку переменных;
- `pos($<массив>)` - синоним функции `current`;
- `reset` - устанавливает внутренний указатель на первый элемент массива;
- `shuffle` - переставляет элементы массива случайным образом;
- `sizeof($<массив>)` - синоним функции `count`.

## <a id="Дополнительные-методы" href="#Дополнительные-методы">Дополнительные методы</a>

- `implode("<строка_разделитель>", $<массив>)` - формирует строку из массива, разделяя элементы разделителем и возвращает ее;
- `explode("<строка_разделитель>", $<строка>)` - формирует массив из строки, по указанному разделителю и возвращает его;
- `extract($<массив>)` - если массив проиндексированн строчными данным, то присваивает значение переменным, одноименным с соответствующими индексами в массиве;
- `compact($<переменная1>[, ...])` - складывает из переменных массив и возвращает его.

## <a id="JSON" href="#JSON">JSON</a>

- `json_encode($<массив>)` - производит сериализацию массива в объект JSON в виде текста и возвращает его;
- `json_decode("<JSON_объект_как_строка>"[, true])` - преобразует JSON строку в объект [ассоциативный массив] и возращает его.

## <a id="URL" href="#URL">URL</a>

`http_build_query(<массив>[, '<префикс_к_ключу>'[, '<разделитель_ключей>'[, PHP_QUERY_RFC1738 | PHP_QUERY_RFC3986 ]]])` - возвращает сгенерированую URL-кодированную строку запроса из предоставленного ассоциативного (или индексированного) массива (`PHP_QUERY_RFC1738` - пробел знаком `+`, `PHP_QUERY_RFC3986` - знаком `%20`).

<a id="Работа-с-файловой-системой" href="#Работа-с-файловой-системой">Работа с файловой системой</a>
==========================

## <a id="Функции-для-работы-с-файлами" href="#Функции-для-работы-с-файлами">Функции для работы с файлами</a>

- `fopen("<имя_файла>", <тип_доступа>[, true])` - возвращает указатель (типа ресурс) на открытый файл или `false`, если не возможно открыть файл. В качестве параметров этой функции передаются: имя файла, который нужно открыть, который должен содержать правильное локальное имя файла или URL-адрес файла в сети, тип доступа к файлу [ и, параметр, определяющий, искать ли указанный файл в `include_path`]. Где `<тип_доступа>`:
    - `r` - открывает файл только для чтения; устанавливает указатель позиции в файле на начало файла;
    - `r+` - открывает файл для чтения и записи; устанавливает указатель файла на его начало;
    - `w` - открывает файл только для записи; устанавливает указатель файла на его начало и усекает файл до нулевой длины. Если файл не существует, то пытается создать его;
    - `w+` - открывает файл для чтения и записи; устанавливает указатель файла на его начало и усекает файл до нулевой длины. Если файл не существует, то пытается создать его;
    - `a` - открывает файл только для записи; устанавливает указатель файла в его конец. Если файл не существует, то пытается создать его;
    - `a+` - открывает файл для чтения и записи; устанавливает указатель файла в его конец. Если файл не существует, то пытается создать его;
    - `x` - создает и открывает файл только для записи; помещает указатель файла на его начало. Если файл уже существует, то `fopen()` возвращает `false` и генерируется предупреждение. Если файл не существует, то делается попытка создать его;
    - `x+` - создает и открывает файл для чтения и записи; помещает указатель файла на его начало. Если файл уже существует, то `fopen()` возвращает `false` и генерируется предупреждение. Если файл не существует, то делается попытка создать его.

- `fclose($<указатель_на_файл>)` - закрывает соединение с файлом и в случае успеха возвращает `true`, и `false` - в противном случае;
- `fwrite($<указатель_на_файл>, "<строка>"[, <длина>])` - записывает содержимое строки [максимум указанной длины] в файл. В результате своей работы функция возвращает число записанных байтов или `false`, в случае ошибки. Имеет псевдоним `fputs()`;
- `filesize("<имя_файла>")` - возвращает размер файла в байтах. В случае ошибки эта функция вернет `false`. Применяется только для локальных файлов. Кэширует результаты своей работы, для сброса необходимо вызвать `clearstatcache()`;
- `fread($<указатель_на_файл>, <длина>)` - возвращает строку со считанной из файла информацией, указанной длины байт. Чтение данных происходит до тех пор, пока не встретится конец файла;
- `fgets($<указатель_на_файл>[, <длина>])` - возвращает строку [длиной (`<длина>`-1) байт] из файла. Чтение заканчивается, если [прочитано (`<длина>`-1) символов] или встретился символ перевода строки или конец файла. В случае ошибки возвращает `false`;
- `feof($<указатель_на_файл>)` - возвращает `true`, если достигнут конец файла;
- `fgetss($<указатель_на_файл>, <длина>[,"<допустимые_теги>"])` - считывать строку из указанного файла, но при этом удаляет из него все встретившиеся html-теги [за исключением допустимых (`<тег>...`)];
- `fgetc($<указатель_на_файл>)` - возвращает символ из файла, или `false`, если встречен конец файла;
- `readfile("<имя_файла>"[, true])` - считывает файл и выводит его содержимое на экран [ ищет указанный файл в `include_path`];
- `file("<имя_файла>"[, <флаги>[, <контекст>]])` - возвращает массив, где каждый элемент данного массива является строкой в файле. Символ новой строки тоже включается в каждый из элементов массива. В случае ошибки возвращает `false`. Где флаги:
    - `FILE_USE_INCLUDE_PATH` - ищет файл в `include_path`;
    - `FILE_IGNORE_NEW_LINES` - не добавляет новую строку к концу каждого элемента массива;
    - `FILE_SKIP_EMPTY_LINES` - пропускает пустые строки;
- `file_get_contents("<имя_файла>"[, <use_include_path> = false[,<контекст>[, <отступ> = -1[, <длина>]]]])` - возвращает она содержимое файла в виде строки. В случае ошибки возвращает `false`;
- `file_put_contents("<имя_файла>", <данные>[, FILE_APPEND | LOCK_EX[, <контекст>]])` - записывает данные в файл;
- `file_exists("<имя_файла_или_директории>")` - если директория или файл в файловой системе сервера существует, то функция возвращает `true`, в противном случае - `false`. Результат работы этой функции кэшируется;
- `is_writable("<имя_файла_или_директории>")` - возвращает `true`, если файл (или директория) существует и доступен для записи;
- `is_readable("<имя_файла>")` - возвращает `true`, если из файла разрешено читать информацию;
- `unlink("<имя_файла>")` - удаляет файл, возвращает `true` в случае успеха этой операции и `false` - в случае ошибки;
- `copy("<имя_исходного_файла>", "<имя_нового_файла>")` - копирует содержимое исходного файла в новый файл. Возвращает значение `true` в случае успеха или `false`;
- `rename("<имя_исходного_файла>", "<имя_нового_названия_файла>")` - переименовывает файл задавая для него новое имя. Возвращает значение `true` в случае успеха или `false`.

## <a id="Функции-для-работы-с-каталогами" href="#Функции-для-работы-с-каталогами">Функции для работы с каталогами</a>

- `scandir(<путь_к_каталогу>[, SCANDIR_SORT_ASCENDING])` - возвращает массив, содержащий имена файлов и каталогов, расположенных по пути, переданном в параметре;
- `is_dir(<путь_к_файлу>)` - возвращает `true`, если файл существует и является директорией, иначе возвращается `false`;
- `mkdir(<путь>)` - возвращает `true`, если удалось создать директорию, иначе возвращается `false`;
- `rmdir(<директория>)` - возвращает `true`, если удалось удалить директорию, иначе возвращается `false`. Директория должна быть пустой и должны иметься необходимые для этого права.

<a id="Дата" href="#Дата">Дата</a>
====

## <a id="Функции-для-работы-с-датой" href="#Функции-для-работы-с-датой">Функции для работы с датой</a>

- `time()` - возвращает количество секунд, прошедших с начала Эпохи Unix (The Unix Epoch, 1 января 1970 00:00:00 GMT) до текущего времени.
- `strtotime('<дата_время>'[, <временная_метка_сек>])` — преобразует текстовое представление даты на английском языке в метку времени Unix [относительно метки времени, переданной во `<временная_метка_сек>`]
- `date_parse('<дата_время>')` — возвращает ассоциативный массив с подробной информацией о заданной дате на английском языке или в случае возникновения ошибки элемент массива 'errors' будет содержать сообщения об этих ошибках.
- `date('<шаблон>'[, <временная_метка_сек>])` — форматирует вывод системной даты/времени, отформатированную в соответствии с указанным шаблоном (`Y-m-d H:i:s`) [относительно метки времени, переданной во `<временная_метка_сек>`]

## <a id="Объект-DateTime" href="#Объект-DateTime">Объект DateTime</a>

`$<датавремя> = new DateTime('<дата_время>');` - создает объект дата времени на основе текстового представления даты на английском языке.  
`$<датавремя>->format('<шаблон>')` - возвращает строку дата времени, отформатированную в соответствии с указанным шаблоном (`Y-m-d H:i:s`).  
`$<датавремя>->add($<датаинтервал>)` - добавляет к текущей дата времени интервал дат.  
`$<датавремя>->sub($<датаинтервал>)` - вычитает из текущей дата времени интервал дат.  

## <a id="Объект-DateInterval" href="#Объект-DateInterval">Объект DateInterval</a>

Используется для представления интервала времени.

`$<датаинтервал> = new DateInterval(['<интервал>']);` - создает объект интервала дат, где <интервал> может принимать такой вид:  
`P[<кол>Y][<кол>M][<кол>D][<кол>W][T[<кол>H][<кол>M][<кол>S]]`

Содержит такие свойства, которые по умолчанию = `0`:
- `y` - количество лет;
- `m` - количество месяцев;
- `d` - количество дней;
- `h` - количество часов;
- `i` - количество минут;
- `s` - количество секунд.

И свойство `invert`, которое принимает `1`, если интервал представляет отрицательный период времени и `0` в противном случае.

<a id="Сессии" href="#Сессии">Сессии</a>
======

**Cессии** - это механизм, который позволяет создавать и использовать переменные, сохраняющие свое значение в течение всего времени работы пользователя с сайтом. 

Эти переменные для каждого пользователя имеют различные значения и могут использоваться на любой странице сайта до выхода пользователя из системы. При этом каждый раз, заходя на сайт, пользователь получает новые значения переменных, позволяющие идентифицировать его в течение этого сеанса или сессии работы с сайтом.

Задача идентификации пользователя решается путем присвоения каждому пользователю уникального номера, так называемого идентификатора сессии (SID, Session IDentifier). Он генерируется PHP в тот момент, когда пользователь заходит на сайт, и уничтожается, когда пользователь уходит с сайта, и представляет собой строку из 32 символов. Этот идентификатор передается на сервер вместе с каждым запросом клиента и возвращается обратно вместе с ответом сервера.

Существует несколько способов передачи идентификатора сессии:
- с помощью **cookies** - идентификатор сессии сохраняется во временном файле на компьютере клиента, пославшего запрос;
- с помощью параметров адресной строки - идентификатор сессии автоматически встраивается во все запросы (URL), передаваемые серверу, и хранится на стороне сервера.

`session_start()` - сервер создает новую сессию или восстанавливает текущую, основываясь на идентификаторе сессии, переданном по запросу, нужно вызывать во всех скриптах, в которых предстоит использовать переменные сессии, до вывода каких-либо данных в браузер.  
`session_id()` - возвращает идентификатор сессии.  
`session_name([<имя_сессии>])` - [задает имя сессии] или возвращает его. Делать это нужно до инициализации сессии.  
`session_register('<имя_переменной1>', ...)` - регистрирует имя переменной. Все зарегистрированные таким образом переменные становятся глобальными в течение данной сессии работы с сайтом.  
`$_SESSION['<имя_переменной>'] = <значение_переменой>` - регистрирует переменную. В этом массиве хранятся все зарегистрированные (т.е. глобальные) переменные сессии. Доступ переменным осуществляется с помощью массива `$_SESSION['<имя_переменной>']`.  
`session_unregister('<имя_переменной>')` - удаляет глобальную переменную из текущей сессии.
`unset($_SESSION['<имя_переменной>'])` - удаляет переменную.  
`session_unset()` - сбросывает значения всех переменных сессии.  
`session_destroy()` - уничтожает текущую сессию целиком.

<a id="Функции" href="#Функции">Функции</a>
=======

**Функция** - это набор операторов, который идентифицируется определенным идентификатором (именем).

```php
function [&] <имя_функции>([<тип>] [&][$<аргумент1> [ = <значение_по_ум>][, ...]])
[use ([&][$<переменная_замыкания1>[, ...]])] {
    [<тело>;]
    [return <возвращаемое_значение>;]
}
```

При возвращении ссылки на переменную, необходимо каждый раз при вызове функции перед ее именем тоже писать амперсанд `&`. По ссылке можно возвращать только переменные и ничего больше. Для использования возвращаемой ссылки необходимо применять присвоение по ссылке.
> `$foo =& find_var($bar);`

Также можно функцию присвоить значению переменной:  
`$<переменная> = "<имя_функции>";`  
`$<переменная>(...)` - вызов функции.

Возможно объявление **анонимных функций**, в этом случае имя функции опускается:  
`$<переменная> = function (...) {...};` - присвоение анонимной функции переменной.

Возможно объявлять **замкнутые функции**, в которых значение **унаследованной переменной** задано там, где функция определена, но не там, где вызвана с помощью `use`, где `$<переменная_замыкания1>` будет унаследованной переменной из контекста определения функции. PHP автоматически преобразует такие выражения в экземпляры внутреннего класса `Closure`.

## <a id="Объявления-типов" href="#Объявления-типов">Объявления типов</a>

Объявления типов позволяют функциям строго задавать тип передаваемых параметров. Передача в функцию значений несоответствующего типа будет приводить к ошибке.

Чтобы объявить тип агрумента, необходимо перед его именем добавить имя требуемого типа (**Имя класса/интерфейса**, `array`, `callable`). Также можно объявить тип `NULL`, чтобы указать, что значением по умолчанию аргумента является `NULL`.

## <a id="Объявления-возвращаемых-типов-PHP7" href="#Объявления-возвращаемых-типов-PHP7">Объявления возвращаемых типов (PHP7)</a>

Добавилась возможность указать тип переменной, возвращаемой функцией или методом или замыканием. Для этого он ставится после знака `:`, который ставится после сигнатуры функции.

Следующие типы поддерживаются:  
`string`, `int`, `float`, `bool`, `array`, `callable`, `self` (в методах), `parent` (в методах только) , `Closure`, имя класса, имя интерфейса.

При использовании наследования в классах, дочерние методы должны соблюдать объявления возвращаемых типов указанные в родительском классе/интерфейсе.

## <a id="Методы-доступные-в-функции" href="#Методы-доступные-в-функции">Методы доступные в функции</a>

`func_num_args();` - возвращает число аргументов переданных в функцию.  
`func_get_arg(<номер_аргумента>);` - возвращает аргумент из списка аргументов по указанному номеру.  
`func_get_args();` - возвращает массив аргументов.  
`global $<переменная>;` - объявление глобальной переменной, которая ссылается на переменную, которая глобальна относительно текущей области видимости.  
`$GLOBALS` - массив, который содержит все глобальные переменные, относительно текущей области видимости.  
`static $<переменная>;` - объявление статической переменной.

## <a id="Генераторы" href="#Генераторы">Генераторы</a>

Любую функцию можно использовать в качестве генератора.

Наличие `yield` говорит о том, что PHP вернет специальный класс - **генератор**. Генератор ведет себя так же, как и итератор, поскольку он реализует его. И использовать генератор можно аналогично итераторам. То есть передавать его в `foreach`.

PHP выполнит код до первой встречи ключевого слова `yield` перед значением или переменной: `yield <значение>;`, на котором он запомнит это значение и вернет генератор:  
`$<generator> = <function>(...);`

Затем, будет вызов метода `next()` у генератора, PHP снова выполнит код, только начнет его не с самого начала, а начиная с прошлого значения, и опять, до следующего `yield` или же конца функции, или `return`.

`$<generator>->valid()` - возвращает `true`, если есть еще возможности вызова `yield`.  
`$<generator>->current()` - возвращает текущее значение генератора, которое было возвращено через `yield`.  
`$<generator>->next()` - возвращает `true`, если есть еще возможности вызова `yield`.  
`$<generator>->send(<значение>)` - отправляет `<значение>` в генератор и тогда следующий `yield` вернет переданное значение: `$<переменная> = (yield $<значение>);` - сначало возвращает значение, дожидается вызова метода `send` у генератора, а затем присваивает значение переданое через метод `send` переменной.  

Генераторы однонаправленны.

### <a id="Возврат-выражений-в-генераторах-PHP7" href="#Возврат-выражений-в-генераторах-PHP7">Возврат выражений в генераторах (PHP7)</a>

Позволяет использовать `return <значение>` в генераторах.

Значение может быть получено вызовом метода `$<generator>->getReturn()` у генератора, только по завершении работы генератора. Теперь не нужно проверять является ли значение последним.

### <a id="Делегирование-генераторов-PHP7" href="#Делегирование-генераторов-PHP7">Делегирование генераторов (PHP7)</a>

Построено на основе возможности возврата выражений из генератора.

`yield from {<массив> | <генератор>}`

Будет вызываться до тех пор, пока возвращает данные, затем выполнения продолжится в вызывающем генераторе.

## <a id="callable" href="#callable">callable</a>

Это тип - функция обратного вызова, которую можно вызвать с помощью:  
`call_user_func({'[<имя_класса>::]<имя_функции>' | array({'<имя_класса>' | <объект>}, '<имя_функции>')}[, <параметр1>[, ...]])` - выполняет указанную функцию, при этом параметры не передаются по ссылке, что бы их передать по ссылке необходимо их обернуть в такую конструкцию: `array(&<параметр1>)`  
`call_user_func_array{{'[<имя_класса>::]<имя_функции>' | array({'<имя_класса>' | <объект>}, '<имя_функции>')}[, <массив_параметров>])` - вызывает пользовательскую функцию с массивом параметров

<a id="Взаимодействие-с-HTML" href="#Взаимодействие-с-HTML">Взаимодействие с HTML</a>
=====================

`$_SERVER['REQUEST_METHOD']` - содержит метод, который был использован для запроса страницы: `'GET'`, `'HEAD'`, `'POST'`, `'PUT'` и т. д.

`$_POST`, `$_GET`, `$_REQUEST` - переменные, в которых сохраняются данные, если данные были отправлены методом `POST`, `GET`, любым методом (+ cookies).  
`{$_POST | $_GET | $_ REQUEST}['<имя_поля>']` - возвращает данные переданного поля.

`getenv('<имя_переменной_окружения>')` - возвращает значение переменной окружения.

## <a id="Загрузка-файлов-на-сервер" href="#Загрузка-файлов-на-сервер">Загрузка файлов на сервер</a>

Необходимо в атрибутах формы указать `enctype="multipart/form-data"`, в противном случае загрузка файлов на сервер выполняться не будет.

Глобальный массив `$_FILES` содержит всю информацию о загруженных файлах.

`$_FILES['<имя_поля>']['name']` - оригинальное имя файла на компьютере клиента.  
`$_FILES['<имя_поля>']['type']` - `mime`-тип файла, в случае, если браузер предоставил такую информацию. Этот `mime`-тип не проверяется в PHP, так что на его значение нельзя полагайться без проверки.  
`$_FILES['<имя_поля>']['size']` - размер в байтах принятого файла, если при отправке формы файл выбран не был, PHP установит переменную значением `0`.
`$_FILES['<имя_поля>']['tmp_name']` - временное имя, с которым принятый файл был сохранен на сервере.
`$_FILES['<имя_поля>']['error']` - код ошибки, которая может возникнуть при загрузке файла, `0` если ее нет.

По умолчанию принятые файлы сохраняются на сервере в стандартной временной папке, если принятый файл не был переименован или перемещен, он будет автоматически удален из временной папки.

## <a id="Выгрузка-файла" href="#Выгрузка-файла">Выгрузка файла</a>

```php
header('Content-Description: File Transfer');
header('Content-Type: '.<mime_type>);
header('Content-Disposition: attachment; filename="'.<file_name>.'"');
header('Expires: 0');
header('Cache-Control: must-revalidate');
header('Pragma: public');
header('Content-Length: '.<file_size>);
echo <file_content>;
```

<a id="ООП" href="#ООП">ООП</a>
===

## <a id="Основные-термины-и-понятия" href="#Основные-термины-и-понятия">Основные термины и понятия</a>

**ООП** расшифровывается как **объектно-ориентированное программирование**. Это парадигма (совокупность идей и понятий) программирования, в которой основными концепциями являются понятия объектов и классов.

**Абстракция** — абстрагирование, это способ описания общих характеристик объекта.

**Инкапсуляция** — это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе, и скрыть детали реализации от пользователя.

**Наследование** — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется **базовым**, **родительским**. Новый класс — **потомком**, **наследником** или **дочерним** классом.

**Полиморфизм** — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

**Класс** является описываемой на языке терминологии исходного кода моделью ещё не существующей сущности (объекта). Фактически он описывает устройство объекта, являясь своего рода чертежом.

**Объект** — это экземпляр класса, совокупность данных (свойств) и функций (методов) для обработки данных.

## <a id="Классы" href="#Классы">Классы</a>

Класс является одним из типов данных. Каждое определение класса начинается с ключевого слова `class`, затем следует имя класса, пара фигурных скобок, внутри которых можно определять свойства и методы этого класса.

```php
[abstract] class <Имя_Класса> extends [<Имя_Класса_Родителя>] [implements <Интерфейс1>[, ...]] {
    [use <имя_вкл_трейта1>[, ...]]
    [function __construct([&][<аргумент1> [ = <значение_по_ум>][, ...]]) {
        ...
    }]
    
    [function __destruct() {
        ...
    }]
    
    [{public | protected | private}] [static] $<свойство> = <значение>;
    
    const <КОНСТАНТА> = <значение>;
    
    [{public | protected | private}] [static] function <имя_метода>([&][<аргумент1> [ = <значение_по_ум>][, ...]]){
        [<тело>;]
        [return <возвращаемое_значение>;]
    }
    
    abstract [{public | protected}] function <имя_метода>([&][<аргумент1> [ = <значение_по_ум>][, ...]]);
    ...
}
```

В пределах методов класса доступ к свойствам может быть получен с помощью `->` (объектного оператора) и указателя `$this`.

Отличие констант состоит в том, что при объявлении или при обращении к ним не используется символ `$`. Значение должно быть неизменяемым выражением, не свойством, или вызовом функции. Доступ внутри классовых методов: `self::<КОНСТАНТА>`.

Области видимости:
- `public` — элементы доступны всем;
- `private` — элементы не доступны извне (за пределами класса);
- `protected` — элементы доступны только классу и всем его потомкам.

Методы, где определение области видимости отсутствует, определяются как `public`.

Наследование полезно использовать при расширении класса, дочерний класс наследует все публичные (`public`) и защищенные (`protected`) методы из родительского класса. Эти методы будут иметь исходную функциональность до тех пор, пока не будут переопределены. Такой подход полезный для абстрагирования функциональности. Позволяет реализовать дополнительную функциональность в похожих объектах без необходимости реализовывать всю общую функциональность.

Чтобы вызвать конструктор, объявленный в родительском классе, следует обратиться к методу `parent::__construct()` внутри конструктора класса-потомка.

Класс, который содержит хотя бы один абстрактный метод, должен быть определен как **абстрактный**. Абстрактные классы реализуют на практике один из принципов ООП — полиморфизм. Нельзя создать экземпляр абстрактного класса. Методы, объявленные абстрактными, лишь описывают смысл и не могут включать реализации. При наследовании от абстрактного класса, все методы, помеченные абстрактными в родительском классе, должны быть определены в классе-потомке; кроме того, область видимости этих методов должна совпадать (или быть менее строгой). Более того, контроль типов и количество обязательных аргументов должно быть одинаковым.

Объявление свойств и методов класса статическими (`static`) позволяет обращаться к ним без создания экземпляра класса. Атрибут класса, объявленный статическим, не может быть доступен посредством экземпляра класса (но статический метод может быть вызван). Доступ к статическим свойствам класса может быть получен через оператор `::`:  
`<Имя_Класса>::<имя_метода>([...])`, `<Имя_Класса>::$<свойство>`.

Ключевые слова в методах класса:
- `self` - ссылка на текущий класс;
- `parent` - ссылка на родительский класс.

Используются:  
`<ключевое_слово>::<имя_метода>([...])`, `<ключевое_слово>::$<свойство>`

`$<экземпляр> = new <Имя_Класса>([...]);` - создание экземпляра класса

Если с директивой `new` используется строка (`string`), содержащая имя класса, то будет создан новый экземпляр этого класса:  
`$<экземпляр> = new "<Имя_Класса>";`

`$<экземпляр>-><имя_метода>([...]);` - вызов метода  
`$<экземпляр>-><свойство>;` - получение значения свойства  
`<Имя_Класса>::<КОНСТАНТА>;` - доступ к константе

### <a id="Анонимные-классы-PHP7" href="#Анонимные-классы-PHP7">Анонимные классы (PHP7)</a>

Есть возможность использовать анонимные классы:  
`new class[(<аргумент_конструктора1>[, ...])] {...}`

Они позволяют делать тоже самое что и обычные классы: передавать данные в конструктор, наследовать другие классы, использовать трейты и т.п.

Анонимные классы поддерживают вложенность. Вложенные классы не будут иметь доступа к `private`/`protected` свойствам внешнего класса.

## <a id="Интерфейсы" href="#Интерфейсы">Интерфейсы</a>

С помощью интерфейсов можно описать методы, которые должны бить реализованы в классе без необходимости описания их функционала. Интерфейсы объявляются так же, как и обычные классы, но с использованием ключевого слова `interface`. Тела методов интерфейсов должны быть пустыми. Методы, внутри интерфейса, должны бать определены как публичные.

```php
interface <Интерфейс> {
    public function <имя_метода>([&][<аргумент1> [ = <значение_по_ум>][, ...]]);
    ...
}
```

## <a id="Перегрузка-свойств" href="#Перегрузка-свойств">Перегрузка свойств</a>

Обращения к свойствам объекта могут быть перегружены с использованием методов `__get` и `__set`. Эти методы будут срабатывать в том случае, если объект не содержат свойства, к которому осуществляется доступ. Синтаксис (переопределяются в классе):  
`public void __set (string $<свойство>, mixed $<значение>)`  
`public mixed __get (string $<свойство>)`

## <a id="Перегрузка-методов" href="#Перегрузка-методов">Перегрузка методов</a>

Вызовы методов могут быть перегружены с использованием методов `__call`. Эти методы будут срабатывать в том случае, если объект не содержат метода, к которому осуществляется доступ. Синтаксис (переопределяются в классе):  
`public mixed __call (string $<имя_метода>, array $<список_аргументов>)`

## <a id="Метод-toString" href="#Метод-toString">Метод `__toString`</a>

Метод `__toString()` будет срабатывать при попытке преобразования класса в строку. Синтаксис (переопределяются в классе):  
`public string __toString()`

## <a id="Метод-invoke" href="#Метод-invoke">Метод `__invoke`</a>

Метод `__invoke()` вызывается, когда объект пытается выполнить как функцию. Синтаксис (переопределяются в классе):  
`mixed __invoke([<аргумент1>[ = <значение_по_ум>][, ...]])`

## <a id="Клонирование-объектов" href="#Клонирование-объектов">Клонирование объектов</a>

`$<копия_экземпляра> = clone $<экземпляр>;`
При клонировании объекта, PHP выполняет неполную копию всех свойств объекта. Любые свойства, являющиеся ссылками на другие переменные, останутся ссылками.

## <a id="Метод-clone" href="#Метод-clone">Метод `__clone`</a>

Метод `__clone()` вызывается, по завершении клонирования у свежесозданной копии объекта, для возможного изменения всех необходимых свойств. Синтаксис (переопределяются в классе):  
`void __clone()`

## <a id="Контроль-типа" href="#Контроль-типа">Контроль типа</a>

В PHP 5 есть возможность использования контроля типов. При передаче параметром есть возможность проверить данные на такие типы в методах: объекты (путем указания имени класса в прототипе функции), интерфейсы, массивы, колбеки с типом callable. Указываются перед аргументом:  
`<имя_метода>([<тип>] [<аргумент1>[ = <значение_по_ум>][, ...]]);`

## <a id="Трейты" href="#Трейты">Трейты</a>

Трейт похож на класс, но предназначен для группирования функционала хорошо структурированым и последовательным образом. Невозможно создать самостоятельный экземпляр трейта. Это дополнение к обычному наследованию, то есть возможность использования функционала класса без необходимости наследования.

```php
trait <Трейт> {
    [use <Включаемый_Трейт1>[, ...] [{
        [<Включаемый_Трейт1>::<элемент> insteadof <Включаемый_Трейт2>;
        ...]
        [<Включаемый_Трейт1>::<элемент> as <псевдоним>
        ...]
    }]]
    <описание_собственного_метода_или_свойства>
    ...
}
```

Конструкция `use` позволяет включить трейт в класс или в трейт, внутри нее можно разрешить конфликт имен, с указанием приоритета одного трейта над другим с помощью: `<Включаемый_Трейт1>::<элемент> insteadof <Включаемый_Трейт2>;` - т.е. `<элемент>` из `<Включаемый_Трейт1>` будет иметь приоритет над `<элемент>` из `<Включаемый_Трейт2>`.

Методы и свойства описаные в трейте должны быть полностью реализованными, также методы имеют доступ к методам и свойствам класса.

Порядок приоритета: члены из текущего класса переопределяют методы в трейте, которые в свою очередь переопределяют унаследованные методы.

## <a id="Сериализация" href="#Сериализация">Сериализация</a>

`serialize(<значение>)` - возвращает строковое представление любого значения, которое может быть сохранено в PHP. Использование для сериализации объекта сохранит имя класса и все его свойства, однако методы не сохраняются.  
`unserialize(<строка_значения>)` - возвращает исходное значение восстановленное из строки. Для объекта необходимо чтобы класс этого объекта был определен заранее.

<a id="Пространства-имен" href="#Пространства-имен">Пространства имен</a>
=================

Пространства имен, это один из способов инкапсуляции элементов. В PHP пространства имен используются для решения двух проблем:
1. Конфликт имен между вашим кодом и сторонними.
2. Возможность создавать псевдонимы (или сокращения) для длинных имен, чтобы облегчить первую проблему и улучшить читаемость исходного кода.

`namespace <имяПространстваИмен>[\<подИмя1>[...]]` - определение пространства имен. Должно находиться в начале перед любым другим кодом, кроме `declare`.

`__NAMESPACE__` - содержит текущее имя пространства имен.

`<имяПодПространстваИмен>[\<подИмя1>[...]]\<элементПространстваИмен>` - полное имя, для использования в коде, раскрывается в:  
`<имяПространстваИмен>\<имяПодПространстваИмен>[\<подИмя1>[...]]\<элементПространстваИмен>`

`\<имяПространстваИмен>[\<подИмя1>[...]]\<элементПространстваИмен>` - абсолютное имя элемента.

`use <имяПростр>[[\...]\<элементПростр> [as <псевдоним>]][, ...] `- импортирование, должно находиться в начале перед любым другим кодом, кроме пространства имен.  
`\<элементПространстваИмен>` - использование из глобального пространства имен.

## <a id="Группировка-объявлений-use-PHP7" href="#Группировка-объявлений-use-PHP7">Группировка объявлений `use` (PHP7)</a>

Если у импортируемых классов общее пространство имен, можно объединить их импорт в группу (это относится к классам, функциям, константам, интерфейсам), для этого нужно поместить их в `{}`, через запятую сразу после общего пространства имен.

<a id="PDO" href="#PDO">PDO</a>
===

**Объекты данных PHP** (PDO) определяет простой и согласованный интерфейс для доступа к базам данных в PHP. PDO обеспечивает абстракцию (доступа к данным).

Все методы могут выбросить исключение `PDOException`.

`$pdo = new PDO('<dsn>', '<пользователь>', '<пароль>'[, $<опции>])` - производит соединение с базой данных и возвращает объект данных, где:
- `'<dsn>'` - `"<тип_БД>:host=<хост_URL>;dbname=<имя_БД>;port=<порт>;charset=<кодировка>"`
- `<опции>` - массив опций, вида:
    ```
    array(
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
    );
    ```

`$pdo->exec('<SQL_запрос>')` - запускает SQL запрос на выполнение и возвращает количество строк, задействованных в ходе его выполнения, не возвращает результат выборки оператором `SELECT`.  
`$pdo->lastInsertId()` - возвращает ID последней вставленной строки либо последнее значение, которое выдал объект последовательности.

`$stmt = $pdo->query('<SQL_запрос>')` - выполняет SQL запрос и возвращает результат запроса, для `SELECT` в виде объекта PDO `statement`.  
`$stmt = $pdo->prepare('<SQL_запрос>')` - подготавливает SQL запрос (в нем можно использовать позиционные плейсхолдеры `?`, для которых важен порядок передаваемых переменных, и именованные `:<имя>`, для которых порядок не важен, плейсхолдер может заменять только строку или число, все данные, которые были переданы напрямую в плейсхолдер, форматируются как строки) и возвращает объект PDO `statement`.  
`$stmt->execute({array(<значение>[, ...]) | array(<имя_плейсхолдера> => <значение>[, ...])})` - выполняет подготовленный запрос с указанными значениями, подготовленные запросы можно выполнять многократно с разными значениями. Возвращает `true` в случае успешного завершения или `false` в случае возникновения ошибки.  
`$stmt->rowCount()` - возвращает количество строк, которые были затронуты в ходе выполнения последнего запроса `DELETE`, `INSERT` или `UPDATE`.

`$row = $stmt->fetch([<тип>])` - возвращает следующую строку результата запроса в виде массива или `false`, если ее нет. Где `<тип>`:
- `PDO::FETCH_ASSOC` - возвращает массив, индексированный именами столбцов результирующего набора;
- `PDO::FETCH_BOTH` - (по умолчанию) возвращает массив, индексированный именами столбцов результирующего набора, а также их номерами (начиная с 0);
- `PDO::FETCH_NUM` - возвращает массив, индексированный номерами столбцов (начиная с 0);
- `PDO::FETCH_OBJ` - создает анонимный объект со свойствами, соответствующими именам столбцов результирующего набора.

`$row[{'<имя_столбца>' | <индекс>}]` - возвращает значение столбца запроса указанной строки.

`$data = $stmt->fetchAll([<тип>])` - возвращает массив, который состоит из всех строк, которые вернул запрос. Где `<тип>` - тип из `fetch` плюс:
- `PDO::FETCH_COLUMN` - простой одномерный массив, если запрошено одно единственное поле из кучи строк, т. е. одну колонку;
- `PDO::FETCH_KEY_PAIR` - массив пар ключ-значение, если запрошено два поля, где в первой колонке указано уникальное поле;
- `PDO::FETCH_UNIQUE` - массив всех строк, индексированных первым уникальным полем.

`$data[<индекс_строки>][{'<имя_столбца>' | <индекс>}]` - возвращает значение столбца запроса указанной строки.  
`$stmt->fetchColumn()` - возвращает значение единственной колонки.

`$pdo->quote($<строка>)` - заключает строку в кавычки (если требуется) и экранирует специальные символы внутри строки подходящим для драйвера способом и возвращает ее.

<a id="SimpleXML" href="#SimpleXML">SimpleXML</a>
=========

`$simpleXML= new SimpleXMLElement('<строкаXml>')` - создание объекта `SimpleXML` из указанной строки.

`$simpleXML-><имя_тега>[[<индекс>]][...]` - возвращает значение узла, для тегов которые содержат в названии недопустимые символы используется вместо `<имя_тега>` - `{'<имя_тега>'}`. Позволяет также присваивать значения узлу.  
`$simpleXML-><имя_тега>[[<индекс>]][...]->count()` - возвращает количество дочерних элементов.

Если существует несколько экземпляров дочерних элементов в одном родительском элементе, то нужно применять стандартные методы итерации, например `for` или `foreach` перебирая при этом `$simpleXML-><имя_тега_нескольких_элементов>`.

Узлы с дочерними элементами - это итеративный объект в виде массива.

`$simpleXML-><имя_тега>['<имя_атрибута>']` - возвращает значение атрибута.

Для сравнения элемента или атрибута со строкой или для передачи в функцию в качестве текста, необходимо привести его к строке, используя `(string)`.

`$simpleXML->xpath('<xpath_выражение>')` - возвращает все узлы, которые соответствуют xpath-выражению.

`$simpleXML->asXML()` - возвращает Xml в виде строки.

`$simpleXML-><имя_тега>[[<индекс>]][...]->addChild('<имя_тега>'[, '<значение>'])` - добавляет к указанному тегу дочерний элемент.  
`$simpleXML-><имя_тега>[[<индекс>]][...]->addAttribute('<имя_атрибута>'[, '<значение>'])` - добавляет к указанному тегу атрибут.  
Узлы удаляются с помощью `unset(<узел>)`.

`$dom = new DOMDocument;`  
`$dom->loadXML('<строкаXml>');`  
`$simpleXML = simplexml_import_dom($dom);` - преобразует DOM элемент в `SimpleXML`.

<a id="Шаблоны-Smarty" href="#Шаблоны-Smarty">Шаблоны Smarty</a>
==============

В шаблоне Smarty могут быть условные операторы, операторы вставки файлов, операторы изменения переменных, циклы и т.п. Другая особенность Smarty - это компиляция шаблонов. Шаблоны переводятся в php-код, и интерпретатор PHP производит все необходимые действия по подстановке значений. Для ускорения работы скомпилированные шаблоны кэшируются.

## <a id="Подключение" href="#Подключение">Подключение</a>

`require('Smarty.class.php');` - подключение файла с описанием класса Smarty

`$smarty = new Smarty;` - создание экземпляра класса Smarty

Директории, необходимые для работы Smarty:
- `$smarty->template_dir` - директория, где хранятся созданные шаблоны (по ум `templates`);
- `$smarty->compile_dir` - директория, где Smarty будет хранить скомпилированные шаблоны (по ум `templates_c`);
- `$smarty->config_dir` - директория для хранения конфигурационных файлов (по ум `configs`);
- `$smarty->cache_dir` - директория для КЭШа (по ум `cache`).

Доступ к перечисленным директориям осуществляется библиотекой Smarty и никогда не выполняется напрямую через web-браузер.

## <a id="Строение-шаблонов" href="#Строение-шаблонов">Строение шаблонов</a>

Шаблоны по умолчанию имеют расширение `tpl`.

Все элементы (теги) языка шаблонов Smarty заключаются между символами-ограничителями. По умолчанию это символы фигурных скобок `{` и `}`, но их можно изменить. Все, что не заключено в такие ограничители, Smarty рассматривает как константы, не требующие обработки.

Каждый Smarty тег либо выводит значение переменной, либо вызывает какую-либо функцию.

`{$<переменная>}` - это производит вывод переменной  
`{$<числ_массив>[<индекс>]}` - это производит вывод элемента числового массива  
`{$<ассоц_массив>.<ключ>}` - это производит вывод значение ключа массива  
`{#<переменная>#}` - это производит вывод переменной из текущего конфигурационного файла

Существует переменная `{$smarty}`, зарезервированная для некоторых специальных переменных шаблона, таких как переменные HTTP запроса, даты и времени, и т.п.

`{*Это комментарий*}`

`{<имя_функции> <атрибут1>="<значение1>" [...]}` - вызывает функцию с указанными атрибутами.

## <a id="Встроенные-функции" href="#Встроенные-функции">Встроенные функции</a>

### <a id="Функция-configload" href="#Функция-configload">Функция `config_load`</a>

Используется для загрузки в шаблон переменных из конфигурационных файлов.

```smarty
{config_load file="<имя_файла>"
    [section=<имя_секции>]}
```

### <a id="Функция-capture" href="#Функция-capture">Функция `capture`</a>

Предназначена для того, чтобы собирать в переменную выходные данные шаблона вместо того, чтобы выводить их на экран.

```smarty
{capture name="<имя_блока>"
    [assign="<имя_переменной>"]}
    <тело_шаблона>
{/capture}
```

Все, что находится между `{capture}` и `{/capture}`, будет записано в переменную с именем `<имя_блока>`. Захваченный таким образом контент может быть использован в шаблоне посредством специальной переменной `$smarty.capture.<имя_блока>`. [Параметр `assign` задает имя переменной, которой будет присвоено захваченное выходное значение]

### <a id="Функция-section" href="#Функция-section">Функция `section`</a>

Это цикл для обхода элементов массива.

```smarty
{section name="<имя_секции>"
    loop=$<переменная_для_выч-ния_числа_итераций>
    [start="<индекс_начальной_позиции>"] 
    [step="<шаг>"] [max="<максимум_итераций>"] 
    [show="<показывать_ли_секцию>"] }
    <тело_секции>
{/section}
```

Обязательными являются параметры `name`, с помощью которого задается имя секции, и `loop`, который представляет собой переменную, определяющую число итераций цикла. Как правило, `loop` - это переменная типа массив, и число итераций секции равно числу элементов этого массива. Чтобы вывести переменную внутри цикла, нужно после имени переменной указать в квадратных скобках имя секции:  
`{$<переменная_для_выч-ния_числа_итераций>[<имя_секции>]}`

Свойства цикла:
- `$smarty.section.<название_цикла>.index` - номер текущего элемента массива.

### <a id="Функция-foreach" href="#Функция-foreach">Функция `foreach`</a>

Являются альтернативой циклам `section`.

```smarty
{foreach from=$<имя_массива> 
    item="<значение_текущего_элемента>"
    [key="<ключ_текущего_элемента>"]
    [name="<название_цикла>"]}
    <тело_секции>
[{foreachelse}
    <тело_секции_когда_ничего_не_найдено>
]
{/foreach}
```

Действие функции `foreach` очень похоже на работу цикла `foreach` в языке PHP. Получение значение элемента:  
`{$<значение_текущего_элемента>}`
`{$<ключ_текущего_элемента>}` - значение ключа

Свойства цикла:
- `$smarty.foreach.<название_цикла>.index` - номер текущего элемента массива, с 0;
- `$smarty.foreach.<название_цикла>.iteration` - номер текущего итерации, с 1;
- `$smarty.foreach.<название_цикла>.first` - равно `TRUE`, если текущая итерация - первая;
- `$smarty.foreach.<название_цикла>.last` - равно `TRUE`, если текущая итер. - последняя;
- `$smarty.foreach.<название_цикла>.total` - содержит общее количество итераций.

### <a id="Оператор-if-elseif-else" href="#Оператор-if-elseif-else">Оператор `if, elseif, else`</a>

```smarty
{if <выражение>}
    <блок_действий>
{elseif <выражение1>}
    <блок_действий1>
[...]
{else}
    <блок_действий_при_ложном_условии>
{/if}
```

Действие оператора практически аналогично оператору `if... elseif... else` языка PHP. В выражениях могут использоваться следующие операторы сравнения: `eq`, `ne`, `neq`, `gt`, `lt`, `lte`, `le`, `gte`, `ge`, `is even`, `is odd`, `is not even`, `is not odd`, `not`, `mod`, `div by`, `even by`, `odd by`, `==,` `!=`, `>`, `<`, `<=`, `>=`. Каждый из них обязательно должен быть отделен от окружающих его значений пробелами. В выражениях можно использовать круглые скобки и вызывать php-функции.

### <a id="Функция-include" href="#Функция-include">Функция `include`</a>

Используется для включения других шаблонов в текущий.

```smarty
{include file="<имя_файла>"
    [assign="<имя_переменной>"]
    [<переменная>="<значение1>" [...]]}
```

Любые переменные, доступные в текущем шаблоне, доступны и во включаемом [, атрибут `assign` указывает, что результат выполнения `{include}` будет присвоен переменной вместо отображения.]

### <a id="Функция-literal" href="#Функция-literal">Функция `literal`</a>

`{literal}<текст>{/literal}` - текст внутри не интерпретируется, а выводится "как есть".

### <a id="Функция-assign" href="#Функция-assign">Функция `assign`</a>

`{assign var="<имя_переменной>" value="<значение>"}` - используется для установки значения переменной в процессе выполнения шаблона, в сложном значения арифметики переменные должны заключаться в обратные кавычки ``` `` ```.

## <a id="Функция-php" href="#Функция-php">Функция php</a>

Позволяет вставлять PHP-код прямо в шаблон.

```smarty
{php}
    <код>
{/php}
```

Smarty доступен через `$this`. Для доступа к переменным PHP внутри блоков `{php}`, нужно использовать ключевое слово `global`.

## <a id="Модификаторы" href="#Модификаторы">Модификаторы</a>

В шаблонах Smarty определен ряд модификаторов, которые можно применять к переменным, пользовательским функциям или строкам с тем, чтобы модифицировать их значения. Чтобы применить модификатор, нужно указать его название после вертикальной черты `|`, следующей за именем переменной, функции или строкой, к которой он применяется. Можно использовать сразу несколько модификаторов, отделяя их друг от друга прямой вертикальной чертой.

`$<переменная>|<модификатор_или_функция>[:<аргумент2>[...]]` - переменная передается в модификатор или функцию первым аргументом

Виды:
- `upper` - переведет значение в верхний регистр;
- `truncate` - урежет значение до 80 символов;
- `default:"<значение>"` - если у переменной не задано значение, то используется указанное.

Если модификатор применяется к переменной-массиву, то он будет применен к каждому элементу массива. Если же требуется применить модификатор к массиву, как к переменной, то необходимо перед именем модификатора указать символ `@`.

## <a id="Конфигурационные-файлы" href="#Конфигурационные-файлы">Конфигурационные файлы</a>

Конфигурационные файлы используются для того, чтобы управлять глобальными переменными, используемыми в шаблоне, с помощью одного файла. Конфигурационный файл содержит набор переменных и их значения `<переменная>=<значение>`. Значение переменной по желанию заключают в кавычки (двойные или одинарные), если оно состоит из нескольких строк, то его заключают в тройные кавычки.

Конфигурационный файл может состоять из нескольких разделов ( секций ), каждая из которых имеет имя и может загружаться отдельно от остальных секций `[<имя_секции>]`. Кроме секций в конфигурационном файле могут содержаться глобальные переменные - они не входят ни в одну секцию и всегда загружаются при загрузке конфигурационного файла. Если загружается какая-то одна секция, то загружаются ее переменные и глобальные переменные. Если переменная существует и как глобальная переменная, и как переменная секции, то используется переменная секции. 

Чтобы спрятать значение переменной или секцию целиком, нужно перед ее именем поставить точку `.`. В таком случае при загрузке конфигурационного файла эти данные нельзя будет прочесть.
Комментарии в конфигурационном файле можно обозначать символом `#`.

## <a id="Использование-шаблонов" href="#Использование-шаблонов">Использование шаблонов</a>

`$smarty->assign("<переменная>", <значение>);` - присваивает переменной значение  
`$smarty->assign(array("<переменная1>" => <значение1>[, ...]));` - присваивает значения переменным  
`$smarty->append("<переменная>", <значение>);` - позволяет присоединить элемент к массиву, если присоединяеть значение к строковой переменной, то она преобразуется в массив, и значение добавляется уже в него  
`$smarty->append(array("<переменная1>" => <значение1>[, ...]));` - присваивает позволяет присоединить значения переменным  
`$smarty->get_template_vars(["<переменная>"]);` - возвращает массив всех назначенных переменных шаблону [значение указаной переменной]  
`$smarty->display("<имя_шаблона>");` - выводит обработанный шаблон  
`$smarty->fetch("<имя_шаблона>");` - возвращает обработанный шаблон в строковую переменную, вместо того чтобы выводить его на экран  
`$smarty->config_load("<имя_файла>", ["<имя_секции>"]);` - загружает конфигурационный файл и встраивает его в шаблон

<a id="PHP-7" href="#PHP-7">PHP 7</a>
=====

## <a id="Метод-call-у-замыканий-Closure-PHP7" href="#Метод-call-у-замыканий-Closure-PHP7">Метод `call()` у замыканий Closure (PHP7)</a>

Новый метод `call()` - используется для выполнения лямбды с прикрепленным объектом выполнения.

```php
class A {private $x = 1;}
$getX = function() {return $this->x;};
echo $getX->call(new A);
```

## <a id="Ожидания---Expectations-PHP7" href="#Ожидания---Expectations-PHP7">Ожидания - Expectations (PHP7)</a>

`assert(<утверждение>[, {<ошибка> | <исключение>}]);`

Если первый параметр функции равен `false`, то бросается исключение / выводится ошибка с `AssertionError` (второй параметр)

`ini_set('assert.exception', 1);` - установка генерирования исключения
Настройки `PHP.ini`: `zend.assertions = 1`. Где:
- `1` - обрабатывать утверждения assert (режим разработки | development mode);
- `0` - генерировать код, но не выполнять;
- `-1` - игнорировать код (0-стоимость, production mode).

## <a id="Целочисленное-деление-intdiv-PHP7" href="#Целочисленное-деление-intdiv-PHP7">Целочисленное деление `intdiv()` (PHP7)</a>

Функция `intdiv(<число1>, <число2>)` - позволяет делить числа на выходе получая целые числа.

## <a id="Функции-CSPRNG-PHP7" href="#Функции-CSPRNG-PHP7">Функции CSPRNG (PHP7)</a>

Криптографически стойкий генератор псевдослучайных чисел (англ. Cryptographically secure pseudorandom number generator, CSPRNG). Нововведение добавляет две новых функции для генерации криптографических стойких целых чисел и строк. Функции работают одинаково на всех платформах.

`random_bytes(<длина>)` - возвращает случайный набор байтов указанной длины в виде строки  
`random_int(<минимум>, <максимум>)` - возвращает случайное целое в указанном диапазоне

Обе функции сгенерируют исключение `Error`, если источник необходимой случайности будет не найден.

## <a id="Целочисленная-семантика-PHP7" href="#Целочисленная-семантика-PHP7">Целочисленная семантика (PHP7)</a>

Поменялась семантика работы с целыми числами для обеспечения кроссплатформенности:
- преобразование `NAN` и `INF` в integer всегда = 0;
- битовый сдвиг `<<, >>` на отрицательное число теперь запрещен (возвращает `false`, с ошибкой `E_WARNING`);
- `<<` левый сдвиг с количством бит превышающем размер целого всегда = 0;
- `>>` правый сдвиг с количством бит превышающем размер целого = 0 или -1 (зависит от знака).