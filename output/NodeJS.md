[Содержание](#Содержание)
==========

- [Node.JS](#user-content-NodeJS)
    - [Запуск](#user-content-Запуск)
    - [Асинхронность для операций **I/O**](#user-content-Асинхронность-для-операций-IO)
    - [Модули](#user-content-Модули)
        - [Базовая настройка](#user-content-Базовая-настройка)
        - [Экспорт функций модуля](#user-content-Экспорт-функций-модуля)
    - [Функции обратного вызова (callback)](#user-content-Функции-обратного-вызова-callback)
    - [Использование `EventEmitters`](#user-content-Использование-EventEmitters)
        - [Комбинирование колбэков и `EventEmitter`](#user-content-Комбинирование-колбэков-и-EventEmitter)
    - [Ошибки](#user-content-Ошибки)
    - [Таймеры](#user-content-Таймеры)
    - [Потоки](#user-content-Потоки)
        - [`stream.Readable`](#user-content-streamReadable)
            - [Произвольный поток чтения](#user-content-Произвольный-поток-чтения)
        - [`stream.Writable`](#user-content-streamWritable)
            - [Произвольный поток записи](#user-content-Произвольный-поток-записи)
        - [`stream.Duplex`](#user-content-streamDuplex)
        - [`stream.Transform`](#user-content-streamTransform)
            - [Произвольный поток преобразования](#user-content-Произвольный-поток-преобразования)
    - [`Process`](#user-content-Process)
        - [Потоки ввода-вывода](#user-content-Потоки-ввода-вывода)
    - [`Buffer`](#user-content-Buffer)
        - [`btoa` / `atob`](#user-content-btoa--atob)
        - [Порядок байтов](#user-content-Порядок-байтов)
    - [Глобальные объекты](#user-content-Глобальные-объекты)
    - [NPM](#user-content-NPM)
        - [NPX](#user-content-NPX)
        - [Рекомендации по формированию номера версии](#user-content-Рекомендации-по-формированию-номера-версии)
    - [Стандартные модули](#user-content-Стандартные-модули)
        - [Модуль `fs`](#user-content-Модуль-fs)
        - [Модуль `util`](#user-content-Модуль-util)
        - [Модуль `child_process`](#user-content-Модуль-childprocess)
        - [Модуль `cluster`](#user-content-Модуль-cluster)
        - [Модуль `worker_threads`](#user-content-Модуль-workerthreads)
            - [Строение воркера](#user-content-Строение-воркера)
        - [Модуль `dns`](#user-content-Модуль-dns)
        - [Модуль `url`](#user-content-Модуль-url)
        - [Модуль `querystring`](#user-content-Модуль-querystring)
        - [Модуль `http`](#user-content-Модуль-http)
        - [Модуль `https`](#user-content-Модуль-https)
        - [Модуль `net`](#user-content-Модуль-net)
        - [Модуль `dgram`](#user-content-Модуль-dgram)
        - [Модуль `path`](#user-content-Модуль-path)
        - [Модуль domain (устаревший)](#user-content-Модуль-domain-устаревший)
        - [Модуль `readline`](#user-content-Модуль-readline)
        - [Модуль `crypto`](#user-content-Модуль-crypto)
        - [Модуль `os`](#user-content-Модуль-os)
        - [Модуль `assert`](#user-content-Модуль-assert)
        - [Модуль `test`](#user-content-Модуль-test)
    - [Дополнительные модули](#user-content-Дополнительные-модули)
        - [Модуль `debug`](#user-content-Модуль-debug)
        - [Модуль `mime`](#user-content-Модуль-mime)
        - [Модуль `optimist`](#user-content-Модуль-optimist)
        - [Модуль `nconf`](#user-content-Модуль-nconf)
        - [Модуль `async`](#user-content-Модуль-async)
        - [Модуль `ws`](#user-content-Модуль-ws)
        - [Модуль `formidable`](#user-content-Модуль-formidable)
        - [Модуль `redis` для работы с Redis](#user-content-Модуль-redis-для-работы-с-Redis)
            - [Пары ключ/значение](#user-content-Пары-ключзначение)
            - [Хеш-таблицы](#user-content-Хеш-таблицы)
            - [Список](#user-content-Список)
            - [Множества](#user-content-Множества)
            - [Подписки](#user-content-Подписки)
        - [Модуль `mysql` для работы с MySql](#user-content-Модуль-mysql-для-работы-с-MySql)
        - [Модуль `mongodb` для работы с MongoDB](#user-content-Модуль-mongodb-для-работы-с-MongoDB)
    - [Фреймворк `Connect`](#user-content-Фреймворк-Connect)
        - [Связующие программы](#user-content-Связующие-программы)
            - [Собственные связующие программы](#user-content-Собственные-связующие-программы)
            - [Собственная обработка ошибок приложения](#user-content-Собственная-обработка-ошибок-приложения)
        - [Связующие программы `Connect`](#user-content-Связующие-программы-Connect)
    - [Фреймворк Express](#user-content-Фреймворк-Express)
        - [Установка](#user-content-Установка)
        - [Структура каталогов проекта](#user-content-Структура-каталогов-проекта)
        - [Базовая настройка](#user-content-Базовая-настройка)
        - [Конфигурирование](#user-content-Конфигурирование)
        - [Middleware](#user-content-Middleware)
            - [Основные свойства запроса `request`](#user-content-Основные-свойства-запроса-request)
            - [Основные методы запроса `request`](#user-content-Основные-методы-запроса-request)
            - [Основные методы ответа `response`](#user-content-Основные-методы-ответа-response)
        - [Роутинг](#user-content-Роутинг)
        - [Хранение транзитных сообщений в сеансах](#user-content-Хранение-транзитных-сообщений-в-сеансах)
        - [Шаблонизация ejs](#user-content-Шаблонизация-ejs)
    - [Тестирование](#user-content-Тестирование)
        - [Модуль `assert`](#user-content-Модуль-assert)
    - [Шаблонизатор EJS](#user-content-Шаблонизатор-EJS)
        - [Фильтры](#user-content-Фильтры)
    - [Шаблонизатор Hogan (Mustache)](#user-content-Шаблонизатор-Hogan-Mustache)
        - [Mustache-теги](#user-content-Mustache-теги)
            - [Лямбда-секции](#user-content-Лямбда-секции)
        - [Компоненты](#user-content-Компоненты)
    - [Шаблонизатор Jade](#user-content-Шаблонизатор-Jade)
        - [Данные в Jade-шаблоне](#user-content-Данные-в-Jade-шаблоне)
        - [Jade-теги](#user-content-Jade-теги)
        - [Программная логика в Jade-шаблонах](#user-content-Программная-логика-в-Jade-шаблонах)
        - [Условные и итеративные инструкции](#user-content-Условные-и-итеративные-инструкции)
        - [Наследование шаблонов](#user-content-Наследование-шаблонов)
        - [Включение шаблонов](#user-content-Включение-шаблонов)
        - [Примеси](#user-content-Примеси)
- [Основы проектирования Node-приложений](#user-content-Основы-проектирования-Node-приложений)
    - [Структура проекта](#user-content-Структура-проекта)
        - [Структурирование решений на основе компонентов](#user-content-Структурирование-решений-на-основе-компонентов)
        - [Слои компонентов](#user-content-Слои-компонентов)
        - [Общие утилиты](#user-content-Общие-утилиты)
        - [Разделение Express "приложения" и "сервера"](#user-content-Разделение-Express-приложения-и-сервера)
        - [Параметры приложения](#user-content-Параметры-приложения)
    - [Струткура приложения](#user-content-Струткура-приложения)
- [Основы развертывания Node-приложений](#user-content-Основы-развертывания-Node-приложений)
    - [Инструмент Nodejitsu Forever](#user-content-Инструмент-Nodejitsu-Forever)
    - [Поддержание доступности приложения, Upstart](#user-content-Поддержание-доступности-приложения-Upstart)
    - [Распределение нагрузки с помощью Nginx](#user-content-Распределение-нагрузки-с-помощью-Nginx)

<a id="NodeJS" href="#NodeJS">Node.JS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

Представляет собой язык JS на сервере.

## <a id="Запуск" href="#Запуск">Запуск</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`node [<флаги>] <файл_входа>.js` - запуск файла `<файл_входа>.js`, где `<флаги>`:
- `--watch` - в режиме наблюдения с перезапуском;
- `--env-file=<файл_с_переменными_окруждения>` - с установкой переменных окружения;
- `--expose-gc` - запуск с минимальным участием GC;
- `--experimental-permission <разрешения>` - включает режим установки разрешений для приложения, где `<разрешения>` могут быть:
    - `--allow-fs-read=<путь>` - с разрешением читать только по пути;
    - `--allow-fs-write=<путь>` - с разрешением писать только по пути;
    - `--allow-net=<адрес>` - с разрешением обращаться по сети только на адрес;

## <a id="Асинхронность-для-операций-IO" href="#Асинхронность-для-операций-IO">Асинхронность для операций **I/O**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`UV_THREADPOOL_SIZE=<количество_асинхронных_нитий>` - переменная окружения, которая устанавливает количество потоков (нитий) для операций **I/O** (по умолчанию 4).

## <a id="Модули" href="#Модули">Модули</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Базовая-настройка" href="#Базовая-настройка">Базовая настройка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var <модуль> = require("<имя_модуля>");` - происходит подключения файла с модулем `<имя_модуля>` (можно указывать или не указывать расширение файла), которое сначала ищет в текущей директории с расширением `js`, `json`, а затем если не находит, то в папке с именем модуля в файле `index`, которая будет главной точной входа в модуль, то есть объект `exports` модуля станет равен `<модуль>`.

### <a id="Экспорт-функций-модуля" href="#Экспорт-функций-модуля">Экспорт функций модуля</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`exports.<имя_экспорта> = <экспортируемый_объект>;`

Объект `exports` доступен в любом модуле и возвращается при каждом вызове функции `require` при подключении модуля.

`global.<имя_экспорта> = <экспортируемый_объект>;` - подключение объекта в глобальную область видимости, то есть теперь не нужно использовать объект модуля.

`module` - главный объект модуля, который доступен в модуле.  
`module.parent` - информация о том, кто подключает текущий модуль.  
`module.exports` - ссылка на `exports`.  
`module.exports = <функция>;` - экспорт только единственной функции, подходит для конструктора.

`node_modules` - используется как базовая директория для модулей, для текущего проекта, там будут искаться подключаемые модули по базовому названию.

Модуль кэшируется, то есть инициализируется один раз, при множественном подключении.

## <a id="Функции-обратного-вызова-callback" href="#Функции-обратного-вызова-callback">Функции обратного вызова (callback)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Если функция должна принимать **callback** функцию, то она должна принимать ее **последним параметром**.

Если **callback** функция должна принимать ошибку, то она должна принимать ее в качестве **первого параметра**.

Для того чтобы избежать двойного вызова функции обратного вызова, используется такая конструкция: `return callback(...)`.

Если функция принимает колбэк, то она не должна его вызывать сразу, а использовать для его вызова (в качестве обвертки): `setImmediate()` или `process.nextTick()`.

## <a id="Использование-EventEmitters" href="#Использование-EventEmitters">Использование `EventEmitters`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Node.js реализует шаблон проектирования наблюдатель, используя класс `EventEmitter`. Всегда, когда есть объект, который является источником событий, Node.js наследует класс этого объекта от класса `EventEmitter`.

`const EventEmitter = require('events');`

`const <eventEmitter> = new EventEmitter();`

`<eventEmitter>.on("<событие>", <функция_обработки>)` - связывает событие объекта с функцией обработки, которая будет вызвана при событии, добавляет в конец очереди обработчиков события, возвращает ссылку на объект `<eventEmitter>`, которому она принадлежит, что позволяет связывать в цепочки вызовов несколько прослушивателей событий.  
`<eventEmitter>.addListener("<событие>", <функция_обработки>)` - синоним `on`.  
`<eventEmitter>.once("<событие>", <функция_обработки>)` - аналогично предыдущей, только реагирует на первое возникновение события.  
`<eventEmitter>.prependListener("<событие>", <функция_обработки>)` - аналогично `on` только добавляет в начало очереди обработчиков события.  
`<eventEmitter>.prependOnceListener("<событие>", <функция_обработки>)` - аналогично `once` только добавляет в начало очереди обработчиков события.  

`<eventEmitter>.removeListener("<событие>", <функция_обработки>)` - удаляет функцию прослушивания с определенного события.  
`<eventEmitter>.off("<событие>", <функция_обработки>)` - (node 10) синоним `removeListener`.  
`<eventEmitter>.removeAllListeners("<событие>")` - удаляет всех обработчиков с определенного события.

`<eventEmitter>.emit("<событие>"[, <аргумент1>[, ...]])` - вызывает всех слушателей события по порядку подписки, с указанными аргументами.

`<eventEmitter>.listeners("<событие>")` - возвращает массив слушателей события данного типа.  
`<eventEmitter>.listenerCount("<событие>")` - возвращает количество слушателей события данного типа.  
`<eventEmitter>.setMaxListeners(<количество>)` - устанавливает количество разрешенных слушателей.

При создании генераторов событий применяется соглашение, что вместо непосредственного вызова ошибки можно генерировать событие `error`. Если не задан ни один слушатель для события этого типа, то в результате генерирования события типа `error` генератор событий выведет на экран трассировку стека и остановит выполнение программы. Трасса стека будет указывать на ошибку, тип которой определяется с помощью второго аргумента вызова `emit`. Подобное поведение присуще только событиям типа `error`.

`EventEmitter` должен использоваться вместо колбэка, когда есть больше чем одно событие или событие вызывается множественное количество раз или когда необходимо подписавать множественное количество объектов.

### <a id="Комбинирование-колбэков-и-EventEmitter" href="#Комбинирование-колбэков-и-EventEmitter">Комбинирование колбэков и `EventEmitter`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Иногда удобно комбинировать колбэки и `EventEmitter`. Для этого функция возвращает `EventEmitter` и принимает колбэк последним аргументом для основного события, если он есть, то использует его иначе `EventEmitter`.

## <a id="Ошибки" href="#Ошибки">Ошибки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Реализуются и наследуются от стандартного класса `Error`. Необходимо переопределить свойства `name` и `message`.

`Error.captureStackTrace(this)`- производит захват стека, пишется внутри конструктора класса ошибки.

## <a id="Таймеры" href="#Таймеры">Таймеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Аналогично встроенным в браузер.

`var <timer> = setTimeout(<функция>, <задержка_мс>[, <аргумент1_для_функции>[, ...]])` - исполнение `<функция>` произойдет спустя время, указанное в `<задержка_мс>`, возвращает таймер `<timer>`, который можно использовать для отмены действия.

`clearTimeout(<timer>)` - отменяет исполнение таймера.

`var <timer> = setInterval(<функция>, <задержка_мс>[, <аргумент1_для_функции>[, ...]])` - исполнение `<функция>` произойдет спустя время, указанное в `<задержка_мс>`, а затем будет повторятся через каждые `<задержка_мс>`, возвращает таймер <`timer>`, который можно использовать для отмены действия.

`clearInterval(<timer>)` - отменяет исполнение интервала.

`<timer>.unref()` - означает что таймер служебный, то есть его можно завершить и он не будет препятствовать завершению процесса.  
`<timer>.ref()` - отменяет `unref`.

`process.nextTick(function () {...})` - запускает следующую функцию асинхронно, после завершения текущей итерации цикла событий, до начала следующей, до следующей операции ввода/вывода.

`setImmediate(function () {...})` - запускает следующую функцию асинхронно, на следующей итерации цикла событий, после операции ввода/вывода. Это как `setTimeout(function () {...}, 0)`

## <a id="Потоки" href="#Потоки">Потоки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var stream = require('stream');`

### <a id="streamReadable" href="#streamReadable">`stream.Readable`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Может работать в двух режимах: в поточном режиме и в нее его (по умолчанию).

Необходимо придерживаться единого метода получения данных и не переключаться между ними.

`var <stream> = new stream.Readable([<опции>]);` - универсальный поток для чтения. Где опции - объект со свойствами:
- `encoding` - кодировка, по умолчанию `null`, задается в виде `"<кодировка>"`;
- `objectMode` - объектный режим если `true`, по умолчанию `false`;
- `highWaterMark` - максимальный размер буфера задается в виде `<размер_в_байтах>` или `<количество_объектов>`, по ум. 16KB или 16 объектов;
- `read` - представление внутреннего метода `_read`, в виде функции `<функция>`.

`var <stream> = <поток>;` - поток для чтения.

`<stream>.on('readable', function () {...});` - (не поточный режим) вызывается при считывании данных из потока.

`<stream>.read([<размер>])`; - возвращает часть считанных данных [указанного размера] из потока в виде строки, `Buffer`, а также `null`, если данных уже в буфере нет. Используется внутри функции события `'readable'`. Для считывания всего буфера используются такая конструкция:
```javascript
var chunk;
while((chunk = <stream>.read()) !== null) {
    ...
}
```

`<stream>.on('data', function (chunk) {...});` - (поточный режим) вызывается при считывании данных из потока, где `chunk` - это часть данных в виде строки, `Buffer` или другого типа, включает поточный режим.  
`<stream>.on('end', function () {...});` - вызывается при завершении считывания данных из потока.  
`<stream>.on('error', function (err) {...});` - вызывается при ошибке считывания данных из потока.  

`<stream>.pipe(<writable_stream>[, <опции>]);` - считывает часть данных из потока чтения в поток записи, возвращает переданный поток `<writable_stream>`, можно присоединять множественное число потоков записи [, где опции могут быть: `{end: false}` - тогда поток чтения, не вызывает автоматически событие `'end'` после завершения всего чтения].  
`<stream>.unpipe(<writable_stream>);` - отсоединяет поток записи, от потока чтения.

`<stream>.destroy();` - закрывает поток и вызывается событие `'error'`.

`<stream>.isPaused();` - возвращает `true`, если поток приостановлен.  
`<stream>.pause();` - приостанавливает поток, в это время он перестает генерировать события `'data'`.  
`<stream>.resume();` - возобновляет поток, включает поточный режим.

`<stream>.setEncoding("<кодировка>");` - устанавливает кодировку, возвращает `<stream>`.

`<stream>.unshift(<chunk>);` - записывает данные обратно в буфер потока, нельзя вызывать после события `'end'`.

#### <a id="Произвольный-поток-чтения" href="#Произвольный-поток-чтения">Произвольный поток чтения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```javascript
function <Stream>() {
    stream.Readable.call(this, options);
}
util.inherits(<Stream>, stream.Readable);
<Stream>.prototype._read = function (size) {
    ...
    this.push(<chunk>[, "<кодировка>"]);
}
```

Создает новый класс, который наследуется от `stream.Readable`, `options` представляет собой объект конфигурации.

`_read` - переопределяет внутреннюю функцию заполнения буфера потока, где `size` - предпочитаемый размер, будет вызываться при попытке чтения из потока, внутри этой функции нужно вызывать функцию для заполнения буфера данными:  
    `this.push(<chunk>[, "<кодировка>"]);` - записывает данные в буфер потока и если есть еще место в буфере (ограничено `highWaterMark`), то возвращает `true`, иначе `false`, для окончания передачи нужно передать `null`.

### <a id="streamWritable" href="#streamWritable">`stream.Writable`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var <stream> = new stream.Writable([<опции>]);` - универсальный поток для записи. Где `<опции>` - объект со свойствами:
- `decodeStrings` - автоматическая конвертация строк в буфер перед передачей их в метод `_write()` при значении `true`, по умолчанию `true`;
- `objectMode` - объектный режим при значении `true`, по умолчанию `false`;
- `highWaterMark` - максимальный размер буфера задается в виде `<размер_в_байтах>` или `<количество_объектов>`, по ум. 16KB или 16 объектов;
- `final` - представление внутреннего метода `_final`, в виде функции `<функция>`;
- `write` - представление внутреннего метода `_write`, в виде функции `<функция>`;
- `writev` - представление внутреннего метода `_writev`, в виде функции `<функция>`.

`var <stream> = <поток>;` - поток для записи.

`<stream>.setDefaultEncoding("<кодировка>");` - устанавливает кодировку по умолчанию, возвращает `<stream>`.

`<stream>.write(<data>[, "<кодировка>"][, function () {...}]);` - записывает данные в поток и если есть еще место в буфере, то возвращает `true`, иначе `false` [, вызывает колбэк, когда данные будут записаны]. Для записи большого куска данных в поток, которые больше размера буфера `highWaterMark`, используется такая конструкция:
```javascript
function generateMore() {
    var shouldContinue = <stream>.write(<data>);
    if (!shouldContinue) {
        return <stream>.once('drain', generateMore);
    }
    <stream>.end(<end_data>, function () {...});
}
generateMore();
```

`<stream>.cork();` - включает запись данных в память, а не в буфер, используется для избежания генерации событий вставки в буфер для множества маленьких данных.  
`<stream>.uncork();` - записывает все данные из памяти в буфер.

`<stream>.on('drain', function () {...});` - вызывается при завершении считывания данных из буфера потока.  
`<stream>.end([<data>][, "<кодировка>"][, function () {...}]);` - [записывает данные в поток и] финализирует поток.  
`<stream>.on('finish', function (err) {...});` - вызывается при завершении считывания данных из буфера потока и финализации потока, после вызова `<stream>.end([<data>])` у потока.  
`<stream>.on('error', function (err) {...});` - вызывается при ошибке считывания данных из потока.

`<stream>.destroy();` - закрывает поток и вызывается событие `'error'`.

`<stream>.on('pipe', function (<readable_stream>) {...});` - вызывается, когда метод `<stream>.pipe(<writable_stream>)` вызывается в универсальном потоке для чтения для добавления в набор назначения.

`<stream>.on('unpipe', function (<readable_stream>) {...});` - вызывается, когда метод `<stream>.unpipe(<writable_stream>)` вызывается в универсальном потоке для чтения для удаления из набора назначения.

#### <a id="Произвольный-поток-записи" href="#Произвольный-поток-записи">Произвольный поток записи</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```javascript
function <Stream>() {
    stream.Writable.call(this, options);
}
util.inherits(<Stream>, stream.Writable);
<Stream>.prototype._final = function (callback) {
    ...
}
<Stream>.prototype._write = function (chunk, encoding, callback) {
    ...
}
<Stream>.prototype._writev = function (chunks, callback) {
    ...
}
```

Создает новый класс, который наследуется от `stream.Writable`, `options` представляет собой объект конфигурации.

`_final` - переопределяет внутреннюю функцию финиша записи, где `callback` - колбэк завершения записи, который необходимо вызвать.

`_write` - переопределяет внутреннюю функцию записи, где `chunk` - данные, `encoding` - кодировка, а `callback` - колбэк завершения записи, который необходимо вызвать.

`_writev` - переопределяет внутреннюю функцию записи для обработки множественных кусков данных, где `chunk` - массив данных с элементами в виде: `{chunk: <данные>, encoding: <кодировка>}`, а `callback` - колбэк завершения записи, который необходимо вызвать.

### <a id="streamDuplex" href="#streamDuplex">`stream.Duplex`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это потоки, которые реализуют и `stream.Readable` и `stream.Writable`.

`var <stream> = new stream.Duplex([<опции>]);` - создает поток, дополнительные опции создания, к опциям `stream.Readable` и `stream.Writable`:
- `allowHalfOpen` - автоматическое закрытие потока чтения при закрытии потока записи при значении `true`, по умолчанию `true`;
- `readableObjectMode` - объектный режим для чтения при значении `true`, по умолчанию `false`;
- `writableObjectMode` - объектный режим записи при значении `true`, по умолчанию `false`;
- `readableHighWaterMark` максимальный размер буфера для чтения задается в виде `<размер_в_байтах>` или `<количество_объектов>`, по ум. 16KB или 16 объектов;
- `writableHighWaterMark` максимальный размер буфера для записи задается в виде `<размер_в_байтах>` или `<количество_объектов>`, по ум. 16KB или 16 объектов.

### <a id="streamTransform" href="#streamTransform">`stream.Transform`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это потоки, которые реализуют `Duplex`, и преобразовывают данных на этапе получения из потока записи в поток чтения.

`var <stream> = new stream.Transform([<опции>]);` - создает поток, дополнительные создания:
- `decodeStrings` - автоматическая конвертация строк в буфер перед передачей их в метод `_transform()` при значении `true`, по умолчанию `true`;
- `objectMode` - объектный режим при значении `true`, по умолчанию `false`;
- `transform` - представление внутреннего метода `_transform`, в виде функции `<функция>`;
- `flush` - представление внутреннего метода `_flush`, в виде функции `<функция>`.

#### <a id="Произвольный-поток-преобразования" href="#Произвольный-поток-преобразования">Произвольный поток преобразования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```javascript
function <Stream>() {
    stream.Transform.call(this, options);
}
util.inherits(<Stream>, stream.Transform);
<Stream>.prototype._transform = function (chunk, encoding, callback) {
    ...
    this.push(<chunk>[, "<кодировка>"]);
    [callback([<err>[, <chunk>]]);]
}
<Stream>.prototype._flush = function (callback) {
    ...
    this.push(<chunk>[, "<кодировка>"]);
    [callback([<err>[, <chunk>]]);]
}
```

Создает новый класс, который наследуется от stream.Transform, options представляет собой объект конфигурации.

`_transform` - переопределяет внутреннюю функцию преобразования, где `chunk` - данные, `encoding` - кодировка, а `callback` - колбэк завершения записи, который необходимо вызвать. Внутри нужно вызвать указаную функцию:  
    `this.push(<chunk>[, "<кодировка>"]);` - записывает данные в буфер потока и если есть еще место в буфере (ограничено `highWaterMark`), то возвращает `true`, иначе `false`, для окончания передачи нужно передать `null`.  
    `callback([<err>[, <chunk>]]);` - альтернативный вызов предыдущего варианта.

`_flush` - переопределяет внутреннюю функцию, которая вызывается перед тем как входящий поток завершится, и используется для вставки оставшихся данных в исходящий поток, `callback` - колбэк завершения записи, который необходимо вызвать.

## <a id="Process" href="#Process">`Process`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Глобальный объект, который доступен как `process` и содержит информацию о текущем процессе Node. Имеет свойства:  
- `process.argv` - возвращает все переменные переданные во время запуска;
- `process.env.<имя_окружения>` - возвращает значение окружения;
- `process.execPath` - возвращает путь выполнения Node;
- `process.version` - возвращает версию Node;
- `process.platform` - возвращает платформу сервера;
- `process.pid` - возвращает `pid` процесса;
- `process.memoryUsage()` - возвращает объект в котором содержится информация о потребляемой памяти, с указанными свойствами:
    - `rss` - содержит в виде числа размер всей памяти в байтах;
    - `heapTotal` - содержит в виде числа размер кучи в байтах;
    - `heapUsed` - содержит в виде числа сколько использовано кучи в байтах;
    - `external` - содержит в виде числа размер памяти занимаемой C++ объектами в байтах.

`process.exit(<код>);` - завершает процесс с указанным кодом ошибки.

`process.cwd();` - возвращает текущую рабочую директорию запущенного процесса.

`process.on('exit', function (err) {...});` - вызовется непосредственно перед завершением процесса, уже после остановки цикла событий.  
`process.on('SIGINT', function () {...});` - вызовется непосредственно после нажатия клавиш `Ctrl-C` для уничтожении процесса или приема сигнала `SIGINT`.  
`process.on('<сигнал>', function () {...});` - вызовется непосредственно после приема сигнала `POSIX`.  
`process.on('uncaughtException', function (error) {...});` - вызовется при перехвате не перехваченного исключения, где `error` - ошибка.  
`process.on('unhandledRejection', function (reason, promise) {...});` - вызовется при перехвате не обработаного отклоненного промиса, где `reason` - значение с которым промис отклонился, а `promise` - промис.

`process.kill(<pid_процесса>[, '<сигнал>']);` - убивает процесс [посылая ему указанный сигнал].

### <a id="Потоки-ввода-вывода" href="#Потоки-ввода-вывода">Потоки ввода-вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Потоки `process.stdout`, `process.stdin` являются асинхронными, а `process.stderr` синхронным.
`process.stdin.resume();` - возобновляет поток для ввода, так как по ум. приостановлен.  
`process.stdin.on('data', function (data) {...});` - вызывается каждый раз при получении данных.

`process.stdout.write(<data>);` - записывает данные в поток вывода.

## <a id="Buffer" href="#Buffer">`Buffer`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Специальный тип данных `Buffer` действует как фрагмент необработанных данных фиксированной длины. Буферы подобны массивам, отличия заключаются в том, что размеры буфера неизменны, причем буфер может содержать только значения в диапазоне от 0 до 255. Буфер можно рассматривать как эквивалент функции `malloc()` языка C или оператора `new` языка C++.

`var <buffer> = new Buffer(<данные>);` - считается устаревшим.

`Buffer.alloc(<размер>[, <значение_заполнитель>[, <кодировка>]])` - создает `Buffer` указаного размера [, во значениями `<значение_заполнитель>` [, в указаной кодировке `<кодировка>`]].

`<buffer>.length;` - содержит длину буфера.  
`<buffer>.toString([<кодировка>]);` - возвращает содержимое буфера в виде строки, виды кодировок:
- `'ascii'` - только для 7-bit ASCII данных;
- `'utf8'`;
- `'utf16le'`;
- `'ucs2'` - синоним `'utf16le'`;
- `'base64'`;
- `'latin1'`;
- `'binary'` - синоним `'latin1'`;
- `'hex'` - каждый байт представляет собой вид двух hex-символов.

`Buffer.from(<массив>)` - возвращает буфер из массива.  
`Buffer.from('<строка>')` - возвращает буфер из строки.  
`Buffer.from(<буфер>)` - возвращает точную копию буфера из буфера.

`Buffer.concat(<массив_из_буферов>)` - возвращает новый буфер в котором соеденины буферы из массива.

`Buffer.byteLength('<строка>')` - возвращает длину строки в байтах.  

`<buffer>.write<Тип>(<данные>[, <позиция>]);` - записывает в буфер данные [, начиная с указанной позиции].

### <a id="btoa--atob" href="#btoa--atob">`btoa` / `atob`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Их реализаций не имеется, есть альтернативы:
- `btoa('<строка>')` - `Buffer.from('<строка>').toString('base64')`;
- `atob('<строка_в_формате_Base64>')` - `Buffer.from('<строка_в_формате_Base64>', 'base64').toString()`.

### <a id="Порядок-байтов" href="#Порядок-байтов">Порядок байтов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Он относится к порядку следования байтов в многобайтовой последовательности. Если байты расположены в последовательности от младшего к старшему, младший значащий бит (*Least Significant Byte*, *LSB*) хранится первым, а последовательность байтов считывается в направлении справа налево. В случае расположения байтов от старшего к младшему сначала сохраняется старший байт (*Most Significant Byte*, *MSB*), а последовательность байтов считывается в направлении слева направо.

## <a id="Глобальные-объекты" href="#Глобальные-объекты">Глобальные объекты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`__dirname` - возвращает полный путь к каталогу текущего модуля.  
`__filename` - возвращает полный путь к файлу текущего модуля.

## <a id="NPM" href="#NPM">NPM</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`npm {i | install} [--production] [-g | --global] [<имя_модуля>[@<номер_версии>]]` - производит установку всех модулей из файла `package.json` из `dependencies` и `devDependencies` [указанного модуля `<имя_модуля>` [указанной версии `<номер_версии>` (`latest` - последняя на текущий момент)]] в самую ближайшую папку `node_modules`. Ключи:
- `--production` - `devDependencies` игнорируется при установке;
- `-g` | `--global` - означает использование как глобального модуля;
- `--save-prod` | `-P` - (по умолчанию) добавит указанный пакет в список зависимостей проекта для разработки в `dependencies`;
- `--save-dev` | `-D` - добавит указанный пакет в список зависимостей проекта в `devDependencies`;
- `--save-optional` | `-O` - добавит указанный пакет в список зависимостей проекта в `optionalDependencies`;
- `--save-peer` - добавит указанный пакет в список зависимостей проекта в `peerDependencies`.

Для того чтобы поменять местоназначение пакета `dependencies` / `devDependencies` / `optionalDependencies` / `peerDependencies` нужно помторно произвести установку пакета с указанным флагом расположения `-P` / `-D` / `-O` / `--save-peer`.

Флаг `--prefix <путь_к_каталогу>` к командам производит все манипуляции с пакетами в указанном каталоге: `<путь_к_каталогу>`.

Установка из git-репозитория:
- с сайта github.com:
    - `npm install https://github.com/<имя_пользователя>/<имя_репозитория>/tarball/<имя_ветки>`;
    - `npm install <имя_пользователя>/<имя_репозитория>}[#<имя_ветки>]`;
    - `npm install git+https://git@github.com/<имя_пользователя>/<имя_репозитория>.git`;
    - `npm install git+ssh://git@github.com/<имя_пользователя>/<имя_репозитория>.git`.
- с произвольного:
    - `npm install {git | git+ssh | git+http | git+https | git+file}://[<пользователь>[:<пароль>]@]<имя_хоста>[:<порт>][:][/]<путь_к_репозиторию>[#<номер-коммита> | #<имя_ветки> | #<имя_тега> | #semver:<значение>]`.

> `npm install express`  
> `npm install visionmedia/express#master`  
> `npm install --save https://github.com/Amitesh/gulp-rev-all/tarball/master`  
> `npm install git+ssh://git@github.com:npm/cli#semver:^5.0`  
> `npm install git+https://isaacs@github.com/npm/cli.git`

`npm update [-g | --global] [<имя_модуля>]` - производит обновление всех модулей [только указаного `<имя_модуля>`] до актуальной версии мажора - минора и патча.

`npm outdated [<имя_модуля>] `- производит проверку всех модулей [только указаного] на наличие новой версии.

`npm search <ключевое_слово>[ ...]` - производит поиск всех модулей по указанным ключевым словам и выводит их.

`npm {uninstall | remove| rm | r | un | unlink} [-g | --global] <имя_модуля>[@<номер_версии>] [-S | --save]` - удаляет указанный пакет. Ключи:
- `-S` | `--save` - удаляет пакет также из `dependencies`.

`npm {ls | list | la | ll} [-g | --global] [--depth=0] [<имя_модуля>] [--dev | --prod]` - отображает список установленных локальных [глобальных] пакетов [только указаного `<имя_модуля>`] [только пакеты верхнего уровня, которые перечислены в `package.json`] [только зависимости из `devDependencies` | только зависимости из `dependencies`].

`npm init` - создает пакет и файл информации о нем: `package.json`.

`npm view <имя_модуля>` - возвращает подробую информацию о пакете.  
`npm view <имя_модуля> version` - возвращает самый последний номер версии пакета.  
`npm view <имя_модуля> versions` - возвращает все номера версии пакета.  
`npm view <имя_модуля> <имя_свойства>` - возвращает значение свойства `<имя_свойства>` из файла `package.json` модуля.

`npm show <имя_модуля>` - выводит информацию о пакете.

`npm version [ --no-git-tag-version] { major | minor | patch }` - увеличивает текущую версию пакета (модуля) [без использования git]: `<major>.<minor>.<patch>`.

`npm i --package-lock-only` - перегенирирует `package-lock.json`.

`npm pack [--dry-run]` - собирает [только отображает то, что попадет в] tar-архив для текущего проекта, чтобы его можно было установить в другой проект как пакет, с помощью команды `npm install <package.tar>`.

`npm publish [--access public]` - публикует пакет [с публичным доступом].

`npm cache clean --force` - удаляет кеш пакетов.

`--loglevel verbose` - при добавлении к командам включает логирование.

Строение `package.json`:
```json
{
    "name": "<имя_пакета>",
    "private": true,
    "main": "<путь_к_файлу-точки_входа_в_пакет>",
    "description": "<описание_пакета>",
    "version": "<номер_текущей_версии_пакета>",
    "keywords": "<список_ключевых_слов_о_пакете>",
    "bugs": {
        "url": "<url_куда_можно_отправлять_сообщения_об_ошибках>",
        "email": "<email_куда_можно_отправлять_сообщения_об_ошибках>"
    },
    "licenses": "<тип_лицензии_пакета>",
    "files": [
        "<файл_или_каталог_включения_к_пакету1>"
        ],
    "repositories": {
        "type": "<тип_репозитория_пакета>",
        "url": "<url_репозитория_пакета>"
  	},
    "dependencies": {
        "<имя_пакета1>": "[<|>][=]<номер_версии>[ [<|>][=]<номер_версии>]|*"
    },
    "devDependencies": {
        "<имя_пакета1>": "[<|>][=]<номер_версии>[ [<|>][=]<номер_версии>]|*"
    },
    "peerDependencies": {
        "<имя_пакета1>": "[<|>][=]<номер_версии>[ [<|>][=]<номер_версии>]|*"
    },
    "overrides": {
        "<имя_пакета1>": {
            "<имя_зависимости_пакета1>": "$<имя_общей_зависимости1>",
        }
    },
    "scripts": {
        "start": "<команды_запуска>",
        "install": "<команды_установки>",
        "<команда>": "<команды>",
    },
    "imports": {
        "#<имя_алиаса1>": "<шаблон_или_путь_к_файлу_или_каталогу>",
        "#<имя_алиаса2>": [
            "<шаблон_или_путь_к_файлу_или_каталогу1>"
        ],
        "#<имя_алиаса3>": {
            "<тип_установки1>": "<шаблон_или_путь_к_файлу_или_каталогу>",
            "default": "<шаблон_или_путь_к_файлу_или_каталогу>",
        }
    }
}
```

При этом в секции:
- `dependencies` - содержаться пакеты, которые необходимы для запуска кода JavaScript;
- `devDependencies` - содержаться пакеты, которые используются для разработки и тестирования кода, но не требуются при его выполнении;
- `peerDependencies` - содержаться пакеты, которые требуются во время выполнения, для работы самого пакета, при установке пакета они не будет ставиться, а будут требоваться из вне.

Где в секции `"scripts"`:
- `"start"` - обозначает что выполнит указанные команды при запуске пакета `npm start`;
- `"install"` - обозначает что выполнит указанные команды при установке пакета;
- `"<команда>"` - обозначает что указанные команды будут вызваны при вызове `npm run <команда>`.

### <a id="NPX" href="#NPX">NPX</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`npx` - утилита, которая позволяет производить запуск исполняемых файлов, входящих в состав npm-пакетов.

`npx [node@<номер_версии>] <имя_модуля>[@<номер_версии>][ <аргумент1>[ ...]]` - запускает [используя указанную версию node] модуль как команду, что приводит к автоматическому поиску нужного файла запуска в папке проекта `node_modules`.

### <a id="Рекомендации-по-формированию-номера-версии" href="#Рекомендации-по-формированию-номера-версии">Рекомендации по формированию номера версии</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<major>.<minor>.<patch>[[-<pre_release>]+<metadata>]`

Где:
- `<major>` - соответствует цифрам, при изменении которой появляются несовместимые изменения с предыдущей мажорной версией;
- `<minor>` - соответствует цифрам, при изменении которой появляется новая функциональность, не нарушая обратной совместимости;
- `<patch>` - соответствует цифрам, при изменении которой исправляется функциональность при нахождении ошибок, не нарушая обратной совместимости;
- `<pre_release>` - обозначает нестабильную версию;
- `<metadata>` - обозначает версию сборки.

> `5.9.26`  
> `5.9.26-beta.1+ML.29`

## <a id="Стандартные-модули" href="#Стандартные-модули">Стандартные модули</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Модуль-fs" href="#Модуль-fs">Модуль `fs`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `fs` реализует файловую систему.

`var fs = require('fs');`

`fs.readFile("<путь_к_файлу>"[, {"binary" | "utf8" | <опции>}], function (err, file) {...});` - читает файл и записывает в переменную `file` все его содержимое (по ум. используется тип `Buffer`), а затем вызывает функцию обратного вызова.  
`fs.readFileSync("<путь_к_файлу>"[, {"binary" | "utf8" | <опции>}]);` - синхронно читает файл и возвращает все его содержимое (по ум. используется тип `Buffer`), в случае ошибки выбрасывает исключение.

`fs.writeFile("<путь_к_файлу>", <содержимое>[, {"binary" | "utf8" | <опции>}], function (err) {...});` - записывает в файл содержимое, а затем вызывает функцию обратного вызова.  
`fs.writeFileSync("<путь_к_файлу>", <содержимое>[, {"binary" | "utf8" | <опции>}]);` - синхронно записывает в файл содержимое, в случае ошибки выбрасывает исключение.

`fs.appendFile("<путь_к_файлу>", <содержимое>[, {"binary" | "utf8" | <опции>}], function (err) {...});` - дописывает в файл содержимое, а затем вызывает функцию обратного вызова.  
`fs.appendFileSync("<путь_к_файлу>", <содержимое>[, {"binary" | "utf8" | <опции>}]);` - синхронно дописывает в файл содержимое, в случае ошибки выбрасывает исключение.

`fs.rename("<путь_к_файлу>", "<новый_путь_к_файлу>", function (err) {...});` - переименовывает файл (или его перемещает по новому пути), а затем вызывает функцию обратного вызова.  
`fs.unlink("<путь_к_файлу>", function (err) {...});` - удаляет файл, а затем вызывает функцию обратного вызова.

`fs.stat("<путь_к_файлу>", function (err, stats) {...});` - возвращает информацию о файле в виде объекта `stats` типа `fs.Stats` с такими методами:
- `stats.isFile()`;
- `stats.isDirectory()`;
- `stats.isBlockDevice()`;
- `stats.isCharacterDevice()`;
- `stats.isSymbolicLink()`;
- `stats.isFIFO()`;
- `stats.isSocket()`.

если `error.code = 'ENOENT'`, то это значит что файл не найден.

`fs.statSync("<путь_к_файлу>");` - синхронно возвращает информацию о файле в виде объекта: `fs.Stats`, в случае ошибки выбрасывает исключение.

`fs.existsSync("<путь_к_файлу>");` - синхронно возвращает `true` если файл существует, иначе `false`, в случае его отсутствия.

`fs.readdir("<путь_к_файлу>", function (err, files) {...});` - читает содержимое каталога, а затем вызывает функцию обратного вызова где `files` - массив файлов каталога.  
`fs.readdirSync("<путь_к_файлу>");` - синхронно читает содержимое каталога, а затем возвращает массив файлов каталога, в случае ошибки выбрасывает исключение.  
`fs.mkdir("<путь_к_каталогу>", function (err) {...});` - создает каталог , а затем вызывает функцию обратного вызова.  
`fs.rmdir("<путь_к_файлу>", function (err) {...});` - удаляет каталог, а затем вызывает функцию обратного вызова.

`fs.watchFile("<путь_к_файлу>", function (curr, prev) {...});` - отслеживает изменение файла, где `curr` и `prev` представляют текущий и предыдущий объекты `fs.Stat`, которые должны иметь различные временные метки, соответствующие времени изменения файла, функция передаваемая этому методу, будет вызываться при каждом изменении файла.

`fs.unwatchFile("<путь_к_файлу>"[, <слушатель>]);` - убирает всех наблюдателей с файла[, или определенного `<слушатель>`].

`fs.watch("<путь>"[, {recursive: true}], function (eventType, filename) {...});` - отслеживает изменение за файлом или директорией, где `eventType` - это тип события: `'rename'` - при появлении или исчезании файла в директории [и во всех поддиректориях] или `'change'` - при изменении его содержимого; и `filename` - имя измененного файла. Возвращает `fs.FSWatcher`, у которого есть метод: `close()` для остановки наблюдения.

`var <stream> = new fs.ReadStream("<путь_к_файлу>");` - возвращает поток для чтения.  
`var <stream> = fs.createReadStream("<путь_к_файлу>"[, <объект_опций>]);` - возвращает поток для чтения.

`var <stream> = new fs.WriteStream("<путь_к_файлу>");` - возвращает поток для записи.  
`var <stream> = fs.createWriteStream("<путь_к_файлу>"[, <объект_опций>]);` - возвращает поток для записи. Где `<опции>` - объект со свойствами:
- `flags` - режим записи:
    - `w` - перезапись файла;
    - `a` - дополнение к текущему файлу.

`fs.promises` - предоствляет обертки над всеми функциями `fs`, которые теперь не принимают каллбеки, а возвращают промисы, все функции обернуты подобно использованию: `util.promisify(fs.<функция>)`;

### <a id="Модуль-util" href="#Модуль-util">Модуль `util`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `util` реализует утилиты.

`var util = require('util');`

`util.inspect(<объект>)` - выводит информацию о объекте.  
`util.format("<строка>"[, <аргумент_строки_1>[, ...]])` - выводит форматированную строку.  
`util.inherits(<объект1>, <объект2>)` - производит наследование `<объект1>` от `<объект2>`, эквивалентно записи `<объект1>.prototype = new <объект2>();`.

`var <промис_функция> = util.promisify(<исходная_функция>)` - (node 8) - оборачивает функцию в промис, исходная функция должна соответствовать:
- колбэк в параметрах исходной функции всегда идет последним;
- первым параметром колбэка приходит объект ошибки, если она есть.

```javascript
<промис_функция>([<аргумент_1>[, ...]])
    .then(value => {...}[, err => {...}])
    .catch(err => {...});
```

### <a id="Модуль-childprocess" href="#Модуль-childprocess">Модуль `child_process`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `child_process` позволяет запускать дочерние процессы.

`var child_process = require('child_process');`

`child_process.exec("<shell_команда>"[, <объект_опций>], function (err, stdout, stderr) {...});` - выполняет shell-команду внутри Node.js а затем вызывает callback-функцию.

`child_process.execFile("<путь_к_файлу>"[, <объект_опций>], function (err, stdout, stderr) {...});` - выполняет файл внутри Node.js а затем вызывает callback-функцию.

`var <process> = child_process.spawn("<shell_команда>"[, <массив_аргументов>][, <объект_опций>]);` - запускает команду в новом процессе [, с указанным числом аргументов] [где `<объект_опций>` - это объект со свойствами:
- `detached` - разрешает процессу работать после прекращения работы главного процесса при значении `true`, необходимо также вызвать `<process>.unref()` чтобы прекратить наблюдение за процессом, по умолчанию `false`].

`<process>.stdout.on('data', function (data) {...});` - вызывается при получении данных в поток вывода процесса, где `data` - данные.  
`<process>.stderr.on('data', function (data) {...});` - вызывается при получении данных в поток ошибок процесса, где `data` - данные.  
`<process>.on('exit', function (code, signal) {...});` - вызывается при завершении процесса, где `code` - код завершения процесса, `signal` - сигнал, которым был процесс завершен.  
`<process>.on('close', function (code, signal) {...});` - вызывается когда `stdin` процесса закрывается, где `code` - код завершения процесса, `signal` - сигнал, которым был процесс завершен.  
`<process>.stdin.write(<data>);` - записывает данные в поток ввода процесса.  
`<process>.stdin.end();` - закрывает поток ввода процесса.

`var <process> = child_process.fork("<путь_к_файлу_js>"[, <массив_аргументов>[, <объект_опций>]]);` - запускает файл js в новом процессе [с указанным числом аргументов], со специальным встроенным IPC-каналом.

`<process>.on('message', function (message) {...});` - вызывается при получении сообщения от порожденного процесса.  
`process.send(<сообщение>);` - отправляет сообщение (может быть любым типом данных, включая объект) используется в порожденном процессе.

### <a id="Модуль-cluster" href="#Модуль-cluster">Модуль `cluster`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Кластер это система приложений которые где есть две роли: Главная роль (master) и рабочая роль (worker). Есть один мастер на который приходят все запросы, и n-ое количество рабочих.

`var cluster = require('cluster');`

`var numCPUs = require('os').cpus().length;` - возвращает количество ядер процессора.

`cluster.isMaster` - возвращает `true`, если `cluster` вызывается в главном процессе, в главном процессе необходимо создавать рабочих.

`var <worker> = cluster.fork([<объект_новых_переменных_окружения>]);` - запускает новый процесс идентичный текущему.

`<worker>.send('<сообщение>');` - посылает сообщение в воркер.  
`<worker>.process;` - возвращает `ChildProcess`.  
`<worker>.disconnect();` - отключает воркер.  
`<worker>.kill();` - убивает воркер.  
`<worker>.isDead();` - возвращает `true`, если воркер убит или завершил свою работу, иначе false.

`cluster.workers;` - объект запущенных воркеров, в виде: `{<idWorker>: <worker>}`.
`cluster.on('message', function (worker, message, handle) {...});` - принимает сообщение от воркеров.  
`cluster.on('exit', function (deadWorker, code, signal) {...});` - вызовется если воркер умер, позволяет перезапустить воркера с помощью `var <worker> = cluster.fork();`.

`cluster.isWorker` - возвращает `true`, если `cluster` является рабочим `worker`, в рабочем процессе необходимо выполнять все остальные функции.

`process.on('message', function (msg) {...});` - принимает сообщение.  
`process.send('<сообщение>');` - посылает сообщение в мастер.  
`process.exit([<код_возврата>]);` - завершает воркера.  
`cluster.worker;` - ссылка на текущий воркер.

### <a id="Модуль-workerthreads" href="#Модуль-workerthreads">Модуль `worker_threads`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для создания *потоков* для выполнения CPU-емких JavaScript операций. Их не нужно использовать для операций ввода/вывода, так как уже встроенные в Node.js механизмы более эффективно справляются с такими задачами. Могут иметь общую память с остальными потоками.

`const worker_threads = require('worker_threads');`

`const <worker> = new worker_threads.Worker('<путь_к_js_файлу>'[, <объект_опций>]);` - создает воркера с его кодом, с указанными опциями в объекте `<объект_опций>` с ключами:
- `workerData` - содержит начальные данные для воркера;
- `eval` - при значении `true` выполнит первый аргумент как скрипт.

Если файл существует и к нему есть доступ, то нода создаст новый поток, который асинхронно загрузит этот файл. После того, как загрузка будет завершена, начнется выполнение кода воркера.

`worker_threads.isMainThread` - содержит `true` если это главный поток.

`<worker>.postMessage(<данные> [, <массив_передаваемых_объектов>]);` - передает в воркер указанные данные `<данные>` [, а также передает во влвдение все объекты из массива `<массив_передаваемых_объектов>`, эти объекты становятся непригодные в текущем контексте и становятся доступны только в воркере, объекты могут быть экземплярами классов `ArrayBuffer`, `MessagePort` или `ImageBitmap`. Для удобства использования на них должна передаваться ссылка в объекте `<данные>`].

`<worker>.parentPort.on('message', (data) => {})` - регистрирует функцию принимающую данные от воркера, где `data` - это копия переданых данных, которые были переданы из воркера посредством вызова метода `postMessage`.  
`<worker>.parentPort.on('error', (error) => {})` - регистрирует функцию, которая будет вызвана при получении ошибки в воркере, где `error` - это ошибка, которая возникла в воркере.  
`<worker>.parentPort.on('exit', (code) => {})` - регистрирует функцию, которая будет вызвана при окончании работы воркера, где `code` - это код завершения работы воркера.

`<worker>.terminate();` - уничтожает воркера.

#### <a id="Строение-воркера" href="#Строение-воркера">Строение воркера</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Воркеры могут создавать новых воркеров, если нужно.

`worker_threads.workerData` - это копия объекта с начальными данными, которые были переданны в воркер при его инициализации.

`worker_threads.parentPort` - это объект `MessagePort`, который расширяет `EventEmitter`, который используется для связи с главным потоком, тем кто его запустил.

`worker_threads.parentPort.on('message', (data) => {})` - регистрирует функцию принимающую данные от главного потока, того кто запустил воркера, где `data` - это копия переданых данных, которые были переданы в воркер посредством вызова метода `postMessage`.

`process.exit(<код>);` - завершает работу воркера с указанным кодом.

### <a id="Модуль-dns" href="#Модуль-dns">Модуль `dns`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `dns` обеспечивает разрешение имен доменов.

`var dns = require('dns');`

`dns.lookup('<доменное_имя>', function (err, addresses, family) {...});` - находит первый ip-адрес указанного доменного имени и вызывает функцию, где `addresses` - его ip-адрес, `family` - тип ip-адреса: 4 или 6.

`dns.resolve('<доменное_имя>', '<тип>', function (err, addresses) {...});` - находит ip-адреса для указанного доменного имени по указанному типу `'<тип>'` (`'A'` - `IPV4`, `'AAAA'` - `IPV6`) и вызывает функцию, где `addresses` - массив его ip-адресов.

`dns.reverse('<ip-адрес>', function (err, hostnames) {...});` - находит список доменов указанного ip-адрес и вызывает функцию, где `hostnames` - список доменных адресов.

### <a id="Модуль-url" href="#Модуль-url">Модуль `url`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `url` поддерживает методы, которые позволяют извлекать различные части URL (такие как запрошенный путь (URL path) и строка параметров запроса (query string)).

`var url = require('url');`

`url.parse("<url>"[, true])` - возвращает объект разбора URL [строку параметров `query` преобразует ее в объект] со свойствами:
- `pathname` - содержит путь;
- `query` - содержит строку параметров запроса [объект].

### <a id="Модуль-querystring" href="#Модуль-querystring">Модуль `querystring`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `querystring` поддерживает методы, которые используется для парсинга строки параметров запроса (query string).

`var querystring = require('querystring');`

`querystring("<url>")["<параметр>"]` - возвращает значение указанного параметра запроса.

`querystring.parse("<данные>"[, <разделитель_пар_ключей_значений>[, <разделитель_ключей_и_значений>]]);` - распарсивает строку с данными и возвращает ассоциативный массив.

`querystring.stringify(<объект>[, <разделитель_пар_ключей_значений>[, <разделитель_ключей_и_значений>]]);` - формирует строку с данными и возвращает ее из ассоциативного массива.

### <a id="Модуль-http" href="#Модуль-http">Модуль `http`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `http` содержит сервер.

`var http = require('http');`

`var <server> = new http.Server([function (request, response) {...}]);` - создает сервер.  
`var <server> = http.createServer([function (request, response) {...}]);` - создает сервер.

`<server>.listen(<порт>[, '<ip>']);` - устанавливает сервер на прослушку указанного порта.

`<server>.on("request", function (request, response) {...})` - установка обработчика события на новой запрос. Основные переменные:
- `request` - объект запроса:
    - `request.url` - возвращает `url`;
    - `request.method` - возвращает `method`;
    - `request.headers` - возвращает заголовки в виде объекта.

    `request.on("data", function (chunk) {...});` - подписывание на событие получения порции - `chunk` данных из запроса в виде `Buffer` и вызовом функции при получении (используется для сбора всех данных из POST).

    `request.on("end", function () {...});` - подписывание на событие получения всех порций - `chunk` данных из запроса и вызовом функции при получении всех (используется для сбора всех данных из POST).

    `request.setEncoding("<кодировка>");` - указывает какая кодировка ожидается для обработки запроса, при `"utf8"` - будут возвращаться строки вместо `Buffer`.
    Для форм значение заголовка `content-type` может быть:
    - `application/x-www-form-urlencoded` - значение (по ум.) для HTML-форм;
    - `application/json` - если тело содержит JSON данные;
    - `multipart/form-data` - используется когда форма содержит файлы, двоичные данные или текст, кодировка которого отличается от ASCII (задается на форме как `enctype="multipart/form-data"`).

- `response` - объект ответа:
    `response.getHeader("<заголовок>");` - возвращает заголовок ответа.  
    `response.setHeader("<заголовок>", "<значение>");` - устанавливает заголовок ответа. Значение заголовка `Content-Length` должно представлять длину строки, выраженную в байтах, а не в символах.
    `response.removeHeader("<заголовок>");` - удаляет заголовок ответа.  
    `response.writeHead(<код_статуса_возврата>, {"<заголовок>": "<значение>"[, ...]});` - устанавливает код возврата и заголовки через объект.

    Добавлять и удалять заголовки можно в произвольном порядке, но только до первого вызова метода `response.write()` или `response.end()`.

    `response.write("<текст_ответа>");` - записывает текст в ответ [в бинарном виде].  
    `response.write(<данные> , "binary");` - записывает данные в ответ в бинарном виде.  
    `response.end(["<текст_ответа>"]);` - (автоматичестки устанавливает заголовки ответа) завершает ответ.  
    `response.statusCode` - код статуса возврата.

    `response.on('close', function () {...});` - вызывается при завершении соединения.

`var <request> = http.request(<опции>, function (response) {...});` - посылает запрос с указанными опциями и в конце вызывает указанную функцию, где `response` - объект ответа, а `<опции> `- объект со свойствами:
- `hostname` - `'<доменное_имя_или_ip_сайта>'`;
- `port` - `<номер_порта>`;
- `path` - `'<путь_запроса_с_/>'`;
- `method` - `'<МЕТОД_запроса>'`;
- `headers` - `<объект_заголовков>`;
- `auth` - `'<пользователь>:<пароль>'`;
- `timeout` - `<кол_мс_таймаута>`.

У `response` доступны события для обработки:
- `response.on("data", (chunk) => {...});` - при получении порции - `chunk` данных из запроса в виде `Buffer`;
- `response.on("end", () => {...});` - при окончании получения всех данных.

`<request>.write(<данные>);` - записывает данные в тело запроса (для POST).  
`<request>.end();` - отправляет запрос.  
`<request>.on('error', function (err) {...});` - запускает функцию в случае возникновения ошибки связанную с запросом.

### <a id="Модуль-https" href="#Модуль-https">Модуль `https`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Аналогичен модулю `http`, используется для шифрования, различается только метод создания сервера:  
`var https = require('https');`

`var <server> = https.createServer({key: <key.pem>, cert: <key-cert.pem>}[, function (request, response) {...}]);`

### <a id="Модуль-net" href="#Модуль-net">Модуль `net`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для TCP передачи данных.

`var net = require('net');`

`var <server> = net.createServer([{allowHalfOpen: true},] function (socket) {` - создает сервер [, без отправки FIN пакета после получения FIN пакета], и вызывает функцию при каждом подключении, где `socket` является типом `net.Socket`.

`<server>.listen(<порт>[, '<ip>']);` - устанавливает сервер на прослушку указанного порта.

Тип `net.Socket` предоставляет собой сокет.

`socket.remoteAddress` - содержит удаленный ip-адрес.  
`socket.address()` - возвращает объект с информацией о удаленном ip-адресе.  
`socket.setEncoding("<кодировка>")` - указывает какая кодировка ожидается для обработки запроса, `"utf8"` - будут возвращаться строки вместо `Buffer`.

`socket.on("data", function (data) {...})` - вызывается при получении данных, где `data` данные из запроса в виде `Buffer`.  
`socket.on("end", function () {...})` - вызывается при получении FIN пакета.  
`socket.on("close", function () {...})` - вызывается при полном закрытии сокета.  
`socket.on("error", function (err) {...})` - вызывается при ошибке сокета.  
`socket.on("drain", function () {...})` - вызывается при завершении считывания данных из буфера ввода, когда буфер очищен.

`socket.write(<data>[, "<кодировка>"][, function () {...}])` - отправляет данные на запись в сокет, возвращает `true` если все данные удачно были помещены в буфер ядра или `false` если все или часть данных поместились в пользовательскую память, вызовет событие `"drain"`, когда буфер освободится[, вызовет функцию, когда данные полностью запишутся].

`var <socket> = new net.Socket(); `- создает сокет для подключения к серверу.

`<socket>.connect(<порт>[, "<ip_адрес>"][, function () {...}]);` - подключается к серверу по указанному порту [, и затем вызовет функцию, после удачного соединения].

### <a id="Модуль-dgram" href="#Модуль-dgram">Модуль `dgram`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для UDP передачи данных.

`var dgram = require('dgram');`

`var <socket> = dgram.createSocket({'udp4' | 'udp6'});` - создает сокет с указанным типом.

`<socket>.send(<сообщение>[, <отступ>, <длина>], <порт>, "<ip_адрес>"[, function (err) {...}])` - отправляет сообщение, которое содержит данные, которые должны быть `Buffer`, `String`, `Array` [с указанным отступом и длиной] на указанный порт и адрес [, и затем вызовет функцию].

`<socket>.on('error', function (err) {...});` - вызывается при ошибке сокета.

`<socket>.on('message', function (msg, rinfo) {...});` - вызывается по приходу сообщения на сокет, где `msg` в виде `Buffer`, а `rinfo` содержит объект с информацией о удаленном ip-адресе:
- `address` - `'<ip-адрес>'`;
- `family` - `'<тип_ip-адреса>'`;
- `port` - `<номер_порта>`;
- `size` - `<размер_пакета_в_байтах>`.

`<socket>.on('listening', function (error) {...});` - вызывается при начале прослушивания датаграммы из сокета.

`<socket>.bind(<порт>);` - привязывает сокет к прослушке указанного порта.

### <a id="Модуль-path" href="#Модуль-path">Модуль `path`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `path` - используется для работы с путями.

`var path = require('path');`

`path.normalize('<путь>')` - нормализует путь (`..` и `.`), и заменяет множественные `/` на один и возвращает его.  
`path.join('<путь1>'[, ...])` - соединяет пути и нормализует и возвращает его.  
`path.parse('<путь>')` - возвращает объект пути строки с `root`, `dir`, `base`, `ext`, `name`.  
`path.resolve(['<путь1>'[, ...])` - разрешает последовательность путей или части путей в абсолютный путь, если много путей с абсолютным путем, то выберется последний и возвращает его.  
`path.dirname('<путь>')` - возвращает родительскую директорию файла.  
`path.extname('<путь>')` - возвращает расширение файла.  
`path.basename('<путь>'[, '<расширение>'])` - возвращает имя файла [без расширения].  

### <a id="Модуль-domain-устаревший" href="#Модуль-domain-устаревший">Модуль domain (устаревший)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль domain - используется для перехвата всех асинхронный исключений и ошибок.

`var domain = require('domain');`

`var <domain> = domain.create();` - создает домен.

`<domain>.run(<функция>);` - запускает функцию для которой необходимо обработать ошибку.  
`<domain>.on('error', function (err) {...});` - запускает функцию в случае возникновения ошибки в запускаемой функции.  
`<domain>.add(<объект>)` - добавляет объект в домен для слежения за ним и перехватки всех ошибок.  
`<domain>.remove(<объект>) `- удаляет объект из домена для слежения за ним.

### <a id="Модуль-readline" href="#Модуль-readline">Модуль `readline`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `readline` - представляет интерфейс для чтения данных из `Readable` потока (по умолчанию из `process.stdin`) строка за строкой.

`var readline = require('readline');`

`var <readline> = readline.createInterface(<опции>);` - создает интерфейс, где `<опции>` - это объект со свойствами:
- `input` - используется для чтения данных;
- `output` - для вывода сообщений.

`<readline>.on("close", function () {...});` - вызывается при закрытии потока `input`, через метод `end` или принятии сигналов: `end-of-transmission` (`EOT`) (`<ctrl>-D`), `SIGINT` (`<ctrl>-C`).  
`<readline>.on("line", function (line) {...});` - вызывается при получении строки `line` из `input` потока, которая оканчивается концом строки (`\n`, `\r`, или `\r\n`), обычно при нажатии клавиш `<Enter>` или `<Return>`.  
`<readline>.on("pause", function () {...});` - вызывается при приостановке (получении паузы) потока `input` или принятии сигнала: `SIGCONT`.  
`<readline>.on("resume", function () {...});` - вызывается при возобновлении потока `input`.

`<readline>.close();` - закрывает интерфейс и вызывает событие `"close"`.
`<readline>.pause();` - приостанавливает поток `input`.
`<readline>.resume(); `- возобновляет поток `input`.

`<readline>.setPrompt('<сообщение>');` - устанавливает сообщение `prompt` для вывода.  
`<readline>.prompt([true]); `- выводит сообщение `prompt` в `output` с новой строки и переводит курсор на следующую строку [не переводит].  
`<readline>.question('<сообщение>', function (input) {...});` - выводит сообщение и дожидается ввода пользователя на сообщение, а затем вызывает функцию, где `input` - ввод пользователя.

`<readline>.write('<сообщение>');` - записывает сообщение в поток `output` вывода.
`<readline>.write(null, {[ctrl: {true | false}], [meta: {true | false}], [shift: {true | false}], name: '<имя_клавиши>'});` - записывает нажатие клавиши в поток `output` вывода.

### <a id="Модуль-crypto" href="#Модуль-crypto">Модуль `crypto`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `crypto` - предоставляет криптографический функционал.

`const crypto = require('crypto');`

`const <hash> = crypto.createHash({'sha256' | 'md5'});` - создает экземпляр класса `Hash` для подсчитывания хеша данных.  
`<hash>.update(<данные>);` - обновляет (добавляет) содержимое хеша данными.  
`<hash>.createHash({'hex' | 'latin1' | 'base64'});` - возвращает хеш содержимого в указаном формате.  

### <a id="Модуль-os" href="#Модуль-os">Модуль `os`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `os` - предоставляет доступ ко многим функциям, которые можно использовать для получения информации об операционной системе и об аппаратном обеспечении компьютера, на котором работает NodeJS.

`const os = require('os');`

`os.EOL;` - содержит используемый в системе разделитель строк (признак конца строки). В Linux и macOS это `\n`, в Windows - `\r\n`.  
`os.constants;` - содержит константы системы.  
`os.arch();` - возвращает строку, идентифицирующую архитектуру системы (`arm`, `x64`, `arm64`).  
`os.cpus();` - возвращает массив процессоров, доступных в системе в виде объектов.  
`os.endianness();` - возвращает `'BE'` или `'LE'` в зависимости от того, какой порядок байтов (Big Engian или Little Endian) был использован для компиляции бинарного файла NodeJS.  
`os.freemem();` - возвращает количество свободной системной памяти в байтах.  
`os.totalmem();` - возвращает количество общей системной памяти в байтах.  
`os.homedir();` - возвращает путь к домашней директории текущего пользователя.  
`os.tmpdir();` - возвращает путь к заданной в системе директории для хранения временных файлов.  
`os.hostname();` - возвращает имя хоста.  
`os.networkInterfaces();` - возвращает объект со сведениями о сетевых интерфейсах, доступных в системе.  
`os.platform();` - возвращает сведения о платформе (`darwin`, `win32`), для которой был скомпилирован NodeJS.  
`os.release();` - возвращает строку, идентифицирующую номер релиза операционной системы.  
`os.uptime();` - возвращает время работы системы в секундах с последней перезагрузки.  

### <a id="Модуль-assert" href="#Модуль-assert">Модуль `assert`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержит функции для проверок утверждений.

`import assert from 'node:assert';`

`assert.strictEqual(<значение_1>, <значение_2>[, "<сообщение>"]);` - проверяет значение на строгое равенство, а иначе выбрасывает исключение [с сообщением `<сообщение>`].  
`assert.equal(<значение_1>, <значение_2>[, "<сообщение>"]);` - проверяет значение на равенство, а иначе выбрасывает исключение [с сообщением `<сообщение>`].  
`assert.throws(<функция>[, "<ошибка>"][, "<сообщение>"]);` - проверяет что функция выбрасывает исключение [с ошибкой `<ошибка>`], а иначе выбрасывает исключение [с сообщением `<сообщение>`].

### <a id="Модуль-test" href="#Модуль-test">Модуль `test`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержит функции для запуска тестов.

`import {test, describe} from 'node:test';`

```js
describe("<описание_тестового_кейса>", () => {
    test("<имя_теста_1>", [async] () => {
        // тело теста
    });
    // ...
});
```

Если в функции `test` возникает исключение, то тест проваливается.

Тесты должны именоваться с расширением `.test.js`.

Запуск:
- `node --test` - запускает все тесты;
- `node --test --watch` - запускает все тесты в режиме наблюдения;
- `node --test --experimental-test-coverage` - выводит покрытие приложения тестами;

## <a id="Дополнительные-модули" href="#Дополнительные-модули">Дополнительные модули</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Модуль-debug" href="#Модуль-debug">Модуль `debug`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `debug` - используется для отладки.

`var debug = require('debug')('<имя>[:<подимя>]');` - устанавливает `debug` для указанного имени.

`debug('<сообщение>');` - запись сообщения.

Для вывода необходимо запустить сервер с параметрами:  
`SET DEBUG=<имя>[:<подимя> | *][, ...]`

### <a id="Модуль-mime" href="#Модуль-mime">Модуль `mime`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `mime` - используется для получения типа mime файла.

`var mime = require('mime');`

`mime.lookup("<путь_к_файлу>")` - возвращает тип mime файла.

### <a id="Модуль-optimist" href="#Модуль-optimist">Модуль `optimist`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `optimist` - возвращает переменные, которые были переданы скрипту.

`var optimist = require('optimist');`

`optimist.argv` - возвращает переменные, которые были переданы скрипту в виде объекта ключ-значение.

### <a id="Модуль-nconf" href="#Модуль-nconf">Модуль `nconf`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `nconf` - используется для конфигурирования приложения.

`var nconf = require('nconf');`

`nconf.argv()` - подключает аргументы командной строки.  
`nconf.env()` - подключает параметры окружения.  
`nconf.file({file: '<путь_к_файлу_настроек_json>'})` - подключает настройки.  
`nconf.set('<свойство>[:<под_свойство>]', <значение>)` - устанавливает значение свойства.  
`nconf.get('<свойство>[:<под_свойство>]')` - получает значение свойства.

### <a id="Модуль-async" href="#Модуль-async">Модуль `async`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль as`ync - используется для управлениями цепочками асинхронных вызовов.

`var async = require(async);`

```javascript
async.parallel([
        function (callback) {...}
        [, ...]
    ]
    [, function (err[, results]) {...}]
    )
```
Вызывает функции для параллельного асинхронного выполнения, где каждая функция в конце своего выполнения должна вызвать `callback(err, result)` - и передав вместо `err` - ошибку и вместо `result` - результат работы [в конце всех функций вызовется главный колбэк всего или если где-то вызвался колбэк с ошибкой, где `err` - любая первая ошибка любого колбэка [и `results` - результат работы всех функций в виде массива]]

```javascript
async.series([
        function (callback) {...}
        [, ...]
    ]
    [, function (err[, results]) {...}]
    )
```
Вызывает функции для последовательного выполнения, где каждая функция в конце своего выполнения должна вызвать `callback(err, result)` - и передав вместо `err` - ошибку и вместо `result` - результат работы [в конце всех функций вызовется главный колбэк всего или если где-то вызвался колбэк с ошибкой, где `err` - любая первая ошибка любого колбэка [и `results` - результат работы всех функций в виде массива]]

```javascript
async.waterfall([
        function (callback) {...}
        [, function ([<аргумент>[, ...], ]callback) {...}
        [ ...]]
    ]
    [, function (err[, result[, ...]]) {...}]
    )
```
Вызывает функции для последовательного выполнения, где каждая функция в конце своего выполнения должна вызвать `callback(err[, <аргумент>[, ...]])` - и передав вместо `err` - ошибку [и аргументы для следующей функции] [в конце всех функций вызовется главный колбэк всего или если где-то вызвался колбэк с ошибкой, где `err` - любая первая ошибка любого колбэка [и `result[, ...]` - результат работы последней функции]]

```javascript
async.each(<массив>,
    function (item, callback) {...},
    function (err) {...}
    )
```
Используется для асинхронной обработки массива, где для каждого элемента массива применяется функция параллельно, где `item` - элемент массива и должна вызвать `callback(err)` - и передав вместо `err` - ошибку; по завершению обработки массива функциями вызовется главный колбэк всего или он вызовется если где-то вызвался колбэк с ошибкой, где `err` - любая первая ошибка любого колбэка.

```javascript
async.eachSeries(<массив>,
    function (item, callback) {...},
    function (err) {...}
    )
```
Аналогично `each`, только последовательно, одна асинхронная операция.

```javascript
async.eachLimit(<массив>,
    <лимит>,
    function (item, callback) {...},
    function (err) {...}
    )
```
Аналогично `each`, только выполняется максимум `<лимит>` асинхронных операций.

```javascript
async.eachOf(<объект>,
    function (value, key, callback) {...},
    function (err) {...}
    )
```
Аналогично `each`, только используется для асинхронной обработки объекта, где `value` - значение ключа, `key` - ключ.

```javascript
async.eachOfSeries(<объект>,
    function (value, key, callback) {...},
    function (err) {...}
    )
```
Аналогично `eachOf`, только последовательно, одна асинхронная операция.

```javascript
async.eachOfLimit(<объект>,
    <лимит>,
    function (value, key, callback) {...},
    function (err) {...}
    )
```
Аналогично `eachOf`, только выполняется максимум <лимит> асинхронных операций.

```javascript
async.map(<массив>,
    function (item, callback) {...},
    function (err, results) {...}
    )
```
Используется для асинхронной обработки массива, где для каждого элемента массива применяется функция параллельно, где `item` - элемент массива и должна вызвать `callback(err, result)` - и передав вместо `err` - ошибку и вместо `result` - результат работы; по завершению обработки массива функциями вызовется главный колбэк всего или он вызовется если где-то вызвался колбэк с ошибкой, где `err` - любая первая ошибка любого колбэка и `results` - результат работы функции над элементами массива в виде массива.

```javascript
async.mapSeries(<массив>,
    function (item, callback) {...},
    function (err, results) {...}
    )
```
Аналогично `map`, только последовательно, одна асинхронная операция.

```javascript
async.mapLimit(<массив>,
    <лимит>,
    function (item, callback) {...},
    function (err, results) {...}
    )
```
Аналогично `map`, только выполняется максимум <лимит> асинхронных операций.

```javascript
async.filter(<массив>,
    function (item, callback) {...},
    function (err, results) {...}
    )
```
Используется для асинхронного фильтрования массива, где для каждого элемента массива применяется функция, где `item` - элемент массива и должна вызвать `callback(err, truthValue)` - и передав вместо `err` - ошибку, а `truthValue` - `true` если элемент должен присутствовать в результирующем массиве; по завершению обработки массива функциями вызовется главный колбэк всего или он вызовется если где-то вызвался колбэк с ошибкой, где `err` - любая первая ошибка любого колбэка, а `results` - отфильтрованный массив.

```javascript
async.reduce(<массив>,
    <начальное_значение>,
    function (accumulator, item, callback) {...},
    function (err, result) {...}
    )
```
Используется для свертки массива, с начальным значением свертки равным `<начальное_значение>`, где для каждого элемента массива последовательно применяется функция, где `accumulator` - результат свертки на предыдущем этапе, `item` - элемент массива и должна вызвать `callback(err, accumulator)` - и передав вместо `err` - ошибку, а `accumulator` - новое значение свертки; по завершению обработки массива функциями вызовется главный колбэк всего или он вызовется если где-то вызвался колбэк с ошибкой, где `err` - любая первая ошибка любого колбэка, а `result` - результат свертки массива.

```javascript
async.reduceRight(<массив>,
    <начальное_значение>,
    function (accumulator, item, callback) {...},
    function (err, result) {...}
    )
```
Аналогично `reduce`, только справа.

`var <очередь> = async.queue(function (task, callback) {...}, <лимит>)` - возвращает очередь, которая использует указанную функцию для обработки задач, с ограниченным количеством `<лимит>` задач одновременно, где `task` - задача, ей может быть что угодно и должна вызвать `callback(err)` - и передав вместо err - ошибку, по завершению обработки задачи.

`<очередь>.push(<задача>, function (err) {...});` - добавляет задачу в конец очереди, по окончании выполнения задачи вызовется указаная функция, где `err` - ошибка.  
`<очередь>.unshift(<задача>, function (err) {...});` - добавляет задачу в начало очереди, по окончании выполнения задачи вызовется указаная функция, где `err` - ошибка.

### <a id="Модуль-ws" href="#Модуль-ws">Модуль `ws`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `ws` - используется для работы с `WebSocket`.

`var WebSocketServer = require('ws').Server;`

`var <webSocketServer> = new WebSocketServer({[server: <http_сервер>][, port: <порт>]});` - создает сервер на основе готового сервера.

`<webSocketServer>.on('connection', function (ws) {...});` - вызывается при новом соединении.  
`ws.send(<данные>, function (err) {...});` - отправляет данные.  
`ws.on('message', function (message) {...});` - вызывается при приеме сообщения.  
`ws.on('close', function () {...});` - вызывается при закрытии соединения.

### <a id="Модуль-formidable" href="#Модуль-formidable">Модуль `formidable`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Модуль `formidable` - делает форму, отправленную через HTTP POST, доступной для парсинга в Node.js. Для этого нужно создать новый экземпляр объекта `IncomingForm`, который является абстракцией отправленной формы и может быть использован для парсинга объекта `request` HTTP-сервера, для полей и файлов, отправленных через эту форму.

Используется для форм с заголовком `content-type=multipart/form-data`.

`var formidable = require('formidable');`

`var <form> = new formidable.IncomingForm();`

`<form>.uploadDir` - путь к папке размещения файлов (по умолчанию - `/tmp`).  
`<form>.parse(request[, function (err, fields, files) {...}]);` - производит разбор пришедшей формы [и вызывает функцию, где `err` - ошибка, `fields` - переданные поля с значениями и `files` - загруженные файлы].  
`<form>.on('field', function (field, value) {...});` - событие происходит после завершения получения данных поля, где `field` - имя поля, `value` - значение поля.  
`<form>.on('file', function (name, file) {...});` - событие генерируется после получения и обработки файла, где `name` - имя файла, `file` - объект файла, который поддерживает размер файла, путь к файлу, исходное базовое имя и MIME-тип.  
`<form>.on('end', function () {...});` - событие генерируется после окончания разбора формы.

### <a id="Модуль-redis-для-работы-с-Redis" href="#Модуль-redis-для-работы-с-Redis">Модуль `redis` для работы с Redis</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var redis = require("redis");`

`var <client> = redis.createClient(<порт>, '<ip_адрес>');` - создает клиента соединенного с Redis-сервером.

`<client>.on('error', function (err) {...});` - генерирует событие если возникают проблемы при попытке установки соединения с Redis-сервером.

`redis.print` - функция вывода информации, может передаваться как обратная.

`<client>.quit()` - закрывает соединение клиента, после всех команд.  
`<client>.end()` - немедленно закрывает соединение клиента.

#### <a id="Пары-ключзначение" href="#Пары-ключзначение">Пары ключ/значение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<client>.set('<ключ>', '<значение>'[, function (err, res) {...}]);` - устанавливает значение ключа [и после этого вызывает функцию].  
`<client>.get('<ключ>', function (err, value) {...});` - возвращает значение ключа через функцию, где `value` - значение ключа или `null` если ключа нет.  
`<client>.del('<ключ>'[, function (err, res) {...}]);` - удаляет ключ [и после этого вызывает функцию].

#### <a id="Хеш-таблицы" href="#Хеш-таблицы">Хеш-таблицы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<client>.hset('<ключ>', '<поле>', '<значение>'[, function (err, res) {...}]);` - устанавливает значение поля ключа [и после этого вызывает функцию].  
`<client>.hmset('<ключ>', <объект_полей_значений>[, function (err, res) {...}]);` - устанавливает значение полей ключа по полям и значениям объекта.  
`<client>.hget('<ключ>', '<поле>', function (err, value) {...});` - возвращает значение поля ключа через функцию, где `value` - значение поля ключа или `null` если ключа нет.  
`<client>.hgetall('<ключ>', function (err, values) {...});` - возвращает значения ключей через функцию, где `values` - объект вида поле-значение или `null` если ключа нет.  
`<client>.hkeys('<ключ>', function (err, value) {...});` - возвращает значение ключа через функцию, где `value` - значение ключа в виде объекта или `null` если ключа нет.  
`<client>.hdel('<ключ>', '<поле>'[, function (err, res) {...}]);` - удаляет поле ключа [и после этого вызывает функцию].

#### <a id="Список" href="#Список">Список</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<client>.lpush('<список>', '<значение>'[, function (err, res) {...}]);` - добавляет в список значение [и после этого вызывает функцию].  
`<client>.lrange('<список>', <начальный_индекс>, <конечный_индекс>, function (err, items) {...});` - возвращает значения списка через функцию, где `items` - массив значений списка или `null` если значений нет.  
`<client>.lpop('<список>', function (err, item) {...});` - возвращает первое значение списка через функцию, где `item` - значение списка или `null` если списка нет.  
`<client>.lrem('<список>', <количество>, '<значение>'[, function (err, res) {...}]);` - удаляет заданое количество (`0 `- все, `< 0` - с хвоста, `> 0` с головы) значений из списка, если они равны указаному значению [и после этого вызывает функцию].

#### <a id="Множества" href="#Множества">Множества</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<client>.sadd('<множество>', '<значение>'[, function (err, res) {...}]);` - добавляет в множество значение [и после этого вызывает функцию].  
`<client>.smembers('<множество>', function (err, members) {...});` - возвращает значения множества через функцию, где `members` - массив значений или `null` если множества нет.  
`<client>.srem('<список>', '<значение>'[, function (err, res) {...}]);` - удаляет значение из множества, если оно равно указаному значению [и после этого вызывает функцию].

#### <a id="Подписки" href="#Подписки">Подписки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

После перевода соединения в режим подписки к нему можно применять только команды, относящиеся к подписке.

`<client>.subscribe('<канал>');` - подписка на канал.  
`<client>.on('message', function (channel, message) {...});` - вызывает функцию при получении сообщения из канала, где `channel` - канал, `message` - сообщение.  
`<client>.publish('<канал>', <сообщение>);` - посылает сообщение в заданный канал.  
`<client>.unsubscribe('<канал>');` - производит отписку от канала.

### <a id="Модуль-mysql-для-работы-с-MySql" href="#Модуль-mysql-для-работы-с-MySql">Модуль `mysql` для работы с MySql</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var mysql = require('mysql');`
`var <db> = mysql.createConnection(<опции>);` - создает соединение с БД, где <опции> это объект со свойствами:
- `host` - `'<ip_адрес>'`;
- `user` - `'<имя_пользователя>'`;
- `password` - `'<пароль>'`;
- `database` - `'<имя_БД>'`.

`<db>.query('<sql_запрос>'[, <массив_значений_для_подстановки>], function (err, rows) {...});` - выполняет запрос к БД [, в который подставляет вместо знака `?` значение в массиве в указанном порядке] где в `rows` - передается результат скрипта в виде массива, где элемент массива - это строка результата в виде объекта - `{<имя_колонки>: <значение>[, ...]}`.

### <a id="Модуль-mongodb-для-работы-с-MongoDB" href="#Модуль-mongodb-для-работы-с-MongoDB">Модуль `mongodb` для работы с MongoDB</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var mongodb = require('mongodb');`

`var <server> = new mongodb.Server('<ip_адрес>', <порт>, <объект_опций>);` - подключение к серверу.

`var <client> = new mongodb.Db('<имя_БД>', <server>, {w: 1});` - создает клиента сервера.

`<client>.open(function (err) {...});` - открывает соединение с БД.  
`<client>.close();` - закрывает соединение с БД.  
`<client>.collection('<имя_коллекции>', function (err, collection) {...});` - представляет доступ к коллекции БД.

## <a id="Фреймворк-Connect" href="#Фреймворк-Connect">Фреймворк `Connect`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В основе лежит использование **middleware** (связующего программного обеспечения).

`var connect = require("connect");`
`var <connect> = connect();` - является подклассом `http.Server`.

`http.createServer(<connect>).listen(<порт>);` - переопределяет все запросы на `<connect>`.

### <a id="Связующие-программы" href="#Связующие-программы">Связующие программы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Все связующие программы вызываются в порядке задания.

`<connect>.use(['<префикс_пути>', ]function (request, response, next) {...});` - установка функции обработки запроса [если `url` запроса совпадает по указанному префиксу пути, перед вызовом связующей программы **Connect** удаляется префикс из свойства `url` объекта запроса], если функция обрабатывает запрос не до конца, то она должна вызывать `next()`.

Для большей гибкости можно использовать вложенность связующих программ, для этого передается собственная связующая программа, которая в зависимости от условий будет вызывать соответствующие связующие программы, которые ей могут быть переданы в качестве аргументов или `next()`.

#### <a id="Собственные-связующие-программы" href="#Собственные-связующие-программы">Собственные связующие программы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для создания собственной связующей программы необходимо определить функцию которая после вызова возвратит функцию с указанной сигнатурой: `function (request, response, next) {...}`, и передать (вызвать) ее в: `<connect>.use(<связующая_программа>(...));`

#### <a id="Собственная-обработка-ошибок-приложения" href="#Собственная-обработка-ошибок-приложения">Собственная обработка ошибок приложения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Аналогично собственной связующей программе, только должна возвращать функцию с указанной сигнатурой `function (err, request, response, next) {...}`, где `err` - ошибка и передать (вызвать) ее в `<connect>.use(<связующая_программа>(...));`. Будет вызвана при вызове `next(<Error>)` или исключению в какой-то связующей программе.

### <a id="Связующие-программы-Connect" href="#Связующие-программы-Connect">Связующие программы `Connect`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<connect>.use(connect.directory('<путь_к_каталогу>')[, <опции>]);` - регистрирует связующую программу для отдачи списка файлов в указанном каталоге и перемещения по ним, где `<опции>` это объект со свойствами:
- `hidden` - при `true` позволяет перемещаться по скрытым файлам;
- `icons` - при `true` позволяет отображать иконки файлов.

`<connect>.use(connect.static('<путь_к_каталогу>')[, <опции>]);` - регистрирует связующую программу для отдачи статики в указанном каталоге. Если запрашивается папка, в которой находится файл `index.html`, будет отдан этот файл, где `<опции>` это объект со свойствами:
- `maxAge` - `<время_кэша_в_мс>`;
- `hidden` - при `true` позволяет перемещаться по скрытым файлам;
- `redirect` - при `true` устанавливает перенаправление по замыкающему слешу `/`.

`<connect>.use(connect.favicon("<путь_к_иконке>"));` - регистрирует связующую программу для отдачи иконки сайта.

`<connect>.use(connect.logger({<опции>));` - регистрирует связующую программу для логирования, по умолчанию в `stdout`, где `<опции>` это объект со свойствами:
- `format` - формат вывода, один из `"default"` | `"short"` | `"tiny"` | `"dev"`;
- `stream` - ссылка на поток вывода `<stream>`;
- `immediate` - если `true` то пишет только в том случае, если запрос получен в первый раз;
- `buffer` - содержит количество мс `<кол_мс>` в виде числа, на основе их пишет в поток не чаще чем раз в заданное значение.

`var cookieParser = require('cookie-parser');`  
`<connect>.use(cookieParser(["<ключ_шифрования>"]));` - регистрирует связующую программу для извлечения данных `cookie` из заголовка запроса и сохранения данных в объекте запроса по ключу `cookies`, в виде объекта, где ключ - имя куки, значение - полное значение куки [, а в объекте запроса по ключу `signedCookies` будут находиться куки, которые подписаны SHA-1 HMAC (в виде `<значение>.<подпись>`), в виде объекта, где ключ - имя куки, значение - полное значение куки без `.<подпись>`, и назначает в объекте запроса по ключу `secret` ключ шифрования, если же значение подписанной cookie-файла изменится, то она поместится в `cookies`] JSON куки будут иметь префикс `j:` в значении куки.

`response.setHeader('Set-Cookie', "<имя>=<полное_значение>");` - задание куки. Среда `Connect` исправляет заданную по умолчанию Node-функцию `response.setHeader()` таким образом, чтобы использовать заголовки `Set-Cookie` специального вида.

`var cookieSession = require('cookie-session');`
`<connect>.use(cookieSession(<опции>));` - регистрирует связующую программу для работы с сессиями, данные сессии добавляются в объект запроса по ключу `session`, в виде объекта, в который можно записывать произвольные данные сессии. Для обнуления необходимо ключ `session` задать равным `null`. Куки сессии доступны по ключу `session.cookie`, где `<опции>` это объект со свойствами:
- `name` - имя куки хранения сессии в виде `"<имя_куки_хранения>"`, по ум. `"express:sess"`;
- `keys` - список ключей для подписывания и верефикации кук, задается в виде массива `["<ключ>"[, ...]]`;
- `cookie` - содержит объект для хранения информации о куке хранения сессии, со свойствами:
    - `maxAge` - максимальное время хранения в виде числа `<время_хранения>`;
    - `httpOnly` - при `true` использовать только с `http`;
    - `secure` - при `true` использовать только с `https`.
- `store` - содержит объект для хранения сессии, в виде `<объект_для_хранения_сессии>`.

Для хранения сессии в `redis`, необходимо использовать модуль connect-redis.

```javascript
var RedisStore = require('connect-redis')(connect);
<connect>.use(connect.session({
    store: new RedisStore({prefix: '<префикс_для_ключа_редиса>'})
}));
request.session.destroy(function (err) {...});
```
Обнуления сессии, если сессия хранится в хранилище;

`<connect>.use(connect.limit('<размер_в_байтах>'));` - регистрирует связующую программу для ограничения размера тела запроса.

`var bodyParser = require('body-parser');`

`<connect>.use(bodyParser());` - регистрирует связующую программу для разбора `POST`, и помещает в объект запроса по ключу `body` объект, где ключ - имя поля, значение - значение, разбирает данные на основании значения `Content-Type`. Если задано `multipart/form-data` то помещает файлы в объект запроса по ключу `files` объект, где ключ - имя поля, значение - объект информации о файле со свойствами:
- `size` - `<размер>`;
- `path` - '`<путь_к_загруженому_файлу>'`;
- `name` - '`<оригинальное_имя>'`;
- `type` - '`<тип>'`;
- `lastModifiedDate` - `<время>`;
- `length` - длина файла;
- `filename` - имя файла;
- `mime` - `mime` тип фала.

`<connect>.use(connect.query());` - регистрирует связующую программу для разбора `GET`, и помещает в объект запроса по ключу `query` объект, где ключ - имя поля, значение - значение.

`<connect>.use(connect.vhost('<имя_хоста>', <объект_http_Server>));` - регистрирует связующую программу для перенаправления всего запроса на другой сервер.

`<connect>.use(connect.basicAuth('<имя_пользователя>', '<пароль>'));` - регистрирует связующую программу для HTTP аутентификации, если пользователь введет правильные данные, то его пустит дальше.

`<connect>.use(connect.basicAuth(function (user, pass) {...});` - функция должна возвращать `true` если имя пользователя `user` и пароль `pass` верны, иначе `false`.

`<connect>.use(connect.csrf());` - регистрирует связующую программу для предотвращения кросс-фаер атаки, должен помещаться после сессии и записывает 24 значный токен в объект запроса по ключу `session._csrf`. Нужно помещать его после `connect.bodyParser`. После этого его можно получить для сверки в объекте запроса по ключу `body._csrf`.

`<connect>.use(connect.errorHandler());` - регистрирует связующую программу для вывода ошибки при вызове `next(<Error>)` с ошибкой, используется во время разработки.

`<connect>.use(connect.compress([]));` - регистрирует связующую программу для сжатия и разжатия данных с помощью `gzip` и `deflate` которые могут быть указаны в заголовке `AcceptEncoding` [будет использоваться только для тех запросов, на которые функция фильтр вернет `true`], его необходимо помещать как можно выше, так как он переопределяет методы `write()` и `end()` объекта запроса, где `<опции>` это объект со свойствами:
- `filter` - функция вида: `function (req, res) {...}`, которая должна возвращать `true` для применения фильтра, в противном случае `false`;
- `level` - `<уровень_сжатия>`;
- `memLevel` - `<уровень_потребления_памяти>`.

## <a id="Фреймворк-Express" href="#Фреймворк-Express">Фреймворк Express</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Фреймворк `Express` представляет собой надстройку над `Connect`.

### <a id="Установка" href="#Установка">Установка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`nmp I -g express`  
`express -e -s` - флаг `-e` включает поддержку EJS в файле `app.js`, а флаг `-s` - поддержку сеансов  
`nmp i`

### <a id="Структура-каталогов-проекта" href="#Структура-каталогов-проекта">Структура каталогов проекта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `controllers/` - определяются роуты и их логика, должны обрабатывать запросы обслуживать шаблоны для пользователя, взаимодействовать с моделями для получения и извлечения данных, в нем может содержаться главный файл `index.js`, в котором будут склеиваться все контролеры (роуты);
- `helpers/` - код и функциональность, которая должна быть доступна для разных частей проекта;
- `middlewares/` - `Express` мидверы, которые обрабатывают входящие запросы перед передачей их в контролеры (роуты), например авторизация;
- `models/` - представляет данные, реализует бизнес логику и обработку их хранения в БД, так и в других источниках, она не должна напрямую работать с объектами запросов и ответов и должна по минимуму зависеть от окружающего мира, должно существовать по минимуму одному файлу на каждую сущность в БД;
- `public/` - содержит все статичные файлы - изображения, `css`, `js`, `html`;
- `views/` - предоставляет шаблоны, которые отображаются и обслуживаются контролерами (роутами), содержит как минимум по каталогу для каждого контролера (роута), в самом шаблоне должно содержаться по минимуму логики;
- `tests/` - содержит тесты для приложения;
- `app.js` - инициализирует приложение и склеивает все вместе.

### <a id="Базовая-настройка" href="#Базовая-настройка">Базовая настройка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var express = require("express");`

`var <app> = express();` - создает функцию для обработки запросов, является подклассом `http.Server`.

`http.createServer(<app>).listen(<порт>, function () {...})` - переопределяет все запросы на `<app>` на указанный `<порт>`.

### <a id="Конфигурирование" href="#Конфигурирование">Конфигурирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Переменная окружения `NODE_ENV` (`NODE_ENV=production`) используется в качестве средства извещения Node-приложения о текущем окружении, в котором по умолчанию происходит разработка. Ее можно получить через `process.env.NODE_ENV`.

`<app>.configure(['<имя_конфигурации>' [, ...],] function () {...});` - вызывает указанную функцию для всех [только для указанных] конфигураций.

`<app>.set('<свойство>', <значение>);` - устанавливает значение свойства.  
`<app>.get('<свойство>');` - получает значение свойства.

`<app>.enable('<свойство>');` - (устарело) аналогично `<app>.set('<свойство>', true)`.  
`<app>.enabled('<свойство>');` - (устарело) возвращает `true`, если свойство установлено, иначе `false`.  
`<app>.disable('<свойство>');` - (устарело) аналогично `<app>.set('<свойство>', false)`.  
`<app>.disabled('<свойство>');` - (устарело) возвращает `true`, если свойство не установлено, иначе `false`.

### <a id="Middleware" href="#Middleware">Middleware</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются аналогичные как из `connect`.

`<app>.use(express.static('<путь_к_каталогу>'[, <опции>]));` - регистрирует связующую программу для отдачи статики в указанном каталоге.

`<app>.use(express.json([<опции>]));` - регистрирует связующую программу для разбора `POST` (с типом `Content-Type` равным `application/json`), и помещает в объект запроса по ключу `body` объект, где ключ - имя поля, значение - значение.  
`<app>.use(express.urlencoded({ extended: true }));` - регистрирует связующую программу для разбора `POST` (с типом `Content-Type` равным `application/x-www-form-urlencoded`), и помещает в объект запроса по ключу `body` объект, где ключ - имя поля, значение - значение.

`express.errorHandler(err, request, response, next);` - производит форматированный вывод ошибки.

Express также расширяет `request`, `response` дополнительными методами и свойствами.

#### <a id="Основные-свойства-запроса-request" href="#Основные-свойства-запроса-request">Основные свойства запроса `request`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`request.app` - содержит ссылку на объект приложения.  
`request.baseUrl` - содержит ссылку на экземпляр маршрутизатора `express.Router`.  
`request.body` - содержит данные, помещенные в тело запроса (POST и другие) (должны быть разобраны (parsed) и заполнены (populated) перед использованием, к примеру с помощью промежуточное программное обеспечение `express.json()` и `express.urlencoded()`).  
`request.cookies` - содержит куки, установленные в запросе (требуется промежуточное программное обеспечение `cookie-parser`).  
`request.hostname` - название хоста сервера.  
`request.ip` - IP-адрес сервера.  
`request.method` - метод запроса.  
`request.params` - объект с именованными параметрами запроса из роутинга.  
`request.path` - URL запроса.  
`request.protocol` - протокол запроса.  
`request.query` - объект с параметрами строки запроса.  
`request.secure` - содержит `true`, если запрос является безопасным (если используется HTTPS);
`request.signedCookies` - содержит подписанные куки (требуется `cookie-parser`).  
`request.xhr` - содержит `true`, если запрос - это XMLHttpRequest.  
`request.accepted` - возвращает массив поддерживаемых медиа типов заданных в поле `Accept` заголовка от наивысшего значения `quality` - качества, в таком формате:
    - `value` - `'<медиа_тип>'`;
    - `quality` - `<качество>`;
    - `type` - `'<медиа_тип_главный>'`;
    - `subtype` - `'<медиа_подтип>'`.

#### <a id="Основные-методы-запроса-request" href="#Основные-методы-запроса-request">Основные методы запроса `request`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`request.param('<имя_параметра>');` - возвращает значение параметра по имени из таких источников в указанном порядке:
- `request.params`;
- `request.body`;
- `request.query`.

`request.header('<имя_заголовка>');` - возвращает значение заголовка запроса.

#### <a id="Основные-методы-ответа-response" href="#Основные-методы-ответа-response">Основные методы ответа `response`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`response.format(<объект>);` - вызывает указаную функцию в зависимости от принятого медиа типа в поле `Accept` заголовка, в виде объекта, где ключ - это медиа тип в виде: `'<медиа_тип>'` | `'html'` | `'xml'` | `'json'`, а значение функция `function () {...}`.

`response.status(<код_ответа>)` - устанавливает код ответа, а также возвращает `response`.  
`response.json(<JSON>)` - (автоматичестки устанавливает заголовки ответа) отсылает JSON объект.  
`response.send([<код_ответа>, ]<текст_JSON> | '<текст>')` - (автоматичестки устанавливает заголовки ответа) отсылает [код ответа] сразу данные.  
`response.sendStatus(<код_ответа>)` - (автоматичестки устанавливает заголовки ответа) отсылает код ответа и текст ответа, который соответстсвует статусу.

`response.redirect('<url>')` - (автоматичестки устанавливает заголовки ответа) перенаправляет на другую страницу, устанавливает постоянное перенаправление **302**.  
`response.redirect(301, '<url>')` - (автоматичестки устанавливает заголовки ответа) перенаправляет на другую страницу, устанавливает временное перенаправление **301**.  
`response.redirect('back')` - (автоматичестки устанавливает заголовки ответа) перенаправляет к странице, указанной в заголовке **Referer** (по умолчанию имеет значение `/`).

`response.sendFile('<путь_к_файлу>'[, <опции>][, function (err) {...}]);` - (автоматичестки устанавливает заголовки ответа) отправляет файл на выгрузку автоматически устанавливая заголовок `Content-Type` в зависимости от типа файла, используется код, аналогичный отдачи статики [с указанными опциями] [и вызывает указанную функцию после выгрузки файла, где `err` - ошибка передачи], где `<опции>` это объект со свойствами:
- `maxAge` - время кэширования `<время_кэширования_в_мс>`, по ум. `0`;
- `root` - путь к корневой директории файла `'<путь_к_корневой_директории>'`.

`response.download('<путь_к_файлу>'[, '<имя_файла>'][, function (err) {...}]);` - отправляет пользователю приглашение на загрузку файла, полю `Content-Disposition` заголовка присваивается имя файла [указанное имя] используя при выгрузке метод `sendFile` [и вызывает указанную функцию после выгрузки файла, где `err` - ошибка передачи].

`response.cookie('<имя_куки>', '<значение>' [, <опции>])` - устанавливает значение куки, где `<опции>` это объект со свойствами:
- `domain` - домен;
- `path` - путь к страницам сайта, по ум. `/`;
- `expires` - дата истечения куки в формате `Date`, если значение не задано или равно `0`, то кука будет удалена по окончанию сессии;
- `httpOnly` - `true` если только по передаче HTTP, без досупа JavaScript;
- `secure` - `true` если только по передаче HTTPS.

`response.clearCookie('<имя_куки>')` - удаляет куку.

`request.set('<имя_заголовка>', '<значение>');` - устанавливает значение заголовка запроса.  
`request.type({ 'html' | 'json' | 'png' });` - устанавливает значение заголовка запроса **Content-Type**, где переводит: `html` => `text/html`, `json` => `application/json`, `png` => `image/png`.

### <a id="Роутинг" href="#Роутинг">Роутинг</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<app>.use(express.router);`

Тогда можно использовать следующие методы, для разных методов запросов:
- `<app>.use(['<путь_маршрута>', ]function (request, response, next) {...}[, ...]);` - для любого;
- `<app>.all('<путь_маршрута>', function (request, response, next) {...}[, ...]);` - для всех;
- `<app>.<имя_метода>('<путь_маршрута>', function (request, response, next) {...}[, ...]);`.

    `<app>['<имя_метода>']('<путь_маршрута>', function (request, response, next) {...}[, ...]);` - используется для маршрутизации методов, где `<имя_метода>` может быть указано именем метода HTTP: `get`, `post`, `put`, `head`, `delete`, `options`, `trace`, `copy`, `lock`, `mkcol`, `move`, `purge`, `propfind`, `proppatch`, `unlock`, `report`, `mkactivity`, `checkout`, `merge`, `m-search`, `notify`, `subscribe`, `unsubscribe`, `patch`, `search` и `connect`.

Пути маршрутов могут представлять собой строки, шаблоны строк или регулярные выражения. Символы `?`, `+`, `*` и `()` представляют собой подмножества соответствующих им регулярных выражений. Дефис `-` и точка `.` интерпретируются буквально в путях на основе строк.

Маски пути маршрутов для задания:
`'<url>/:<переменная>'` - то тогда переменная будет доступна как `request.params.<переменная>`, знак `?` после переменной указывает на ее необязательность.

`<app>.route('<путь_маршрута>').<имя_метода>(function (request, response, next) {...})[. ...]` - позволяет создавать обработчики маршрутов, образующие цепочки, для пути маршрута.

`var <router> = express.Router();` - маршрутизатор, позволяет создавать модульные, монтируемые обработчики маршрутов. Представляет собой комплексную систему промежуточных обработчиков и маршрутизации; по этой причине часто называется "мини-приложением".

`<router>.use(['<путь_маршрута>', ]function (request, response, next) {...}[, ...]);` - указание обработчика специфичного для данного маршрутизатора.  
`<router>.<имя_метода>('<путь_маршрута>', function (request, response, next) {...}[, ...]);` - используется для маршрутизации методов, которые специфичны для данного маршрутизатора.  
`<app>.use(['<путь_маршрута>', ]<router>);` - загрузка маршрутизатора в приложение.

### <a id="Хранение-транзитных-сообщений-в-сеансах" href="#Хранение-транзитных-сообщений-в-сеансах">Хранение транзитных сообщений в сеансах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Обычным паттерном проектирования веб-приложений является паттерн **PRG** (*Post/Redirect/Get* - *отправить/перенаправить/получить*).

Объект `express.response` представляет собой прототип, который в Express используется для объектов ответа. Добавление свойств к объекту означает, что они будут доступны всему программному обеспечению промежуточного уровня и соответствующим маршрутам.

### <a id="Шаблонизация-ejs" href="#Шаблонизация-ejs">Шаблонизация ejs</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<app>.set('views', '<путь_к_каталогу_с_шаблонами>');`  
`<app>.set('views engine', 'ejs');` - установка движка шаблонов.  
`<app>.engine('ejs', require('ejs-locals'));` - установка расширенного движка шаблонов.

`<app>.locals` - содержит объект с переменными для шаблонов, в котором можно присваивать ключей значениями переменных, которые будут доступны в шаблоне по имени ключа, как `<переменная>` так и `locals.<переменная>`.  
`response.locals` - аналогично `<app>.locals`, только имеет область видимости текущего запроса и имеет выше приоритет.

`response.render('<имя_шаблона>', {'<переменная>': <значение>[, ...]}[, {delimiter: '<символ_разделителя>'}]);` - (автоматичестки устанавливает заголовки ответа) производит рендер шаблона в ответ, все переменные которые переданы, будут доступны в шаблоне по их имени.

Виды комманд ejs в html шаблоне:
- разделители команд (обвертки) `<? ?>` и `<% %>`;
- `<%-<переменная>%>` - выводит значение переменной как html, без экранирования;
- `<%=<переменная>%>` - выводит значение переменной как текст с экранированием переменной;
- `-%>` - обрезает появление новой строки после команды;
- `<%_` - обрезает пробелы до начала команды;
- `_%>` - обрезает пробелы после конца команды;
- `<%#<текст>%>` - комментарий;
- `<%%` - вывод `<%`;
- `%%>` - вывод `%>`.

По умолчанию Express экспонирует представлениям только одну переменную уровня приложения, переменную `settings`. Эта переменная представляет собой объект, включающий все значения, установленные методом `<app>.set()`.

`<%- include('<путь_к_под_шаблону>', {'<переменная>': <значение>[, ...]}) %>` - включает указанный шаблон, в который передаются указанные переменные и переменные доступные для текущего шаблона в текущий шаблон.

`<% layout('<путь_к_главному_шаблону>')-%> ` - поместит все тело шаблона в главный шаблон в `<%- body -%>`.  
`<%- block('<переменная>', '<значение>'); -%>` - добавляет значение к переменной, которая будет доступна, через `blocks.<переменная>` в главном шаблоне.  
`<%- partial('<путь_к_под_шаблону>')%>` - загружает подшаблон в текущий шаблон.

## <a id="Тестирование" href="#Тестирование">Тестирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные виды тестирования:
- **модульное тестирование** - разновидность автоматического тестирования, в ходе которого проверяются отдельные части приложения, непосредственная проверка логики приложения, обычно на уровне функции или метода; модульное тестирование применимо ко всем типам приложений. Подразделяется на:
    - **разработка на основе тестирования** (*Test-Driven Development*, *TDD*);
    - **разработка на основе функционирования** (*Behavior-Driven Development*, *BDD*).
- **приемочное тестирование** - дополнительный уровень тестирования, применяется преимущественно при отладке веб-приложений, подразумевает контроль сценариев из браузера и проверку функциональности веб-приложений с его помощью.

### <a id="Модуль-assert" href="#Модуль-assert">Модуль `assert`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Встроенный модуль. В нем выполняется проверка некоего условия, к примеру сравнивается вычисленное значение и ожидаемое значение, и если условие не выполняется, генерируется ошибка и результатом утверждения становится вывод на консоль трассы стека с сообщением об ошибке.

`var assert = require('assert');`

`assert.equal(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - проверяется, действительно ли значение переменной равно значению второго аргумента.  
`assert.notEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - проверяется на не равенство.  
`assert.strictEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - проверяется на строгое равенство.  
`assert.notStrictEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - проверяется на не строгое равенство.  
`assert.deepEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - выполняется рекурсивное сравнение двух объектов на равенство, то есть сравниваются свойства двух объектов, а если свойства сами являются объектами, они тоже сравниваются.  
`assert.notDeepEqual(<выч_значение>, <ожид_значение>, '<сообщение_ошибки>');` - выполняется рекурсивное сравнение двух объектов на не равенство, то есть сравниваются свойства двух объектов, а если свойства сами являются объектами, они тоже сравниваются.  
`assert.ok(<выч_значение>,'<сообщение_ошибки>');` - проверяет асинхронное значение на истинность, если значение не равно true, то это ошибка.  
`assert.throws(<функция>[, <регулярное_выражение>], '<сообщение_ошибки>');` - проверяет функцию на генерацию исключений (ошибки)[, сообщение которой совпадает с регулярным выражением].

## <a id="Шаблонизатор-EJS" href="#Шаблонизатор-EJS">Шаблонизатор EJS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var ejs = require('ejs');`

`ejs.render('<содержимое_шаблона>', <опции>)` - возвращает сгенерированный результат шаблона, на основе указанного шаблона с заданными переменными, где `<опции>` это объект со свойствами:
- `locals` - объект в виде: `{'<переменная>': <значение>[, ...]}`, гарантирует, что отдельные биты контекстных данных не будут интерпретироваться как EJS-параметры;
- `cache` - при `true` кэширует шаблон;
- `filename` - в виде `'<уникальное_значение_шаблона>'`.

### <a id="Фильтры" href="#Фильтры">Фильтры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<%=: <переменная>| <фильтр>[:<параметр>[: ...]][| ...] %>` - вывод переменной с помощью фильтра, фильтры могут выстраиваться в цепочки. Виды фильтров:
- `first` - возвращает первый элемент из массива;
- `last` - возвращает последний элемент из массива;
- `get:'<свойство_индекс>'` - возвращает указанное свойство из объекта или массива;
- `capitalize` - возвращает строку, где первая буква прописная;
- `downcase` - возвращает строку, где только символы нижнего регистра;
- `upcase` - возвращает строку, где только символы верхнего регистра;
- `truncate`: <количество> - возвращает усеченную строку до указанного количества символов;
- `truncate_words: <количество>` - возвращает усеченную строку до указанного количества слов;
- `replace:'<искомая_строка_или_RegExp>','<строка_для_замены>'` - возвращает строку с замененными подстроками;
- `prepend: '<текст>'` - возвращает строку с текстом до;
- `append: '<текст>'` - возвращает строку с текстом после;
- `sort` - возвращает отсортированный массив;
- `sort_by:'<свойство>'` - возвращает отсортированный массив объектов по указанному свойству;
- `map:'<свойство>'` - возвращает массив из массива, в котором содержится указанное свойство из объектов.

```javascript
ejs.filters.<имя_фильтра>= function (<вводимое_значение>[, <параметр>[, ...]) {
    ...
    return <новое_значение>;
}
```
Создает собственный фильтр.

## <a id="Шаблонизатор-Hogan-Mustache" href="#Шаблонизатор-Hogan-Mustache">Шаблонизатор Hogan (Mustache)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var hogan = require('hogan.js');`

`var <шаблон> = hogan.compile('<содержимое_шаблона>');` - компилирует шаблон на основе текста и возвращает его.

`<шаблон>.render({'<переменная>': <значение>[, ...]}));` - возвращает результат шаблона на основе указанного шаблона с заданными переменными.

### <a id="Mustache-теги" href="#Mustache-теги">Mustache-теги</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`{{<переменная>}}` - выводит экранированное значение переменной.  
`{{{<переменная>}}}` или `{{&<переменная>}}` - выводит значение переменной.  
`{{!<комментарий>}}` - комментарий.  
`{{#<переменная>}} <текст> {{/<переменная>}}` - если переменная `<переменная>` не равна `false` или массив на который указывает переменная не пуст или, то отобразится секция.  
`{{#<переменная_массив>}} <текст>{{<ключ_текущего_элемента_из_массива>}}... {{/<переменная_массив>}}` - перебирает массив объектов из переменной, где в тело секции помещается по очереди элемент.  
`{{^<переменная>}} <текст> {{/<переменная>}}` - выполнится, если переменная указывает на массив, который пуст или переменная равна `false`, или если она не существует.

#### <a id="Лямбда-секции" href="#Лямбда-секции">Лямбда-секции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`{{#<секция>}} <текст> {{/<секция>}}` - объявление произвольной секции.

`<шаблон>.render({'<переменная>': <значение>[, ...], <объект_секций>);` - возвращает результат шаблона с произвольными секциями, где `<объект_секций>` - это объект, где в виде ключей - имя секции `'<секция>'`, а значение - функция вида:  
`function () {... return function (text, render) {...return <новый_текст>;};}`, которая должна возвращать функцию для рендера секции, где в `text` помещается текст секции, а `render` - функция для стандартного рендеринга.

### <a id="Компоненты" href="#Компоненты">Компоненты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`{{> <имя_подшаблона>}}` - передает текущий объект в указанный подшаблон.

```javascript
var <шаблон> = hogan.compile('<содержимое_шаблона>');
var <подшаблон> = hogan.compile('<содержимое_подшаблона>');
<шаблон>.render({'<переменная>': <значение>[, ...]},
    {<имя_подшаблона>: <подшаблон>[, ...]}
);
```
Возвращает результат шаблона на основе указанного шаблона с заданными переменными и подшаблонами.

## <a id="Шаблонизатор-Jade" href="#Шаблонизатор-Jade">Шаблонизатор Jade</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В Jade используются те же названия тегов, что и в HTML, но в Jade можно не применять открывающие и закрывающие символы (`<` и `>`), а уровень вложенности тегов разрешается выражать отступами.

`<тег>[.<CSSкласс>[....]][#<идентификатор>][(<атрибут>[=<значение>][, ...])]`

Если тег это `div`, то его можно не писать. После запятой можно ставить перенос строки.

`<тег>[...] [<содержимое тега>]`

Символ `|` перед содержимым позволяет разбивать содержимое построчно для удобства. Если HTML-тег, такой как `style` или `script`, принимает только текст (то есть вложенные HTML-элементы не допускаются) то символы `|` можно не писать. Добавление точки `.` после тега без пробела перед ней дает понять компилятору Jade, что все внутри данного тега является текстом.

Текстовые блоки должны быть дважды заэкранированы.

В случае блочного расширения после тега указывается двоеточие `:` что позволяет писать сразу новый тег на текущей строке.

```jade
div.movie-card#oceans-11
    h1(class="movie-title")
        | Ocean's
        | 11
    img(src="/img/oceans-11.png", class="movie-poster")
    ul.genre-list.genre-list-blue
        li Comedy
        li.
            Thriller
```

### <a id="Данные-в-Jade-шаблоне" href="#Данные-в-Jade-шаблоне">Данные в Jade-шаблоне</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var jade = require('jade');`

`var <функция_шаблона> = jade.compile('<содержимое_шаблона>');` - компилирует шаблон на основе текста и возвращает его функцию.

`<функция_шаблона>({'<переменная>': <значение>[, ...]}));` - возвращает результат шаблона на основе указанного шаблона с заданными переменными.

### <a id="Jade-теги" href="#Jade-теги">Jade-теги</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`#{<переменная>}` - выводит значение переменной в содержимом тега.  
`<переменная>` - выводит значение переменной в теге.

### <a id="Программная-логика-в-Jade-шаблонах" href="#Программная-логика-в-Jade-шаблонах">Программная логика в Jade-шаблонах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В Jade можно непосредственно внедрять в шаблоны строки JavaScript-кода.

Если предварить строку JavaScript-кода символом `-`, это приведет к выполнению JavaScript-кода без возвращения какого-либо значения в выводимых шаблоном данных.

Если же строку JavaScript-кода предварить символом `=`, возвращаемое этим кодом значение попадет в выводимые данные, причем оно будет экранировано для предотвращения XSS-атак.

Если же генерируемое JavaScript-кодом значение экранировать не нужно, можно предварить код символами `!=`.

`<переменная> = <значение>` - объявляет переменную.

Для вывода переменных необходимо использовать символы `= <переменная>` - экранировать или `!= <переменная>` для не экранирования, сразу после тега без пробела.

### <a id="Условные-и-итеративные-инструкции" href="#Условные-и-итеративные-инструкции">Условные и итеративные инструкции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Их можно писать без префиксов. На них действует вложенность как в html для тегов.

`each <элемент> in <массив>` - используется для перебора массива, где в `<элемент>` помещается элемент массива.  
`each <значение>, <ключ> in <объект>` - используется для перебора объекта, где в `<значение>` помещается значение объекта, а в `<ключ>` его ключ.

`if <условие>` - дальнейший код выполниться если условие вернет `true`.

`unless <условие>` - дальнейший код выполниться если условие вернет `false`.

Конструкция выбора:
```jade
case <переменная>
    when <значение>
        <код_при_совпадении>
    ...
    default
        <код_по_ум>
```

### <a id="Наследование-шаблонов" href="#Наследование-шаблонов">Наследование шаблонов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью блоков при наследовании шаблонов задается место, в котором будет находиться контент, предоставляемый производным шаблоном.

`block <имя>` - объявление блока в родительском шаблоне.

`extends <имя_шаблона>` - экспортирует блоки в указанный шаблон, заменяя приэтом их.

Объявление блока с кодом:
```jade
block [append|]<имя>
    <код>
```

Если же блок в унаследованном шаблоне содержит контент, этот контент может не заменяться производными шаблонами, а наращиваться путем добавления блоков в начало и в конец шаблона.

`var <функция_шаблона> = jade.compile('<содержимое_шаблона>' {filename: '<имя_файла_шаблона>'});` - компилирует шаблон на основе текста и возвращает его функцию.

### <a id="Включение-шаблонов" href="#Включение-шаблонов">Включение шаблонов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`include <имя_шаблона>` - включает шаблон в текущий шаблон, также можно включить имя файла.

### <a id="Примеси" href="#Примеси">Примеси</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Jade-команда `mixin` является аналогом JavaScript-функции. Как и функция, команда mixin может принимать аргументы, на основе которых генерируется Jade-код.

Объявление примеси:
```jade
mixin <имя_примеси>(<переменная>[, ...])
    <код_примеси>
```

`<имя_примеси>(<переменная>[, ...])` - вызывает примесь и помещает ее результат в текущее место.

<a id="Основы-проектирования-Node-приложений" href="#Основы-проектирования-Node-приложений">Основы проектирования Node-приложений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====================================

## <a id="Структура-проекта" href="#Структура-проекта">Структура проекта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Структурирование-решений-на-основе-компонентов" href="#Структурирование-решений-на-основе-компонентов">Структурирование решений на основе компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Структура проекта должна основываться на особенностях проекта, а не на его ролях. Она должна выглядеть как решения на самодостаточных компонентах, в файле компонента `index.js` должна описываться только развязка подключения всех других фалов компонента, но не логика:
```
application
|-- components
|   |-- orders
|   |-- users
|   |   |-- index.js
|   |   |-- user.js
|   |   |-- userApi.js
|   |   |-- userController.js
|   |   '-- userTesting.js
|   |-- ...
|   '-- other
'-- libraries
```

А не группировать файлы, основываясь на их технической роли:
```
application
|-- controllers
|-- models
|-- test
|-- utils
'-- views
```

### <a id="Слои-компонентов" href="#Слои-компонентов">Слои компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Каждый компонент должен содержать "слои" - определенные объекты, которые должны исполнять только одну роль для веба, логики и доступа к данным и как минимум пересекаться, а должны обмениваться только данными (контекстом), которые нужны для конкретной цели, так они будут менее связаны.

### <a id="Общие-утилиты" href="#Общие-утилиты">Общие утилиты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Общие утилиты, которые нужны для каждого компонента должны помещаться в приватный npm-пакет. Также так могут оборачиваться 3-ии библиотека для уменьшения зависимостей от их реализации. Структура проекта:
```
locale_modules
|-- module1
|   |-- package.json
|   '-- index.js
|-- module2
|-- ...
'-- moduleN
package.json
```

Для их подключения используется объявление зависимости в файле `package.json` приложения:
```json
{
    "dependencies": {
        "module1": "file:local_modules/module1",
        "module2": "file:local_modules/module2",
        "...": "file:local_modules/...",
        "moduleN": "file:local_modules/moduleN"
    }
}
```

Тогда их подключение будет как: `require('module1').User`, а не: `require('../../../../module1/User')`.

Прямую вложеность можно обеспечить использование установки переменной окружения `NODE_PATH=.`. Для кроссплатформенной установки используется модуль `cross-env`:
> `npx cross-env NODE_PATH=. npx nodemon app.js`

### <a id="Разделение-Express-приложения-и-сервера" href="#Разделение-Express-приложения-и-сервера">Разделение Express "приложения" и "сервера"</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Express приложение должно разделяться как минимум на два файла:
- **приложение** - где описываются API, а для лучшей структуры необходимо локализировать описание API внутри компонентов;
- **сервер** - где подключается сетевое взаимодействие с самим приложением.

Это позволит тестировать API без применения сетевых вызовов. А также лучше разделяет бизнес логику API.

### <a id="Параметры-приложения" href="#Параметры-приложения">Параметры приложения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Все параметры, которые нужны для работы приложения должны храниться в отдельных файлах, в отдельной директории от всего остального кода, к примеру: `config` и должны быть в виде JSON файла или должны передаваться в приложение, как параметры окружения. Так будет проще конфигурировать и тестировать приложение.

## <a id="Струткура-приложения" href="#Струткура-приложения">Струткура приложения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Вариант структуры приложения:
```
application
|-- app // содержит главный код приложения
    |-- actions // содержит действия по бизнес логики приложения (в файла или каталогах при необходимости) для каждой сущности в проекте или общие действия для всего проекта по работе как с сущностями, так и в общем. Могут вызывать другие действия
        |-- action1.js
        |-- ...
    |-- heplers // содержит модули по дополнительной логике
    |-- middlewares // содержит миделварки, которые промежуточно обрабатывают запрос, т.е. вызывают next() или вызывают ошибки
    |-- entities // содержит сущности, которая реализует бизнес логику приложения (в файла или каталогах при необходимости) (используется вместе с `actions`, только для конкретных сущностей)
    |-- orm
    |-- routes // содержит роутеры (в файла или каталогах при необходимости) для каждой сущности в проекте
        |-- index.js // подключает все роутеры высшего уровня
        |-- router1.js
        |-- ...
    |-- tasks // содержит задачи для CLI общего назначения (очистка каталогов, БД и т.п.)
        |-- task1.js
        |-- ...
    |-- utils // содержит утилиты общего назначения
    |-- server.js // файл по запуску сервера, который подключает миддлеверки, для обработки запросов, такие как `bodyparser`, `cors`, `multer` и `errorhandlers` и главный роутер из `routes`, а также инициализирует сервер
    '-- task.js // запускает задачи
|-- docs // (опционально) содержиться документация
|-- lib // (опционально) содержиться скомпилированный код приложения для использования
|-- migrations // содержит миграции
|-- node_modules
|-- tests // содержит юнит тесты
|-- config // содержит конфигурации приложения
    |-- index.js // подключает все конфигурации приложения, переобпределяет их, если это необходимо
    |-- config1.json // конфигурация по умолчанию
    |-- config1.local.json // переопределенная конфигурация
    |-- ...
|-- package.json
```

<a id="Основы-развертывания-Node-приложений" href="#Основы-развертывания-Node-приложений">Основы развертывания Node-приложений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====================================

## <a id="Инструмент-Nodejitsu-Forever" href="#Инструмент-Nodejitsu-Forever">Инструмент Nodejitsu Forever</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Он позволяет сохранить Node-приложение работающим даже после разрыва SSH-соединения и дополнительно обеспечивает его перезапуск после сбоя.

`sudo npm install -g forever` - установка.

`forever [-w] start <приложение>` - запускает приложение и поддерживает его работоспособность. [И автоматически перезагружает приложение в случае изменения какого-либо исходного файла.]  
`forever stop <приложение>` - останавливает приложение.  
`forever list` - отображает список приложений, которыми можно управлять с помощью Forever.

## <a id="Поддержание-доступности-приложения-Upstart" href="#Поддержание-доступности-приложения-Upstart">Поддержание доступности приложения, Upstart</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Проект Upstart предлагает элегантный способ управления запуском и остановкой любого Linux-приложения, включая Node-приложение.

`sudo apt-get install upstart` - установка на Ubuntu.  
`sudo yum install upstart` - установка на CentOS.

После установки Upstart для каждого из приложений нужно добавить конфигурационный файл программы Upstart.  
`sudo touch /etc/init/<имя_приложения>.conf`

Его строение:
```ini
author "<имя_автора>"
description "<описание_приложения>"
setuid "<имя_пользователя>"
start on (local-filesystems and net-device-up IFACE=eth0) #запуск при
stop on shutdown #остановка при
respawn [<количество> <интервал>] #попытки перезапуска в случае сбоя
console log #логирования потоков вывода
env <переменная_окружения>=<значение>
...
exec <команда> #запуск приложения
```

Запуск приложения:  
`sudo service <приложение>`

## <a id="Распределение-нагрузки-с-помощью-Nginx" href="#Распределение-нагрузки-с-помощью-Nginx">Распределение нагрузки с помощью Nginx</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`sudo apt-get install nginx` - установка.

Файл `nginx.conf`:
```nginx
http {
    # ...
    upstream nodejs_design_patterns_app {
        server 127.0.0.1:8081;
        server 127.0.0.1:8082;
        server 127.0.0.1:8083;
        server 127.0.0.1:8084;
    }
    # ...
    server {
        listen 80;
        location / {
            proxy_pass http://nodejs_design_patterns_app;
        }
    }
    # ...
}
```

Где:
- в разделе `nodejs_design_patterns_app` определяется список внутренних серверов для обработки сетевых запросов;
- директива `proxy_pass`, в разделе `server`, требует от сервера Nginx перенаправлять любые запросы в группу серверов в разделе `nodejs_design_patterns_app`.