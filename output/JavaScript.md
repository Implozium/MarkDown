[Содержание](#Содержание)
==========

- [Основы JavaScript](#Основы-JavaScript)
    - [Структура кода](#Структура-кода)
    - [Директива use strict](#Директива-use-strict)
    - [Переменные](#Переменные)
        - [Переменные: `let` и `const` (ES6)](#Переменные-let-и-const-ES6)
        - [Правила именования](#Правила-именования)
        - [Деструктуризация (ES6)](#Деструктуризация-ES6)
            - [Массив](#Массив)
            - [Оператор spread](#Оператор-spread)
            - [Деструктуризация объекта](#Деструктуризация-объекта)
    - [Шесть типов данных](#Шесть-типов-данных)
    - [Основные операторы](#Основные-операторы)
        - [Побитовые операторы](#Побитовые-операторы)
        - [Сокращённая арифметика с присваиванием](#Сокращённая-арифметика-с-присваиванием)
        - [Оператор запятая `,`](#Оператор-запятая-)
        - [Операторы сравнения и логические значения](#Операторы-сравнения-и-логические-значения)
        - [Логические операторы](#Логические-операторы)
        - [Оператор `typeof`](#Оператор-typeof)
        - [Оператор `void`](#Оператор-void)
    - [Преобразование типов для примитивов](#Преобразование-типов-для-примитивов)
        - [Вспомогательные функции `parseInt`, `toString`](#Вспомогательные-функции-parseInt-toString)
    - [Условные операторы: `if`, `?:`](#Условные-операторы-if-)
        - [Тернарный оператор вопросительный знак `?:`](#Тернарный-оператор-вопросительный-знак-)
    - [Циклы](#Циклы)
        - [Цикл `while`](#Цикл-while)
        - [Цикл `do...while`](#Цикл-dowhile)
        - [Цикл `for`](#Цикл-for)
        - [Прерывание цикла](#Прерывание-цикла)
            - [Метки для `break`/`continue`](#Метки-для-breakcontinue)
    - [Конструкция `switch`](#Конструкция-switch)
    - [Функции](#Функции)
        - [Параметры по умолчанию (ES6)](#Параметры-по-умолчанию-ES6)
        - [Оператор spread вместо `arguments` (ES6)](#Оператор-spread-вместо-arguments-ES6)
        - [Объявление Function Expression](#Объявление-Function-Expression)
        - [Функции через `=>` (ES6)](#Функции-через--ES6)
    - [Создание функции из текста - `new Function`](#Создание-функции-из-текста---new-Function)
        - [Рекурсия, стек](#Рекурсия-стек)
    - [Консоль](#Консоль)
    - [Советы по стилю кода](#Советы-по-стилю-кода)
    - [Структуры данных](#Структуры-данных)
        - [Числа](#Числа)
            - [Округление](#Округление)
            - [Встроенные функции для тригонометрических вычислений](#Встроенные-функции-для-тригонометрических-вычислений)
            - [Функции общего назначения](#Функции-общего-назначения)
        - [Строки](#Строки)
            - [Строки в `` ` `` (ES6)](#Строки-в----ES6)
            - [Функции шаблонизации (ES6)](#Функции-шаблонизации-ES6)
            - [Свойства и методы](#Свойства-и-методы)
        - [Объекты как ассоциативные массивы](#Объекты-как-ассоциативные-массивы)
            - [Короткое свойство (ES6)](#Короткое-свойство-ES6)
            - [Вычисляемые свойства (ES6)](#Вычисляемые-свойства-ES6)
            - [Цикл по свойствам](#Цикл-по-свойствам)
    - [Массивы c числовыми индексами](#Массивы-c-числовыми-индексами)
        - [`ArrayBuffer` (ES6)](#ArrayBuffer-ES6)
        - [`DataView` (ES6)](#DataView-ES6)
        - [TypedArray (ES6)](#TypedArray-ES6)
    - [Дата и Время](#Дата-и-Время)
    - [Тип данных `Symbol` (ES6)](#Тип-данных-Symbol-ES6)
    - [`Map` (ES6)](#Map-ES6)
    - [`Set` (ES6)](#Set-ES6)
    - [`WeakMap`, `WeakSet` (ES6)](#WeakMap-WeakSet-ES6)
    - [Обещания `Promise` (ES6)](#Обещания-Promise-ES6)
    - [Генераторы (ES6)](#Генераторы-ES6)
        - [Композиция](#Композиция)
        - [Передача данных в генератор](#Передача-данных-в-генератор)
        - [Плоский асинхронный код](#Плоский-асинхронный-код)
        - [Асинхронное выполнение с генераторами](#Асинхронное-выполнение-с-генераторами)
        - [Async / await (ES7)](#Async--await-ES7)
    - [`Proxy` (ES6)](#Proxy-ES6)
        - [Ловушки](#Ловушки)
    - [`Reflect` (ES6)](#Reflect-ES6)
    - [Итераторы, цикл `for..of` (ES6)](#Итераторы-цикл-forof-ES6)
    - [Замыкания, область видимости](#Замыкания-область-видимости)
        - [Глобальный объект](#Глобальный-объект)
        - [Лексическое окружение](#Лексическое-окружение)
        - [Модули через замыкания](#Модули-через-замыкания)
        - [Устаревшая конструкция `with`](#Устаревшая-конструкция-with)
    - [Методы объектов и контекст вызова](#Методы-объектов-и-контекст-вызова)
        - [Методы объектов, `this`](#Методы-объектов-this)
            - [Методы объекта (ES6) `[[HomeObject]]`](#Методы-объекта-ES6-HomeObject)
        - [Создание объектов через `new`](#Создание-объектов-через-new)
        - [Дескриптор](#Дескриптор)
        - [Статические и фабричные методы](#Статические-и-фабричные-методы)
        - [Вызовы функций](#Вызовы-функций)
    - [Некоторые другие возможности, `instanceof`](#Некоторые-другие-возможности-instanceof)
        - [Формат JSON](#Формат-JSON)
        - [Внутренние таймеры-планировщики](#Внутренние-таймеры-планировщики)
        - [Eval](#Eval)
        - [Base64](#Base64)
        - [Кодирование URI](#Кодирование-URI)
        - [Кодировка `urlencoded`](#Кодировка-urlencoded)
    - [Перехват ошибок. `Error`](#Перехват-ошибок-Error)
        - [Объект ошибки](#Объект-ошибки)
    - [ООП в функциональном стиле](#ООП-в-функциональном-стиле)
        - [Классы](#Классы)
        - ["Геттеры" и "сеттеры"](#Геттеры-и-сеттеры)
        - [Наследование](#Наследование)
    - [ООП в прототипном стиле](#ООП-в-прототипном-стиле)
        - [Специальное свойство `__proto__`](#Специальное-свойство-proto)
        - ["Псевдокласс"](#Псевдокласс)
        - [Наследование](#Наследование)
    - [Классы (ES6)](#Классы-ES6)
        - [Приватные свойства](#Приватные-свойства)
        - [Статические свойства](#Статические-свойства)
        - [Наследование](#Наследование)
    - [Примесь](#Примесь)
    - [Модули (ES6)](#Модули-ES6)
- [Регулярные выражения](#Регулярные-выражения)
    - [RegExp](#RegExp)
    - [Методы String](#Методы-String)
    - [Методы RegExp](#Методы-RegExp)
    - [Свойства RegExp](#Свойства-RegExp)
    - [Классы и спецсимволы](#Классы-и-спецсимволы)
    - [Наборы и диапазоны](#Наборы-и-диапазоны)
    - [Квантификаторы `+`, `*`, `?` и `{n}`](#Квантификаторы----и-n)
        - [Жадные и ленивые квантификаторы](#Жадные-и-ленивые-квантификаторы)
    - [Скобочные группы](#Скобочные-группы)
        - [Исключение из запоминания через `?:`](#Исключение-из-запоминания-через-)
        - [Обратные ссылки](#Обратные-ссылки)
    - [Альтернация (или) `|`](#Альтернация-или-)
    - [Начало строки `^` и конец `$`](#Начало-строки--и-конец-)
    - [Упреждение](#Упреждение)
- [Документирование API (JSDoc)](#Документирование-API-JSDoc)
    - [Основы](#Основы)
    - [Основные теги](#Основные-теги)
    - [Тип](#Тип)
    - [Описание структуры объекта типа](#Описание-структуры-объекта-типа)
    - [Описание произвольного типа](#Описание-произвольного-типа)
    - [Описание колбека](#Описание-колбека)
    - [Описание функции как параметра функции](#Описание-функции-как-параметра-функции)
- [Тестирование](#Тестирование)
    - [Автоматические тесты при помощи chai и mocha](#Автоматические-тесты-при-помощи-chai-и-mocha)
        - [Поток разработки](#Поток-разработки)
        - [Дополнительные методы тестирования](#Дополнительные-методы-тестирования)
        - [Виды `chai.assert`](#Виды-chaiassert)
        - [Виды `chai.expect`](#Виды-chaiexpect)
        - [Асинхронные тесты](#Асинхронные-тесты)
        - [Размещение тестов](#Размещение-тестов)
        - [Sinon](#Sinon)
            - [Шпион `spy`](#Шпион-spy)
            - [Заглушки `stub`](#Заглушки-stub)
            - [Имитация `mock`](#Имитация-mock)
- [Приемы](#Приемы)
    - [Паттерн RORO](#Паттерн-RORO)
    - [Паттерн Ice Factory](#Паттерн-Ice-Factory)
    - [Паттерн BIF](#Паттерн-BIF)
    - [Паттерн Модуль](#Паттерн-Модуль)
- [TypeScript](#TypeScript)
    - [Структура](#Структура)
    - [Настройки компиляции](#Настройки-компиляции)
        - [Файл конфигурации tsconfig.json](#Файл-конфигурации-tsconfigjson)
    - [Типы данных](#Типы-данных)
        - [Объединения](#Объединения)
        - [Псевдонимы типов](#Псевдонимы-типов)
        - [Type assertion](#Type-assertion)
    - [Определение функции](#Определение-функции)
        - [Параметр `this`](#Параметр-this)
        - [Перегрузка функций](#Перегрузка-функций)
        - [Тип функции](#Тип-функции)
    - [Классы](#Классы)
        - [Абстрактные классы](#Абстрактные-классы)
    - [Интерфейсы](#Интерфейсы)
        - [Интерфейсы классов](#Интерфейсы-классов)
        - [Интерфейсы функций](#Интерфейсы-функций)
        - [Интерфейсы объектов](#Интерфейсы-объектов)
        - [Гибридные интерфейсы](#Гибридные-интерфейсы)
    - [Оператор `instanceof`](#Оператор-instanceof)
    - [Обобщения](#Обобщения)
        - [Ограничения обобщений](#Ограничения-обобщений)
        - [Ключевое слово `new`](#Ключевое-слово-new)
    - [Пространства имен](#Пространства-имен)
        - [Псевдонимы](#Псевдонимы)
    - [Модули](#Модули)
    - [Заголовочные файлы](#Заголовочные-файлы)
    - [Декораторы](#Декораторы)
        - [Декораторы классов](#Декораторы-классов)
        - [Декоратор метода](#Декоратор-метода)
        - [Декораторы параметров методов](#Декораторы-параметров-методов)
        - [Декораторы свойств](#Декораторы-свойств)
        - [Декоратор метода доступа](#Декоратор-метода-доступа)
    - [Фабрики декораторов](#Фабрики-декораторов)
    - [TODO: delete](#TODO-delete)

<a id="Основы-JavaScript" href="#Основы-JavaScript">Основы JavaScript</a>
=================

## <a id="Структура-кода" href="#Структура-кода">Структура кода</a>

**Команды**: как правило, каждая команда пишется на отдельной строке и после нее ставится точка с запятой `;`. Точку с запятой во многих случаях можно не ставить, если есть переход на новую строку.

**Комментарии** могут находиться в любом месте программы и никак не влияют на её выполнение. Интерпретатор JavaScript попросту игнорирует их. Однострочные комментарии начинаются с двойного слэша `//`. Текст считается комментарием до конца строки. Многострочные комментарии начинаются слешем-звездочкой `/*` и заканчиваются звездочкой-слэшем `*/`. Вложенные комментарии не поддерживаются.

## <a id="Директива-use-strict" href="#Директива-use-strict">Директива use strict</a>

Директива выглядит как строка `"use strict";` или `'use strict';` и ставится в начале скрипта, переводит код в режим полного соответствия современному стандарту.

## <a id="Переменные" href="#Переменные">Переменные</a>

Переменная состоит из имени и выделенной области памяти, которая ему соответствует. Для объявления или, другими словами, создания переменной используется ключевое слово `var`:  
`var <имя_переменной>;`

После объявления, можно записать в переменную данные:  
`<имя_переменной> = <значение_переменной>;`

Эти данные будут сохранены в соответствующей области памяти и в дальнейшем доступны при обращении по имени. Для краткости можно совместить объявление переменной и запись данных. Можно даже объявить несколько переменных сразу через запятую `,`.

JavaScript перемещает операторы `var` и определение `function` наверх ближайшей оборачивающей области видимости, переменные заданные через `var` до своего конкретного определения равны `undefined`.

На **имя переменной** в JavaScript наложены всего два ограничения:
- имя может состоять из: букв, цифр, символов `$` и `_`;
- первый символ не должен быть цифрой.

**Константа** - это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание `<ИМЯ_КОНСТАНТЫ>`.

### <a id="Переменные-let-и-const-ES6" href="#Переменные-let-и-const-ES6">Переменные: `let` и `const` (ES6)</a>

`let <имя_переменной>;`

У объявлений переменной через `let` есть три основных отличия от `var`:
- область видимости переменной `let` - блок `{...}` - переменная, объявленная через `let`, видна только в рамках блока `{...}`, в котором объявлена. Это, в частности, влияет на объявления внутри `if`, `while` или `for`;
- переменная `let` видна только после объявления;
- при использовании в цикле, для каждой итерации создаётся своя переменная - каждому повторению цикла соответствует своя независимая переменная `let`. Если внутри цикла есть вложенные объявления функций, то в замыкании каждой будет та переменная, которая была при соответствующей итерации.

`const <ИМЯ_КОНСТАНТЫ> = <значение>;`  
`const <имя_константы> = <объект>;`  
Объявление `const` задаёт константу, то есть переменную, которую нельзя менять, в случае объекта не позволяет изменять переменную как ссылку на другое значение, а не сам объект

### <a id="Правила-именования" href="#Правила-именования">Правила именования</a>

- **правило 1** - никакого транслита. Только английский;
- **правило 2** - использовать короткие имена только для переменных "местного значения". Название переменной должно быть понятным. Иногда для этого нужно использовать несколько слов;
- **правило 3** - переменные из нескольких слов пишутся - `вместеВотТак` - в формате `camelCase`;
- **правило последнее, главное** - имя переменной должно максимально чётко соответствовать хранимым в ней данным.

Если при поиске переменной с одним именем, находится - с другим, то зачастую самый лучший ход - это переименовать переменную, чтобы имя было тем, которое искали.

### <a id="Деструктуризация-ES6" href="#Деструктуризация-ES6">Деструктуризация (ES6)</a>

**Деструктуризация** (*destructuring assignment*) - это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.

#### <a id="Массив" href="#Массив">Массив</a>

`let [{<переменная1>[= <значение_по_ум>] | }[, ...][, ...<переменная_все_остальное>]] = [<значение>[, ...]];` - при таком присвоении первое значение массива пойдёт в переменную `<переменная1>`, второе - в следующую, а последующие (если есть) - будут отброшены. Ненужные элементы массива также можно отбросить, поставив лишнюю запятую.

Если необходимо получить и последующие значения массива, но не уверены в их числе - можно добавить ещё один параметр, который получит "*всё остальное*", при помощи оператора `...` ("**spread**", троеточие). Значением этой переменной `<переменная_все_остальное>` будет массив из оставшихся элементов массива.

Если значений в массиве меньше, чем переменных - ошибки не будет, просто им присваивается `undefined`. В качестве значений по умолчанию можно использовать не только примитивы, но и выражения, даже включающие в себя вызовы функций. При этом вызов функции для генерации значения по умолчанию будет осуществлён только при необходимости, то есть если значения нет в массиве.

> `let [a, , c = 2, ...d] = [1, 2, 3, 4, 5];`

#### <a id="Оператор-spread" href="#Оператор-spread">Оператор spread</a>

Оператор расширения (`...`) позволяет расширять выражения в тех местах, где предусмотрено использование нескольких аргументов (при вызовах функции) или ожидается несколько элементов (для массивов). Использование, может находиться в любом месте:  
`...<перечисляемый_объект>`
> `[...[1, 2, 3], 4] // [1, 2, 3, 4]`  
> `Math.max(...[1, 3, 4, 5]) // Math.max(1, 3, 4, 5)`  
> `const copyArray = [...[1, 2, 3]] // копирует массив`

#### <a id="Деструктуризация-объекта" href="#Деструктуризация-объекта">Деструктуризация объекта</a>

Деструктуризацию можно использовать и с объектами. При этом указывают, какие свойства в какие переменные должны "*идти*". Базовый синтаксис:  
`let {<переменная_из_объекта1>[: <новое_имя>][= <значение_по_ум>][, ...]} = <объект>`

Объект справа - уже существующий объект, который нужно разбить на переменные. А слева - список переменных, в которые нужно соответствующие свойства записать.

Если объект или массив содержат другие объекты или массивы, и их тоже хочется разбить на переменные - не проблема. Деструктуризации можно как угодно сочетать и вкладывать друг в друга. Можно использовать в аргументах функции.

Чтобы избежать интерпретации деструктуризации как блока (для существующих переменных), нужно обернуть всё присваивание в скобки `(...)`:  
`({<переменная_из_объекта_как_имя_существующей_переменной>[: <имя_переменной>][= <значение_по_ум>][, ...]} = <объект>)`

> `const {2: country, 4: state} = '1997,John Doe,US,john@doe.com,New York'.split(',');`

## <a id="Шесть-типов-данных" href="#Шесть-типов-данных">Шесть типов данных</a>

Примитивные типы:
- **Число "number"** - единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения `Infinity` (бесконечность) и `NaN` (ошибка вычислений). Бесконечность `Infinity` получается при делении на ноль. Ошибка вычислений `NaN` будет результатом некорректной математической операции;
- **Строка "string"** - для представления строк, заключается в кавычки, в JavaScript **одинарные** `'` и **двойные** `"` кавычки равноправны. Можно использовать или те или другие;
- **Булевый (логический) тип "boolean"** - у него всего два значения: `true` (истина) и `false` (ложь). Как правило, такой тип, используется для хранения значения типа да/нет;
- **Специальное значение "null"** - значение `null` не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного значения `null`. Это просто специальное значение, которое имеет смысл "**ничего**" или "**значение неизвестно**";
- **Специальное значение "undefined"** - значение `undefined`, как и `null`, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл "**значение не присвоено**". Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть `undefined`.

Объектный тип:
- **Объекты "object"** - он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок `{...}`.

## <a id="Основные-операторы" href="#Основные-операторы">Основные операторы</a>

**Операнд** - то, к чему применяется оператор.  
**Унарным** называется оператор, который применяется к одному выражению.  
**Бинарным** называется оператор, который применяется к двум операндам.

**Сложение строк, бинарный `+`** - обычно при помощи плюса `+` складывают числа. Но если бинарный оператор `+` применить к строкам, то он их объединяет в одну. Иначе говорят, что "*плюс производит конкатенацию (сложение) строк*". Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке. Это приведение к строке - особенность исключительно бинарного оператора `+`. Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

**Преобразование к числу, унарный плюс `+`** - унарный, то есть применённый к одному значению, плюс ничего не делает с числами. Тем не менее, он широко применяется, так как его "*побочный эффект**" - преобразование значения в число, для этого используется унарный плюс, чтобы преобразовать строку к числу.

**Присваивание** - возможно присваивание по цепочке, такое присваивание работает справа-налево. Оператор `=` возвращает значение, как и все операторы.

**Взятие остатка `%`** - результат `a % b` - это остаток от деления `a` на `b`.

**Инкремент/декремент: `++`, `--`** - увеличивают/уменьшают значение переменной на `1`. Постфиксная форма `i++` отличается от префиксной `++i` тем, что возвращает старое значение, бывшее до увеличения. Инкремент/декремент можно использовать в любых выражениях.

### <a id="Побитовые-операторы" href="#Побитовые-операторы">Побитовые операторы</a>

Рассматривают аргументы как **32-разрядные целые числа** и работают на уровне их внутреннего двоичного представления. Поддерживаются следующие побитовые операторы:
- **побитовое И (AND) `a & b`** - ставит 1 на бит результата, для которого соответствующие биты операндов равны 1;
- **побитовое ИЛИ (OR) `a | b`** - ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1;
- **побитовое исключающее ИЛИ (XOR) `a ^ b`** - ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба);
- **побитовое НЕ (NOT) `~a`** - заменяет каждый бит операнда на противоположный;
- **левый сдвиг `a << b`** - сдвигает двоичное представление `a` на `b` битов влево, добавляя справа нули;
- **правый сдвиг, переносящий знак `a >> b`** - сдвигает двоичное представление `a` на `b` битов вправо, отбрасывая сдвигаемые биты;
- **правый сдвиг с заполнением нулями `a >>> b`** - сдвигает двоичное представление `a` на `b` битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.

В JavaScript побитовые операторы `^`, `&`, `|` выполняются после сравнений `==`. Битовые операции отбрасывают десятичную часть.

`-n = ~n + 1`  
`~n == 0 только если n == -1`

### <a id="Сокращённая-арифметика-с-присваиванием" href="#Сокращённая-арифметика-с-присваиванием">Сокращённая арифметика с присваиванием</a>

Имеет вид:
`<имя_переменной> <бинарный_оператор> = <второй операнд>;`

### <a id="Оператор-запятая-" href="#Оператор-запятая-">Оператор запятая `,`</a>

Оператор запятая `,` - обычно используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Каждое из них - вычисляется и отбрасывается, за исключением последнего, которое возвращается.

### <a id="Операторы-сравнения-и-логические-значения" href="#Операторы-сравнения-и-логические-значения">Операторы сравнения и логические значения</a>

Операторы сравнения:
- **больше/меньше**: `a > b`, `a < b`;
- **больше/меньше** или равно: `a >= b`, `a <= b`;
- **равно** `a == b`. Для сравнения используется два символа равенства `==`. Один символ `=` означал бы присваивание;
- **"не равно"**. В математике он пишется как `≠`, в JavaScript - знак равенства с восклицательным знаком перед ним `!=`.

Как и другие операторы, сравнение возвращает значение. Это значение имеет логический тип.

**Строки сравниваются** побуквенно, сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой, при этом любая буква больше отсутствия буквы.

При сравнении значений разных типов, используется **числовое преобразование**. Оно применяется к обоим значениям.

Для проверки равенства без преобразования типов используются операторы строгого равенства `===`(*тройное равно*) и `!==`. Если тип разный, то они всегда возвращают `false`.

Сравнение с `null` и `undefined`:
- значения `null` и `undefined` равны `==` друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка;
- при преобразовании в число `null` становится `0`, а `undefined` становится `NaN`. При этом получается некорректный результат сравнения `null` с `0`, и значение `undefined` вообще нельзя сравнивать.

### <a id="Логические-операторы" href="#Логические-операторы">Логические операторы</a>

`||` (**ИЛИ**) - логическое **ИЛИ** в классическом программировании работает следующим образом: "если хотя бы один из аргументов `true`, то возвращает `true`, иначе - `false`". Оператор **ИЛИ** вычисляет ровно столько значений, сколько необходимо - до первого `true`. При этом оператор **ИЛИ** возвращает то значение, на котором остановились вычисления. Причём, не преобразованное к логическому типу. Если все значения "ложные", то `||` возвратит последнее из них.

`&&` (**И**) - в классическом программировании **И** возвращает `true`, если оба аргумента истинны, а иначе - `false`. Если левый аргумент - `false`, оператор **И** возвращает его и заканчивает вычисления. Иначе - вычисляет и возвращает правый аргумент.

Приоритет у `&&` больше, чем у `||`.

`!` (**НЕ**) - оператор **НЕ** - самый простой. Он получает один аргумент. Действия `!`:
1. Сначала приводит аргумент к логическому типу `true`/`false`.
2. Затем возвращает противоположное значение.

В частности, двойное НЕ (`!!`) используют для преобразования значений к логическому типу.

### <a id="Оператор-typeof" href="#Оператор-typeof">Оператор `typeof`</a>

Оператор `typeof` возвращает тип аргумента в виде строки. У него есть два синтаксиса: со скобками и без:
- синтаксис оператора: `typeof <аргумент>`;
- синтаксис функции: `typeof(<аргумент>)`.

С помощью такой конструкции можно проверить существование переменной, ее объявление:  
`typeof <переменная> === "undefined"` - вернет `true`, если переменная не существует.

### <a id="Оператор-void" href="#Оператор-void">Оператор `void`</a>

Оператор `void` вычисляет переданное выражение и возвращает `undefined`.У него есть два синтаксиса: со скобками и без:
- синтаксис оператора: `void <выражение>`;
- синтаксис функции: `void(<выражение>)`.

С помощью такой конструкции можно вызвать анонимную функцию:  
`void function (...) {...}();`

## <a id="Преобразование-типов-для-примитивов" href="#Преобразование-типов-для-примитивов">Преобразование типов для примитивов</a>

**Строковое преобразование** - `String(<аргумент>)` - возвращает аргумент в виде строки, преобразование происходит наиболее очевидным способом, "как есть": `false` становится `"false"`, `null` - `"null"`, `undefined` - `"undefined"` и т.п. Также для явного преобразования применяется оператор `+`, у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент.

**Численное преобразование** - для преобразования к числу в явном виде можно вызвать `Number(<аргумент>)`, который возвращает аргумент в виде строки либо поставить перед выражением унарный плюс `+`, при этом: `undefined` - `NaN`; `null` - `0`; `true` - `1`; `false` - `0`; **Строка** - пробельные символы по краям обрезаются, далее, если остаётся пустая строка, то `0`, иначе из непустой строки "*считывается*" число, при ошибке результат `NaN`.

**Логическое преобразование** - для явного преобразования используется двойное логическое отрицание `!!<значение>` или вызов `Boolean(<аргумент>)`, который возвращает аргумент в виде логического значения, при этом `undefined`, `null` - `false`; **Числа** - все `true`, кроме `0`, `NaN` - `false`; **Строки** - все `true`, кроме пустой строки `""` - `false`; **Объекты** - всегда `true`.

### <a id="Вспомогательные-функции-parseInt-toString" href="#Вспомогательные-функции-parseInt-toString">Вспомогательные функции `parseInt`, `toString`</a>

`parseInt(<строка_с_числом>, <система_числа>)` - переводит строку в заданной системе в число.  
`<число>.toString(<система_числа>)` - получает для числа запись в заданной системе в виде строки.

## <a id="Условные-операторы-if-" href="#Условные-операторы-if-">Условные операторы: `if`, `?:`</a>

Оператор `if` ("если") - получает условие, он вычисляет его, и если результат - `true`, то выполняет команду. Если нужно выполнить более одной команды - они оформляются блоком кода в фигурных скобках `{<код>}`. Выполняет код только истиного условия, а если таких нет, то ложного. Вычисление условий происходит в порядке следования условий.

```javascript
if (<условие>) {
    <код_для_результата_условия_истины>
} [else if(<альтернативное_условие>) {
    <код_для_результата_альтернативного_условия_истины>
}] [...] [else {
    <код_для_результата_условия_лжи>
}]
```

Оператор `if (...)` вычисляет и преобразует выражение в скобках к логическому типу. В логическом контексте:
- число `0`, пустая строка `""`, `null` и `undefined`, а также `NaN` являются `false`;
- остальные значения - `true`.

### <a id="Тернарный-оператор-вопросительный-знак-" href="#Тернарный-оператор-вопросительный-знак-">Тернарный оператор вопросительный знак `?:`</a>

`<условие> ? <значение1> : <значение2>` - проверяется условие, затем если оно верно - возвращается `<значение1>`, если неверно - `<значение2>`.

## <a id="Циклы" href="#Циклы">Циклы</a>

### <a id="Цикл-while" href="#Цикл-while">Цикл `while`</a>

```javascript
while (<условие>) {
    <код_тела_итерации_цикла>
}
```

Пока условие: `<условие>` верно - выполняется тело: `<код_тела_итерации_цикла>`.

### <a id="Цикл-dowhile" href="#Цикл-dowhile">Цикл `do...while`</a>

```javascript
do {
    <код_тела_итерации_цикла>
} while (<условие>);
```

Цикл, описанный, таким образом, сначала выполняет тело: `<код_тела_итерации_цикла>`, а затем проверяет условие: `<условие>`.

### <a id="Цикл-for" href="#Цикл-for">Цикл `for`</a>

```javascript
for (<начало>; <условие>; <шаг>) {
    <код_тела_итерации_цикла>
}
```

Поток выполнения: `<начало>` -> (если `<условие>` истинно -> тело: `<код_тела_итерации_цикла>` -> `<шаг>`) -> (если `<условие>` истинно -> тело: `<код_тела_итерации_цикла>` -> `<шаг>`) -> ... и так далее, пока верно условие. В цикле также можно определить переменную в `<начало>`. Любая часть `for` может быть пропущена.

### <a id="Прерывание-цикла" href="#Прерывание-цикла">Прерывание цикла</a>

`break` - прекращает выполнение текущей итерации цикла и выходит из его тела.

`continue` - прекращает выполнение текущей итерации цикла и переходит на следующую.

#### <a id="Метки-для-breakcontinue" href="#Метки-для-breakcontinue">Метки для `break`/`continue`</a>

Метка имеет вид `<имя_метки>:`, имя должно быть уникальным. Она ставится перед циклом. Вызов `break <имя_метки>` ищет ближайший внешний цикл с такой меткой и переходит в его конец. Директива `continue <имя_метки>` также может быть использована с меткой, в этом случае управление перепрыгнет на следующую итерацию цикла с меткой.

Также для меток можно использовать блок кода:  
`<имя_метки>: {...}` - тогда вызов `break <имя_метки>` переходит в конец блока.

## <a id="Конструкция-switch" href="#Конструкция-switch">Конструкция `switch`</a>

Конструкция `switch` заменяет собой сразу несколько `if`. Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами. Синтаксис:

```javascript
switch(<переменная>) {
    case <значение1>: {
        <код_при_равенстве_переменной_значению1>
        [break;]
    }
    case <значение2>: {
        <код_при_равенстве_переменной_значению2>
        [break;]
    }
    [...]
    default: {
        <код_по_умолчанию_при_неравенстве_переменной_ни_одному_из_значений>
        [break;]
    }
}
```

Переменная проверяется на строгое равенство первому значению, затем второму и так далее. Если соответствие установлено - `switch` начинает выполняться от соответствующей директивы `case` и далее, до ближайшего `break` (или до конца `switch`). Если ни один `case` не совпал - выполняется (если есть) вариант `default`. При этом `case` называют вариантами `switch`.

Если `break` нет в теле `case`, то выполнение пойдёт ниже по следующим `case` до ближайшего `break` (или до конца `switch`), при этом остальные проверки игнорируются.

Несколько значений `case` можно группировать, просто не записывая код.

## <a id="Функции" href="#Функции">Функции</a>

Главная цель создания функций: избавление от дублирования кода. Синтаксис **Function Declaration**:

```javascript
function <имя_функции>([<параметр1>[, ...]]) {
    <код_функции>
    [return [<возвращаемое_значение>];]
}
```
Использование:
`<имя_функции>([<аргумент1>[, ...]]);`

Функция может содержать локальные переменные, объявленные через `var`. Такие переменные видны только внутри функции. Блоки `if/else`, `switch`, `for`, `while`, `do..while` не влияют на область видимости переменных. При объявлении переменной в таких блоках, она всё равно будет видна во всей функции. Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию.

Функция может обратиться ко внешней переменной. Такие переменные, объявленные на уровне всего скрипта, называют "**глобальными переменными**".

Параметры копируются в локальные переменные функции. Функцию можно вызвать с любым количеством аргументов. Если параметр не передан при вызове - он считается равным `undefined`. При объявлении функции необязательные аргументы, как правило, располагают в конце списка.

Для указания значения "по умолчанию", то есть, такого, которое используется, если аргумент не указан, используется два способа:
- можно проверить, равен ли аргумент `undefined`, и если да - то записать в него значение по умолчанию;
- использовать оператор `||`: `<параметр1> = <параметр1> || <значение_по_умолчанию>;`.

"Псевдо-массив" `arguments` - содержит список аргументов по номерам переданных в функцию, а также свойство `length`. При этом `arguments` - это не массив `Array`. В действительности, это обычный объект, просто ключи числовые и есть `length`.

`Array.prototype.slice.call(arguments);` - возвращает массив из `arguments`.

В старом стандарте JavaScript объект `arguments` не только хранил список аргументов, но и содержал в свойстве `arguments.callee` ссылку на функцию, которая выполняется в данный момент, а свойство `arguments.callee.caller` хранит ссылку на функцию, которая вызвала данную.

Для возврата значения используется директива `return`. Она может находиться в любом месте функции. Как только до неё доходит управление - функция завершается и значение передается обратно. В случае, когда функция не вернула значение или `return` был без аргументов, считается что она вернула `undefined`.

Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие. Если оно сложное и подразумевает поддействия - имеет смысл выделить их в отдельные функции, чтобы лучше структурировать код. Но самое главное - в функции не должно быть ничего, кроме самого действия и поддействий, неразрывно связанных с ним.

В JavaScript функция является значением, таким же как строка или число. Функцию можно запустить через скобки `()`, а можно и скопировать в другую переменную или передать в функцию как переменную.

В JavaScript **нет "перегрузки" функций**.

(ES6) Объявление функции **Function Declaration**, сделанное в блоке, видно только в этом блоке.

### <a id="Параметры-по-умолчанию-ES6" href="#Параметры-по-умолчанию-ES6">Параметры по умолчанию (ES6)</a>

Можно указывать параметры по умолчанию через равенство `=` в сигнатуре функции: `<параметр1> = <значение_по_умолчанию>`. Параметр по умолчанию используется при отсутствующем аргументе или равном `undefined`. При передаче любого значения, кроме `undefined`, включая пустую строку `''`, `0` или `null`, параметр считается переданным, и значение по умолчанию не используется. Параметры по умолчанию могут быть не только значениями, но и выражениями, при этом значение выражения будет вычислено, и соответствующие функции вызваны - лишь в том случае, если это необходимо, то есть когда функция вызвана без параметра.

### <a id="Оператор-spread-вместо-arguments-ES6" href="#Оператор-spread-вместо-arguments-ES6">Оператор spread вместо `arguments` (ES6)</a>

Чтобы получить массив аргументов, можно использовать оператор `...`, перед последней переменной в функцию. В который попадёт массив всех аргументов, начиная со второго. При этом это - настоящий массив, в отличие от arguments.

`...` оператор можно использовать и при вызове функции, для передачи массива параметров как списка параметров.

Если функция получает объект, то она может его тут же разбить в переменные с помощью деструктуризации.

### <a id="Объявление-Function-Expression" href="#Объявление-Function-Expression">Объявление Function Expression</a>

`var <имя_переменно_функции> = function [<имя_функции>]([<параметр1>[, ...]]) {...}` - возвращает функцию. Основное отличие между ними: функции, объявленные как **Function Declaration**, создаются интерпретатором до выполнения кода, и их можно вызвать до объявления.

Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.

### <a id="Функции-через--ES6" href="#Функции-через--ES6">Функции через `=>` (ES6)</a>

`<параметр> => <возвращаемый_результат>`  
`<параметр> => {... [return ...]}`  
`(<параметр1>, <параметр2>[, ...]) => <возвращаемый_результат>`  
`(<параметр1>, <параметр2>[, ...]) => {... [return ...]}`  
`() => <возвращаемый_результат>`
`() => {... [return ...]}`

> `a => a + 2`  
> `(a, b) => {a++; b--; return a*b}`

Основные особенности:
- стрелочные функции не имеют своего `this`. Внутри стрелочных функций - тот же `this`, что и снаружи. В стрелочных функциях `this` никогда не приобретает новое значение вне зависимости от того, как функция вызвана;
- стрелочные функции нельзя запускать с `new`, так как у стрелочных функций отсутствует "свой `this`";
- стрелочные функции не имеют своего `arguments`. В качестве `arguments` используются аргументы внешней "обычной" функции;
- стрелочные функции нельзя использовать для объявления методов объектов, т.к. в случае необходимости больше будет нельзя сослаться на объект через `this`.

Для возвращения объекта, объект оборачивается в скобки: `(<объект>)`.
> `() => ({a: 4, b: 3})`

## <a id="Создание-функции-из-текста---new-Function" href="#Создание-функции-из-текста---new-Function">Создание функции из текста - `new Function`</a>

`new Function('<список_аргументов>', '<код_тело_функции>');` - возвращает функцию созданную из аргументов.

### <a id="Рекурсия-стек" href="#Рекурсия-стек">Рекурсия, стек</a>

В коде функции могут вызывать другие функции для выполнения подзадач. Частный случай подвызова - когда функция вызывает сама себя. Это называется **рекурсией**. Рекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как некое действие в совокупности с решением той же задачи в более простом варианте.

Значение, на котором рекурсия заканчивается называют **базисом рекурсии**. Общее количество вложенных вызовов называют **глубиной рекурсии**. Максимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на **10000** вложенных вызовов, но некоторые интерпретаторы допускают и больше.

При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных - "**стеке контекстов**".

Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее. Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции, в зависимости от условий, используются различные рекурсивные подвызовы, когда ветвление более сложное.

Специально для работы с рекурсией в JavaScript существует особое расширение функциональных выражений, которое называется "*Named Function Expression*" (сокращённо NFE) - "**именованное функциональное выражение**", которое ставится после `function` в **Function Expression**. Имя функционального выражения имеет особый смысл. Оно доступно только изнутри самой функции. **NFE** используется в первую очередь в тех ситуациях, когда функцию нужно передавать в другое место кода или перемещать из одной переменной в другую. Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.

## <a id="Консоль" href="#Консоль">Консоль</a>

Используется при отладке, кроме просмотра переменных и передвижения по скрипту, позволяет запускать команды JavaScript.

`console.log(<аргументы>)` - пишет переданные ей аргументы в консоль.  
`console.log("<сообщение>"[, <аргумент>[, ...]])` - форматирует сообщение по указанным аргументам и пишет его в консоль. В сообщения могут встраиваться шаблоны для аргументов:
- `%o` или `%O` - выводит как JavaScript объект;
- `%d` или `%i` - выводит как целое число;
- `%s` - выводит как строку;
- `%f` - выводит как дробное число;
- `%c` - применяет к дальнейшему выводу в консоль CSS-стили из аргумента.

`console.info(<аргументы>)` - тоже что и лог, только как инфо.  
`console.info("<сообщение>"[, <аргумент>[, ...]])` - тоже что и лог, только как инфо.

`console.warn(<аргументы>)` - тоже что и лог, только как предупреждение.  
`console.warn("<сообщение>"[, <аргумент>[, ...]])` - тоже что и лог, только как предупреждение.

`console.error(<аргументы>)` - тоже что и лог, только как ошибка.  
`console.error("<сообщение>"[, <аргумент>[, ...]])` - тоже что и лог, только как ошибка.

`console.trace("<сообщение>"[, <аргумент>[, ...]])` - выводит сообщение как лог, плюс трейс вызова.

```javascript
console.dir(<объект>[, {
    showHidden: false, // если true, то будут отображать еще и не перечисляемые свойства и символы
    depth: <глубина_вложености>,
    colors: false // если true, то вывод будет стилизован под цвета ANSI
}])
```
Выводит элемент в виде JavaScript-объекта, для анализа его свойств.

`console.assert(<значение>[, "<сообщение>"[, <аргумент>[, ...]]])` - если значение не равно `true`, то выведется сообщение.

`console.time('<метка>')` - включить внутренний хронометр браузера с меткой.  
`console.timeEnd('<метка>')` - выключить внутренний хронометр браузера с меткой и вывести результат разницу в мс между конечной и начальной меткой.

`console.table({<массив> | <объект>}[, ["<отображаемое_свойство1>"[, ...]]])` - логгирует аргумент `<массив>` или `<объект>` в виде таблицы. Каждый элемент массива (или каждое свойство, если это объект) будет представлять строку таблицы. Если элементы массива, либо свойства объекта, в свою очередь сами являются массивами или объектами, тогда эти элементы или свойства перечисляются построчно, перечисляя вложенные элементы/свойства в колонках.

## <a id="Советы-по-стилю-кода" href="#Советы-по-стилю-кода">Советы по стилю кода</a>

```
function pow(x, n) {
            ^ ^ ^  ^
            | | |  +-- фигурная скобка { на той же строке через пробел
            | | +-- пробел между параметрами
            +-+-- между именем функции и скобкой ( и первым параметром нет пробела
    var result = 1;
^^^^          ^ ^ ^
||||          | | +-- точка с запятой ; обязательна
||||          +-+-- пробелы вокруг операторов
++++-- отступ 4/2 пробела для вложености
    for (var i = 0; i < n; i++) {
        ^
        +-- пробел после всех ключевых слов
        result *= x;
    }
    return result;
}
var x = prompt("x?", "");
var n = prompt("n?", "");
<-- пустая строка между логическими блоками
if (n < 0) {
    alert('Степень ', + n + <-- длина строки не больше 80 символов
        ' не поддерживается, введите целую степень, большую 0');
} else { <-- без перевода строки
    alert( pow(x, n) );
            ^         ^
            +---------+-- пробелы вокруг вложеного вызова
}
```

## <a id="Структуры-данных" href="#Структуры-данных">Структуры данных</a>

Все значения в JavaScript, за исключением `null` и `undefined`, содержат набор вспомогательных функций и значений, доступных "**через точку**". Такие функции называют "**методами**", а значения - "**свойствами**".

### <a id="Числа" href="#Числа">Числа</a>

Все числа в JavaScript, как целые так и дробные, имеют тип `Number` и хранятся в **64-битном формате IEEE-754**, также известном как "*double precision*".

Способы записи:
- `<число_в_десятичной_системе>`;
- `0b<число_в_двоичной_системе>`;
- `0x<число_в_шестнадцатеричной_системе>`;
- `0o<число_в_восьмеричной_системе>`;
- `<число_в_десятичной_системе>e<число_нулей>`.

`Infinity` - особенное численное значение, которое ведет себя в точности как математическая бесконечность `∞`. `Infinity` больше любого числа. Добавление к бесконечности не меняет её. Бесконечность можно присвоить и в явном виде: `var <переменная> = Infinity`. Бывает и минус бесконечность `-Infinity`. В качестве результата деления на 0 получается "бесконечность".

Если математическая операция не может быть совершена, то возвращается специальное значение `NaN` (*Not-A-Number*). Деление `0/0` в математическом смысле неопределенно, поэтому его результат `NaN`. Значение `NaN` используется для обозначения математической ошибки и обладает следующими свойствами:
- значение `NaN` - единственное, в своем роде, которое не равно ничему, включая себя;
- значение `NaN` "прилипчиво". Любая операция с `NaN` возвращает `NaN`.

`isNaN(<число>)` - преобразует аргумент к числу и возвращает `true`, если получилось `NaN`, и `false` - для любого другого значения.  
`isFinite(<число>)` - преобразует аргумент к числу и возвращает `true`, если это не `NaN`/`Infinity`/`-Infinity`.

`parseInt(<число>[, <система_счисления>])` и ее аналог:  
`parseFloat(<число>)` - преобразуют строку символ за символом, пока это возможно. При возникновении ошибки возвращается число, которое получилось. Функция `parseInt` читает из строки целое число, а `parseFloat` - дробное. `parseInt` / `parseFloat` возвращают `NaN` при ошибке на первом же символе.

`<число>.toString(<система_числа>)` - возвращает запись числа в заданной системе в виде строки.  
`<число>.toLocaleString("<локаль>")` - возвращает запись числа в указаной локали.  
`<число>.toFixed(<точность>)` - округляет число до точности и возвращает результат в виде строки. Округление идёт до ближайшего значения, аналогично `Math.round`. Итоговая строка, при необходимости, дополняется нулями до нужной точности.  
`<число>.toPrecision(<количество>)` - возвращает число в виде строки в записи с фиксированной запятой или в экспоненциальной записи, округлённое до `<количество>` значащих цифр.  
`<число>.toExponential(<кол_цифр_после_запятой>)` - возвращает строку, представляющую объект в экспоненциальной записи.

`Number.isInteger(<значение>)` - проверяет, является ли переданное значение целым числом и возвращает `true` если является, иначе `false`.  
`Number.isSafeInteger(<значение>)` - проверяет, является ли переданное значение безопасным целым числом в диапазоне от `-(2**53 - 1)` до `2**53 - 1` и возвращает `true` если является, иначе `false`.

#### <a id="Округление" href="#Округление">Округление</a>

- `Math.floor(<число>)` - округляет вниз и возвращает число;
- `Math.ceil(<число>)` - округляет вверх и возвращает число;
- `Math.round(<число>)` - округляет до ближайшего целого и возвращает число.

#### <a id="Встроенные-функции-для-тригонометрических-вычислений" href="#Встроенные-функции-для-тригонометрических-вычислений">Встроенные функции для тригонометрических вычислений</a>

- `Math.acos(<число>)` - возвращает арккосинус `<число>` (в радианах);
- `Math.asin(<число>)` - возвращает арксинус `<число>` (в радианах);
- `Math.atan(<число>)` - возвращает арктангенс `<число>` (в радианах);
- `Math.atan2(y, x)` - возвращает угол до точки` (y, x)`;
- `Math.sin(<число>)` - вычисляет синус `<число>` (в радианах);
- `Math.cos(<число>)` - вычисляет косинус `<число>` (в радианах);
- `Math.tan(<число>)` - возвращает тангенс `<число>` (в радианах).

#### <a id="Функции-общего-назначения" href="#Функции-общего-назначения">Функции общего назначения</a>

- `Math.sqrt(<число>)` - возвращает квадратный корень из `<число>`;
- `Math.log(<число>)` - возвращает натуральный (по основанию e) логарифм `<число>`;
- `Math.pow(<число>, <степень>)` - возводит число в степень, возвращает `<число>^<степень>`. Работает в том числе с дробными и отрицательными степенями;
- `Math.abs(<число>)` - возвращает абсолютное значение числа;
- `Math.exp(<число>)` - возвращает `e^<число>`, где `e` - основание натуральных логарифмов;
- `Math.max(a, b, c[, ...])` - возвращает наибольший из списка аргументов;
- `Math.min(a, b, c[, ...])` - возвращает наименьший из списка аргументов;
- `Math.random()` - возвращает псевдо-случайное число в интервале `[0,1)` - то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализируется текущим временем;
- `Math.hypot(a, b, c[, ...])` - возвращает корень из суммы квадратов аргументов.

### <a id="Строки" href="#Строки">Строки</a>

В JavaScript любые текстовые данные являются строками. Внутренним форматом строк, вне зависимости от кодировки страницы, является **Юникод** (**Unicode**). Строки создаются при помощи двойных или одинарных кавычек. В JavaScript нет разницы между двойными и одинарными кавычками.

Строки могут содержать специальные символы:
- `\0` - нулевой символ (символ NUL);
- `\'` - одинарная кавычка;
- `\"` - двойная кавычка;
- `\\` - обратный слэш;
- `\n` - новая строка (New line);
- `\r` - возврат каретки (Carriage return);
- `\v` - вертикальная табуляция;
- `\t` - табуляция (Tab);
- `\b` - забой (Backspace);
- `\f` - подача страницы (Form feed);
- `\uXXXX` - кодовая точка **Юникода** с шестнадцатеричным кодом `XXXX`;
- `\xXX` - символ из кодировки **Latin-1** (**ISO 8859-1**) с шестнадцатеричным кодом `XX`;
- `\u{NNNNNNNN}`, где `NNNNNNNN` - (ES6) максимально восьмизначный (но можно и меньше цифр) код для суррогатных пар.

Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем `\'`. Экранирование служит исключительно для правильного восприятия строки JavaScript. В памяти строка будет содержать сам символ без `\`. Сам символ обратного слэша `\` является служебным, поэтому всегда экранируется, т.е пишется как `\\`. Заэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт.

#### <a id="Строки-в----ES6" href="#Строки-в----ES6">Строки в `` ` `` (ES6)</a>

Если строки создавать в виде: `` `...` ``, то они будут отличаться от двойных `"..."` и одинарных `'...'` кавычек:
- в них разрешёно использовать перевод строки;
- в них можно вставлять выражения при помощи `${...}` - значение переменной `${<переменная>}` или более сложные выражения, которые могут включать в себя операторы, вызовы функций и т.п. Такую вставку называют "интерполяцией".
    > ``const a = 4000, b = `a is ${a}`;``

#### <a id="Функции-шаблонизации-ES6" href="#Функции-шаблонизации-ES6">Функции шаблонизации (ES6)</a>

Можно использовать свою функцию шаблонизации для строк. Название этой функции ставится перед первой обратной кавычкой:  
``let <переменная> = <функция_шаблонизации>`<строка>`;``

Эта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров ${...} и сами эти параметры.

Строка разбивается по очереди на части: "кусок строки" - "параметр" - "кусок строки" - "параметр" и т.д.

`function <функция_шаблонизации>(strings, ...values) {... return <новая_строка>;}` - функция шаблонизации, где:
- участки строки идут в первый аргумент-массив `strings` без выражений в `${...}`;
- у этого массива есть дополнительное свойство `strings.raw`. В нём находятся строки в точности как в оригинале;
- дальнейший список аргументов функции шаблонизации `values` - это значения выражений в `${...}`.

Функция шаблонизации может как-то преобразовать строку и вернуть новый результат.

#### <a id="Свойства-и-методы" href="#Свойства-и-методы">Свойства и методы</a>

`<строка>.length` - возвращает длину строки.  
`<строка>.charAt(<позиция>)` - возвращает строку, состоящую из выбранного символа, если символа нет, то пустую строку. Первый символ имеет позицию 0.  
`<строка>[<позиция>]` - возвращает строку, состоящую из выбранного символа, если символа нет - `undefined`.

Содержимое строки в JavaScript нельзя изменять. Нельзя взять символ посередине и заменить его. Как только строка создана - она такая навсегда. Можно лишь создать целиком новую строку и присвоить в переменную вместо старой.

`<строка>.toLowerCase()` - возвращает строку со всеми символами в нижнем регистре.  
`<строка>.toUpperCase()` - возвращает строку со всеми символами в верхнем регистре.

`<строка>.trim()` - возвращает строку с удаленными пробелами спереди и сзади.

`<строка>.indexOf(<подстрока>[, <начальная_позиция>])` - возвращает позицию, на которой находится подстрока или `-1`, если ничего не найдено [начиная с указанной позиции].  
`<строка>.lastIndexOf(<подстрока>[, <начальная_позиция>])` - ищет не с начала, а с конца строки.

`<строка>.substring(<начальная_позиция>[, <конечная_позиция>])` - возвращает подстроку с начальной позиции до конца [до конечной позиции, но не включая ее].  
`<строка>.substr(<начальная_позиция>[, <длина>])` - возвращает подстроку с начальной позиции до конца [заданной длины].  
`<строка>.slice(<начальная_позиция>[, <конечная_позиция>])` - возвращает подстроку с начальной позиции до конца [до конечной позиции, но не включая ее], при этом отрицательные значения отсчитываются от конца строки.

`String.fromCharCode(<код>)` - возвращает символ по коду Юникода.  
`<строка>.charCodeAt(<позиция>)` - возвращает код символа на позиции. Отсчет позиции начинается с нуля.

`<строка>.localeCompare(<сравниваемая_строка>)` - возвращает негативное число, если `<строка>` предшествует `<сравниваемая_строка>` при сортировке, позитивное если `<строка>` следует за `<сравниваемая_строка>`, иначе `0`.

`String.fromCodePoint(<код>)` и `<строка>.codePointAt(<позиция>)` - (ES6) аналоги `String.fromCharCode(<код>)` и `<строка>.charCodeAt(<позиция>)`, корректно работающие с суррогатными парами - когда одному символу языка соответствует два юникодных символа (итого 4 байта).  
`<строка>.normalize()` - (ES6) юникодная нормализация, при которой строки приводятся к единому, "нормальному", виду.  
`<строка>.includes(<включаемая_строка>[, <начальный_индекс>])` - (ES6) проверяет, включает ли одна строка в себя другую [, начиная с `<начальный_индекс>`], возвращает `true`/`false`.  
`<строка>.endsWith(<подстрока>)` - (ES6) возвращает `true`, если строка заканчивается подстрокой.  
`<строка>.startsWith(<подстрока>)` - (ES6) возвращает `true`, если строка начинается со подстрокой.  
`<строка>.repeat(<кол_повторений>)` - (ES6) повторяет строку указанное количество раз.

### <a id="Объекты-как-ассоциативные-массивы" href="#Объекты-как-ассоциативные-массивы">Объекты как ассоциативные массивы</a>

**Ассоциативный массив** - структура данных, в которой можно хранить любые данные в формате ключ-значение. Создание:
- `{}`;
- `new Object()`.

Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства ("по ключу"). Для обращения к свойствам используется:
`<объект>.<свойство>`  
`<объект>["<свойство>"]`

Можно обратиться к любому свойству объекта, даже если его нет, то вернется специальное значение `undefined`.

Оператор: `"<свойство>" in <объект>` - возвращает `true` если есть в объекте свойство с определенным ключом.

Удаление осуществляется оператором: `delete <объект>.<свойство>`.

Объект можно заполнить значениями при создании, указав их в фигурных скобках:

```javascript
{
    <ключ1>: <значение1>[,
    <ключ2>: <значение2>[,
    ... ]]
}
```

Если создаётся объект при помощи синтаксиса `{...}`, то задать свойства-функции можно прямо в его определении. Для этого используется особый синтаксис: `get <свойство>()` или `set <свойство>(newValue)`.

#### <a id="Короткое-свойство-ES6" href="#Короткое-свойство-ES6">Короткое свойство (ES6)</a>

При объявлении объекта достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем свойства уже ранее объявленной.
> `const day = 'mon', obj = {day}; // {day: 'mon'}`

#### <a id="Вычисляемые-свойства-ES6" href="#Вычисляемые-свойства-ES6">Вычисляемые свойства (ES6)</a>

В качестве имени свойства можно использовать выражение `[<выражение>]`.
> `const param = 'req-', obj = {[param + 'day']: 'mon', [param + 'next']: 'wed'}; // {req-day: "mon", req-next: "wed"}`

#### <a id="Цикл-по-свойствам" href="#Цикл-по-свойствам">Цикл по свойствам</a>

Он последовательно переберёт свойства объекта, имя каждого свойства будет записано в `<ключ>` и вызвано тело цикла:

```javascript
for ([var ]<ключ> in <объект>) {
    ... // доступ к значению <объект>[<ключ>]
}
```

В переменной, которой присвоен объект, хранится не сам объект, а "*адрес его места в памяти*", иными словами - "**ссылка**" на него. При копировании переменной с объектом - копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Так как объект всего один, то изменения через любую переменную видны в других переменных.

`Object.keys(<объект>)` - возвращает массив ключей всех свойств объекта.

## <a id="Массивы-c-числовыми-индексами" href="#Массивы-c-числовыми-индексами">Массивы c числовыми индексами</a>

**Массив** - разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией. Создание:
- `[[<элемент1>[, <элемент2>[, ...]]]]`;
- `new Array([<элемент1>[, <элемент2>[, ...]]])`;
- `new Array(<количество_элементов>)`;
- `Array.from(<псевдомассив>[, function (item, i, arr) {...}[, <this_контекст>]])` - (ES6) возвращает настоящий массив на основе псевдомассива или итерируемых объектов (у которых есть метод `[Symbol.iterator]`) [и к каждому элементу применяет функцию и результат этой функции заносит в массив]. Псевдомассив может быть такого вида: `{length: <количество>}`;
- `Array.of(<значение1>[, ...])` - (ES6) возвращает массив на основании переданных значений, аналогично `new Array(<значение1>[, ...])`, но без специального поведения при одном аргументе.

Элементы нумеруются, начиная с нуля `0`.

Для того чтобы получить нужный элемент из массива - указывается его номер в квадратных скобках `<массив>[<номер_индекс>]`, так же можно добавлять новые элементы.
Общее число элементов, хранимых в массиве, содержится в его свойстве, при этом - это не количество элементов массива, а **последний индекс + 1**:  
`<массив>.length`

При уменьшении `length` массив укорачивается, причем этот процесс необратимый, т.е. даже если потом вернуть `length` обратно - значения не восстановятся.

В массиве может храниться любое число элементов любого типа.

Массив - это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством `length`. Из этого следует следствие - можно присваивать в массив любые свойства.

`<массив>.fill(<значение>[, <нач_индекс> = 0[, <кон_индекс> = this.length]])` - (ES6) заполняет все элементы массива [от начального [до конечного] индекса] одним значением и возвращает его, если элемент это объект, то все элементы будут одним и тем объектом, т.е. иметь ссылки на один и тот же объект.

`<массив>.pop()` - удаляет последний элемент из массива и возвращает его.  
`<массив>.push(<элемент1>[, <элемент2>[, ...]])` - добавляет элементы в конец массива.  
`<массив>.shift()` - удаляет из массива первый элемент и возвращает его.  
`<массив>.unshift(<элемент1>[, <элемент2>[, ...]])` - добавляет элементы в начало массива.

`<массив>.splice(<номер_индекс>[, <кол_элементов>[, <элемент1>[, <элемент2>[, ...]]]])` - удаляет заданное количество элементов, начиная с номера `<номер_индекс>`, а затем вставляет элементы на их место. Возвращает массив из удалённых элементов. Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца.

`<массив>.copyWithin(<номер_индекс>[, <начальная_позиция>[, <конечная_позиция>]])` - (ES6) копирует участок массива в позицию начиная с номера `<номер_индекс>` в текущий массив, не больше длины самого массива [с начальной позиции и до конца [до конечной позиции, он не включая ее]] и возвращает текущий массив. Можно использовать отрицательные индексы, они отсчитываются с конца. Если вообще не указать аргументов - скопируется весь массив с начала в указаную позицию.

`<массив>.slice(<начальная_позиция>[, <конечная_позиция>])` - копирует участок массива с начальной позиции и до конца [до конечной позиции, он не включая ее] и возвращает его. Исходный массив при этом не меняется. Можно использовать отрицательные индексы, они отсчитываются с конца. Если вообще не указать аргументов - скопируется весь массив.

`<массив>.sort([function (a, b) {...}])` - сортирует массив на месте и возвращает его [с помощью функции сортировки, то элементы массива сортируются в соответствии с её возвращаемым значением:
- при положительном значение, сортировка поставит `b` по меньшему индексу, чем `a`;
- при отрицательном значение, сортировка поставит `a` по меньшему индексу, чем `b`, то есть, `a` идёт первым;
- при 0, но вообще - не важно, что возвращать, их взаимный порядок не имеет значения.]

`<массив>.reverse()` - меняет порядок элементов в массиве на обратный на месте и возвращает массив.

`<массив>.concat(<элемент1>[, <элемент2>[, ...]])` - создаёт новый массив и возвращает его, в который копируются элементы из массива, а также указанные элементы. Если аргумент `concat` - массив, то `concat` добавляет элементы из него.

`<строка>.split(<строка_разделитель>[, <макс_кол_элементов>])` - возвращает массив превращенный из строки по разделителю.  
`<массив>.join(<строка_разделитель>)` - склеивает массив в строку с помощью разделителя и возвращает его.

`<массив>.indexOf(<искомый_элемент>[, <начальная_позиция>])` - возвращает номер искомого элемента в массиве или `-1`, если его нет [, при этом поиск начинается с указаного номера, если он указан. Если нет - с начала массива.] Для поиска используется строгое сравнение `===`.  
`<массив>.lastIndexOf(<искомый_элемент>[, <начальная_позиция>])` - ищет справа-налево: с конца массива [с указанного номера].  
`<массив>.includes(<элемент>[, <начальный_индекс>])` - (ES6) проверяет, включает ли массив в себя элемент [, начиная с `<начальный_индекс>`], возвращает в случае успеха `true` иначе `false`.

`<массив>.forEach(function (item, i, arr) {...}[, <this_контекст>])` - используется для перебора массива, он для каждого элемента массива вызывает переданую callback-функцию, где:
- `item` - текущий элемент массива, элементы перебираются по очереди слева-направо;
- `i` - номер текущего элемента;
- `arr` - обрабатываемый массив.

`<массив>.filter(function (item, i, arr) {...}[, <this_контекст>])` - используется для фильтрации массива через функцию. Он создаёт новый массив, в который войдут только те элементы массива, для которых вызов callback-функции возвратит `true`.

`<массив>.map(function (item, i, arr) {...}[, <this_контекст>])` - используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов возвращаемых значений вызова callback-функции для каждого элемента массива.

`<массив>.every(function (item, i, arr) {...}[, <this_контекст>])` - возвращает `true`, если вызов callback-функции вернёт `true` для каждого элемента массива, если для любого элемента массива callback-функции вернёт `false`, метод немедленно вернёт `false` и не будет посещать остальные элементы.

`<массив>.some(function (item, i, arr) {...}[, <this_контекст>])` - возвращает `true`, если вызов callback-функции вернёт `true` для какого-нибудь элемента массива, если такой элемент найден, метод немедленно вернёт `true` и не будет посещать остальные элементы.

`<массив>.reduce(function (accumulator, item, i, arr) {...}[, <начальное_значение>[, <this_контекст>]])` - используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата. Метод `reduce` используется для вычисления на основе массива какого-либо единого значения, иначе говорят "**для свёртки массива**". Он применяет callback-функцию по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат который должна возвращать callback-функция на каждой итерации, где:
- `accumulator` - последний результат вызова функции, он же "**промежуточный результат**";
- `item` - текущий элемент массива, элементы перебираются по очереди слева-направо;
- `i` - номер текущего элемента;
- `arr` - обрабатываемый массив.

Методу можно передать "начальное значение" `<начальное_значение>`. Если он есть, то на первом вызове значение `accumulator` будет равно начальному значению, а если у `reduce` нет второго аргумента, то оно равно **первому** элементу массива, а перебор начинается со **второго**. Если массив пустой и нет второго аргумента, то будет брошено исключение `TypeError`.

`<массив>.reduceRight(function (accumulator, item, i, arr) {...}[, <начальное_значение>[, <this_контекст>]])` - работает аналогично, но идёт по массиву справа-налево.

`<массив>.find(function (item, i, arr) {...}[, <this_контекст>])` - (ES6) возвращает ссылку на значение в массиве, если вызов callback-функции вернёт `true` для какого-нибудь элемента массива, в противном случае возвращается `undefined`.

`<массив>.findIndex(function (item, i, arr) {...}[, <this_контекст>])` - (ES6) возвращает индекс в массиве, если вызов callback-функции вернёт `true` для какого-нибудь элемента массива, в противном случае возвращается `-1`.

`<массив>.entries()` - возвращает итерируемый объект для массива с элементами в виде `[<ключ>, <значение>]`, он используется по умолчанию в `for..of`.  
`<массив>.keys()` - возвращает итерируемый объект для массива с элементами в виде ключей, т.е. по ключам, он используется по умолчанию в `for..of`.  
`<массив>.values()` - возвращает итерируемый объект для массива с элементами в виде значений, т.е. по значениям, он используется по умолчанию в `for..of`.

`Array.isArray(<значение>)` - он возвращает `true` только если `<значение>` - массив.

### <a id="ArrayBuffer-ES6" href="#ArrayBuffer-ES6">`ArrayBuffer` (ES6)</a>

Представляет собой фиксированный сырой буфер с бинарными данными. Напрямую им нельзя манипулировать, из него можно создать типизированный массив или объект `DataView`, который представляет этот буфер в специфическом формате и используется для чтения или записи содержимого в буфер.

`let <arrayBuffer> = new ArrayBuffer(<размер_байт>)` - создает сырой буфер определенного размера в байтах.

`<arrayBuffer>.byteLength` - возвращает размер в байтах.

`<arrayBuffer>.slice(<начальная_позиция_байт>[, <конечная_позиция_байт>])` - возвращает новый `ArrayBuffer` в который копирует участок массива с начальной позиции и до конца [до конечной позиции, он не включая ее] и возвращает его. Исходный массив при этом не меняется. Можно использовать отрицательные индексы, они отсчитываются с конца. Если вообще не указать аргументов - скопируется весь массив.

`ArrayBuffer.isView(<объект>)` - он возвращает `true` только если `<объект>` - типизированный массив или `DataView`.

### <a id="DataView-ES6" href="#DataView-ES6">`DataView` (ES6)</a>

Представляет отображение сырого буфера в специфическом формате и используется для чтения или записи содержимого в буфер.

`let <dataView> = new DataView(<arrayBuffer>[, <отступ_байт>[, <размер_байт>]])` - создает отображение на основании сырого массива [с определенного отступа в байтах [и определенного размера]].

`<dataView>.buffer` - возвращает исходный буфер.  
`<dataView>.byteLength` - возвращает размер в байтах отображения.  
`<dataView>.byteOffset` - возвращает отступ в байтах.  
`<dataView>.<метод_доступа>(<позиция_байт>)` - возвращает значение в определенном формате метода на указанной позиции в отображении.

Методы доступа:
- `getInt8` - возвращает значение типа `Int8`;
- `getUint8` - возвращает значение типа `Uint8`;
- `getInt16` - возвращает значение типа `Int16`;
- `getUint16` - возвращает значение типа `Uint16`;
- `getInt32` - возвращает значение типа `Int32`;
- `getUint32` - возвращает значение типа `Uint32`;
- `getFloat32` - возвращает значение типа `Float32`;
- `getFloat64` - возвращает значение типа `Float64`.

`<dataView>.<метод_установки>(<позиция_байт>, <позиция_байт>[, true])` - устанавливает значение в определенном формате метода на указанной позиции в отображении [в байтовом порядке `littleEndian`].

Методы установки:
- `setInt8` - устанавливает значение типа `Int8`;
- `setUint8` - устанавливает значение типа `Uint8`;
- `setInt16` - устанавливает значение типа `Int16`;
- `setUint16` - устанавливает значение типа `Uint16`;
- `setInt32` - устанавливает значение типа `Int32`;
- `setUint32` - устанавливает значение типа `Uint32`;
- `setFloat32` - устанавливает значение типа `Float32`;
- `setFloat64` - устанавливает значение типа `Float64`.

### <a id="TypedArray-ES6" href="#TypedArray-ES6">TypedArray (ES6)</a>

Объект **TypedArray** (типизированный массив) это массивоподобное представление нижележащего буфера с бинарными данными (`ArrayBuffer`). Нет ни глобального свойства TypedArray, ни открытого конструктора TypedArray. Но существует ряд глобальных элементов, которые являются конструкторами типизированных массивов для конкретно заданных типов данных.

Создание:
- `let <типизированный_массив> = new <TypedArray>(<длина>)` - создает массив с указанным количеством элементов, т.е. в памяти создаётся буфер длины `<длина> * BYTES_PER_ELEMENT` байт, содержащий нули;
- `let <типизированный_массив> = new <TypedArray>(<типизированный_массив>)` - создает массив на основании входного массива одинаковой длины, при этом каждое значение из входного конвертируется в соответствующий конструктору тип прямо перед копированием;
- `let <типизированный_массив> = new <TypedArray>(<объект>)` - создает массив на основании объекта;
- `let <типизированный_массив> = new <TypedArray>(<arrayBuffer>[, <отступ_байт>[, <размер_байт>]])` - создает массив на основании сырого массива [с определенного отступа в байтах [и определенного размера]].

Где `<TypedArray>` это одно из следующих значений:

Тип (TypedArray)    | Размер (байты) | Тип Web IDL         | Тип языка C | Описание
 ------------------ | -------------- | ------------------- | ----------- | --------
`Int8Array`         | 1              | byte                | int8_t      | 8-битное целое со знаком с дополнением до двух
`Uint8Array`        | 1              | octet               | uint8_t     | 8-битное беззнаковое целое
`Uint8ClampedArray` | 1              | octet               | uint8_t     | 8-битное беззнаковое целое (фиксированное от 0 до 255)
`Int16Array`        | 2              | short               | int16_t     | 16-битное целое со знаком с дополнением до двух
`Uint16Array`       | 2              | unsigned short      | uint16_t    | 16-битное беззнаковое целое
`Int32Array`        | 4              | long                | int32_t     | 32-битное целое со знаком с дополнением до двух
`Uint32Array`       | 4              | unsigned long       | uint32_t    | 32-битное беззнаковое целое
`Float32Array`      | 4              | unrestricted float  | float       | 32-битное число с плавающей точкой IEEE-стандарта
`Float64Array`      | 8              | unrestricted double | double      | 64-битное число с плавающей точкой IEEE-стандарта

Получить доступ к элементам массива можно используя стандартный синтаксис по индексу (например, `arr[12]`). Однако, получение и установка индексируемых свойств по цепи прототипов не будет происходить даже в случае, когда будет попытка использовать индексы извне массива.

`<типизированный_массив>.BYTES_PER_ELEMENT` - возвращает размер элемента для разных типизированных массивов.  
`<типизированный_массив>.length` - возвращает количество элементов.  
`<типизированный_массив>.set(<массив>[, <начальный_индекс>])` - копирует данные из массива в текущий массив начиная с позиции 0 текущего массива [на указаную позицию в текущем массиве].  
`<типизированный_массив>.subarray(<начальная_позиция>[, <конечная_позиция>])` - копирует данные из массива в новый массив начиная с указаной позиции массива [и до указаной позиции] который основывается на том же `ArrayBuffer` что и текущий.

## <a id="Дата-и-Время" href="#Дата-и-Время">Дата и Время</a>

Для работы с датой и временем в JavaScript используются объекты `Date`. Создание:
- `new Date()` - создает объект `Date` с текущей датой и временем;
- `new Date(<кол_мс>)` - создает объект `Date`, значение которого равно количеству миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0;
- `new Date('<дата_в_строке>')` - если единственный аргумент - строка, используется вызов `Date.parse` для чтения даты из неё;
- `new Date(<год_из_4_цифр>, <месяц_с_0>[, <день>, <час>, <мин>, <сек>, <мс>])` - если значения, большие логического диапазона (например, 13 в качестве номера месяца или 70 для значения минут) "переметнутся" на соседние значения (`new Date(2013, 13, 1)` равен `new Date(2014, 1, 1)`).

`<дата>.getFullYear()` - возвращает год (из 4 цифр).  
`<дата>.getMonth()` - возвращает месяц, от 0 до 11.  
`<дата>.getDate()` - возвращает число месяца, от 1 до 31.  
`<дата>.getHours()`, `<дата>.getMinutes()`, `<дата>.getSeconds()`, `<дата>.getMilliseconds()` - возвращает соответствующие компоненты.  
`<дата>.getDay()` - возвращает номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0 (воскресенье) до 6 (суббота).

Все эти методы, возвращают результат для местной временной зоны.

Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): `getUTCFullYear()`, `getUTCMonth()`, `getUTCDay()`. То есть, сразу после `get` вставляется `UTC`.

`<дата>.getTime()` - возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0.  
`<дата>.getTimezoneOffset()` - возвращает разницу между местным и UTC-временем, в минутах.

Следующие методы позволяют устанавливать компоненты даты и времени:
`<дата>.setFullYear(<год>[, <месяц>[, <день>]])`  
`<дата>.setMonth(<месяц>[, <день>])`  
`<дата>.setDate(<день>)`  
`<дата>.setHours(<час>[, <мин>[, <сек>[, <мс>]]])`  
`<дата>.setMinutes(<мин>[, <сек>[, <мс>]])`  
`<дата>.setSeconds(<сек>[, <мс>])`  
`<дата>.setMilliseconds(<мс>)`  
`<дата>.setTime(<кол_мс>)` - устанавливает всю дату по миллисекундам с 01.01.1970 UTC

Все методы, кроме `<дата>.setTime()`, обладают также UTC-вариантом, например: `<дата>.setUTCHours()`.

**Неправильные компоненты даты автоматически распределяются по остальным**.

**Даты можно вычитать**, результат вычитания объектов `Date` - их временная разница, в миллисекундах.

Оператор `+` для `Date` использует именно `toString`, а не `valueOf`.

`performance.now()` возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее - с момента выгрузки предыдущей страницы из памяти. Так что это время включает в себя всё, включая начальное обращение к серверу.

`<дата>.toLocaleString("<локаль>", <опции>)` - выводит дату где указано, какие параметры даты нужно вывести, и ряд настроек вывода, после чего интерпретатор сам сформирует строку.

`<дата>.toString()`, `<дата>.toDateString()`, `<дата>.toTimeString()` - возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему - читаемость человеком.

`<дата>.toString()` - возвращает строковое представление даты на американском английском, `<дата>.toDateString()` и `<дата>.toTimeString()` - только дату и время соответственно.  
`<дата>.toUTCString()` - то же самое, что `<дата>.toString()`, но дата в зоне UTC.  
`<дата>.toISOString()` - возвращает дату в формате ISO. Этот формат выглядит так: `YYYY-MM-DDTHH:mm:ss.sssZ`, где:
- `YYYY-MM-DD` - дата в формате год-месяц-день;
- обычный символ `T` используется как разделитель;
- `HH:mm:ss.sss` - время: часы-минуты-секунды-миллисекунды;
- часть `Z` обозначает временную зону - в формате `{+ | -}hh:mm`, либо символ `Z`, обозначающий UTC. По стандарту её можно не указывать, тогда UTC.  
Также возможны укороченные варианты, например `YYYY-MM-DD` или `YYYY-MM` или даже только `YYYY`.

`Date.parse('<дата_в_строке>')` - разбирает строку в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, возвращает `NaN`. Должна выглядеть в формате ISO.

`Date.now()` - возвращает дату сразу в виде миллисекунд.

## <a id="Тип-данных-Symbol-ES6" href="#Тип-данных-Symbol-ES6">Тип данных `Symbol` (ES6)</a>

Новый примитивный тип данных `Symbol` служит для создания уникальных идентификаторов. Синтаксис:  
`let <символ> = Symbol("<имя>");`

У символов есть и соответствующий `typeof`.

Каждый символ - уникален. У функции `Symbol` есть необязательный аргумент "имя символа". Символы с одинаковым именем не равны друг другу. Его можно использовать для описания символа, в целях отладки.

Существует "**глобальный реестр**" символов, который позволяет, при необходимости, иметь общие "глобальные" символы, которые можно получить из реестра по имени. Для чтения (или создания, при отсутствии) "глобального" символа служит вызов:  
`Symbol.for("<имя>")`

Таким образом, можно из разных частей программы, обратившись к реестру, получить единый глобальный символ с именем `"<имя>"`.

`Symbol.keyFor(<символ>)` - возвращает по глобальному символу его имя, работает только для глобальных символов, для остальных будет возвращено `undefined`.

Символы можно использовать в качестве имён для свойств объекта, при этом если в объект записать свойство-символ, то оно не участвует в итерации, к примеру в `for..in`. Кроме того, свойство-символ недоступно, если обратиться к его названию: `<переменная_класса>.<символ>` не существует, а доступно: `<переменная_класса>[<символ>]`.

В спецификации для краткости символы принято обозначать как `@@<имя>`, но доступны они как свойства `Symbol`.

Символы можно использовать для задания свойств, так как они:
- уникальны;
- не участвуют в циклах;
- заведомо не сломают старый код, который о них не знает.

`Object.getOwnPropertySymbols(<объект>)` - возвращает все символы объекта.

## <a id="Map-ES6" href="#Map-ES6">`Map` (ES6)</a>

`Map` - коллекция для хранения записей вида *ключ: значение*. В отличие от объектов, в которых ключами могут быть только строки, в `Map` ключом может быть произвольное значение.

`let <map> = new Map([<итерируемый_объект>]);` - создание [можно сразу инициализовать списком значений, должен быть итерируемый объект (не обязательно именно массив), например: `[[<ключ1>, <значение>][, [<ключ2>, <значение>][, ...]]]`. Везде утиная типизация, что позволяет сделать максимальную гибкость.]

Ключи и значения сохраняются "как есть", без преобразований типов.

В качестве ключей `Map` можно использовать и объекты. Для проверки значений на эквивалентность используется алгоритм **SameValueZero**. Он аналогичен строгому равенству `===`, отличие - в том, что `NaN` считается равным `NaN`. Поэтому значение `NaN` также может быть использовано в качестве ключа.

`<map>.set(<ключ>, <значение>)` - установка значения ключа, возвращает `<map>`.  
`<map>.get(<ключ>)` - получение значения по ключу, если ключа нет то `undefined`.  
`<map>.delete(<ключ>)` - удаляет запись с ключом, возвращает `true`, если такая запись была, иначе `false`.  
`<map>.clear()` - удаляет все записи, очищает коллекцию.  
`<map>.has(<ключ>)` - возвращает `true`, если ключ есть, иначе `false`.  
`<map>.keys()` - возвращает итерируемый объект для ключей.  
`<map>.values()` - возвращает итерируемый объект для значений.  
`<map>.entries()` - возвращает итерируемый объект для записей `[<ключ>, <значение>]`, он используется по умолчанию в `for..of`.  
`<map>.size` - свойство, которое хранит общее количество записей в `<map>`.

Перебор осуществляется в порядке вставки. Объекты `Map` гарантируют это, в отличие от обычных объектов `Object`.

`<map>.forEach(function (value, key, map) {...});` - вызовет функцию для каждого ключа в коллекции. Где:
- `value` - текущее перебираемое значение элемента коллекции;
- `key` - ключ текущего элемента коллекции;
- `map` - текущий объект `<map>`.

## <a id="Set-ES6" href="#Set-ES6">`Set` (ES6)</a>

`Set` - коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.

`let <set> = new Set([<итерируемый_объект>]);` - создание [можно сразу инициализовать списком значений, должен быть итерируемый объект (не обязательно именно массив).]

`<set>.add(<значение>)` - добавляет в коллекцию `<значение>`, возвращает `<set>`.  
`<set>.delete(<значение>)` - удаляет `<значение>` из коллекции, возвращает true, если он там был, иначе `false`.  
`<set>.has(<значение>)` - возвращает `true`, если `<значение>` есть в коллекции, иначе `false`.
`<set>.clear()` - очищает `<set>`.  
`<set>.size` - свойство, которое хранит общее количество записей в `<set>`.

Перебор `Set` осуществляется через `forEach` или `for..of` аналогично как `Map`.

`<set>.forEach(function (value, valueAgain, set) {...});` - вызовет функцию для каждого ключа в коллекции. Где:
- `value` - текущее перебираемое значение элемента множества;
- `valueAgain` - также текущее перебираемое значение элемента множества, для совместимости со всеми перебираемыми функциями;
- `set` - текущий объект `<set>`.

## <a id="WeakMap-WeakSet-ES6" href="#WeakMap-WeakSet-ES6">`WeakMap`, `WeakSet` (ES6)</a>

`WeakSet` - особый вид `Set` не препятствующий сборщику мусора удалять свои элементы. То же самое - `WeakMap` для `Map`. То есть, если некий объект присутствует только в `WeakSet`/`WeakMap` - он удаляется из памяти.

Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь можно хранить для них "вспомогательные" данные, существующие лишь пока жив объект.

Если поместить данные в `WeakMap`, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Таким образом, `WeakMap` избавляет нас от необходимости вручную удалять вспомогательные данные, когда удалён основной объект. У `WeakMap` есть ряд ограничений:
- нет свойства `size`;
- нельзя перебрать элементы итератором или `forEach`;
- нет метода `clear()`.

Иными словами, `WeakMap` работает только на запись (`set`, `delete`) и чтение (`get`, `has`) элементов по конкретному ключу, а не как полноценная коллекция. Нельзя вывести всё содержимое `WeakMap`, нет соответствующих методов. Это связано с тем, что содержимое `WeakMap` может быть модифицировано сборщиком мусора в любой момент, независимо от программиста.

То же самое относится и к `WeakSet`: можно добавлять элементы, проверять их наличие, но нельзя получить их список и даже узнать количество.

## <a id="Обещания-Promise-ES6" href="#Обещания-Promise-ES6">Обещания `Promise` (ES6)</a>

`Promise` ("*промисы*") - предоставляют удобный способ организации асинхронного кода. `Promise` - это специальный объект, который содержит своё состояние. Вначале **pending** ("*ожидание*"), затем - одно из: **fulfilled** ("*выполнено успешно*") или **rejected** ("*выполнено с ошибкой*").

На promise можно навешивать коллбэки двух типов:
- **onFulfilled** - срабатывают, когда промис в состоянии "*выполнен успешно*";
- **onRejected** - срабатывают, когда промис в состоянии "*выполнен с ошибкой*".

Способ использования, в общих чертах, такой:
1. Код, которому надо сделать что-то асинхронно, создаёт объект `Promise` и возвращает его.
2. Внешний код, получив промис, навешивает на него обработчики.
3. По завершении процесса асинхронный код переводит промис в состояние **fulfilled** (с результатом) или **rejected** (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис создания `Promise`:  
`let <promise> = new Promise(function (resolve, reject) {...});`

Функция в конструкторе будет вызвана автоматически, в ней можно делать любые асинхронные операции, а когда они завершатся - нужно вызвать одну из функций: `resolve(<результат>)` при успешном выполнении или `reject(<ошибка>)` при ошибке, они принимают только по одному параметру, последующие игнорируются и не передаются дальнейшим обрабатывающим методам.

`<promise>.then(<onFulfilled>[, <onRejected>])` - универсальный метод для навешивания обработчиков, где `<onFulfilled>` - функция вида `function (resolve) {...}`, которая будет вызвана с результатом при вызове`resolve` [, а `<onRejected>` - функция вида `function (reject) {...}`, которая будет вызвана с ошибкой при `reject`.] Возвращает новый промис.  
`<promise>.then(null, <onRejected>)` - только для ошибки.  
`<promise>.catch(<onRejected>)` - тоже самое, только для ошибки.

Если в момент прикрепления обработчика к промис уже "выполнено успешно" или "выполнено с ошибкой", он все равно будет выполнен, т.е. между выполнением обещания и прикреплением обработчика нет "состояния гонки".

Если в функции промиса происходит синхронный `throw` (или иная ошибка), то вызывается `reject` с этой ошибкой: `reject(<ошибка>)`.  
Промис после вызова одной из функций `resolve`/`reject` - неизменен, то есть когда промис переходит в состояние "выполнен" - с результатом (`resolve`) или ошибкой (`reject`) - это навсегда.

**Промисификация** - это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис. После промисификации использование функционала зачастую становится гораздо удобнее.

Возможно использование цепочки промисов, то есть "*чейнинг*" (*chaining*). При чейнинге, то есть последовательных вызовах `.then...then...then`, в каждый следующий `then` переходит результат от предыдущего, который он вернул через `return`.

Если очередной `then` вернул промис через `return`, то далее по цепочке будет передан не сам этот промис, а его результат. Если `then` возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать. Если внутри `then` стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, необходимо вернуть промис.

То есть, логика довольно проста:
- каждый `then` получает текущий результат работы;
- можно его обработать синхронно и вернуть результат. Или же, если нужна асинхронная обработка - инициировать её и вернуть промис.

При возникновении ошибки - она отправляется в ближайший обработчик `<onRejected>`. Такой обработчик нужно поставить через второй аргумент `.then` или через `.catch`. Обработчик `.catch` получает ошибку и должен обработать её. Есть два варианта развития событий:
- если ошибка не критичная, то возвращает значение через `return`, и управление переходит в ближайший `.then`;
- если продолжить выполнение с такой ошибкой нельзя, то он делает `throw`, и тогда ошибка переходит в следующий ближайший `.catch`.

Если в `.then`, один из обработчиков не указан, то добавляется его "от себя", следующим образом:
- для успешного выполнения - функция `Identity`, которая выглядит как `arg => return arg`, то есть возвращает аргумент без изменений;
- для ошибки - функция `Thrower`, которая выглядит как `arg => throw arg`, то есть генерирует ошибку.

Для того, чтобы результат обработчика передать следующей функции, `.then` создаёт новый промис и возвращает его.

`Promise.all(<итерируемый_объект>)` - получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние "выполнено" с массивом их результатов в порядке следования объявления промисов. Если какой-то из промисов завершился с ошибкой, то результатом `Promise.all` будет эта ошибка. При этом остальные промисы игнорируются.

`Promise.race(<итерируемый_объект>)` - как и `Promise.all`, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис. Но, в отличие от `Promise.all`, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.

`Promise.resolve(<результат>)` - создаёт успешно выполнившийся промис с результатом. Он аналогичен конструкции: `new Promise((resolve) => resolve(<результат>))`.
`Promise.resolve` используют, когда хотят построить асинхронную цепочку, и начальный результат.

`Promise.reject(<ошибка>)` - создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой.

Для последовательной асинхронной обработки массива, может использоваться такая конструкция:

```javascript
<массив>.reduce((promise, item) => {
    return promise.then(res => {
        return new Promise(function (resolve, reject) {...});
    });
}, Promise.resolve());
```

## <a id="Генераторы-ES6" href="#Генераторы-ES6">Генераторы (ES6)</a>

**Генераторы** - новый вид функций. Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени. Генератор это как "*замороженный вызов функции*".

Для объявления генератора используется новая синтаксическая конструкция: `function*`. Её называют "**функция-генератор**" (*generator function*).

```javascript
function* <функция_генератор>([<параметр1>[, ...]]) {
    yield <возвращаемое_значение1>;
    [yield <возвращаемое_значение2>;
    [...]]
    return <возвращаемое_значение>;
}
```

При запуске `<функция_генератор>([<аргумент1>[, ...]])` код такой функции не выполняется. Вместо этого она возвращает специальный объект, который называется "**генератором**":  
`let <генератор> = <функция_генератор>([<аргумент1>[, ...]]);`

Основным методом генератора является `<генератор>.next()`. При вызове он возобновляет выполнение кода до ближайшего ключевого слова `yield`. По достижении `yield` выполнение приостанавливается, а значение - `{value: <возвращаемое_значение1>, done: false}` возвращается во внешний код.

Повторный вызов `<генератор>.next()` возобновит выполнение и вернёт результат следующего `yield`, а последний вызов завершит выполнение функции и вернёт результат `return` - `{value: <возвращаемое_значение>, done: true}`. Новые вызовы `<генератор>.next()` больше не имеют смысла, они будут возвращать один и тот же объект: `{done: true}`.

"**Открутить назад***" завершившийся генератор нельзя, для этого создается новый.

Генератор является итерируемым объектом. Его можно перебирать и через `for..of`, при этом стандартный перебор итератора игнорирует `value` на последнем значении, при `done: true`. Так что результат `return` в цикле `for..of` не выводится, поэтому надо возвращать все значения через `yield`.

### <a id="Композиция" href="#Композиция">Композиция</a>

Один генератор может включать в себя другие. Это называется композицией.

Специальная форма `yield*`: `yield* <функция_вложеного_генератора>([<аргумент1>[, ...]])` - она применима только к другому генератору и делегирует ему выполнение. То есть, при `yield*` интерпретатор переходит внутрь генератора-аргумента, выполняет его, и все `yield`, которые он делает, выходят из внешнего генератора. Получается - как будто вставили код внутреннего генератора во внешний напрямую.

**Композиция** - это естественное встраивание одного генератора в поток другого. При композиции значения из вложенного генератора выдаются "по мере готовности". Поэтому она будет работать даже если поток данных из вложенного генератора оказался бесконечным или ожидает какого-либо условия для завершения.

### <a id="Передача-данных-в-генератор" href="#Передача-данных-в-генератор">Передача данных в генератор</a>

`yield` - дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор.

`let <переменная> = yield <значение>;` - делает следующее:
- возвращает `<значение>` во внешний код, приостанавливая выполнение генератора;
- внешний код может обработать значение, и затем вызвать `next` с аргументом: `<генератор>.next(<аргумент>)`;
- генератор продолжит выполнение, аргумент `<аргумент>` `next` будет возвращён как результат `yield` (и записан в `<переменная>`).

Для того, чтобы передать в `yield` ошибку, используется вызов:  
`<генератор>.throw(<ошибка>)`

При этом на строке с `yield` возникает исключение. Ошибка обрабатывается как обычно.

### <a id="Плоский-асинхронный-код" href="#Плоский-асинхронный-код">Плоский асинхронный код</a>

Одна из основных областей применения генераторов - написание "плоского" асинхронного кода. Общий принцип такой:
- генератор `yield`'ит не просто значения, а промисы;
- есть специальная "функция-чернорабочий" `execute(<generator>)` которая запускает генератор, последовательными вызовами `next` получает из него промисы - один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим `next`;
- последнее значение генератора (`done:true`) `execute` уже обрабатывает как окончательный результат - например, возвращает через промис куда-то ещё, во внешний код.

```javascript
function execute(generator, yieldValue) {
    let next = generator.next(yieldValue);
    if (!next.done) {
        next.value.then(
            result => execute(generator, result),
            err => generator.throw(err)
        );
    } else {
        <код_окончания_обработки_генератора>
    }
}
execute(<generator>());
```

### <a id="Асинхронное-выполнение-с-генераторами" href="#Асинхронное-выполнение-с-генераторами">Асинхронное выполнение с генераторами</a>

```javascript
function asyncFlow(generatorFunction) {
    function callback(err, ...results) {
        if (err) {
            return generator.throw(err);
        }
        generator.next(results.length> 1 ? results : results[0]);
    }
    const generator = generatorFunction(callback);
    generator.next();
}
```

Указаная функция принимает генератор, создает его экземпляр и сразу же запускает. Эта функция позаботится о возобновлении генератора после завершения асинхронной операции. Позволяет писать асинхронный код, применив линейный подход, который обычно используется для блокирующих функций. Функция обратного вызова, переданная в каждую асинхронную функцию, будет возобновлять работу генератора сразу после завершения асинхронной операции.

Генератор должен быть вида:

```javascript
function* (callback) {
    const <результат> = yield <асинхронная_функция>(<параметр>, callback);
    [...]
}
```

Для каждой асинхронной функции должен передаваться `callback` для обратного вызова, где в результат `<результат>` - запишется результат `callback`. В случае ошибки будет выброшено исключение.

Все последующие асинхронные функции нужно оформлять в виде представленой.

### <a id="Async--await-ES7" href="#Async--await-ES7">Async / await (ES7)</a>

Цель функций `async` / `await` упросить использование промисов синхронно и воспроизвести некторое действие над группой Promises. Точно так же как Promises подобны структурированным callback-ам, `async` / `await` подобна комбинации генераторов и промисов.

`async function <функция>([<параметр1>[, ...]]) {...}` - определяет асинхронную функцию. Возвращает промис `Promise` в который будет обернута функция. Когда результат был получен через `return`, `Promise` завершается, возвращая полученное значение. Когда функция `async` выбрасывает исключение, `Promise` ответит отказом с выброшенным (`throws`) значением.

Функция `async` может содержать выражение внутри своего тела `await <promise>`, которое приостанавливает выполнение функции `async` и ожидает ответа от переданного `Promise`, затем возобновляя выполнение функции `async` и возвращая полученное значение в случае успешного разрешения промиса или выбрасывает исключение в случае не успешного. Все `await` происходят линейно в порядке следования.

## <a id="Proxy-ES6" href="#Proxy-ES6">`Proxy` (ES6)</a>

**Прокси** (proxy) - особый объект, смысл которого - перехватывать обращения к другому объекту и, при необходимости, модифицировать их. Синтаксис:  
`let <прокси> = new Proxy(<объект>, <объект_с_ловушками>)` - где:
- `<объект>` - объект, обращения к которому надо перехватывать;
- `<объект_с_ловушками>` - объект с "ловушками": функциями-перехватчиками для операций к `<объект>`.

Почти любая операция может быть перехвачена и обработана прокси до или даже вместо доступа к объекту `<объект>`, например: чтение и запись свойств, получение списка свойств, вызов функции (если `<объект>` - функция) и т.п.

Если для операции нет ловушки, то она выполняется напрямую над `<объект>`'ом.

### <a id="Ловушки" href="#Ловушки">Ловушки</a>

Объявляются в объекте: `{}` как свойства-методы.

Виды ловушек:
`get(target, property, receiver) {...}` - срабатывает при чтении свойства из прокси. Может возвращать значение свойства. Аргументы:
- `target` - целевой объект, тот же который был передан первым аргументом в `new Proxy`;
- `property` - имя свойства;
- `receiver` - объект, к которому было применено присваивание. Обычно сам прокси, либо прототипно наследующий от него. Этот аргумент используется редко.

`set(target, property, value, receiver) {...}` - срабатывает при записи свойства в прокси. Дополнительные аргументы:
- `value` - значение свойства.

Метод `set` должен вернуть `true`, если присвоение успешно обработано и `false` в случае ошибки (приведёт к генерации `TypeError`).

При каждой операции чтения и записи свойств прокси срабатывают методы `get`/`set`. Через них значение в конечном счёте попадает в объект (или считывается из него), если это необходимо.

`has(target, property, receiver) {...} `- срабатывает в операторе `in` и некоторых других случаях, когда проверяется наличие свойства. Возвращает `true`, если есть свойство.

`deleteProperty(target, property, receiver) {...}` - срабатывает при операции `delete`, должен вернуть `true`, если удаление было успешным.

`enumerate(target) {...}` - перехватывает операции `for..in` и `for..of` по объекту и может вернуть итератор для перебора свойств.

`apply(target, thisArgument, argumentsList) {...}` - срабатывает когда вызывается функция. Работает только с функциями. Получает:
- `thisArgument` - контекст `this` вызова;
- `argumentsList` - аргументы вызова в виде массива.

Она может обработать вызов сама и/или передать его функции через `target.apply(thisArgument, argumentsList)`.

`construct(target, argumentsList) `- перехватывает вызовы при помощи `new`.

Остальные ловушки:
- `getPrototypeOf` - перехватывает обращение к методу `getPrototypeOf`;
- `setPrototypeOf` - перехватывает обращение к методу `setPrototypeOf`;
- `isExtensible` - перехватывает обращение к методу `isExtensible`;
- `preventExtensions` - перехватывает обращение к методу `preventExtensions`;
- `getOwnPropertyDescriptor` - перехватывает обращение к методу `getOwnPropertyDescriptor`;
- `defineProperty` - перехватывает обращение к методу `defineProperty`;
- `ownKeys` - перехватывает обращения к методу `getOwnPropertyNames`.

Каждый перехватчик запускается с `<объект_с_ловушками>` в качестве `this`. Это означает, что `<объект_с_ловушками>` кроме ловушек может содержать и другие полезные свойства и методы. Каждый перехватчик получает в аргументах `target` и дополнительные параметры в зависимости от типа. Если перехватчик в `<объект_с_ловушками>` не указан, то операция совершается, как если бы была вызвана прямо на `target`.

## <a id="Reflect-ES6" href="#Reflect-ES6">`Reflect` (ES6)</a>

Используется для работы с объектами.

`Reflect.apply(<функция>, <объект_вызова>, <массив_аргументов>);` - вызывает функцию с указанным контекстом в виде объекта вызова и указанными аргументами.

`Reflect.construct(<функция_конструктор>, <массив_аргументов>[, <функция_прототип>]);` - вызывает конструктор без использования оператора `new` с указанными аргументами [и указаным прототипом] и возвращает созданный объект.

## <a id="Итераторы-цикл-forof-ES6" href="#Итераторы-цикл-forof-ES6">Итераторы, цикл `for..of` (ES6)</a>

Итерируемые или, иными словами, "перебираемые" объекты - это те, содержимое которых можно перебрать в цикле. Перебираемым объектом является массив, строка. Для перебора таких объектов добавлен новый синтаксис цикла `for..of`:

```javascript
for (let <переменная> of <объект>) {
    <код_тела_итерации_цикла>
}
```

Где в `<переменная>` заносятся все итерируемые значения объекта (элементы массива, буквы строки).

Везде, где нужен перебор, он осуществляется через итераторы. Это включает в себя не только строки, массивы, но и вызов функции с оператором `spread` `f(...args)`, и многое другое. В отличие от массивов, "перебираемые" объекты могут не иметь "длины" `length`. Итераторы дают возможность сделать "перебираемыми" любые объекты.

Для возможности использовать объект в `for..of` нужно создать в нём свойство с названием `Symbol.iterator` (системный символ). При вызове метода `Symbol.iterator` перебираемый объект должен возвращать другой объект ("итератор"), который умеет осуществлять перебор.

Здесь имеет место разделение сущностей:
- перебираемый объект сам не реализует методы для своего перебора;
- для этого создаётся другой объект, который хранит текущее состояние перебора и возвращает значение. Этот объект называется **итератором** и возвращается при вызове метода `<объект>[Symbol.iterator]`;
- у итератора (объекта `{...}`) должен быть метод `next()`, который при каждом вызове возвращает объект со свойствами:
    - `value` - очередное значение;
    - `done` - равно `false` если есть ещё значения, и `true` - в конце.

Конструкция `for..of` в начале своего выполнения автоматически вызывает `Symbol.iterator()`, получает итератор и далее вызывает метод `next()` до получения `done: true`. Такова внутренняя механика. Внешний код при переборе через `for..of` видит только значения.

Такое отделение функционала перебора от самого объекта даёт дополнительную гибкость. Например, объект может возвращать разные итераторы в зависимости от своего состояния.

Если функционал по перебору (метод `next`) предоставляется самим объектом, то можно вернуть `this` в качестве итератора. При таком подходе сам объект и хранит состояние итерации (текущий перебираемый элемент).

Для большей гибкости и понятности кода рекомендуется выделять итератор в отдельный объект со своим состоянием и кодом.

```javascript
{
    [Symbol.iterator]() {
        return {
            next() {
                return {
                    done: <завершен>, //false - если есть ещё значения, иначе true
                    value: <значение>
                }
            }
        }
    }
}
```

Встроенные в JavaScript итераторы можно получить и явным образом, без `for..of`, прямым вызовом `Symbol.iterator`:  
`let <итератор>= <объект>[Symbol.iterator]();`

## <a id="Замыкания-область-видимости" href="#Замыкания-область-видимости">Замыкания, область видимости</a>

### <a id="Глобальный-объект" href="#Глобальный-объект">Глобальный объект</a>

**Глобальными** называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции `function`, то они - "**глобальные**". В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется "**глобальный объект**" (global object). В браузере этот объект явно доступен под именем `window`.

### <a id="Лексическое-окружение" href="#Лексическое-окружение">Лексическое окружение</a>

Все переменные внутри функции - это свойства специального внутреннего объекта **LexicalEnvironment**, который создаётся при её запуске, это объект "**лексическое окружение**" или просто "**объект переменных**". При запуске функция создает объект **LexicalEnvironment**, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения. В отличие от `window`, объект **LexicalEnvironment** является внутренним, он скрыт от прямого доступа.

Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем **LexicalEnvironment**, а затем, если её нет - ищет во внешнем объекте переменных.

Такой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется `[[Scope]]`. Это свойство закрыто от прямого доступа. При создании функция получает скрытое свойство `[[Scope]]`, которое ссылается на лексическое окружение, в котором она была создана. Это свойство никогда не меняется. Оно всюду следует за функцией, привязывая её, таким образом, к месту своего рождения.

Переменную во внешней области видимости можно не только читать, но и изменять.

**Замыкание** - это функция вместе со всеми внешними переменными, которые ей доступны.

Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней. Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это - использование функции "*как функции*". А свойство у функции - доступно отовсюду и всегда. Это - использование функции "*как объекта*". Если хочется привязать значение к функции, то можно им воспользоваться вместо внешних переменных. Принципиальная разница - во внутренней механике и в том, что свойство функции, в отличие от переменной из замыкания - общедоступно, к нему имеет доступ любой, у кого есть объект функции. Свойства, привязанные к функции, называют "статическими переменными".

При создании функции с использованием `new Function`, её свойство `[[Scope]]` ссылается не на текущий **LexicalEnvironment**, а на `window`.

### <a id="Модули-через-замыкания" href="#Модули-через-замыкания">Модули через замыкания</a>

Его цель - скрыть внутренние детали реализации скрипта. В том числе: временные переменные, константы, вспомогательные мини-функции и т.п. для этого нужно, чтобы у скрипта была своя собственная область видимости, чтобы его переменные не попали на страницу. Для этого оборачивают всё его содержимое в функцию, которую тут же запускают:

```javascript
(function () {
    <код_модуля>
})();
```

Внутри этой внешней функции: происходит что угодно, объявляются свои локальные переменные, функции, а в `window` выносится то, что нужно снаружи.

Можно оформить модуль и чуть по-другому, например передать значение через `return`.

### <a id="Устаревшая-конструкция-with" href="#Устаревшая-конструкция-with">Устаревшая конструкция `with`</a>

Конструкция `with(<объект>) {...}` использует `<объект>` как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в `<объект>`. Конструкция `with` устарела и не рекомендуется по ряду причин, её необходимо избегать.

## <a id="Методы-объектов-и-контекст-вызова" href="#Методы-объектов-и-контекст-вызова">Методы объектов и контекст вызова</a>

### <a id="Методы-объектов-this" href="#Методы-объектов-this">Методы объектов, `this`</a>

**Свойства-функции** называют "**методами**" объектов. Их можно добавлять и удалять в любой момент, в том числе и явным присваиванием.

Для полноценной работы метод должен иметь доступ к данным объекта. Для доступа к текущему объекту из метода используется ключевое слово `this`. Значением `this` является объект перед "точкой" `.`, в контексте которого вызван метод: `this.<свойство_метод>`.

При вызове `this` в методе объекта, оно ссылается на сам объект.

Через `this` метод может не только обратиться к любому свойству объекта, но и передать куда-то ссылку на сам объект целиком.

Любая функция может иметь в себе `this`. Совершенно неважно, объявлена ли она в объекте или отдельно от него. Значение `this` называется контекстом вызова и **будет определено в момент вызова функции**. Это выяснится при выполнении программы. Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный `this`, значение `this` не зависит от того, как функция была создана, оно определяется исключительно в момент вызова.

Контекст `this` никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы `this` передался, нужно вызвать функцию именно через точку `.` (или квадратные скобки `[]`).

Любой объект в логическом контексте - `true`, даже если это пустой массив `[]` или объект `{}`.

Если в объекте присутствует метод `toString`, который возвращает примитив, то он используется для строкового преобразования.

Для численного преобразования объекта используется метод `valueOf`, а если его нет - то `toString`. Метод `valueOf` обязан возвращать примитивное значение, иначе его результат будет проигнорирован. При этом - не обязательно числовое.

Если создаётся объект при помощи синтаксиса `{...}`, то задать свойства-функции можно прямо в его определении. Для этого используется особый синтаксис: `get <свойство>()` или `set <свойство>(newValue)`.

#### <a id="Методы-объекта-ES6-HomeObject" href="#Методы-объекта-ES6-HomeObject">Методы объекта (ES6) `[[HomeObject]]`</a>

Являются свойствами-функциями, привязанными к объекту. Их особенности:
- более короткий синтаксис объявления;
- наличие в методах специального внутреннего свойства `[[HomeObject]]` ("**домашний объект**"), ссылающегося на объект, которому метод принадлежит.

Для объявления метода вместо записи `<свойство>: function (<параметр1>[, ...]) {...}` нужно написать просто `<свойство>(<параметр1>[, ...]) {...}`.

Также методами станут объявления геттеров `get <свойство>()` и сеттеров `set <свойство>(newValue)`.

Можно задать и метод с вычисляемым названием.

Вызов `super.<родительское_свойство>` позволяет из метода объекта получить свойство его прототипа. При обращении через `super` используется `[[HomeObject]]` текущего метода, и от него берётся `__proto__`. Поэтому `super` работает только внутри методов.

Свойство `[[HomeObject]]` - не изменяемое. При создании метода - он привязан к своему объекту навсегда. Технически можно скопировать его и запустить отдельно, и `super` продолжит работать.

### <a id="Создание-объектов-через-new" href="#Создание-объектов-через-new">Создание объектов через `new`</a>

Конструктором становится любая функция, вызванная через `new`.

Функция, запущенная через `new`, делает следующее:
1. Создаётся новый пустой объект `{}`;
2. Ключевое слово `this` получает ссылку на этот объект;
3. Функция выполняется. Как правило, она модифицирует `this`, добавляет методы, свойства;
4. Возвращается `this`.

`new <FunctionConstructor>([<арг1>[, ...]])` - создание объекта через функцию конструктор.  
`new <FunctionConstructor>` - аналогично предыдущему варианту, с пустым конструктором.

Иногда функцию-конструктор объявляют и тут же используют:  
`new function () {...}`

Так делают, когда хотят создать единственный объект данного типа, когда обычный синтаксис `{...}` не подходит, когда при создании свойств объекта нужны более сложные вычисления. Их можно проделать в функции-конструкторе и записать результат в `this`.

Если явный вызов `return` всё же есть, то применяется простое правило: при вызове `return` с объектом, будет возвращён он, а не `this`, а при вызове `return` с примитивным значением, оно будет отброшено.

### <a id="Дескриптор" href="#Дескриптор">Дескриптор</a>

`Object.defineProperty(<объект>, "<свойство_объекта>", <дескриптор>)` - позволяет объявить свойство для объекта `<объект>` и настроить его особые аспекты, которые никак иначе не изменить, возвращает переданный `<объект>`. Где `<дескриптор>` - это дескриптор, в виде объекта, который описывает поведение свойства. В нём могут быть следующие поля:
- `value` - значение свойства, по умолчанию `undefined`;
- `writable` - значение свойства можно менять, если `true`. По умолчанию `false`;
- `configurable` - если `true`, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов `defineProperty`. По умолчанию `false`;
- `enumerable` - если `true`, то свойство просматривается в цикле `for..in` и методе `Object.keys()`. По умолчанию `false`;
- `get` - функция, которая возвращает значение свойства. По умолчанию `undefined`;
- `set` - функция, которая записывает значение свойства. По умолчанию `undefined`.

Чтобы избежать конфликта, запрещено одновременно указывать значение `value` и функции `get`/`set`. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать `writable` при наличии `get`/`set`-функций.

`Object.defineProperties(<объект>, {<свойство1>: <дескриптор>[, ...]})` - позволяет объявить несколько свойств сразу, возвращает переданный `<объект>`.  
`Object.getOwnPropertyNames(<объект>)` - возвращает массив - список всех свойств объекта.  
`Object.getOwnPropertyDescriptor(<объект>, "<свойство_объекта>")` - возвращает дескриптор для свойства `<объект>["<свойство_объекта>"]`. Полученный дескриптор можно изменить и использовать `Object.defineProperty` для сохранения изменений.  
`Object.preventExtensions(<объект>)` - запрещает добавление свойств в объект.  
`Object.seal(<объект>)` - запрещает добавление и удаление свойств, все текущие свойства делает configurable: `false`, возвращает переданный `<объект>`.
`Object.freeze(<объект>)` - запрещает добавление, удаление и изменение свойств, все текущие свойства делает `configurable`: `false`, `writable`: `false`, возвращает переданный `<объект>`.  
`Object.isExtensible(<объект>)`, `Object.isSealed(<объект>)`, `Object.isFrozen(<объект>)` - возвращают `true`, если на объекте были вызваны методы `Object.preventExtensions`/`seal`/`freeze`.

`Object.keys(<объект>)` - возвращает массив - список свойств объекта, только `enumerable`-свойства.

`Object.assign(<целевой_объект>, <объект1>[, ...])` - (ES6) получает список объектов и копирует в первый `<целевой_объект>` свойства из остальных. При этом последующие свойства перезаписывают предыдущие.  
`Object.is(<значение1>, <значение2>)` - (ES6) возвращает `true`, если значения `<значение1>` и `<значение2>` равны, иначе `false`.

### <a id="Статические-и-фабричные-методы" href="#Статические-и-фабричные-методы">Статические и фабричные методы</a>

Методы и свойства, которые не привязаны к конкретному экземпляру объекта, называют "статическими". Их записывают прямо в саму функцию-конструктор.

`<Функция>.<метод_свойство> = <значение>`

Статический метод также можно использовать для функций, которые вообще не требуют наличия объекта.
"**Фабричный статический метод**" - удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется "фабричным"). Преимущества использования фабричных методов:
- лучшая читаемость кода;
- лучший контроль ошибок;
- удобная расширяемость.

### <a id="Вызовы-функций" href="#Вызовы-функций">Вызовы функций</a>

`<функция>.call(<this_контекст>[, <аргумент_функции1>[, ...]])` - вызывается функция, при этом первый аргумент `call` `<this_контекст>` становится её `this`, а остальные передаются "как есть" для функции.  
При помощи `call` можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого. Это называется "**одалживание метода**" (на англ. method *borrowing*).

`<функция>.apply(<this_контекст>[, <массив_аргументов_функции>])` - работает аналогично `<функция>.call`, но принимает массив аргументов вместо списка.

`<функция>.bind(<this_контекст>[, <аргумент_функции1>[, ...]])` - вернет функцию-обёртку, которая фиксирует контекст и передает вызовы в `<функция>`, при этом если указаны аргументы - они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове.

`<функция>.name` - содержит имя функции, (ES6) а при создании анонимной функции с одновременной записью в переменную или свойство - её имя равно названию переменной (или свойства).  
`<функция>.length` - содержит количество аргументов, ожидаемых функцией.  
`<функция>.caller` - возвращает функцию, которая вызвала указанную функцию, будет равно `null` если функция была вызвана из кода самого верхнего уровня.

**Карринг** (*currying*) или **каррирование** - термин функционального программирования, который означает создание новой функции путём фиксирования аргументов существующей. Тогда новая функция является "**частичной функцией**" (*partial function*) от указаной.

**Декоратор** - приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение. Декоратор получает функцию и возвращает обертку, которая делает что-то своё "вокруг" вызова основной функции.

"**Форвардинг вызова**" (от англ. *forwarding*): текущий контекст и аргументы через `apply` передаются в указанную функцию, так что изнутри указанная функция всё выглядит так, как была вызвана она напрямую, а не декоратор.

Декораторы можно не только повторно использовать, но и комбинировать.

## <a id="Некоторые-другие-возможности-instanceof" href="#Некоторые-другие-возможности-instanceof">Некоторые другие возможности, `instanceof`</a>

Во всех встроенных объектах есть специальное свойство `[[Class]]`, в котором хранится информация о его типе или конструкторе, это свойство - внутреннее. Явно получить его нельзя, но можно прочитать его "в обход", воспользовавшись методом `toString` стандартного объекта `Object`. Для получения `[[Class]]` нужна именно внутренняя реализация `toString` стандартного объекта `Object`, другая не подойдёт.  
`{}.toString.call(<объект>)` - возвращает `"[object <тип_объекта>]"`.

Свойство `[[Class]]` есть и доступно для чтения указанным способом - у всех встроенных объектов. Но его нет у объектов, которые создают функции, точнее, оно есть, но равно всегда `"Object"`.

Оператор `instanceof` позволяет проверить, создан ли объект данной функцией, причём работает для любых функций - как встроенных, так и собственных.

`<объект> instanceof <Функция>` - возвращает `true` только если `<объект>` создан указанной функцией `<Функция>`, сравнивает конструкторы двух операндов.

### <a id="Формат-JSON" href="#Формат-JSON">Формат JSON</a>

Данные в формате JSON (RFC 4627) представляют собой:
- JavaScript-объекты `{...}`;
- массивы `[...]`;
- значения одного из типов:
    - строки в двойных кавычках;
    - число;
    - логическое значение `true`/`false`;
    - `null`.

`JSON.parse(<строка>[, function (key, value) {...}])` - превратит строку с данными в формате JSON в JavaScript-объект/массив/значение и возвратит его [, при этом в процессе чтения объекта из строки `JSON.parse` передаёт функции по очереди все создаваемые пары ключ-значение и может возвратить либо преобразованное значение, либо `undefined`, если его нужно пропустить].

`JSON.stringify(<значение>[, <массив_серриализуемых_свойств> | function (key, value) {...}[, <кол_пробелов_вложености>]])` - преобразует ("сериализует") значение в JSON-строку и возвращает ее [при этом указывается массив свойств, которые подлежат сериализации или функция которая возвращает сериализованное `value` либо `undefined`, если его не нужно включать в результат [, при этом уровни вложенности в JSON оформляются указанным количеством пробелов, если строкой - вставляется эта строка]].

При сериализации объекта вызывается его метод `toJSON`. Если такого метода нет - перечисляются его свойства, кроме функций.

### <a id="Внутренние-таймеры-планировщики" href="#Внутренние-таймеры-планировщики">Внутренние таймеры-планировщики</a>

`var <timerId> = setTimeout(<функция>, <задержка_мс>[, <аргумент_для_функции1>[, ...]])` - исполнение `<функция>` произойдёт спустя время, указанное в `<задержка_мс>`, возвращает числовой идентификатор таймера `<timerId>`, который можно использовать для отмены действия.

`clearTimeout(<timerId>)` - отменяет исполнение таймера.

`var <timer> = setInterval(<функция>, <задержка_мс>[, <аргумент_для_функции1>[, ...]])` - исполнение `<функция>` произойдёт спустя время, указанное в `<задержка_мс>`, а затем будет повторятся через каждые `<задержка_мс>`, возвращает числовой идентификатор таймера `<timerId>`, который можно использовать для отмены действия.

`clearInterval(<timerId>)` - отменяет исполнение интервала.

Важная альтернатива `setInterval` - рекурсивный `setTimeout`. Рекурсивный `setTimeout` гарантирует паузу между вызовами, `setInterval` - нет. Если функция и выполняется дольше, чем пауза `setInterval`, то вызовы будут происходить вообще без перерыва.

По стандарту, минимальная задержка составляет **4мс**, на частоту **4мс** стоит ориентироваться, но не стоит рассчитывать.

### <a id="Eval" href="#Eval">Eval</a>

`eval('<код>')` - позволяет выполнить код, переданный ей в виде строки, этот код будет выполнен в текущей области видимости, возвращает последнее вычисленное выражение. При вызове `eval` имеет полный доступ к локальным переменным.

### <a id="Base64" href="#Base64">Base64</a>

Используется там где необходимо кодировать двоичные данные для удобства включения в URL, скрытые поля форм.

`btoa('<строка>');` - возвращает строку в виде Base64, в которой закодирована указанная строка.  
`atob('<строка_в_формате_Base64>');` - возвращает строку, в которой указанная строка в виде Base64 раскодирована.

### <a id="Кодирование-URI" href="#Кодирование-URI">Кодирование URI</a>

Все символы для кодирования, кроме английских букв, цифр и `; , / ? : @ & = + $ - _ . ! ~ * ' ( ) #` заменяются на их цифровой код в `UTF-8` со знаком `%`.

`encodeURI('<строка>')` - возвращает указанную строку в виде URI кодировке.  
`decodeURI('<uri_строка>')` - возвращает раскодированную указанную строку в URI кодировке.

### <a id="Кодировка-urlencoded" href="#Кодировка-urlencoded">Кодировка `urlencoded`</a>

Все символы для кодировки `urlencoded`, кроме английских букв, цифр и `- _ . ! ~ * ' ( )` заменяются на их цифровой код в `UTF-8` со знаком `%`.

`encodeURIComponent('<строка>')` - возвращает указанную строку в виде `urlencoded` кодировке.  
`decodeURIComponent('<uri_строка>')` - возвращает раскодированную указанную строку в `urlencoded` кодировке.

## <a id="Перехват-ошибок-Error" href="#Перехват-ошибок-Error">Перехват ошибок. `Error`</a>

```javascript
try {
    <код>
} catch (err) {
    <код_для_обработки_ошибки>
}[ finally {
    <код_для_выполнения_всегда>
}]
```

Работает так:
1. Выполняется код внутри блока `try`;
2. Если в нём ошибок нет, то блок `catch(err)` игнорируется, то есть выполнение доходит до конца `try` и потом прыгает через `catch`.
3. Если в нём возникнет ошибка, то выполнение `try` на ней прерывается, и управление прыгает в начало блока `catch(err)`.
4. [Выполняется всегда секция `finally`.]

Таким образом, при ошибке в `try` скрипт не "падает", а получает возможность обработать ошибку внутри `catch`.  
`try..catch` подразумевает, что код синтаксически верен.  
`try..catch` работает только в синхронном коде.

### <a id="Объект-ошибки" href="#Объект-ошибки">Объект ошибки</a>

У него есть три основных свойства:
- `name` - тип ошибки;
- `message` - текстовое сообщение о деталях ошибки;
- `stack` - содержит строку с информацией о последовательности вызовов, которая привела к ошибке.

`throw <объект_ошибки>` - генерирует ошибку. В качестве конструктора ошибок можно использовать встроенный конструктор:
- `new Error('<сообщение>')` - для общей ошибки;
- `new RangeError('<сообщение>')` - для ошибки, возникающей, когда значение не входит в множество или выходит за диапазон допустимых значений;
- `new TypeError('<сообщение>')` - для ошибки, возникающей при недопустимом типе для переменной или параметра;
- `new ReferenceError('<сообщение>')` - для ошибки, возникающую при разыменовывании недопустимой ссылки;
и т.п.

Ошибку, о которой `catch` не знает, он не должен обрабатывать. Такая техника называется "**проброс исключения**": в `catch(err)` анализируется объект ошибки, и если он не подходит для обработки, то она пробрасывается с помощью `throw err` внутри блока `catch`.

Важнейший общий подход к проектированию - каждый участок функционала должен получать информацию на том уровне, который ему необходим. Этот подход называют "**оборачиванием**" исключения, поскольку берется ошибка "**более низкого уровня**" и "**заворачивается**" их в новую ошибку, которая соответствует текущей задаче.

Секцию `finally` используют, чтобы завершить начатые операции при любом варианте развития событий. Блок `finally` срабатывает при любом выходе из `try..catch`, в том числе и `return`. Возможно использование `try..finally` вообще без `catch`.

## <a id="ООП-в-функциональном-стиле" href="#ООП-в-функциональном-стиле">ООП в функциональном стиле</a>

### <a id="Классы" href="#Классы">Классы</a>

Классом в *объектно-ориентированной* разработке называют шаблон/программный код, предназначенный для создания объектов и методов.

Один из важнейших принципов ООП - отделение внутреннего интерфейса от внешнего.

**Внутренний интерфейс** - это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют "**приватными**". Внутренний интерфейс используется для обеспечения работоспособности объекта, его детали используют друг друга.

**Внешний интерфейс** - это свойства и методы, доступные снаружи объекта, их называют "**публичными**".

Локальные переменные, включая параметры конструктора, можно считать приватными свойствами. Свойства, записанные в `this`, можно считать публичными. Тоже самое относится а методам.

Сохранение `this` в замыкании - состоит в том, чтобы предварительно скопировать `this` во вспомогательную переменную например `self` и обращаться из внутренних функций уже к ней, чтобы это работало, не нужно изменять `self`, а все приватные методы, которым нужно иметь доступ к текущему объекту, должны использовать внутри себя `self` вместо `this`.

В терминологии ООП отделение и защита внутреннего интерфейса называется **инкапсуляция**.

### <a id="Геттеры-и-сеттеры" href="#Геттеры-и-сеттеры">"Геттеры" и "сеттеры"</a>

Для управляемого доступа к состоянию объекта используют специальные функции, так называемые "геттеры" и "сеттеры". Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод, который называют "**сеттер**" (*setter method*). А для того, чтобы дать возможность внешнему коду узнать его значение, создадим специальную функцию - "**геттер**" (*getter method*).

Для большего удобства иногда делают единый метод, который называется так же, как свойство и отвечает и за запись и за чтение. При вызове без параметров такой метод возвращает свойство, а при передаче параметра - назначает его.

### <a id="Наследование" href="#Наследование">Наследование</a>

**Наследование** - это создание новых "классов" на основе существующих.

Наследование реализовано вызовом `<Предок_Родитель>.call(this)` в начале конструктора `<Наследник>` или через `<Предок_Родитель>.apply(this)`. Наследник не имеет доступа к приватным свойствам родителя, чтобы наследник имел доступ к свойству, оно должно быть записано в `this`.

Подчёркивание в начале свойства `_` - общепринятый знак, что свойство является внутренним, предназначенным лишь для доступа из самого объекта и его наследников. Такие свойства называют защищёнными.

Общая схема переопределения метода:
1. Копируется доставшийся от родителя метод в переменную `<переменная_с_методом_родителя>`;
2. Заменяется `this.<метод_родителя>` на свою функцию;
3. Метод родителя по-прежнему реализует старый функционал и его можно использовать через вызов `<переменная_с_методом_родителя>.call(this)` или `apply`, или через `<переменная_с_методом_родителя>()` если метод не использует `this`.

## <a id="ООП-в-прототипном-стиле" href="#ООП-в-прототипном-стиле">ООП в прототипном стиле</a>

Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом.

### <a id="Специальное-свойство-proto" href="#Специальное-свойство-proto">Специальное свойство `__proto__`</a>

Если один объект имеет специальную ссылку `__proto__` на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте `__proto__`.

Объект, на который указывает ссылка `__proto__`, называется "**прототипом**". Тогда говорят что указанный объект "**прототипно наследует**" объект.

Прототип используется исключительно при чтении.

**Прототип** - если другими словами, это "**резервное хранилище свойств и методов**" объекта, автоматически используемое при поиске. У объекта, который является `__proto__`, может быть свой `__proto__`, у того - свой, и так далее. При этом свойства будут искаться по цепочке.

`<объект>.hasOwnProperty('<свойство>')` - возвращает `true`, если свойство принадлежит самому объекту, иначе `false`.

`Object.create(null)` - возвращает объект, который не имеет прототипа, а значит в нём нет лишних свойств, удобен для коллекции.  
`Object.getPrototypeOf(<объект>)` - возвращает `<объект>.__proto__`.  
`Object.setPrototypeOf(<объект>, <прототип>)` - устанавливает `<объект>.__proto__ = <прототип>`.  
`Object.create(<прототип>[, <дескрипторы_свойств>])` - создаёт и возвращает пустой объект с `__proto__`, равным первому аргументу `<прототип>`, второй необязательный аргумент может содержать дескрипторы свойств. Если передать в качестве `<прототип>` произвольный объект, то он станет прототипом созданого объекта.

Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство `prototype`. При создании объекта через `new`, в его прототип `__proto__` записывается ссылка из `prototype` функции-конструктора. Свойство `prototype` имеет смысл только у конструктора. Значением `prototype` может быть только объект.

Свойство `prototype.constructor` содержит ссылку на конструктор объекта. JavaScript никак не использует свойство `constructor`, оно создаётся автоматически и указывает на функцию, которая приведет к созданию объекта.

Объект `Object.prototype` - вершина иерархии, единственный, у которого `__proto__` равно `null`. Поэтому говорят, что "**все объекты наследуют от Object**", а если более точно, то от `Object.prototype`.

### <a id="Псевдокласс" href="#Псевдокласс">"Псевдокласс"</a>

"**Псевдоклассом**" или, более коротко, "**классом**", называют функцию-конструктор вместе с её `prototype`. Такой способ объявления классов называют "**прототипным стилем ООП**".

Примитивы не являются объектами, но методы берут из соответствующих прототипов: `Number.prototype`, `Boolean.prototype`, `String.prototype`.

По стандарту, если обратиться к свойству числа, строки или логического значения, то будет создан объект соответствующего типа, например `new String` для строки, `new Number` для чисел, `new Boolean` - для логических выражений.

Значения `null` и `undefined` не имеют свойств.

Чтобы объявить свой класс на прототипах, нужно:
1. Объявить функцию-конструктор.
2. Записать методы и свойства, нужные всем объектам класса, в `prototype`.

Локальные переменные внутри методов доступны также через `this`.

**Достоинства** - функциональный стиль записывает в каждый объект и свойства и методы, а прототипный - только свойства. Поэтому прототипный стиль - быстрее и экономнее по памяти.

**Недостатки** - при создании методов через прототип, теряется возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором.

### <a id="Наследование" href="#Наследование">Наследование</a>

`<Наследник>.prototype = Object.create(<Родитель>.prototype)` - наследование через прототипы, наследник также должен быть объявлен как функция-конструктор.

Конструктор реализуется `<Предок_Родитель>.call(this[, <аргумент>[, ...]])` в начале конструктора `<Наследник>` или через `<Предок_Родитель>.apply(this[, arguments])`.

Методы переопределяются на уровне прототипов `<Наследник>.prototype.<метод>`.

Метод родителя по-прежнему реализует старый функционал и его можно использовать через вызов:
`<Предок_Родитель>.prototype.<метод_родителя>.call(this[, arguments])` или `apply`.

```javascript
function Auto(name) {
    this.name = name;
    this.countOfWheels = 10;
}
Auto.prototype.getName = function () {
    return this.name;
};
Auto.prototype.wheels = function () {
    return this.countOfWheels;
};
function Car() {
    Auto.call(this, 'Car');
    this.countOfWheels = 4;
}
Car.prototype = Object.create(Auto.prototype);
Car.prototype.getName = function () {
    return 'Super ' + Auto.prototype.getName.call(this);
};
```

Базовая реализация, но у этого подхода **важный недостаток** он создает родителя, а не только унаследует его методы:  
`Наследник>.prototype = new <Родитель>();`  
`Наследник>.prototype = <объект>;`

## <a id="Классы-ES6" href="#Классы-ES6">Классы (ES6)</a>

Реализует удобное ООП. В целом это обвертка над "ООП в прототипном стиле". Синтаксис для классов выглядит так:

```javascript
class <Класс>[extends <Родитель>] {
    [constructor(...) {...}]
    <методы>
}
```

Функция `constructor` запускается при создании `new <Класс>`, остальные методы записываются в `<Класс>.prototype`. В конструкторе объявляются переменные как `this.<переменная>`, как и в функции.

Но при объявлении через `class` есть и ряд отличий:
- класс нельзя вызывать без `new`, будет ошибка;
- объявление класса с точки зрения области видимости ведёт себя как `let`. В частности, оно видно только в текущем блоке и только в коде, который находится ниже объявления (Function Declaration видно и до объявления).

Методы, объявленные внутри `class`, также имеют ряд особенностей:
- методы является именно методами, то есть имеет доступ к `super`;
- все методы класса работают в строгом режиме `use strict`, даже если он не указан;
- все методы класса не перечислимы. То есть в цикле `for..in` по объекту их не будет.

Метод может быть:
- простой функцией: `<метод>(...) {...}`;
- генератором: `* <метод>(...) {...}`;
- асинхронной функцией: `async <метод>(...) {...}`;
- функцией с вычисляемым именем: `['<имя>'](...) {...}` или  `[<символ>](...) {...}`.

Также, как и **Function Expression**, классы можно задавать "инлайн", в любом выражении и внутри вызова функции - это называется **Class Expression**. Имя такому классу можно дать, тогда оно, как и в **Named Function Expression**, будет доступно только внутри класса. Наиболее очевидная область применения этой возможности - создание вспомогательного класса прямо при вызове функции.

В классах, как и в обычных объектах, можно объявлять геттеры и сеттеры через `get`/`set`, а также использовать [...] для свойств с вычисляемыми именами.

`class` не позволяет задавать свойства-значения в описании класса, если это необходимо то можно воспользоваться после объявления класса:  
`<Класс>.prototype.<свойство> = <значение>;`

Если свойство-значение, всё же, необходимо, то можно создать геттер, который будет нужное значение возвращать.

Все свойства и методы класса технически доступны снаружи.

### <a id="Приватные-свойства" href="#Приватные-свойства">Приватные свойства</a>

Реализуются с помощью замыкания на определенной `WeakMap` и записи в нее приватных свойств, тогда они будут доступны только внутри этого класса.

```javascript
const pr = new WeakMap(); // хранилище всех приватных свойств
class <Class> {
    constructor() {
        pr.set(this, {
            <key>: <value>[,
            ...]
        });
    }
    <method>() {
        pr.get(this).<key>;
    }
}
```

### <a id="Статические-свойства" href="#Статические-свойства">Статические свойства</a>

Класс, как и функция, является объектом. Статические свойства класса - это свойства непосредственно, то есть доступные из него "через точку".

Для их объявления используется ключевое слово `static` перед методами. Чтобы вызвать статический метод в другом статическом методе того же класса, можно использовать ключевое слово `this`. Вызов статических методов внутри методов класса:
- `<Класс>.<статический_метод>()`;
- `this.constructor.<статический_метод>()`.

Внутри статических методов `this` ссылается на класс `<Class>`.

Внутри переопределенных статических методов можно вызывать статические методы родителя с помощью конструкции: `super.<статический_метод>()`.

### <a id="Наследование" href="#Наследование">Наследование</a>

При наследовании через `extends` формируется стандартная цепочка прототипов: методы `<Наследник>` находятся в `<Наследник>.prototype`, методы `<Родитель>` - в `<Родитель>.prototype`, и они связаны через `__proto__`. И в `<Наследник>` доступны (через `super`) методы родителя.

Конструктор `constructor` родителя наследуется автоматически. То есть, если в потомке не указан свой `constructor`, то используется родительский. Если же у потомка свой `constructor`, то, чтобы в нём вызвать конструктор родителя - используется синтаксис `super()` с аргументами для родителя. Для такого вызова есть небольшие ограничения:
- вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, `super()` нельзя вызвать из произвольного метода;
- в конструкторе потомка обязано вызвать `super()` до обращения к `this`. До вызова `super()` не существует `this`, так как по спецификации в этом случае именно `super()` инициализирует `this`.

> `constructor(...) {super(...); ...}`

## <a id="Примесь" href="#Примесь">Примесь</a>

**Примесь** (англ. *mixin*) - класс или объект, реализующий какое-либо чётко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования.

Самый простой вариант примеси - это объект с полезными методами, которые просто копируется в нужный прототип.

Для добавления примеси в класс - её просто "подмешивают" в прототип:

```javascript
for (var key in <примесь>) {
  <объект>.prototype[key] = <примесь>[key];
}
```

"*Подмешать*" можно сколько угодно примесей, но если имена методов в разных примесях совпадают, то возможны конфликты.

## <a id="Модули-ES6" href="#Модули-ES6">Модули (ES6)</a>

Модули предоставляют удобные средства для разбития кода по функциональным блокам в разных файлах. Модулем считается файл с кодом.

В этом файле ключевым словом `export` помечаются переменные и функции, которые могут быть использованы снаружи.

Ключевое слово `export` можно ставить:
- перед объявлением переменных, функций и классов: `export <экспорт>`;
- отдельно, при этом в фигурных скобках указывается, что именно экспортируется: `export {<экспорт1>[ as <экспортируемое_имя>][, ...]}`.

Для экспорта обязательно нужно имя.

Когда один модуль экспортирует одно значение, предусмотрено особое ключевое сочетание `export default`. Если поставить после `export` слово `default`, то значение станет "экспортом по умолчанию". Такое значение можно импортировать без фигурных скобок.

Другие модули могут подключать экспортированные значения при помощи ключевого слова `import`:  
`import [<имя_экспорта_по_умолчанию>, ]{* as <импортируемое_имя> | {<импорт1>[ as <импортируемое_имя>][, ...]}} from "<путь_к_модулю>";`
> `import React, {Component} from 'react';`

<a id="Регулярные-выражения" href="#Регулярные-выражения">Регулярные выражения</a>
====================

**Регулярные выражения** - мощное средство поиска и замены в строке. Регулярное выражение (оно же "регэксп", "регулярка" или просто "рег"), состоит из **паттерна** (он же "*шаблон*") и **необязательных флагов**. В JavaScript регулярные выражения реализованы отдельным объектом `RegExp` и интегрированы в методы строк.

## <a id="RegExp" href="#RegExp">RegExp</a>

Синтаксис создания регулярного выражения:  
`var <рег_выражение> = new RegExp("<шаблон>", "<флаги>");`  
`var <рег_выражение> = /<шаблон>/[g][m][i];`

Регулярные выражения могут иметь флаги, которые влияют на поиск, их всего три:
- `i` - если этот флаг есть, то регэксп ищет независимо от регистра, то есть не различает между верхним и нижним регистром;
- `g` - если этот флаг есть, то регэксп ищет все совпадения, иначе - только первое;
- `m` - многострочный режим.

## <a id="Методы-String" href="#Методы-String">Методы String</a>

`<строка>.search(<рег_выражение>)` - возвращает индекс, на котором найдено совпадение или `-1`, если ничего не найдено; он всегда ищет только первое совпадение.

`<строка>.match(<рег_выражение>)` - без флага `g` - находит только одно, первое совпадение, и возвращает массив, состоящий из этого совпадения по индексу `0`, с дополнительными свойствами `index` - позиция, на которой оно обнаружено и `input` - строка, в которой был поиск. Если часть шаблона обозначена скобками `()`, то она станет отдельным элементом массива. В случае, если совпадений не было, `match` возвращает `null`.

`<строка>.match(<рег_выражение>)` - с флагом `g` - возвращает обычный массив из всех совпадений. Никаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают. В случае, если совпадений не было, `match` возвращает `null`.

`<строка>.split({<рег_выражение> | <подстрока>}[, <макс_количество>])` - разбивает строку в массив по разделителю - регулярному выражению или подстроке и возвращает его.

`<строка>.replace(<рег_выражение>, {<строка_замены> | <функция_замены>})` - производит поиск и замену любого уровня сложности. При вызове со строкой замены `replace` всегда заменяет только первое совпадение, а чтобы заменить все совпадения, нужно использовать для поиска не строку, а регулярное выражение обязательно с флагом `g`. В строке для замены можно использовать специальные символы:
- `$$` - вставляет знак `$`;
- `$&` - вставляет всё найденное совпадение;
- `` $` `` - вставляет часть строки до совпадения;
- `$'` - вставляет часть строки после совпадения;
- `$<n>` - вставляет содержимое скобочной группы, где `<n>` - цифра или двузначное число, обозначает `n`-ю по счёту скобку, если считать слева-направо начиная с 1-го.

`<функция_замены>` - будет вызвана для каждого совпадения, и её результат будет вставлен как замена. Имеет вид:

```javascript
function (str[, p1[, p2[, ...]]], offset, s) {
    ...
    return <результат_замены>
}
```
Эта функция получает следующие аргументы:
- `str` - найденное совпадение;
- [`p1`, `p2`, ..., `pn` - содержимое скобок (если есть)];
- `offset` - позиция, на которой найдено совпадение;
- `s` - исходная строка.

Если скобок в регулярном выражении нет, то у функции всегда будет ровно 3 аргумента.

Функция - это самый мощный инструмент для замены, какой только может быть. Она владеет всей информацией о совпадении и имеет доступ к замыканию, поэтому может всё.

## <a id="Методы-RegExp" href="#Методы-RegExp">Методы RegExp</a>

`<рег_выражение>.test(<строка>)` - проверяет, есть ли хоть одно совпадение в строке. Возвращает `true`/`false`.  
`<рег_выражение>.exec(<строка>)` - позволяет искать и все совпадения и скобочные группы в них. Найденные результаты находятся там в том же формате, что и `match` - с учётом скобок, со свойствами `index` и `input`. Он ведёт себя по-разному, в зависимости от того, есть ли у регэкспа флаг `g`:
- если флага `g` нет, то ищет и возвращает первое совпадение, является полным аналогом вызова `<строка>.match(<рег_выражение>)`;
- если флаг `g` есть, то вызов возвращает первое совпадение и запоминает его позицию в свойстве `<рег_выражение>.lastIndex`. Последующий поиск он начнёт уже с этой позиции. Если совпадений не найдено, то сбрасывает `<рег_выражение>.lastIndex` в ноль. Можно заставить искать сразу с нужной позиции, если поставить `lastIndex` вручную.

## <a id="Свойства-RegExp" href="#Свойства-RegExp">Свойства RegExp</a>

Свойства доступны для чтения.

`<рег_выражение>.lastIndex` - индекс, с которого начнётся следующая попытка сопоставления. Если отсутствует флаг `g`, остаётся равным нулю. Является также записываемым.  
`<рег_выражение>.ignoreCase` - равен `true`, если в регулярном выражении используется флаг игнорирования регистра `i`, иначе `false`.  
`<рег_выражение>.global` - равен `true`, если в регулярном выражении используется флаг глобального сопоставления `g`, иначе `false`.  
`<рег_выражение>.multiline` - равен `true`, если в регулярном выражении используется флаг сопоставления по нескольким строкам `m`, иначе `false`.  
`<рег_выражение>.source` - содержит текст шаблона регулярного выражения.

## <a id="Классы-и-спецсимволы" href="#Классы-и-спецсимволы">Классы и спецсимволы</a>

**Класс символов** - это специальное обозначение, под которое подходит любой символ из определённого набора. Виды:
- `\d` (от английского "digit" - "цифра") - цифра, символ от 0 до 9;
- `\s` (от английского "space" - "пробел") - пробельный символ, включая табы, переводы строки и т.п;
- `\w` (от английского "word" - "слово") - символ "слова", а точнее - буква латинского алфавита или цифра или подчёркивание `_`. Не-английские буквы не являются `\w`, то есть русская буква не подходит;
- `\b` - это граница слова, особый класс - обозначает не символ, а границу между символами. Граница имеет "нулевую ширину" в том смысле, что обычно символам регулярного выражения соответствуют символы строки, но не в этом случае. Граница - это проверка;
- `\D` - не-цифра, то есть любой символ кроме `\d`;
- `\S` - не-пробел, то есть любой символ кроме `\s`;
- `\W` - любой символ, кроме `\w`, то есть не латиница, не подчёркивание, не цифра. В частности, русские буквы принадлежат этому классу;
- `\B` - проверка, обратная `\b`;
- `[\b]` - сопоставляется с символом забоя;
- `\0` - сопоставляется с нулевым символом;
- `\cX` - сопоставляется с управляющим символом в строке. Где `X` является буквой от `"A"` до `"Z"`. Сопоставляется с символом `control-X` в строке;
- точка `.` - обозначает любой символ, кроме перевода строки.

Чтобы использовать специальный символ `[` `\` `^` `$` `.` `|` `?` `*` `+` `(` `)` в качестве обычного, он должен быть экранирован, перед символом должен быть обратный слэш `\`. Сам символ слэш `/`, хотя и не является специальными символом в регулярных выражениях, но открывает-закрывает регэксп в синтаксисе `/<шаблон>/`, поэтому его тоже нужно экранировать. Если нам нужно найти сам обратный слэш `\`, то его нужно просто задублировать.

## <a id="Наборы-и-диапазоны" href="#Наборы-и-диапазоны">Наборы и диапазоны</a>

`[[^]<символ1>[<символ2>[...]]]` - это набор, который означает один любой символ из указанных[ при `^` не указанных]. Квадратные скобки могут также содержать диапазоны символов:  
`[<символ_начала>-<символ_конца>[...]]`

> `[0129]`  
> `[^09]`  
> `[A-Z0-9]`

**Символьные классы** - всего лишь более короткие записи для диапазонов, в частности:
- `\d` - то же самое, что `[0-9]`;
- `\w` - то же самое, что `[a-zA-Z0-9_]`;
- `\s` - то же самое, что `[\t\n\v\f\r ]` плюс несколько юникодных пробельных символов.

В квадратных скобках можно использовать и диапазоны и символьные классы - вместе.

Квадратные скобки, начинающиеся со знака каретки `^`: `[^...]` находят любой символ, кроме указанных.

В квадратных скобках большинство специальных символов можно использовать без экранирования, если конечно они не имеют какой-то особый смысл именно внутри квадратных скобок. Без экранирования можно использовать символы: точка `.`; плюс `+`; круглые скобки `(` `)`; дефис `-`, если он находится в начале или конце квадратных скобок, то есть не выделяет диапазон; символ каретки `^`, если не находится в начале квадратных скобок; открывающая квадратная скобка `[`.

## <a id="Квантификаторы----и-n" href="#Квантификаторы----и-n">Квантификаторы `+`, `*`, `?` и `{n}`</a>

Количество повторений символа можно указать с помощью числа в фигурных скобках: `{<количество>}`, после символа. Такое указание называют **квантификатором** (от англ. quantifier). Виды:
- точное количество: `{<количество>}`;
- количество от-до: `{<количество_от>, [<количество_до>]}`.

Короткие обозначения:
- `+` - означает "один или более", то же что `{1,}`;
- `?` - означает "ноль или один", то же что и `{0,1}`. По сути, делает символ необязательным;
- `*` - означает "ноль или более", то же что `{0,}`. То есть, символ может повторяться много раз или вообще отсутствовать.

### <a id="Жадные-и-ленивые-квантификаторы" href="#Жадные-и-ленивые-квантификаторы">Жадные и ленивые квантификаторы</a>

В **жадном режиме** (по умолчанию) регэксп повторяет квантификатор настолько много раз, насколько это возможно, чтобы найти соответствие.

**Ленивый режим** работы квантификаторов - противоположность жадному, он означает "*повторять минимальное количество раз*". Его можно включить, если поставить знак вопроса `?` после квантификатора, так что он станет таким: `*?` или `+?` или даже `??` для `?`. Чтобы не возникло путаницы - важно понимать: обычно `?` сам является квантификатором (ноль или один). Но если он стоит после другого квантификатора (или даже после себя), то обретает другой смысл - в этом случае он меняет режим его работы на ленивый. Ленивость распространяется только на тот квантификатор, после которого стоит `?`. Прочие квантификаторы остаются жадными. Ленивый режим без необходимости лишний раз квантификатор не повторит.

## <a id="Скобочные-группы" href="#Скобочные-группы">Скобочные группы</a>

Часть шаблона может быть заключена в скобки `(...)`. Такие выделенные части шаблона называют "**скобочными выражениями**" или "**скобочными группами**". У такого выделения есть два эффекта:
1. Он позволяет выделить часть совпадения в отдельный элемент массива при поиске через `String#match` или `RegExp#exec`;
2. Если поставить квантификатор после скобки, то он примениться ко всей скобке, а не всего лишь к одному символу.

Скобки нумеруются слева направо. Поисковой движок запоминает содержимое каждой скобки и позволяет обращаться к нему - в шаблоне и строке замены и в результатах.

Скобки могут быть и вложенными. В этом случае нумерация также идёт слева направо. На первом месте - всегда совпадение полностью, далее - группы. Нумерация всегда идёт слева направо, по открывающей скобке.

Даже если скобочная группа необязательна и не входит в совпадение, соответствующий элемент массива существует (и равен `undefined`).

### <a id="Исключение-из-запоминания-через-" href="#Исключение-из-запоминания-через-">Исключение из запоминания через `?:`</a>

Если скобки нужны, чтобы квантификатор правильно применился, а запоминать её в массиве не нужно, то скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало `?:` - `(?:...)`.

### <a id="Обратные-ссылки" href="#Обратные-ссылки">Обратные ссылки</a>

Ссылки в строке замены имеют вид `$<n>`, где `<n>` - это номер скобочной группы. Вместо `$<n>` подставляется содержимое соответствующей скобки.

Ссылки в шаблоне регулярного выражения имеют вид `\<n>`, где `<n>` - это номер скобочной группы. Вместо `\<n>` подставляется содержимое соответствующей скобки.

Скобочные группы вида `(?:...)` не участвуют в нумерации.

## <a id="Альтернация-или-" href="#Альтернация-или-">Альтернация (или) `|`</a>

**Альтернация** - термин в регулярных выражениях, которому в русском языке соответствует слово "ИЛИ". Она обозначается символом вертикальной черты `|` и позволяет выбирать между вариантами. Для указания границ альтернации используют скобки `(...)`.

> `(red|blue|green)`

## <a id="Начало-строки--и-конец-" href="#Начало-строки--и-конец-">Начало строки `^` и конец `$`</a>

Знак каретки `^` и доллара `$` имеют в регулярном выражении особый смысл. Они называются "**якорями**" (anchor - англ.). Каретка `^` совпадает в начале текста, а доллар `$` - в конце, и ставятся вначале или в конце регулярного выражения соответственно. Якоря являются не символами, а проверками.

Оба якоря используют одновременно, если требуется, чтобы шаблон охватывал текст с начала и до конца. Обычно это требуется при валидации.

В многострочном режиме с флагом `m`, якоря сопоставляются в началом / концом каждой строки в многострочной строке, а не с началом / концом всей многострочной строки.

## <a id="Упреждение" href="#Упреждение">Упреждение</a>

`<символ>(?=<упреждение>)` - соответствует символу только если за ним следует набор символов упреждения, где может быть любая конструкция регулярных выражений. Это называется упреждение. Упреждение не являются частью результата сопоставления.

`<символ>(?!<упреждение>)` - соответствует символу только если за ним не следует набор символов упреждения, где может быть любая конструкция регулярных выражений. Это называется отрицательное упреждение. Упреждение не являются частью результата сопоставления.

<a id="Документирование-API-JSDoc" href="#Документирование-API-JSDoc">Документирование API (JSDoc)</a>
============================

## <a id="Основы" href="#Основы">Основы</a>

Документирование располагается сразу перед тем участком кода, который нужно задокументировать, и пишется в таком формате:

```javascript
/**
 * <описание>
 * @<тег> <значение>
 * ...
 */
```

## <a id="Основные-теги" href="#Основные-теги">Основные теги</a>

`@deprecated <описание>` - обозначение того что метод является устаревшим.  
`@description <описание>` - содержит описание.  
`@namespace <объект>` - глобальная ссылка на объект (имя переменной, которая на него указывает), если код относится к объекту или часть его.  
`@class <имя>` - имя, используемое для обозначения объекта или функции-конструктора или класса.  
`@augments <имя>` - имя, используемое для обозначения наследования от другого класса.  
`@extends <имя>` - аналогично.  
`@constructor` - указывает, что это в действительности является функцией-конструктором.  
`@method <имя>` - объявляет метод объекта и определяет его имя.  
`@override` - объявляет, что метод переопределяет метод родителя.  
`@param {<тип>} <имя_аргумента> <описание>` - перечисляет аргументы, принимаемые функцией. Может повторяться.  
`@returns {<тип>} <описание>` - описывает значение, возвращаемое методом, где <тип> может указывать на переменную.  
`@return {<тип>} <описание>` - аналогично.  
`@property {<тип>} <имя>` - имя свойства объекта. Может повторяться.  
`@type {<тип>}` - тип свойства объекта или свойства класса.  
`@typedef <имя>` - обозначает описание типа с указанным именем.  
`@callback <имя>` - описывает сигнатуру функции обратного вызова.  
`@throws {<тип>} <описание>` - описывает исключения которые может выбрасывать функция. Может повторяться.  
`@generator` - описывает что функция возвращает генератор.  
`@yield {<тип>}` - описывает тип возвращаемого значения генератора.

## <a id="Тип" href="#Тип">Тип</a>

Тип должен указывать все возможные типы, которые возможно принять.

Стандартные типы:
- `*` - любой тип;
- примитивные типы: `number`, `boolean`, `string`, `null`, `undefined`;
- массив:
    - `<тип>[]` - где `<тип>` означает тип элемента массива;
    - `Array.<<тип>>` - где `<тип>` означает тип элемента массива:
        > `Array.<number>`
- объект:
    - `object` - просто объект;
    - `{}` - просто объект;
    - `Object.<<тип_ключа>, <тип_значения>>` - специальная коллекция, где `<тип_ключа>` - тип всех ключей, `<тип_значения>` - тип всех значений:
        > `Object.<number, boolean>`
    - `{<имя_ключа1>: <тип_значения_ключа>[, <имя_ключа2>: <тип_значения_ключа>[, ...]]}` - объект с определенным строением;
        > `{stream: fs.WriteStream, chunks: string[], count: number}`  
        > `Object.<date: Date, price: number>`  
        > `Object.<string, {stream: fs.WriteStream, chunks: string[], count: number}>`
- конструктор:
    - `typeof <тип>`
        > `typeof Entry`
- промис:
    - `Promise.<<тип_разрешаемого_значения>>` - где `<тип_разрешаемого_значения>` означает тип, которым разрешиться промис.

Модификаторы типа:
- множественное значение типов: `<тип1>|...` или `(<тип1>|...)`;
- возможно принимать `null`: `?<тип>`;
- не возможно принимать `null`: `!<тип>`;
- опциональный параметр: `<тип>=`;
- оставшиеся параметры (для функции): `...<тип>`.

`{<тип>} [<имя_аргумента>] <описание>` - опциональное значение.

`{<тип>} [<имя_аргумента>=<значение_по_умолчанию>] <описание>` - значение по умолчанию.

## <a id="Описание-структуры-объекта-типа" href="#Описание-структуры-объекта-типа">Описание структуры объекта типа</a>

```javascript
/**
 * @param {object} <имя_аргумента> <описание>
 * @param {<тип>} <имя_аргумента>.<имя_свойства> <описание>
 * ...
 */
```

Если это массив объектов, то тогда описание свойств выглядит как:  
`@param {<тип>} <имя_аргумента>[].<имя_свойства> <описание>`

## <a id="Описание-произвольного-типа" href="#Описание-произвольного-типа">Описание произвольного типа</a>

```javascript
/**
 * @typedef <имя>
 * @type {<базовый_тип>}
 * @property {<тип>} <имя_свойства> <описание>
 * ...
 */
```

```javascript
/**
 * @typedef {<базовый_тип>} <имя>
 * @property {<тип>} <имя_свойства> <описание>
 * ...
 */
```

## <a id="Описание-колбека" href="#Описание-колбека">Описание колбека</a>

```javascript
/**
 * @callback <имя_колбека>
 * @param {<тип>} <имя_аргумента> <описание>
 * ...
 */
```

## <a id="Описание-функции-как-параметра-функции" href="#Описание-функции-как-параметра-функции">Описание функции как параметра функции</a>

`@param {function ([<тип_входящего_параметра>[, ...]])[:<тип_возвращаемого_значения>]} <имя_аргумента> <описание>`

> `@param {function (Event):boolean=} opt_allowDragStart`

> `@param {function (T, ...boolean)} type`

<a id="Тестирование" href="#Тестирование">Тестирование</a>
============

## <a id="Автоматические-тесты-при-помощи-chai-и-mocha" href="#Автоматические-тесты-при-помощи-chai-и-mocha">Автоматические тесты при помощи chai и mocha</a>

**Автоматизированное тестирование** - это когда тесты написаны отдельно от кода, и можно в любой момент запустить их и проверить все важные случаи использования.

**Тесты BDD** (*Behavior Driven Development*) - это три в одном: И тесты И документация И примеры использования одновременно.

**Спецификация** это то, что функция будет делать и можно это описать это по методике BDD:

```javascript
describe("<имя_тестируемой_сущности>", function () {
    it("<что_делает_функция>", function () {
        assert.equal(<тестируемая_функция>(...), <ожидаемый_результат>);
    });
});
```

У спецификации есть три основных строительных блока:
- `describe("<имя_тестируемой_сущности>", function () {...})` - задаёт, что именно описывается, используется для группировки "рабочих лошадок" - блоков `it`;
- `it("<что_делает_функция>", function () {...})` - в названии блока `it` человеческим языком описывается, что должна делать функция (с маленькой буквы), далее следует тест, который проверяет это;
- `assert.equal(<значение1>, <значение2>)` - код внутри `it`, если реализация верна, должен выполняться без ошибок.

```javascript
// <конкретная_сущность> должна ожидаемое действие / поведение [когда / при / если {<сценарий> | <контекст>}]
describe("<конкретная_сущность>", function () {
    [describe("когда / при / если {<сценарий> | <контекст>}", function () {]
        it("дожнен / должна {<ожидаемое_действие> | <поведение>} при / в случае / если {<название_сценария> | <краткое_описание_условия>}", function () {
            assert.equal(<тестируемая_функция>(...), <ожидаемый_результат>);
        });
    [});]
});
```

Различные функции вида `assert.*` используются, чтобы проверить, делает ли `<тестируемая_функция>` то, что задумано.

### <a id="Поток-разработки" href="#Поток-разработки">Поток разработки</a>

Как правило, поток разработки таков:
1. Пишется спецификация, которая описывает самый базовый функционал;
2. Делается начальная реализация;
3. Для проверки соответствия спецификации задействуется одновременно фреймворк (Mocha) вместе со спецификацией и реализацией. Фреймворк запускает все тесты `it` и выводит ошибки, если они возникнут. При ошибках вносятся исправления;
4. Спецификация расширяется, в неё добавляются возможности, которые пока, возможно, не поддерживаются реализацией;
5. Перходим на пункт 2, делаем реализацию, и так далее, до завершения спецификации и реализации.

Разработка ведётся итеративно, один проход за другим, пока спецификация и реализация не будут завершены.

Для запуска тестов нужны соответствующие JavaScript-библиотеки:
- **Mocha** - эта библиотека содержит общие функции для тестирования, включая `describe` и `it`;
- **Chai** - библиотека поддерживает разнообразные функции для проверок;
- **Sinon** - для эмуляции и хитрой подмены функций "заглушками".

**Один тест тестирует ровно одну вещь.**

В `describe` можно вкладывать `describe`, который объявит новую "подгруппу" тестов, блоки `it` которой запускаются так же, как и обычно, но выводятся с подзаголовком.

В каждом блоке `describe` можно также задать функции:
- `before(function ([done]) {...})` - выполнится до запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `after(function ([done]) {...})` - выполнится после запуска тестов [где `done` - необходимо вызвать по завершению асинхронной работы];
- `beforeEach(function ([done]) {...})` - выполнится до каждого `it` [где `done` - необходимо вызвать по завершению асинхронной работы];
- `afterEach(function ([done]) {...})` - выполнится после каждого `it` [где `done` - необходимо вызвать по завершению асинхронной работы].

### <a id="Дополнительные-методы-тестирования" href="#Дополнительные-методы-тестирования">Дополнительные методы тестирования</a>

- `.skip`:
    - после `it` позволяет пропустить тест;
    - после `describe` позволяет пропустить группу тестов, лучше использовать вместо комментирования самих тестов;
    > `it.skip("<что_делает_функция>", function () {...})`
- `.only`:
    - после `it` позволяет выполнить только этот тест;
    - после `describe` позволяет выполнить только эту группу тестов, и все другие с модификатором `.only`;
    > `describe.only("<имя_тестируемой_сущности>", function () {...})`

### <a id="Виды-chaiassert" href="#Виды-chaiassert">Виды `chai.assert`</a>

- `assert(<значение>[, '<сообщение>'])` - проверяет что `<значение>` является `true` в логическом контексте;
- `assert.equal(<значение1>, <значение2>[, '<сообщение>'])` - проверяет равенство `<значение1> == <значение2>`;
- `assert.strictEqual(<значение1>, <значение2>[, '<сообщение>'])` - проверяет строгое равенство `<значение1> === <значение2>`;
- `assert.notEqual(<значение1>, <значение2>[, '<сообщение>'])`, `assert.notStrictEqual(<значение1>, <значение2>[, '<сообщение>'])` - проверки, обратные двум предыдущим;
- `assert.deepEqual(<объект1>, <объект2>[, '<сообщение>'])` - производит глубокую проверку что один объект равен другому объекту по его свойствам;
- `assert.isTrue(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === true`;
- `assert.isFalse(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === false`;
- `assert.isOk(<значение>[, '<сообщение>'])` - проверяет, что `<значение>` есть;
- `assert.isNotOk(<значение>[, '<сообщение>'])` - проверяет, что `<значение>` нет;
- `assert.isNull(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === null`;
- `assert.isUndefined(<значение>[, '<сообщение>'])` - проверяет, что `<значение> === undefined`;
- `assert.exists(<значение>[, '<сообщение>'])` - проверяет, что `<значение> !== null && <значение> !== undefined`;
- `assert.typeOf(<значение>, '<тип>'[, '<сообщение>'])` - проверяет что `<значение>` является указаным типом;
- `assert.instanceOf(<значение>, <функция_конструктор>[, '<сообщение>'])` - проверяет что `<значение>` является экземпляром `<функция_конструктор>`;

Все вызовы `assert` позволяют дополнительным последним аргументом указать строку с описанием ошибки, которое выводится, если `assert` не проходит.

Эту спецификацию можно использовать как:
- тесты, которые гарантируют правильность работы кода;
- документацию по функции, что она конкретно делает;
- примеры использования функции, которые демонстрируют её работу внутри `it`.

### <a id="Виды-chaiexpect" href="#Виды-chaiexpect">Виды `chai.expect`</a>

Используется для BDD (*Behavior-driven development*, *разработка через поведение*).  
Пишутся в стиле английского языка, через описание поведения.

`expect(<значение>)` - инициализация:
- `.to` - начало конструкции (чейнится):
    - `.be` - существование (есть) (чейнится):
        - `.true` - проверяет что значение `<значение> === true`;
        - `.false` - проверяет что значение `<значение> === false`;
        - `.null` - проверяет что значение `<значение> === null`;
        - `.an('<тип>'[, '<сообщение>'])` - проверяет что значение `<значение>` является указаным типом;
        - `.a('<тип>'[, '<сообщение>'])` - аналогично предыдущему;
        - `.instanceof('<функция_конструктор>'[, '<сообщение>'])` - проверяет что `<значение>` является экземпляром `<функция_конструктор>`;
    - `.exist` - значение `<значение>` существует;
    - `.not` - модификатор - отрицает последующие проверочные конструкции (чейнится):
        > `expect([1, 2, 3]).to.not.be.empty;`
    - `.deep` - модификатор - добавляет глубокие проверки для объектов по их свойствам (чейнится), для проверок `.equal`, `.include`, `.members`, `.keys`, `.property`;
    - `.nested` - модификатор - добавляет проверку по пути свойств для имен свойств (чейнится), для проверок `.include`, `.property`:
        > `expect(obj).to.have.nested.property('query.bool.filter[0].term.id');`
    - `.ordered` - модификатор - добавляет проверку порядка (чейнится), для проверок `.members`;
    - `.any` - модификатор - добавляет проверку что существует хотя бы один из (чейнится), для проверок `.keys`;
    - `.all` - модификатор - добавляет проверку что существуют все из (чейнится), для проверок `.keys`;
    - `.equal(<проверяемое_значение>[, '<сообщение>'])` - проверяет равенство значений `<значение>` и `<проверяемое_значение>`;
    - `.eql(<проверяемое_значение>[, '<сообщение>'])` - производит глубокую проверку что один объект равен другому объекту по его свойствам;
    - `.have` - имеет (чейнится):
        - `.members(<массив>[, '<сообщение>'])` - проверяет что входной массив `<значение>` строго содержит все значения из `<массив>` и **только их**;
        - `.property('<имя_свойства>'[, <значение_свойства>])` - проверяет что входной объект `<значение>` содержит свойство с указаным именем `<имя_свойства>` [и оно равно `<значение_свойства>`];
        - `.keys(['<имя_свойства1>'[, ...]])` - проверяет что входной объект `<значение>` содержит все свойства, которые заданы в массиве;
    - `.include`:
        - `.members(<массив>)` - проверяет что входной массив `<значение>` содержит все значения из `<массив>`;
    - `.include({<объект> | '<строка>' | <число>}[, '<сообщение>'])` - проверяет что одно из:
        - входной объект `<значение>` содержит все значения из `<объект>`;
        - входная строка `<значение>` содержит подстроку `<строка>`;
        - входной массив `<значение>` содержит строку `<строка>` или число `<число>`;
    - `.throw([<конструктор_ошибки>])` - проверяет что функция `<значение>` при вызове выбросит исключение экземпляра `<конструктор_ошибки>`;

### <a id="Асинхронные-тесты" href="#Асинхронные-тесты">Асинхронные тесты</a>

Для этого в функцию, которую принимает метод `it("<что_делает_функция>", function (done) {...})` передается дополнительный callback-параметр `done` - который необходимо вызвать по завершению асинхронной работы без параметров в случае успеха `done()`, или с ошибкой в случае не удачи `done(<error>)`.

```javascript
describe('#save()', function () {
    it('should save without error', function (done) {
        var user = new User('Luna');
        user.save(function () {
            done();
        });
    });
});
```

Или можно вернуть промис, который необходимо разрешить.

```javascript
describe('#find()', function () {
    it('respond with matching records', function () {
        return db.find({ type: 'User' }).should.eventually.have.length(3);
    });
});
```

### <a id="Размещение-тестов" href="#Размещение-тестов">Размещение тестов</a>

Глобальные тесты должны располагаться по путь `tests/` в корне проекта.

Тесты модулей должны именоваться `<имя_модуля>.spec.js`.

`mocha` - запуск всех тестов в `tests/`.  
`mocha <имя_модуля>.spec.js` - запуск теста модуля.  
`mocha --exclude node_modules ./**/*.spec.js` - запуск всех тестов модулей.

### <a id="Sinon" href="#Sinon">Sinon</a>

#### <a id="Шпион-spy" href="#Шпион-spy">Шпион `spy`</a>

`const <spy> = sinon.spy([{<функция> | <объект>, '<метод>'}]);` - возвращает новую функцию (шпиона), которая записывает аргументы, возвращаемое значение, исходное значение и выданные ошибки (если таковые были) для всех вызовов [поверх готовой функции `<функция>` или заменяет исходный метод `<метод>` объекта `<объект>`].

`<spy>.called` - содержит `true` если функция была вызвана, иначе `false`.  
`<spy>.calledOnce` - содержит `true` если функция была вызвана единожды, иначе `false`.  
`<spy>.callCount` - содержит количество вызовов функции.  
`<spy>.args` - содержит массив из массивов аргументов для вызовов функции.  
`<spy>.exceptions` - содержит массив из исключений для вызовов функции.  
`<spy>.returnValues` - содержит массив из возвращаемых значений для вызовов функции.  
`<spy>.getCall(<номер_вызова>)` - возвращает объект с запросами вызова функции, где `args` - массив аргументов для вызова функции.  
`<spy>.calledWith([<аргумент1>[, ...]])` - возвращает `true` если функция была вызвана с указанными аргументами, иначе `false`.  
`<spy>.threw()` - возвращает `true` если функция выбросила исключение, иначе `false`.  
`<spy>.calledBefore(<другой_spy>)` - возвращает `true` если функция была вызвана перед вызовом другого шпиона `<другой_spy>`, иначе `false`.  
`<spy>.calledAfter(<другой_spy>)` - возвращает `true` если функция была вызвана после вызова другого шпиона `<другой_spy>`, иначе `false`.

#### <a id="Заглушки-stub" href="#Заглушки-stub">Заглушки `stub`</a>

`const <stub> = sinon.stub([<объект>[, '<метод>']]);` - возвращает новую функцию (заглушку) с предварительно запрограммированным поведением, полностью поддерживает API шпионов в дополнение к методам, которые могут быть использованы для изменения поведения заглушек [для всех методов указаного объекта `<объект>`[, только указаного метода `<метод>`, тогда вызов `<stub>(...)` будет аналогичен вызову `<объект>.<метод>(...)`]].

`<stub>.returns(<значение>)` - возвращает указаное значение `<значение>` при вызове функции.  
`<stub>.returnsThis()` - возвращает `this` при вызове функции.  
`<stub>.resolves(<значение>)` - возвращает промис, который успешно разрешиться значением `<значение>` при вызове функции.  
`<stub>.resolvesArg(<номер>)` - возвращает промис, который успешно разрешиться значением переданным аргументом под номером `<номер>` при вызове функции.  
`<stub>.rejects(<значение>)` - возвращает промис, который неуспешно разрешиться значением `<значение>` при вызове функции.  
`<stub>.throws(['<Тип_Исключения>'])` - выбрасывает указаное исключение [с указаным типом `<Тип_Исключения>`] при вызове функции.  
`<stub>.withArgs([<аргумент1>[, ...]]).<метод_возврата_значения>` - `<метод_возврата_значения>` (к примеру как `returns` и `throws`) будут вызваны только при вызове функции с указанными аргументами, а иначе будут вызваны другие `<метод_возврата_значения>`, их объявляют до `<метод_возврата_значения>` без этого метода.  
`<stub>.onCall(<номер>).<метод_возврата_значения>` - `<метод_возврата_значения>` (к примеру как `returns` и `throws`) будут вызваны только при указаном `<номер>` вызове функции, а иначе будут вызваны другие `<метод_возврата_значения>`.  
`<stub>.callsArg(<номер>)` - вызывает указанный переданный аргумент под номером `<номер>` как функцию при вызове заглушки.  
`<stub>.callsArgWith(<номер>[, <аргумент1>[, ...]])` - вызывает указанный переданный аргумент под номером `<номер>` как функцию при вызове заглушки с указанными аргументами.  
`<stub>.restore()` - восстанавливает исходную функцию.

```javascript
const callback = sinon.stub();
callback.withArgs(42)
    .onFirstCall().returns(1)
    .onSecondCall().returns(2);
callback.returns(0);
```

#### <a id="Имитация-mock" href="#Имитация-mock">Имитация `mock`</a>

`const <mock> = sinon.mock(<объект>);` - возвращает имитацию для указанного объекта, с предварительно запрограммированным поведением (как заглушка), а также предварительно запрограммированным ожиданием, сам объект не изменяется, но обертывает mock-объект для установки ожиданий на методах объекта.

`<mock>.restore()` - восстанавливает все методы имитации.  
`<mock>.verify()` - возвращает `true` если все ожидания прошли проверку, иначе `false`.

`const <expectation> = <mock>.expects('<метод>');` - возвращает ожидание - функцией имитации, для указаного метода `<метод>`.

`<expectation>.atLeast(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное минимальное количество раз.  
`<expectation>.atMost(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное максимальное количество раз.  
`<expectation>.exactly(<количество>)` - возвращает это ожидание и устанавливает, что метод будет вызван указаное точное количество раз.  
`<expectation>.once()` - возвращает это ожидание и устанавливает, что метод будет вызван один раз.  
`<expectation>.never()` - возвращает это ожидание и устанавливает, что метод не будет вызван.  
`<expectation>.withArgs(<аргумент1>[, ...])` - возвращает это ожидание и устанавливает, что метод будет вызван с заданными аргументами (возможно подобными).  
`<expectation>.withExactArgs(<аргумент1>[, ...])` - возвращает это ожидание и устанавливает, что метод будет вызван с заданными аргументами и никакими другими.  
`<expectation>.verify()` - возвращает `true` если ожидание прошло проверку, иначе `false`.

<a id="Приемы" href="#Приемы">Приемы</a>
======

## <a id="Паттерн-RORO" href="#Паттерн-RORO">Паттерн RORO</a>

Основной смысл этого принципа заключается во фразе *receive an object, return an object* (получил объект, вернул объект) и применяется для функций:

`function <имя>(<входящий_объект>) {... return <исходящий_объект>;}`

Этот паттерн позволяет избежать передачи параметров в функцию в заданом порядке и позволяет делать именованные параметры, все это упрощается благодаря декомпозиции. Также это позволяет задать обязательные поля с помощью функции, которая выбрасывает исключения:

> `function func({key, key2 = requiredParam('key2'), key3 = 4}) {...}`

```javascript
function requiredParam(param) {
    const requiredParamError = new Error(`Required parameter, "${param}" is missing.`);
    if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(
            requiredParamError,
            requiredParam
        );
    }
    throw requiredParamError;
}
```

Благодаря тому что всегда получается и возвращается объект можно реализовать удобную композицию функций:

```javascript
function pipe(...fns) {
    return param => fns.reduce((result, fn) => fn(result), param);
}
```

Эта функция принимает список функций и возвращает одну функцию, которая может выполнить эти функции слева направо, передав первой из этих функций аргументы, переданные в `pipe`, второй - то, что вернёт первая функция, и так далее.

> `pipe(validate, normalize, persist)(userInfo)`

## <a id="Паттерн-Ice-Factory" href="#Паттерн-Ice-Factory">Паттерн Ice Factory</a>

Представляет собой функцию, которая возвращает "замороженный" (иммутабеленый) объект. Используется для построения фабрик по производству объектов, что позволяет скрывать их реализацию:

```javascript
function make<Имя>(<параметры>) { // <параметры> представляют собой объект
    // определение локальных переменных
    const <переменная>[ = <значение>];
    [...]
    //возврат иммутабельного объекта
    return Object.freeze({
        <переменная>[, ...],
        <метод>[, ...]
    });
    //определение методов
    function <метод>() {
        // код, который использует локальные переменные
    }
    [...]
}
```

В этом паттерне вместо наследования применяется композиция.

```javascript
const productList = makeProductList(<параметры>);
const cart = makeShoppingCart(productList);
```

## <a id="Паттерн-BIF" href="#Паттерн-BIF">Паттерн BIF</a>

Паттерн BIF (Backend In the Frontend) использует ту же логику, которая может применяться при использовании BFF (комбинирование нескольких API и очистка данных), но эта логика перемещается на сторону клиента.

```
    | Backend  |                        | Frontend                        |
    |          |                        |                                 |
    | +------+ | <-[ /auth          ]-> | +------+               +------+ |
    | | Data | | <-[ /profile       ]-> | | BIF  | <-[ /user ]-> | App  | |
    | +------+ | <-[ /notifications ]-> | +------+               +------+ |
```

Его использование не приводит к необходимости убирать какую-то логику из проекта. Он всего лишь отделяет логику одного типа (модификация структур данных) от логики другого типа (формирование пользовательского интерфейса).

Это приводит к комбинированию обращений к Backend через функции. То есть теперь все обращения к внешним данным будут проходить только через функции.

Эти функции также должны производить очистку и модификацию данных для приложения, то есть производить нормализацию данных.

## <a id="Паттерн-Модуль" href="#Паттерн-Модуль">Паттерн Модуль</a>

Заключается в использовании самовызывающийся функции (IIFE, Immediately-Invoked Function Expression, немедленно вызываемое функциональное выражение), которая возвращает модуль в переменную или объявляет какие-то данные глобально. Подобные функции удобно использовать для того, чтобы решить некую задачу, которую нужно решить лишь один раз, не оставляя при этом ничего лишнего в глобальной области видимости. Внутри этой функции создаётся приватная область видимости, недоступная извне.

```javascript
[var <Модуль> = ](function () {
    // приватные переменные и функции
    return {
        // публичные переменные
    };
})();
```

Существует одно соглашение, в соответствии с которым в начале имён приватных функций ставят знак подчёркивания.

<a id="TypeScript" href="#TypeScript">TypeScript</a>
==========

TypeScript представляет язык программирования на основе JavaScript. TypeScript - это строго типизированный и компилируемый язык. TypeScript реализует многие концепции, которые свойственны объектно-ориентированным языкам, как, например, наследование, полиморфизм, инкапсуляция и модификаторы доступа и так далее. TypeScript является надмножеством JavaScript, а это значит, что любая программа на JS является программой на TypeScript. В TS можно использовать все те конструкции, которые применяются в JS - те же операторы, условные, циклические конструкции. Более того код на TS компилируется в javascript.

`npm install -g typescript` - установка через NPM.

`tsc -v` - вывод версии.

Все файлы для TypeScript именуются с суффиксом `ts`.

`tsc <файл>.ts` - производит компиляцию файла `<файл>.ts` в `<файл>.js`.

## <a id="Структура" href="#Структура">Структура</a>

Проект по умолчанию имеет следующие файлы:
- `app.ts` - файл с кодом на TypeScript;
- `package.json` - файл с определением пакетов и прочей конфигурации для Node.js;
- `tsconfig.json` - файл конфигурации TypeScript.

## <a id="Настройки-компиляции" href="#Настройки-компиляции">Настройки компиляции</a>

Осуществляются в качестве ключей для `tsc`:
- `-w` - автоматически перекомпилирует файлы typescript, если в них были внесены какие-либо изменения;
- `-t <версия>` - позволяет указать версию стандарта, может принимать следующие значения: "ES3" (по умолчанию), "ES5", "ES6", "ES2015", "ES2016", "ES2017" или "ESNext";
- `--removeComments` - удаляет комментарии при компиляции;
- `--outDir <каталог>` - указывает папку для хранения скомпилированных файлов js;
- `--outFile <файл>[ ...]` - позволяет объединить файлы в один файл;
- `-m` - позволяет указать тип модуля, который будет использоваться для компиляции. Эта опция может принимать следующие значения: "none", "commonjs", "amd", "system" - универсальный, "umd", "es6", "es2015" и "esnext".

### <a id="Файл-конфигурации-tsconfigjson" href="#Файл-конфигурации-tsconfigjson">Файл конфигурации tsconfig.json</a>

С помощью файла `tsconfig.json` можно настроить проект TypeScript. В частности, этот файл выполняет следующие задачи:
- устанавливает корневой каталог проекта TypeScript;
- выполняет настройку параметров компиляции;
- устанавливает файлы проекта.

Строение файла:

```json
{
    "compileOnSave": true,
    "compilerOptions": {
        "target": "es5",
        "removeComments": true,
        "outDir": "js",
        "sourceMap": true
        "outFile": "main.js"
    },
    ["files": [
        "<файл>"[, ...]
    ],]
    ["exclude": [
        "<каталог>"[, ...]
    ],]
}
```

Файл `tsconfig.json` используется при компиляции в том случае, если компилятору не передаются названия файлов, которые надо скомпилировать. В этом случае компилятор TypeScript просматривает текущий каталог, ищет в нем файл `tsconfig.json` и затем при компиляции использует те параметры, которые определены в этом файле.

## <a id="Типы-данных" href="#Типы-данных">Типы данных</a>

TypeScript является строго типизированным языком, и каждая переменная и константа в нем имеет определенный тип. При этом в отличие от javascript нельзя динамически изменить ранее указанный тип переменной.

Для установки типа применяется знак двоеточия `:`:

`{let | const} <переменная>: <тип>[ = <значение>];`

В TypeScript имеются следующие базовые типы:
- `boolean` - логическое значение `true` или `false`;
- `number` - представляет числа, причем все числа в TypeScript, как и в JavaScript, являются числами с плавающей точкой. TS поддерживает двоичную (`0b`), восьмеричную (`0o`), десятичную и шестнадцатиричную (`0x`) записи чисел;
- `string` - строки;
- `array` - массивы - определяются с помощью выражения [] и также являются строго типизированными:
    - `let <переменная>: <тип_элементов_массива>[];`;
    - `let <переменная>: Array<<тип_элементов_массива>>;`;
    > `let names: Array<string> = ["Tom", "Bob", "Alice"];`

    Есть тип `ReadonlyArray<T>`, который, по сути, является типом `Array<T>`, из которого удалены все изменяющие его методы, так что такие массивы не будут изменяться после создания.
- `tuple` - кортежи - как и массивы, представляют набор элементов, для которых уже заранее известен тип:
    - `let <переменная>: [<тип_элемента>[, ...]];`;
    > `let userInfo: [string, number] = ["Tom", 28];`
- `enum` - перечисления - предназначен для описания набора числовых данных с помощью строковых констант (если элемент не имеет инициализатора, ему присваивается значение 0):
    - `enum <ИмяПеречисления> {<ИмяЭлемента>[ = {<значение> | <начальное_значение>}][, ...]};`;
    > `enum Season { Winter = 5, Spring, Summer, Autumn }; // 5, 6, 7, 8`  
    > `let a = Season.Winter`
- `any` - произвольный тип - описывает данные, тип которых может быть неизвестен на момент написания приложения;
- `null`, `undefined` - соответствуют значениям `null` и `undefined` в javascript, фактически можно присваивать значения `undefined` и `null` переменным других типов. В этом плане `null` и `undefined` выступают как подтипы других типов и полезны преимущественно в каких-то операциях, где неизвестен результат - то ли это будет число или строка, то ли это будет `null`;
- `void` - отсутствие конкретного значения, используется в основном в качестве возвращаемого типа функций;
- `never` - также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку;

Большинство из этих типов соотносятся с примитивными типами из JavaScript.

Для определения типа объекта используется структура, при этом необязательные параметры должны быть помечены вопросительным знаком `?`:

`let <переменная>: {<ключ>: <тип_значения>[, ...]};`
> `let obj: {a: string, b?: number};`

Если тип не указан то компилятор выдаст ей тип присвоеного значения.  
Если же переменная определяется без значения, и только впоследствии при работе программы ей присваивается значение, тогда считается, что она имеет тип `any`.

### <a id="Объединения" href="#Объединения">Объединения</a>

Объединения или union не являются собственно типом данных, но они позволяют определить переменную, которая может хранить значение двух или более типов:

`{let | const} <переменная>: <тип1> | <тип2>[ | ...][ = <значение>];`

> `let id: number | string;`

### <a id="Псевдонимы-типов" href="#Псевдонимы-типов">Псевдонимы типов</a>

TypeScript позволяет определять псевдонимы типов с помощью ключевого слова `type`:

`type <имяПсевдонима> = <тип1> | <тип2>[ | ...];`

Теперь можно применять псевдоним аналогично типу данных.

> `type stringOrNumberType = number | string; let sum: stringOrNumberType = 36.6;`

### <a id="Type-assertion" href="#Type-assertion">Type assertion</a>

Type assertion представляет модель преобразования значения переменной к определенному типу.

`<<тип>><переменная>`  
`<переменная> as <тип>`

> `let someAnyValue: any = "hello world!"; let strLength: number = (<string>someAnyValue).length;`

## <a id="Определение-функции" href="#Определение-функции">Определение функции</a>

`function <имя>(<аргумент>: <тип>[ = <значение>][, ...]): <тип_результата> {...}`

Если функция ничего не возвращает, то указывается тип результата `void`.

Чтобы иметь возможность передавать различное число значений в функцию, в TS некоторые параметры можно объявить как необязательные. Необязательные параметры должны быть помечены вопросительным знаком `?`. Причем необязательные параметры должны идти после обязательных.

`<аргумент>?: <тип>`

Если же необходимо, чтобы функция принимала набор однотипных параметров, то используется знак многоточия, после которого идет массив. Причем этот параметр идет после обязательных.

`...<аргумент>: <тип>[]`

### <a id="Параметр-this" href="#Параметр-this">Параметр `this`</a>

Так как `this` берется из функционального выражения внутри объектного литерала, то чтобы исправить это, можно явно указать `this` в качестве параметра. Параметр `this` - это "фальшивый" параметр, который идет первым в списке параметров функции:

`function <имя>(this: <тип>, <аргумент>: <тип>[ = <значение>][, ...]): <тип_результата> {...}`

> `function (this: Deck) {...}`

### <a id="Перегрузка-функций" href="#Перегрузка-функций">Перегрузка функций</a>

TypeScript поддерживает возможность перегрузки функций, то есть можно определить несколько версий функции, которые будут иметь одно и то же имя, но разные типы параметров или разное количество параметров или разные возвращаемые типы результатов.  
Для перегрузки вначале определяются все версии функции, которые не будут иметь никакой логики. А потом определяем версию функции с общей сигнатурой, которая подходит под все ранее определенные варианты. И в этой общей версии уже определяем конкретную логику функции.  
То есть вначале аргументы идут с определенными типами, а потом в общей функции с типом `any`.

```typescript
function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: any, y: any): any {
    return x + y;
}
```

### <a id="Тип-функции" href="#Тип-функции">Тип функции</a>

Каждая функция имеет тип, как и обычные переменные. Тип функции фактически представляет комбинацию типов параметров и типа возвращаемого значения. Имеет вид:

`(<аргумент>: <тип>[, ...]) => <тип_результата>`

> `let operationFunc: (x: number, y: number) => number;`

Тип функции используется также как и простые типы.

## <a id="Классы" href="#Классы">Классы</a>

TypeScript реализует объектно-ориентированный подход, в нем есть полноценная поддержка классов. Класс представляет шаблон для создания объектов и инкапсулирует функциональность, которую должен иметь объект. Класс определяет состояние и поведение, которыми обладает объект.

```typescript
class <Класс>[ extends <Родитель>][ implements <Интерфейс>] {
    [static] [{private | public | protected | readonly}] <свойство1>: <тип>[ = <начальное_значение>]; // Объявление свойства
    constructor([{private | public | protected | readonly}] <аргумент>: <тип>[, ...]): <тип> {
        [super(...);]
        ...
    }
    [static] [{private | public | protected | readonly}] <метод1>(<аргумент>: <тип>[, ...]): <тип> {...}
}
```

Если к свойствам и функциям классов не применяется модификатор, то такие свойства и функции расцениваются как будто они определены с модификатором `public`. То есть доступ к переменным есть из вне.

Если же к свойствам и методам применяется модификатор `private`, то к ним нельзя будет обратиться извне при создании объекта данного класса.

Модификатор `protected` во многом аналогичен `private` - свойства и методы с данным модификатором не видны из вне, но к ним можно обратиться из классов-наследников.

Ключевое слово `readonly` позволяет определить свойства, которые доступны только для чтения. Его значение можно установить только в конструкторе класса или при объявлении.

Также в описании класса можно описывать свойства с двумя методами `get`/`set`.

Имя класса используется также как и простые типы.

Если класс реализует интерфейс, то он обязан определить все те же свойства и функции, которые есть в интерфейсе. При этом объект класса является как объектом типа `<Класс>`, так и объектом `<Интерфейс>`.

`typeof <Класс>` - возвращает тип идентификатора, который является типом функции-конструктора. Этот тип будет содержать все статические члены `<Класс>`, вместе с конструктором, который создает экземпляры класса `<Класс>`.

### <a id="Абстрактные-классы" href="#Абстрактные-классы">Абстрактные классы</a>

Абстрактные классы представляют классы, определенные с ключевым словом `abstract`. Они во многом похожи на обычные классы за тем исключением, что мы не можем создать напрямую объект абстрактного класса, используя его конструктор.

```typescript
abstract class <Класс>[ extends <Родитель>] {
    [static] [{private | public | protected | readonly}] <свойство1>: <тип>;
    [static] [{private | public | protected | readonly}] <метод1>(<аргумент>: <тип>[, ...]): <тип> {...}
    abstract [{private | public | protected | readonly}] <метод1>(<аргумент>: <тип>[, ...]): <тип>; // абстрактный метод, который необходимо переопределить в наследнике
}
```

## <a id="Интерфейсы" href="#Интерфейсы">Интерфейсы</a>

### <a id="Интерфейсы-классов" href="#Интерфейсы-классов">Интерфейсы классов</a>

Интерфейс определяет свойства и методы, которые объект должен реализовать. Другими словами, интерфейс - это определение кастомного типа данных, но без реализации. Интерфейсы определяются с помощью ключевого слова `interface`.

```typescript
interface <Интерфейс>[ extends {<Интерфейс> | <Класс>}[, ...]] {
    [readonly] <свойство1>: <тип>; // Обязательное свойство
    [readonly] <свойство1>?: <тип>; // Необязательное свойство
    [propName: <тип_ключа>]: <тип_значения>; // Описание всех остальных свойств, которые не перечислены в описании интерфейса
    <метод1>(<аргумент>: <тип>[, ...]): <тип>;
    new(<аргумент>: <тип>[, ...]): <тип>; // Определение типа конструктора для класса
}
```

Также интерфейс может содержать свойства только для чтения, значение которых нельзя изменять. Такие свойства определяются с помощью ключевого слова `readonly`.

Имя интерфейса используется также как и простые типы.

По соглашению, имя интерфейса имеет префикс `I`.

Если объект, удовлетворяет перечисленным требованиям интерфейса для аргумента функции, то он считается подходящим для функции. Проверка типов не требует, чтобы свойства шли в определенном порядке: важно лишь, что необходимые свойства присутствуют и имеют подходящий тип.

```typescript
interface IUser {
    id: number;
    name: string;
}
let employee: IUser = {
    id: 1,
    name: "Alice"
};
```

### <a id="Интерфейсы-функций" href="#Интерфейсы-функций">Интерфейсы функций</a>

Интерфейсы функций содержат определение типа функции. Затем они должны быть реализованы объектом, который представляет функцию данного типа.

```typescript
interface <Интерфейс> {
    (<аргумент>: <тип>[, ...]): <тип>;
}
```

```typescript
interface FullNameBuilder {
    (name: string, surname: string): string;
}
let simpleBuilder: FullNameBuilder = function (name:string, surname: string): string {
    return "Mr. " + name + " " + surname;
}
```

### <a id="Интерфейсы-объектов" href="#Интерфейсы-объектов">Интерфейсы объектов</a>

Интерфейсы объектов содержат описание структуры ключа и структуры его значения. Затем они должны быть реализованы, тем кто представляет данный тип.

```typescript
interface <Интерфейс> {
    [readonly] [index: <тип_ключа>]: <тип_значения>;
}
```

```typescript
interface Dictionary {
    [index: string]: string;
}
var colors: Dictionary = {};
colors["red"] = "#ff0000";
colors["green"] = "#00ff00";
colors["blue"] = "#0000ff";
```

Сигнатуру индекса можно сделать доступной только для чтения, чтобы запретить присваивание индексам после объявления.

### <a id="Гибридные-интерфейсы" href="#Гибридные-интерфейсы">Гибридные интерфейсы</a>

Интерфейсы могут сочетать различные стили, могут применяться сразу как к определению объекта, так и к определению функции.

Преобразование к интерфейсам происходит по правилу утиной типизации или с помощью конструкций стандартного преобразования.

## <a id="Оператор-instanceof" href="#Оператор-instanceof">Оператор `instanceof`</a>

С помощью оператора `instanceof` можно проверить, принадлежит ли объект определенному классу.

## <a id="Обобщения" href="#Обобщения">Обобщения</a>

Для функций:

`function <имя><T>(<аргумент>: T[, ...]): T {...}`

С помощью выражения `<T>` указывают, что функция типизирована определенным типом `T`. При выполнении функции вместо `Т` будет подставляться конкретный тип. Причем на этапе компиляции конкретный тип не известен. И возвращать функция будет объект этого типа. Таким образом, можно передать в функцию объекты различных типов, но при этом сохраняется строгая типизация, каждый вариант обобщенной функции может принимать объекты только определенного типа.

```typescript
function getId<T>(id: T): T {
    return id;
}
let result1 = getId<number>(5);
let result2 = getId<string>("abc");
```

Для классов и интерфейсов:

`class <Класс><T> {...}`

`interface <Интерфейс><T> {...}`

Только нужно учитывать, что если типизировали объект определенным типом, то сменить данный тип уже не получится. То есть в следующем случае второе создание объекта не будет работать, так как объект уже типизирован типом изначальным типом.

```typescript
let tom = new User<number>(3);
console.log(tom.getId());
tom = new User<string>("vsf");
```

### <a id="Ограничения-обобщений" href="#Ограничения-обобщений">Ограничения обобщений</a>

`<T extends {<Интерфейс> | <Класс>}>` - устанавливает что только можно передавать объекты, которые расширяют `{<Интерфейс> | <Класс>}`.

```typescript
class UserInfo<T extends IUser> {
    getUserInfo(user: T): void {
        user.getInfo();
    }
}
```

### <a id="Ключевое-слово-new" href="#Ключевое-слово-new">Ключевое слово `new`</a>

`<T>(type: { new (): T; }): T`

Чтобы создать новый объект в коде обобщений, нужно указать, что обобщенный тип `T` имеет конструктор. Это означает, что вместо параметра `type: T` нужно указать `type: {new (): T;}`.

```typescript
function userFactory<T>(type: { new (): T; }): T {
    return new type();
}
class User {
    constructor() {console.log("создан объект User");}
}
let user: User = userFactory(User);
```

## <a id="Пространства-имен" href="#Пространства-имен">Пространства имен</a>

Пространства имен предназначены для организации больших программ. Пространства имен содержат группу классов, интерфейсов, функций, других пространств имен, которые могут использоваться в некотором общем контексте. Чтобы типы и объекты, определенные в пространстве имен, были видны извне, они определяются с ключевым словом `export`.

При этом пространства имен могут содержать и интерфейсы, и объекты, и функции.

```typescript
namespace <имя_пространства_имен> {
    // тело пространства имен, которое содержит группу классов, интерфейсов, функций, других пространств имен
    export <экспортируемый_тип>;
}
```

С помощью директивы `/// <reference path="<файл>.ts" />` подключается файл `<файл>.ts`, в котором содержатся данные.

`<имя_пространства_имен>.<экспортируемый_тип>` - доступ к элементам пространства имен.

Пространства имен могут быть вложенными. Причем вложенные пространства имен определяются со словом `export`. Соответственно при обращении к типам надо использовать все пространства имен.

### <a id="Псевдонимы" href="#Псевдонимы">Псевдонимы</a>

Псевдонимы задаются с помощью ключевого слова `import`.

`import <псевдоним> = <имя_пространства_имен>.<экспортируемый_тип>;`

> `import employee = Data.Personnel.Employee;`

## <a id="Модули" href="#Модули">Модули</a>

TypeScript поддерживает работу с модулями. Модули являются концепцией, привнесенной стандартом ES2015.

Модули в некотором смысле похожи на пространства имен: они могут заключать различные классы, интерфейсы, функции, объекты. Модули выделяются в отдельные файлы. При этом модули подключаются в приложение не посредством тега `<script>`, а с помощью загрузчика модулей.

Работают аналогично модулям ES2015.

## <a id="Заголовочные-файлы" href="#Заголовочные-файлы">Заголовочные файлы</a>

Для установки связи с внешними файлами скриптов javascript в TS служат декларативные или заголовочные файлы. Это файлы с расширением `.d.ts`, они описывают синтаксис и структуру функций и свойств, которые могут использоваться в программе, не предоставляя при этом конкретной реализации. Их действие во многом похоже на работу файлов с расширением `.h` в языках C/C++. Они выполняют своего рода роль оберток над библиотеками JavaScript.

С помощью ключевого слова `declare` в программу на TS подключается определение глобальной переменной.

```typescript
declare var globalVar: string;
declare function display(): void;
```

Подключение с помощью: `/// <reference path="globals.d.ts" />`.

## <a id="Декораторы" href="#Декораторы">Декораторы</a>

Декораторы являются инструментом декларативного программирования, они позволяют добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода.

Декораторы представляют функции, которые могут применяться к классам, методам, методом доступа (геттерам и сеттерам), свойствам, параметрам.

Включаются с помощью `"experimentalDecorators": true`.

### <a id="Декораторы-классов" href="#Декораторы-классов">Декораторы классов</a>

Декоратор класса представляет функцию, которая принимает один параметр:

`function <декоратор>(constructor: Function) {...}`

В качестве параметра выступает конструктор класса.

Для применения декоратора используется знак `@`. Сам декоратор ставится перед названием класса: `@<декоратор>`.

Также декораторы могут изменять результат работы конструктора. В этом случае определение функции декоратора немного меняется, но она также в качестве параметра принимает конструктор класса:

`function <декоратор><TFunction extends Function>(target: TFunction): TFunction {...}`

В самом декораторе передаваемый конструктор target никак не используется. Но создается новый конструктор который и возвращается `return <TFunction><новый_конструктор>;`.

```typescript
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}
@sealed
class User {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    print(): void {
        console.log(this.name);
    }
}
```

### <a id="Декоратор-метода" href="#Декоратор-метода">Декоратор метода</a>

Декоратор метода также представляет функцию, которая принимает три параметра:

`function <декоратор>(target: any, propertyName: string, descriptor: PropertyDescriptor) {...}`

Декоратор принимает следующие параметры:
- `target` - функция конструктора класса для статического метода, либо прототип класса для обычного метода;
- `propertyName` - название метода;
- `descriptor` - объект интерфейса `PropertyDescriptor`.

```typescript
interface PropertyDescriptor {
    configurable?: boolean;
    enumerable?: boolean;
    value?: any;
    writable?: boolean;
    get? (): any;
    set? (v: any): void;
}
```

Этот объект описывает изменение декорируемого метода. Его свойство `value` содержит определение функции. Свойство `writable` указывает, является ли функция модифицируемой (если значение `true`, то является).

Указывается перед описанием метода.

### <a id="Декораторы-параметров-методов" href="#Декораторы-параметров-методов">Декораторы параметров методов</a>

Декоратор параметра метода представляет функцию, которая принимает три параметра:

`function <декоратор>(target: Object, propertyKey: string, parameterIndex: number) {...}`

Где `target` - представляет конструктор класса, если метод статический, либо прототип класса, если метод нестатический, `propertyKey` - представляет имя параметра, `parameterIndex` - представляет порядковый индекс параметра в списке параметров.

### <a id="Декораторы-свойств" href="#Декораторы-свойств">Декораторы свойств</a>

Декоратор свойства представляет функцию, которая принимает два параметра:

`function <декоратор>(target: Object, propertyKey: string) {...}`

Где `target` - представляет конструктор класса, если свойство статическое, либо прототип класса, если свойство нестатическое, `propertyKey` - представляет имя свойства.

В функциях декораторов методов, свойств `this` - указывает на текущий экземпляр класса.

```typescript
class User {
    @format
    name: string;
    @logMethod
    setName(@logParameter name: string) {
        this.name = name;
    }
}
```

### <a id="Декоратор-метода-доступа" href="#Декоратор-метода-доступа">Декоратор метода доступа</a>

Декоратор метода доступа принимает три параметра:

`function <декоратор>(target: Object, propertyName: string, descriptor: PropertyDescriptor) {...}`

Декоратор принимает следующие параметры:
- `target` - функция конструктора класса для статического метода, либо прототип класса для обычного метода;
- `propertyName` - название метода;
- `descriptor` - объект интерфейса `PropertyDescriptor`.

## <a id="Фабрики-декораторов" href="#Фабрики-декораторов">Фабрики декораторов</a>

Фабрика декоратора представляет функцию, которая в свою очерель возвращает функцию декоратора.

```typescript
function <фабрика_декораторов>(<параметры>) {
    ...
    return function <декоратор>(...) {}
}
```

```typescript
function regex(pattern: string) {
    const expression = new RegExp(pattern);
    return function regex(target: Object, propertyName: string) {
        let propertyValue = this[propertyName];
        const getter = function () {
            return propertyValue;
        };
        const setter = function (newVal) {
            let isValid: boolean = expression.test(newVal);
            if (isValid === false) {
                throw new Error(`Value ${newVal} does not match ${pattern}`);
            } else {
                console.log(`${newVal} is valid`);
            }
        };
        if (delete this[propertyName]) {
            Object.defineProperty(target, propertyName, {
                get: getter,
                set: setter
            });
        }
    }
}
class Account {
    @regex("^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$")
    email: string;
    @regex("^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$")
    phone: string;
    constructor(email: string, phone: string) {
        this.email = email;
        this.phone = phone;
    }
}
```

## <a id="TODO-delete" href="#TODO-delete">TODO: delete</a>

[^ \n]+  +(?!\n)

–|—

:\n\n

(\S) $|(\S) {3,}\n|^ +$

^\s*- .*[^;:]$

[^ ]( |   )$