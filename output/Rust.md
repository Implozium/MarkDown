[Содержание](#Содержание)
==========

- [Установка](#Установка)
- [Cargo](#Cargo)
    - [Ручная компиляция](#Ручная-компиляция)
- [Основы](#Основы)
    - [Точка входа](#Точка-входа)
    - [Переменные и изменяемость](#Переменные-и-изменяемость)
    - [Типы данных](#Типы-данных)
        - [Скалярные типы](#Скалярные-типы)
            - [Целочисленные типы](#Целочисленные-типы)
            - [Типы с плавающей точкой](#Типы-с-плавающей-точкой)
            - [Булев тип](#Булев-тип)
            - [Символьный тип](#Символьный-тип)
        - [Составные типы](#Составные-типы)
            - [Кортежный тип](#Кортежный-тип)
            - [Массив](#Массив)
    - [Сложные типы](#Сложные-типы)
    - [Функции](#Функции)
        - [Инструкции и выражения](#Инструкции-и-выражения)
    - [Комментарии](#Комментарии)
    - [Управление потоком](#Управление-потоком)
        - [Выражения `if`](#Выражения-if)
        - [Повторение с помощью циклов](#Повторение-с-помощью-циклов)
            - [`loop`](#loop)
            - [`while`](#while)
            - [`for`](#for)
- [Макрокоманды](#Макрокоманды)
- [Концепция владения](#Концепция-владения)
    - [Ссылки и заимствование](#Ссылки-и-заимствование)
        - [Изменяемые ссылки](#Изменяемые-ссылки)
        - [Срезовый тип](#Срезовый-тип)
            - [Строковые срезы](#Строковые-срезы)
            - [Другие срезы](#Другие-срезы)
- [Структуры](#Структуры)
    - [Кортежные структуры](#Кортежные-структуры)
    - [Методы](#Методы)
    - [Связанные функции](#Связанные-функции)
- [Перечисления и сопоставление с паттернами](#Перечисления-и-сопоставление-с-паттернами)
    - [Выражение match как оператор управления потоком](#Выражение-match-как-оператор-управления-потоком)
    - [Сжатое управление потоком с помощью if let](#Сжатое-управление-потоком-с-помощью-if-let)
    - [Перечисление Option](#Перечисление-Option)
- [Управление проектами](#Управление-проектами)
    - [Пакеты и упаковки](#Пакеты-и-упаковки)
    - [Модули и `use`](#Модули-и-use)
- [Общие коллекции](#Общие-коллекции)
    - [Векторы `Vec<T>`](#Векторы-VecT)
    - [Строковый тип `String`](#Строковый-тип-String)
    - [Хеш-отображения `std::collections::HashMap`](#Хеш-отображения-stdcollectionsHashMap)

<a id="Установка" href="#Установка">Установка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

`curl https://sh.rustup.rs -sSf | sh` - для MacOS и Linux.

`rustup update` - производит обновление языка.

`rustup self uninstall` - производит удаление инструмента.

`rustc ––version` - выводит версию языка.

`rustup doc` - открывает локальную документацию в браузере.

<a id="Cargo" href="#Cargo">Cargo</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

Система сборки и пакетный менеджер языка Rust.

`cargo --version` - выводит версию.

`cargo new <имя_проекта>` - создает новый проект, в каталоге `<имя_проекта>` котором будет инициирован репозиторий git с файлом `.gitignore`, каталог `src` в котором будет находиться исходный код с файлом `main.rs` внутри. Также в каталоге проекта будет файл `Cargo.toml` со структурой:

```toml
[package]
name = "<имя_проекта>"
version = "0.1.0"
authors = ["Ваше имя <you@example.com>"]
edition = "2018"
[dependencies]
<имя_упаковки> = "<версия>"
```

`cargo new --lib <имя_проекта>` - создаст проект, аналогично предыдущему, только библиотечный с главным файлом `src/lib.rs`.

`cargo build` - создает исполняемый файл `target/debug/<имя_проекта>`. После выполнения создасться файл `Cargo.lock` который отслеживает точные версии зависимостей в проекте.

`cargo build --release` - создает релизный файл `target/release/<имя_проекта>`.

`cargo run` - создает исполняемый файл и сразу же его выполянет, если ничего не менялось в исходных файлах, то просто его выполянет.

`cargo check` - проверяет исходный код, чтобы убедиться в его компилируемости.

`cargo update` - обновляет упаковки.

## <a id="Ручная-компиляция" href="#Ручная-компиляция">Ручная компиляция</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`rustc <имя_файла>.rs` - производит компиляцию файла.

<a id="Основы" href="#Основы">Основы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

## <a id="Точка-входа" href="#Точка-входа">Точка входа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```rust
fn main() {
    // ...
}
```

## <a id="Переменные-и-изменяемость" href="#Переменные-и-изменяемость">Переменные и изменяемость</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Переменные именуются в стиле **snake_case** - змеином_регистре.

`let [mut] <имя_переменной>[: <тип>] = <значение>;` - объявление неизменяемой [с `mut` изменяемой] переменной с указанным значением и автовыводом типа [с указаным типом `<тип>`].
> `let x = 5;`  
> `let guess: u32 = "42".parse().expect("Не является числом!");`

Переменные можно затенять, то есть повторно их объявлять с одиноковым именем, при этом можно изменять тип. Главное отличие от `mut` то, что можно выполнить множество трансформаций значения, но после всех трансформаций переменная будет неизменяемой.
```rust
let spaces = " ";
let spaces = spaces.len();
```

Константы именуются в стиле **SCREAMING_SNAKE_CASE** - КРИЧАЩЕМ_ЗМЕИНОМ_РЕГИСТРЕ.

`const <ИМЯ_КОНСТАНТЫ>: <тип> = <значение>;` - объявление константы с указанным значением и типом.
> `const MAX_POINTS: u32 = 100_000;`

## <a id="Типы-данных" href="#Типы-данных">Типы данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Скалярные-типы" href="#Скалярные-типы">Скалярные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="Целочисленные-типы" href="#Целочисленные-типы">Целочисленные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Целое число - это число без дробной составляющей.

Длина   | Знаковый   | Беззнаковый
------- | ---------- | -----------
8 бит   | `i8`       | `u8`
16 бит  | `i16`      | `u16`
32 бит  | `i32`      | `u32`
64 бит  | `i64`      | `u64`
128 бит | `i128`     | `u128`
arch    | `isize`    | `usize`

Типы `isize` и `usize` зависят от типа компьютера, на котором выполняется программа: 64 бита, если используется 64-битная архитектура, и 32 бита, если 32-битная архитектура.

Типы `isize` или `usize` по преимуществу используются в индексировании коллекции.

`_` можно применять в качестве визуального разделителя разрядов.

Системы счисления:
- `0x<значение>` - число в 16 системе.
    > 0xff
- `0o<значение>` - число в 8 системе.
    > 0o77
- `0b<значение>` - число в 2 системе.
    > 0b1111_1111
- `b'<значение>'` - число в байтовой системе.
    > b'A'

#### <a id="Типы-с-плавающей-точкой" href="#Типы-с-плавающей-точкой">Типы с плавающей точкой</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Тип `f32` представляет собой вещественное число с одинарной точностью, а `f64` имеет двойную точность. По умолчанию используется `f64`. Всегда должны иметь `.` в значении.

#### <a id="Булев-тип" href="#Булев-тип">Булев тип</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Тип `bool` имеет два возможных значения: `true` и `false`.

#### <a id="Символьный-тип" href="#Символьный-тип">Символьный тип</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Тип `char` равен четырем байтам и представляет собой скалярное значение Юникод и задается одинарными кавычками.
> `let z = 'ƶ';`

### <a id="Составные-типы" href="#Составные-типы">Составные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Составные типы группируют многочисленные значения в один тип.

#### <a id="Кортежный-тип" href="#Кортежный-тип">Кортежный тип</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Кортеж** - это часто встречающийся способ группирования ряда других значений с разнообразными типами в один составной тип. Кортежи имеют фиксированную длину: после объявления они не могут увеличиваться или уменьшаться в размере.

Кортеж создают, записывая список значений через запятую внутри круглых скобок. Каждая позиция в кортеже имеет свой тип, а типы разных значений в кортеже не обязательно должны быть одинаковыми.

`let <кортеж>: (<тип1>[, <тип2>[, ...]]) = (<значение1>[, <значение2>[, ...]]);`
> `let tup: (i32, f64, u8) = (500, 6.4, 1);`

Для доступа к значениям кортежа используется **деструктурирование**:  
`let (<переменная1>[, <переменная2>[, ...]]) = <кортеж>;` - значения кортежа запишутся в отдельные переменные.
> `let (x, y, z) = tup;`

Или доступ по индексу (начиная с 0):  
`let <переменная> = <кортеж>.<индекс>;`
> `let one = tup.0;`

#### <a id="Массив" href="#Массив">Массив</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имеет фиксированную длину, где каждый элемент массива должен иметь один и тот же тип. Массив представляет собой отдельную часть памяти, выделенную в стеке.

`let <массив>: [<тип>; <количество>] = [<значение1>[, <значение2>[, ...]]];`
> `let a: [i32; 5] = [1, 2, 3, 4, 5];`

`let <массив>: [<тип>; <количество>] = [<значение_по_умолчанию>; <количество>];` - заполнение значением по умолчанию всех элементов массива.
> `let a = [3; 5];`

Для доступа к значениям массива используется доступ по индексу (начиная с 0):  
`let <переменная> = <массив>[<индекс>];`
> `let one = a[0];`

`<массив>.len();` - возвращает длину массива.

## <a id="Сложные-типы" href="#Сложные-типы">Сложные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Хранятся в куче.

## <a id="Функции" href="#Функции">Функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имя функции пишется в змеином_регистре.

Языку Rust все равно, где определены функции; главное, чтобы они были где-то определены.

```rust
fn <имя_функции>([<аргумент1>: <тип>[, <аргумент2>: <тип>[, ...]]]) [-> <тип_возвращаемого_значения>] {
    // <код>
}
```

```rust
fn another_function(x: i32, y: i32) {
    println!("Значение x равно {}", x);
    println!("Значение y равно {}", y);
}
```

### <a id="Инструкции-и-выражения" href="#Инструкции-и-выражения">Инструкции и выражения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Инструкции - не возвращают значения.

Вызов функции является выражением. Вызов макрокоманды является выражением. Блок, который используется для создания новых областей, `{}`, является выражением. Выражения не включают конечные точки с запятой. Если добавляется точка с запятой в конец выражения, то оно превращается в инструкцию, которая в таком случае не возвращает значение.

```rust
let y = {
    let x = 3;
    x + 1
};
```

Можно вернуться из функции досрочно, используя ключевое слово `return` и указав значение, но большинство функций неявным образом возвращают последнее выражение.

```rust
fn five() -> i32 {
    5
}
```

Если функция не возвращает значение, то она возвращает по умолчанию пустой кортеж `()`.

## <a id="Комментарии" href="#Комментарии">Комментарии</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`// <комментарий>`

## <a id="Управление-потоком" href="#Управление-потоком">Управление потоком</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Выражения-if" href="#Выражения-if">Выражения `if`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Выражение `if` позволяет ветвить код в зависимости от условий. Условия должны возвращать булевый тип.

```rust
if <условие> {
    // код истиности условия
}[ else if <условие2> {
    // код истиности условия2 и ложности предыдущих условий
}][ else {
    // код ложности
}]
```

```rust
let number = 6;
if number % 3 == 0 {
    println!("число делится на 3");
} else if number % 2 == 0 {
    println!("число делится на 2");
} else {
    println!("число не делится на 3 и 2");
}
```

Выражение `if` можно присваивать переменным, так как блоки `{}`, являются выражением и возвращают значения. Возвращаемые значения должны быть одного типа.

```rust
let <переменная> = if <условие> {
    // код истиности условия
    <значение>
}[ else if <условие2> {
    // код истиности условия2 и ложности предыдущих условий
    <значение>
}][ else {
    // код ложности
    <значение>
}];
```

```rust
let condition = true;
let number = if condition {
    5
} else {
    6
};
```

### <a id="Повторение-с-помощью-циклов" href="#Повторение-с-помощью-циклов">Повторение с помощью циклов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`break` - прерывает выполнение цикла.

`continue` - прерывает текущую итерацию цикла.

#### <a id="loop" href="#loop">`loop`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Выполняется бесконечно.

```rust
loop {
    // код итерации цикла
}
```

```rust
loop {
    println!("еще раз!");
}
```

Выражение `loop` можно присваивать переменным, как и в случае `if`. Для этого используется конструкция `break <значение>;` внутри цикла.

```rust
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};
```

#### <a id="while" href="#while">`while`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Выполняется пока условие истино.

```rust
while <условие> {
    // код итерации цикла
}
```

```rust
let mut number = 3;
while number != 0 {
    println!("{}!", number);
    number = number - 1;
}
```

#### <a id="for" href="#for">`for`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Выполняет, пока не переберет коллекцию.

```rust
for <переменная> in <коллекция> {
    // код итерации цикла
}
```

```rust
let a = [10, 20, 30, 40, 50];
for element in a.iter() {
    println!("Значение равно {}", element);
}
```

<a id="Макрокоманды" href="#Макрокоманды">Макрокоманды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

`print!("<текст> {} <текст>"[, <значение1>[, ...]]);` - производит вывод текста в консоль. Заменяет все `{}` на значения последующих значений.  
`println!("<текст> {} <текст>"[, <значение1>[, ...]]);` - аналогично `print!`, только вконце переносит текст на новую строку.

Спецификаторы:
- `{}` - вывод простого значения или строки;
- `{:?}` - вывод значения с помощью типажа `#[derive(Debug)]`;
- `{:#?}` - расширенный вывод значения.

<a id="Концепция-владения" href="#Концепция-владения">Концепция владения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==================

Владеть можно значениями, которые выделяются в куче. Так как типы, размер которых во время компиляции известен, хранятся полностью в стеке, и поэтому копии фактических значений создаются быстро.

Правила владения:
- Каждое значение в языке Rust имеет переменную, которая называется его владельцем.
- В каждый момент времени может существовать только один владелец.
- Если владелец выйдет из области видимости `{}`, значение будет отброшено методом *drop*.

Во время переприсваивания переменной, которая ссылается на значение, выделенное на куче, другой переменной, то **владение** значением устанавливается на второй переменной и первой переменной нельзя пользоваться - т.е. изменять или передавать в функции. Это все делает недействительной первую переменную, эта операция называется "*перемещение*" (*move*).

```rust
let s1 = String::from("hello");
let s2 = s1; // после этого переменная s1 не действительна
```

Владение переменной всякий раз следует одному и тому же паттерну: присвоение (передача) значения другой переменной перемещает его. Если переменная, содержащая данные в куче, выходит из области видимости, то значение будет очищено методом *drop*, если только данные не были перемещены в другую переменную.

Передача переменной функции приведет к перемещению или копированию, так же как и присвоение значения переменной. Если попытаться использовать переменную после передачи ее в функцию, то будет ошибка.

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s); // значение s перемещается в функцию...
                        // ... и поэтому больше здесь не действует
}
fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}
```

Возвращаемые значения также передают владение.

## <a id="Ссылки-и-заимствование" href="#Ссылки-и-заимствование">Ссылки и заимствование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Амперсанды `&` являются ссылками, они позволяют ссылаться на некое значение, не беря его во владение.

Синтаксис `&<переменная>` позволяет создать ссылку, которая ссылается на значение переменной `<переменная>`, но не владеет им. Поскольку она не является ее владельцем, значение, на которое ссылка указывает, не будет отброшено, когда ссылка выйдет из области видимости.

Синтаксис `&<тип>` - обозначает ссылочный тип.

```rust
let str = String::from("hello");
let str2: &String = &str;
println!("len {}, {}", str.len(), str2.len());
```

### <a id="Изменяемые-ссылки" href="#Изменяемые-ссылки">Изменяемые ссылки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имеют вид `&mut <переменная>` для переменных и `&mut <тип>` для типа. Могут быть переменные только с модификатор `mut`.

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

Изменяемые ссылки имеют одно существенное ограничение: может быть только одна изменяемая ссылка на отдельный фрагмент данных в отдельной области видимости. Преимущество этого ограничения в том, что Rust предотвращает гонку данных во время компиляции. При выходе изменяемой ссылки за область видимости, можно создать новую изменяемую ссылку.

```rust
let mut s = String::from("hello");
{
    let r1 = &mut s;
}
let r2 = &mut s;
```

Нельзя создать изменяемую ссылку, если есть уже неизменяемая.

Основные правила ссылок:
- В любой момент времени может быть один из двух вариантов, но не оба: одна изменяемая ссылка либо любое число неизменяемых ссылок.
- Ссылки всегда должны быть действительными, то есть ссылки нельзя передавать на уровень выше, чем было объвление переменной.

### <a id="Срезовый-тип" href="#Срезовый-тип">Срезовый тип</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Срезы позволяют ссылаться не на всю коллекцию, а на сплошную последовательность элементов в коллекции. Срезы - это ссылки.

`<начальный_индекс>..<конечный_индекс>` - интервальный синтаксис, создает интервал от индекса `<начальный_индекс>` и до `<конечный_индекс>`, но не включая его. Если не указывать `<начальный_индекс>`, то он будет равен `0`. Если не указывать `<конечный_индекс>`, то он будет равен длине.

#### <a id="Строковые-срезы" href="#Строковые-срезы">Строковые срезы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это ссылка на часть значения типа `String`. Имеет тип `&str`.

`let <срез> = &<строка>[<начальный_индекс>..<конечный_индекс>];` - создает срез из строки от индекса `<начальный_индекс>` и до `<конечный_индекс>`, но не включая его. Если не указывать `<начальный_индекс>`, то он будет равен `0`. Если не указывать `<конечный_индекс>`, то он будет равен длине строки.

```rust
let s = String::from("hello");
let len = s.len();
let slice: &str = &s[0..len];
let slice = &s[..];
```

**Строковые литералы** - это срезы и являются неизменяемыми, так как `&str` - это неизменяемая ссылка.
> `let s = "Hello, world!";`

#### <a id="Другие-срезы" href="#Другие-срезы">Другие срезы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для массивов срезы имеют тип `&[<тип_массива>]` и работают по аналогии со строковыми.

```rust
let arr: [f64; 3] = [0.1, 0.2, 0.3];
let slice: &[f64] = &arr[0..2];
```

<a id="Структуры" href="#Структуры">Структуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

Структура, или `struct`, - это настраиваемый тип данных, который позволяет именовать и упаковывать вместе несколько связанных значений, составляющих смысловую группу.

Объявление структуры:
```rust
struct <ИмяСтруктуры> {
    <поле1>: <тип>,
    [<поле2>: <тип>,]
    [...]
}
```

```rust
struct User {
    username: String,
    sign_in_count: u64,
    active: bool,
}
```

Создание структуры:
```rust
let <структура> = <ИмяСтруктуры> {
    <поле1>: <значение>,
    [<поле2>: <значение>,]
    [...,]
};
```

```rust
let mut user = User {
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
```

`<структура>.<поле>` - доступ к значению поля. Изменять поля структуры можно только, если весь экземпляр структуры изменяемый, то есть имеет модификатор `mut`.
> `user.username = String::from("noname");`

Если переменные совпадают по имени и типу в структуре, то можно использовать сокращенный синтаксис присвоения значений только по имени переменной в создании структуры.
```rust
fn build_user(username: String) -> User {
    User {
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

Для обновления экземпляра структуры другой подобной структурой используется синтаксис обновления структуры:
```rust
let <структура> = <ИмяСтруктуры> {
    <поле1>: <значение>,
    [<поле2>: <значение>,]
    [...,]
    ..<структура_источник_значений>
};
```

Этот синтаксис указывает на то, что остальные поля, не заданные явно, должны иметь то же значение, что и поля в конкретном экземпляре.

```rust
let user2 = User {
    username: String::from("anotherusername567"),
    ..user1
};
```

## <a id="Кортежные-структуры" href="#Кортежные-структуры">Кортежные структуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`struct <ИмяСтруктуры>(<тип1>[, <тип2>[, ...]])` - объявление.
> `struct Color(i32, i32, i32);`

`let <структура> = <Имя>(<значение1>[, <значение2>[, ...]]);` - создание.
> `let black = Color(0, 0, 0);`

Можно создать пустые структуры, которые ведут себя аналогично `()`, типу `unit`, пустому типу.

## <a id="Методы" href="#Методы">Методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объявляет метод `<метод>` для структуры `<ИмяСтруктуры>`, где `&self` обозначает ссылку на текущий экземпляр структуры, для которого вызывается метод и имеет тип `&<ИмяСтруктуры>`.
```rust
impl <ИмяСтруктуры> {
    fn <метод1>(&self[, <аргумент1>: <тип>[, <аргумент2>: <тип>[, ...]]]) [-> <тип_возвращаемого_значения>] {
        // ...
    }
    // ...
}
```

Чтобы была возможность изменять структуру в методе используется вместо параметра `&self` параметр `&mut self`. Для владения используется `self`.

Для вызова метода используется синтаксис:  
`<структура>.<метод1>([<значение1>[, <значение2>[, ...]]]);`

Это аналогично вызову `(&<структура>).<метод1>([<значение1>[, <значение2>[, ...]]]);`.

Каждая структура может иметь несколько блоков `impl`.

```rust
struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Площадь прямоугольника равна {} квадратным пикселам.", rect1.area());
}
```

## <a id="Связанные-функции" href="#Связанные-функции">Связанные функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это функции, которые объявляются в `impl <ИмяСтруктуры> { ... }`, но не используют параметр `self`, то есть экземпляр структуры.

Вызываются через использования пространства имен структуры, с помощью синтаксиса `::`:  
`<ИмяСтруктуры>::<функция1>([<значение1>[, <значение2>[, ...]]]);`



```rust
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}
fn main() {
    let sq = Rectangle::square(3);
}
```

<a id="Перечисления-и-сопоставление-с-паттернами" href="#Перечисления-и-сопоставление-с-паттернами">Перечисления и сопоставление с паттернами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========================================

Объявление перечисления:
```rust
enum <ИмяПеречисления> {
    <вариант1>,
    <вариант2>(<тип1>[, <тип2>[, ...]]),
    <вариант3> { <поле1>: <тип>[, ...] },
    [...]
}
```

Где возможны варианты:
- `<вариант1>` - вариант, который не имеет связанных с ним данных;
- `<вариант2>` - вариант, который включает в себя анонимную структуру;
- `<вариант3>` - вариант, который включает в себя значения.

Перечесление имеет тип: `<ИмяПеречисления>`. Для использования конкретных вариантов значений перечесления используется:
- `<ИмяПеречисления>::<вариант1>`;
- `<ИмяПеречисления>::<вариант2>(<значение>[, <значение>[, ...]])`;
- `<ИмяПеречисления>::<вариант1> { <поле1>: <значение>[, ...] }`;

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
fn main() {
    let m: Message = Message::Move { x: 3, y: 4 };
}
```

Для перечислений можно определять методы с помощью ключевого слова `impl` точно так же, как для структур.

## <a id="Выражение-match-как-оператор-управления-потоком" href="#Выражение-match-как-оператор-управления-потоком">Выражение match как оператор управления потоком</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Оно позволяет сравнивать значение с серией паттернов, а затем исполнять код, основываясь на том, какой паттерн совпадает. Паттерны могут состоять из буквенных значений, имен переменных, подстановочных знаков и других элементов.

```rust
match <переменная> {
    <ИмяПеречисления>::<вариант1> => <код>,
    <ИмяПеречисления>::<вариант2>(<переменная_перечисления1>[, <переменная_перечисления2>[, ...]]) => <код>,
    <ИмяПеречисления>::<вариант3>(<переменная_структуры>) => <код>,
    _ => <код>,
}
```

Когда выражение match исполняется, оно по порядку сравнивает полученное значение с паттерном каждого рукава. Если паттерн совпадает со значением, то код, связанный с этим паттерном, исполняется. Если этот паттерн не совпадает со значением, то исполнение продолжается и переходит к следующему рукаву.

Количество рукавов должно охватывать все варианты перечисления, если не охватывает, то нужно добавить вариант `_` - заполнитель, который используется как заглушка для всех остальных вариантов. Если вообще не нужно никак обрабатывать, то используется код: `_ => ()`.

```rust
enum UsState {
    Alabama,
    Alaska,
}
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("Четвертак из штата {:?}!", state);
            25
        },
    }
}
```

## <a id="Сжатое-управление-потоком-с-помощью-if-let" href="#Сжатое-управление-потоком-с-помощью-if-let">Сжатое управление потоком с помощью if let</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Синтаксис `if let` позволяет кратко совместить `if` и `let` для обработки значений, которые совпадают с одним паттерном, игнорируя остальные.

```rust
if let <ИмяПеречисления>::<вариант> = <переменная> {
    // код совпадения
}[ else {
    // код ложности
}]
```

```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("Четвертак из штата {:?}!", state);
} else {
    count += 1;
}
```

## <a id="Перечисление-Option" href="#Перечисление-Option">Перечисление Option</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Изпользуется для ситуаций, когда нет значения, как в других языках `null`. Имеет вид:
```rust
enum Option<T> {
    Some(T),
    None,
}
```

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}
let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

<a id="Управление-проектами" href="#Управление-проектами">Управление проектами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====================

## <a id="Пакеты-и-упаковки" href="#Пакеты-и-упаковки">Пакеты и упаковки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Упаковка** (crate) - это двоичный или библиотечный файл.

**Корень упаковки** (crate root) - это исходный файл, с которого компилятор Rust начинает работу, он составляет корневой модуль упаковки.

**Пакет** - это одна или несколько упаковок, которые обеспечивают функциональность. Пакет содержит файл `Cargo.toml`, который описывает то, как создавать эти упаковки.

Пакет должен включать ноль или одну библиотечную упаковку, но не более. Он может содержать столько двоичных упаковок, сколько нужно, но в нем должна быть по крайней мере одна упаковка (библиотечная либо двоичная).

**Cargo** следует соглашению о том, что `src/main.rs` является упаковочным корнем двоичной упаковки с тем же именем, что и пакет.

**Cargo** знает, что если каталог пакета содержит `src/lib.rs`, то указанный пакет содержит библиотечную упаковку с тем же именем, что и пакет, а `src/lib.rs` является его упаковочным корнем. Cargo передает файлы корня упаковки в `rustc` для построения библиотеки или двоичного файла.

Если в пакете есть `src/main.rs` и `src/lib.rs`, то он имеет две упаковки: библиотечную и двоичную - обе с тем же именем, что и пакет. Пакет может иметь несколько двоичных упаковок, помещая файлы в каталог `src/bin`: каждый файл будет отдельной двоичной упаковкой.

Упаковка будет группировать связанную функциональность в область видимости, вследствие чего эту функциональность можно легко использовать совместно в нескольких проектах.

## <a id="Модули-и-use" href="#Модули-и-use">Модули и `use`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяют управлять организацией, областью видимости и приватностью путей.

Модули позволяют организовывать код внутри упаковки в группы для удобства чтения и многоразового использования. Модули также контролируют конфиденциальность элементов, которая заключается в том, может ли элемент использоваться внешним кодом (публичный) или же он является деталью внутренней реализации и не доступен для внешнего использования (конфиденциальный).

Определение модуля:
```rust
mod <имя_модуля> {
    // содержимое
}
```

Внутри модулей могут быть другие модули. Модули также могут содержать определения других элементов, таких как структуры, перечисления, константы, типажи или функции.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
        fn seat_at_table() {}
    }
}
```

Главный модуль - это модуль с именем `crate` ("упаковка").
```
crate
└── front_of_house
    └── hosting
        ├── add_to_waitlist
        └── seat_at_table
```

Путь принимает две формы:
- **Абсолютный путь** начинается с корня упаковки, используя имя упаковки либо литерал `crate` - для файловой системы аналогично `/`;
- **Относительный путь** начинается с текущего модуля и использует `self`, `super` - для файловой системы аналогично `..` или идентификатор в текущем модуле.

Как асолютные, так и относительные пути сопровождаются одним или несколькими идентификаторами, разделенными двойными двоеточиями `::`.

```rust
fn main() {
    // Абсолютный путь
    crate::front_of_house::hosting::add_to_waitlist();
    // Относительный путь
    front_of_house::hosting::add_to_waitlist();
}
```

Элементы в родительском модуле не могут использовать конфиденциальные элементы внутри дочерних модулей, но элементы дочерних модулей могут использовать элементы в своих предковых модулях. Причина этого заключается в том, что дочерние модули обертывают и скрывают детали своей реализации, но они видят контекст, в котором определены.

Добавление ключевого слова `pub` перед сущностью (модулем, функцией, структурой и т.п.) делает модуль публичным.

Если использовать pub перед определением структуры, то это сделает структуру публичной, но поля структуры все равно будут **конфиденциальными**. Можно сделать каждое поле публичным на индивидуальной основе добавив `pub` перед свойством.

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }
    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("персики"),
            }
        }
    }
}
```

Если у публичной структуры есть приватное поле, то должен быть публичная связанная функция, которая конструирует экземпляр структуры.

Если у перечисления стоит модификатор `pub`, то все его варианты будут публичными.

Если что-то определено на одном уровне с модулем, то оно может использовать модуль, даже в том случае, если он не публичный.

`use <имя_модуля>[::<имя_подмодуля>[::...]] [as <алиас>];` - вводит модуль[ или его подструктуры] в область видимости [под указанным алиасом `<алиас>`]. Подобно символической ссылке.
> `use crate::front_of_house::hosting as host;`

Указание относительного пути с помощью `use` начинается с префикса `self`.
> `use self::front_of_house::hosting;`

Добавление `pub` к `use` осуществляет **реэкспорт** указаного модуля наружу.

Идиоматически функции вводятся как часть модуля, где определены, а другие структуры самостоятельно.

Для множественного ввода элементов модуля используется структура:  
`use <имя_модуля>[::<имя_подмодуля>[::...]]::{[self, ]<имя_подмодуля_или_структуры1>[, ...]};` - таким образом будут введены подмодули или структуры [и сам модуль, благодаря ключевому слову `self`].

`use <имя_модуля>[::<имя_подмодуля>[::...]]::*` - вводит все элемены подмодуля в видимость.

Ключевое слово `mod` объявляет модули, и Rust ищет в файле с тем же именем, что и модуль, код, который входит в этот модуль.

`mod <имя_модуля>;` - сообщает языку Rust о том, что нужно загрузить содержимое модуля из другого файла с тем же именем, что и модуль. И тогда можно использовать ввод элементов модуля с помощью `use`:
```rust
mod <имя_модуля>;
use <имя_модуля>[::<имя_подмодуля>[::...]];
```

<a id="Общие-коллекции" href="#Общие-коллекции">Общие коллекции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===============

В отличие от встроенных массивного и кортежного типов, данные, на которые указывают эти коллекции, хранятся в куче, то есть необходимости знать объем данных во время компиляции нет, и они увеличиваются или уменьшаются в ходе выполнения программы. Каждый вид коллекции имеет разные возможности и затраты.

## <a id="Векторы-VecT" href="#Векторы-VecT">Векторы `Vec<T>`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Векторы позволяют хранить более одного значения одного и того же типа в одной структуре данных, которая помещает все значения рядом в памяти.

`let mut <вектор>: Vec<<тип>> = Vec::new();` - создание вектора, с хранением значений определенного типа.  
`let mut <вектор> = vec![<значение1>[, ...]];` - создание вектора через макрокоманду.

`<вектор>.len();` - возвращает длину вектора.

`<вектор>.push(<значение>);` - добавляет значение в вектор.
`<вектор>.insert(<индекс>, <значение>);` - добавляет значение в вектор по указанной позиции, а остальные элементы сдвигает вправо, `<индекс>` должен быть в интервале от 0 и до длины вектора, если он равен ей, то добавляет его в конец.

Как и любая другая структура, вектор высвобождается, когда он выходит из области видимости. Когда вектор отбрасывается, все его содержимое тоже отбрасывается, то есть те значения, которые он содержит, будут очищены.

`let <переменная>: &<тип> = &<вектор>[<индекс>];` - доступ к элементу вектора по индексу `<индекс>`, возвращает ссылку на элемент типа `&<тип>`. При вызове недоступного индекса будет произведена паника.

`let <переменная>: Option<&<тип>> = <вектор>.get(<индекс>);` - доступ к элементу вектора через метод, возвращает его в типе `Option<&<тип>>`.

`let <переменная>: Option<&<тип>> = <вектор>.pop();` - выталкивает из вектора последний элемент и возвращает его в типе `Option<&<тип>>`.

Если у вектора взят первый элемент, то его уже модифицировать нельзя.

Для перебора используется конструкция:
```rust
for <переменная> in &[mut ]<вектор> {
    // код
}
```
Где в переменную `<переменная>` будут последовательно помещаться значения из вектора.

Для модификации элементов используется конструкция с помощью разыменовывания `*`, если это ссылка на элемент или доступ по индексу:
```rust
let mut v = vec![1, 2, 3];
v[0] = 12;
let link = &mut v[2];
*link = 13;
```

## <a id="Строковый-тип-String" href="#Строковый-тип-String">Строковый тип `String`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Строки реализованы как коллекция байтов, плюс некоторые методы обеспечивают полезную функциональность, когда эти байты интерпретируются как текст.

Тип `String` представляет собой обертку для `Vec<u8>`.

Строковые литералы `"<текст>"` типа `&str`, хранятся в двоичном коде программы и поэтому являются строковыми срезами.

`let <строка> = String::new();` - создание строки.  
`let <строка> = String::from(["<текст>"]);` - создание строки [с указанным текстом из строкового литерала].

`let <строка> = <строковый_литерал>.to_string();` - преобразует строковый литерал в строку.

`let <строка2> = <строка>.clone();` - копирует строку.

`<строка>.len();` - возвращает длину строки в байтах.

`<строка>.clear();` - очищает строку.

`<строка>.push_str("<текст>");` - добавляет текст к строке.  
`<строка>.push('<символ>');` - добавляет символ к строке.  
`let <новая_строка> = <строка1> + &<строка2>;` - возвращает строку из двух строк, при это берет `<строка1>` во владение и ее возвращает.  
`let <строка> = format!("<шаблон>", <строка1>[, ...]);` - макрокоманда, которая возвращает строку, которая отформатирована по аналогии с командой `print!`.

Для перебора используется итераторы, которые можно перебрать в `for`:
- `<строка>.chars();` - возвращает коллекцию из символов типа `char`, каждый из которых равен 4 байта;
- `<строка>.bytes();` - возвращает коллекцию из байтов строки типа `u8`, каждый из которых равен 1 байт.
- `<строка>.split_whitespace();` - возвращает коллекцию из слов разбитых по пробелам.

```rust
for c in "Здравствуйте".chars() {
    println!("{}", c);
}
```

## <a id="Хеш-отображения-stdcollectionsHashMap" href="#Хеш-отображения-stdcollectionsHashMap">Хеш-отображения `std::collections::HashMap`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Находятся в стандартной библиотеке: `std::collections::HashMap`.

Хеш-отображения хранят данные в куче. Они однородны: у всех ключей должен быть один и тот же тип, и у всех значений тоже должен быть один и тот же тип.

`let <хеш>: HashMap<<тип_ключа>, <тип_значения>> = HashMap::new();` - создание.

`<хеш>.insert(<ключ>, <значение>);` - вставка значения по ключу в хеш-отображение.  
`<хеш>.entry(<ключ>).or_insert(<значение>);` - вставка значения по ключу в хеш-отображение, если этого ключа нет в хеше и возвращает изменяемую ссылку на значение этого ключа `&mut V`.

`let <переменная>: Option<&<тип>> = <хеш>.get(<ключ>);` - доступ к значению по ключу хеша, возвращает его в типе `Option<&<тип>>`.

Для перебора используется цикл `for`:
```rust
for (<переменная_ключа>, <переменная_значения>) in &<хеш> {
    // ...
}
```