[Содержание](#Содержание)
==========

- [Командная строка](#user-content-Командная-строка)
    - [`$GOPATH`](#user-content-GOPATH)
- [Точка входа](#user-content-Точка-входа)
- [Система типов](#user-content-Система-типов)
    - [Переменные](#user-content-Переменные)
    - [Типы](#user-content-Типы)
        - [Числа](#user-content-Числа)
            - [Целые числа](#user-content-Целые-числа)
            - [Числа с плавающей точкой](#user-content-Числа-с-плавающей-точкой)
        - [Булевы значения](#user-content-Булевы-значения)
        - [Символы](#user-content-Символы)
        - [Строки](#user-content-Строки)
        - [Пользовательские типы](#user-content-Пользовательские-типы)
    - [Псевдонимы](#user-content-Псевдонимы)
    - [Константы](#user-content-Константы)
    - [Перечисления](#user-content-Перечисления)
    - [Область видимости](#user-content-Область-видимости)
    - [Композитные типы](#user-content-Композитные-типы)
        - [Указатели](#user-content-Указатели)
        - [Массивы](#user-content-Массивы)
            - [Слайсы](#user-content-Слайсы)
        - [Ассоциативный массив](#user-content-Ассоциативный-массив)
- [Управление потоком выполнения](#user-content-Управление-потоком-выполнения)
    - [Операторы ветвления](#user-content-Операторы-ветвления)
        - [Условие if - else](#user-content-Условие-if---else)
        - [Условие switch - case](#user-content-Условие-switch---case)
    - [Циклы](#user-content-Циклы)
        - [Метка](#user-content-Метка)
- [Функции](#user-content-Функции)
    - [Особенные функции](#user-content-Особенные-функции)
    - [Оператор отложенного вызова](#user-content-Оператор-отложенного-вызова)
- [Пакеты](#user-content-Пакеты)
    - [Структура приложения](#user-content-Структура-приложения)
    - [Модули](#user-content-Модули)
- [ООП](#user-content-ООП)
        - [Структуры](#user-content-Структуры)
    - [Методы](#user-content-Методы)
    - [Интерфейсы](#user-content-Интерфейсы)
        - [Пустой интерфейс](#user-content-Пустой-интерфейс)
            - [`switch` с приведением типов](#user-content-switch-с-приведением-типов)
    - [Рефлексия](#user-content-Рефлексия)
- [Обработка ошибок](#user-content-Обработка-ошибок)
- [Стандартные пакеты](#user-content-Стандартные-пакеты)
    - [Пакет `fmt`](#user-content-Пакет-fmt)
    - [Пакет `io`](#user-content-Пакет-io)
    - [Пакет `errors`](#user-content-Пакет-errors)

<a id="Командная-строка" href="#Командная-строка">Командная строка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
================

Исходный код хранится в файлах с расширением `.go`.

`go build <файл>` - компилирует исходный код из файла `<файл>` в бинарный файл.  
`go run <файл>` - компилирует исходный код из файла `<файл>` в бинарный файл и запускает его.  
`go generate` - запускает кодогенерацию.  
`go install <path>` - скачивает исходные коды программы по пути `<path>`, компилирует ее и устанавливает бинарный файл в `$GOPATH/bin`.

`go get <имя_модуля>` - скачивает зависимость и устанавливает ее в файл `go.mod`.  
`go mod init <имя_модуля>` - создает файл со списком зависимостей - модуль.  
`go mod tidy` - актуализирует файл со списком зависимостей.  
`go mod vendor` - "вендорит" зависимости - копирует весь исходный код зависимостей в каталог `vendor` проекта.

`go test` - запускает юнит-тесты.  
`go tool cover` - собирает отчет о покрытии кода юнит-тестами.  
`go tool pprof` - профилирует программу.

`go fmt` - автоформатирует исходный код.  
`go imports` - автоформатирует исходный код и импорты.  
`go vet` - запускает линтеры.  
`go env` - выводит список переменных окружения.  
`go env <переменная>` - выводит значение переменной окружения.  
`go env -w <переменная>=<значение>` - устанавливает значение переменной окружения.

`go help <команда>` - выводит справку по команде `<команда>`.

`GOPROXY=<url>,direct` - устанавливает прокси для скачивания зависимостей.

## <a id="GOPATH" href="#GOPATH">`$GOPATH`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это каталог, где Go хранит установленные бинарники, скачанные зависимости и служебные файлы.

Структура каталога такая:

```
$GOPATH
├──bin # здесь лежат бинарники программ, устанавливаемых командой 'go install'
|    └──<программа> # исполняемый файл программы <программа>
├──src
|    └──<источник>
|         └──<программа>
|              └──main.go # исходный код программы <программа>
└──pkg # тут Go хранит служебные файлы
```

<a id="Точка-входа" href="#Точка-входа">Точка входа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===========

```go
package main
func main() {
}
```

<a id="Система-типов" href="#Система-типов">Система типов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=============

## <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Все переменные имеют значение по умолчанию и они изменяемые.

`var <имя_переменной> <тип>` - обявление переменной с определенным типом.  
`var <имя_переменной_1>[, ...] <тип>` - множественное обявление переменных с определенным типом.
> `var a, b int`

`<имя_переменной> = <значение>` - установка значения переменной.  
`<имя_переменной_1>[, ...] = <значение>[, ...]` - множественная установка значения переменных.
> `a, b = 5, 10`

`var <имя_переменной>[ <тип>] = <значение>` - обявление переменной с определенным значением и выводом типа на основе значения [устанавливает указанный].
> `var b = 10`

`<имя_переменной> := <значение>` - короткая нотация обявления переменной с определенным значением и выводом типа на основе значения.  
`<имя_переменной_1>[, ...] := <значение>[, ...]` - короткая нотация для множественного обявления переменных с определенными значениями и выводом типа на основе значения.
> `pi, e := 3.1415, 2.7183`

Групировочная нотация объявления переменных:
```go
var (
    <имя_переменной_1>[ <тип>][ = <значение>]
    [...]
)
```

**Пустой идентификатор** `_` играет роль временного идентификатора в операциях присваивания, где ожидается переменная, и сбрасывает любые присваиваемые ему значения. Сообщает компилятору, что значение ему не потребуется и его можно не вычислять.

## <a id="Типы" href="#Типы">Типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<тип>(<переменная>)` - приводит переменную к типу `<тип>` и возвращает значение этого типа.
> `string(10)`

### <a id="Числа" href="#Числа">Числа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для числовых типов доступны следующие арифметические операции:
- `+` - сложение;
- `-` - вычитание;
- `*` - умножение;
- `/` - деление нацело;
- `%` - остаток от деления.

И имеют сокращенную запись с присваиванием: `<переменная> <операция>= <значение>`.

`<переменная>++` - инкремент переменной.  
`<переменная>--` - декремент переменной.

Значение по умолчанию: `0`.

#### <a id="Целые-числа" href="#Целые-числа">Целые числа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Бывают:
- знаковые: `int`, `int8`, `int16`, `int32`, `int64`;
- беззнаковые: `uint`, `uint8`, `uint16`, `uint32`, `uint64`.

Где `int` и `uint` зависят от разрядности системы и могут быть: `int32` / `uint32` для 32 разрядной системы, `int64` / `uint64` для 64.

Тип `byte` - это псевдоним типа `uint8`.  
Тип `rune` - это псевдоним типа `int32`.

Способы записи:
- `<число_в_десятичной_системе>`;
- `0b<число_в_двоичной_системе>`;
- `0x<число_в_шестнадцатеричной_системе>`;
- `0<число_в_восьмеричной_системе>`.

Разряды можно разделять с помощью символа `_`:
> 1_000_000

#### <a id="Числа-с-плавающей-точкой" href="#Числа-с-плавающей-точкой">Числа с плавающей точкой</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Бывают:
- комплексные: `complex64`, `complex128`;
- вещественные: `float32`, `float64`.

Способы записи:
- `<число_в_десятичной_системе>.<число_в_десятичной_системе>`;
- `complex(r, i)` - значение типа `complex128` с указанной действительной `r` и мнимой `i` частями, обе типа `float64`;
- `<реальная_часть> + <мнимая_часть>i`.

Функции:
- `real(<cx>)` - возвращает действительную часть числа `<cx>` типа `complex128` как число типа `float64`;
- `imag(<cx>)` - возвращает мнимую часть числа `<cx>` типа `complex128` как число типа `float64`.

### <a id="Булевы-значения" href="#Булевы-значения">Булевы значения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имеют тип `bool`, который принимает значения `true` и `false`.

Значение по умолчанию: `false`.

### <a id="Символы" href="#Символы">Символы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имеют тип `rune` (`int32`), представляют из себя 32 битный символ юникода.

Объявляются в виде символа, который заключен в `'`.

Значение по умолчанию: `0`.

### <a id="Строки" href="#Строки">Строки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имеют тип `string`, представляют собой массив из значений типа `byte`. Строки не изменяемые.

Объявляются в виде символов, которые заключены в `"` или `` ` ``.

`var <строка> = "<текст>"`.

`<строка>[<индекс>]` - возвращает значение в виде числа по индексу `<индекс>`.

Функции:
- `len(<строка>)` - возвращает количество байт в строке.

Значение по умолчанию: `""`.

### <a id="Пользовательские-типы" href="#Пользовательские-типы">Пользовательские типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для разделения данных, имеющих общее представление, в зависимости от логики применения.

Задаются в виде: `type <ИмяТипа> <тип>`.
> `type Fruit string`

## <a id="Псевдонимы" href="#Псевдонимы">Псевдонимы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Псевдонимы позволяют обращаться к типу в коде по другому имени.

Задаются в виде: `type <ИмяТипа> = <тип>`.
> `type byte = uint8 `

Можно смешивать псевдонимы и изначальные типы в одном выражении.

## <a id="Константы" href="#Константы">Константы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Константа** - это типизированное значение, которое вычисляется на этапе компиляции и известно компилятору.

Константы можно инициализировать выражениями, состоящими из констант или литералов следующих типов:
- числа;
- строки;
- символы (руны);
- булевы значения.

Определяются аналогично переменным, только вместо `var` используется `const` и всегда задается значение.
> `const pi = 3.14159`

Если у константы не указывать тип, то будет константа с **неопределенным типом**. Конкретный тип значения константы еще не определен и в разных контекстах будет интерпретироваться компилятором по-разному.

```go
const id = 100
var i int64 = id
var f float64 = id
```

## <a id="Перечисления" href="#Перечисления">Перечисления</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При объявлении каждого блока `const` значение `iota` равно `0` и увеличивается на `1` для каждого следующего элемента.

`iota` увеличивается на единицу для каждой строки, где указано имя константы, даже если той было присвоено конкретное значение.

Задаются в виде:
```go
const (
    <имя_1> = iota
    [...]
)
```

Если к `iota` применить арифметическое выражение, то следующие строки будут его использовать, только с увеличенным на единицу числом.
> `iota * 10`

## <a id="Область-видимости" href="#Область-видимости">Область видимости</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Локальные переменные** - это переменные, константы и функции которые объявлены в теле функций их область видимости ограничена тем блоком кода `{}`, в котором они объявлены. Можно объявлять ключевым словом `var` или короткой нотацией `:=`.

**Глобальные переменные** - это переменные, константы и функции которые объявлены вне тела функций и находятся в области видимости всех блоков кода в пакете. Можно объявлять ключевым словом `var`.

## <a id="Композитные-типы" href="#Композитные-типы">Композитные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Указатели" href="#Указатели">Указатели</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Указатели** хранят значения адреса переменной в памяти.

**Физически указатель** - это ячейка памяти, хранящая адрес ячейки, на которую "смотрит" указатель. После создания указатель не "смотрит" ни на одну ячейку памяти и имеет нулевое значение: `nil`.

Объявляется как `*<тип>`.
> `var p *int`

Для того чтобы присвоить указателю значение (адрес какой-либо переменной), используется операция взятия адреса `&<переменная>`.
```go
var a int = 5
p := &a
```

Тип переменной, на которую создается указатель, должен соответствовать типу указателя.

Указатели ведут себя так же, как и обычные переменные. Их можно копировать, присваивая другим переменным тип указателя, передавать и возвращать в функции, а также создавать указатели уже на них.

Чтобы получить или изменить значение, хранящееся по указателю, применяют оператор **разыменования** (dereference) `*<указатель>`.
> `*p = 21`

Для указателей на структуры есть возможность неявного разыменования при доступе к полям структуры: `<указатель>.<поле>`.

Вызов оператора разыменования на `nil`-указателе приведет к панике на этапе исполнения кода, и программа откажется работать дальше.

Для указателей определены операторы сравнения (`==`, `!=`). Два указателя равны, если они указывают на один и тот же объект в памяти либо если оба равны `nil`.

### <a id="Массивы" href="#Массивы">Массивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Массив** - это последовательность фиксированной длины, состоящая из элементов одного типа. Массивы могут быть многомерными.

Объявляется как: `[<количество>]<тип>[ {<значение_1>[, ...]}]`.
> `thisWeekTemp := [7]int {-3, 5, 7} // [-3 5 7 0 0 0 0]`

Для установки произвольных значений массива по индексу используется: `[<количество>]<тип> {<индекс_1>: <значение_1>[, ...]}`.
> `thisWeekTemp := [7]int {6:11, 2:3} // [0 0 3 0 0 0 11]`

Если нужно выделить массив на основе количества значений, то используется: `[...]<тип>[ {<значение_1>[, ...]}]`.
> `rgbColor := [...]uint8{255, 255, 128} // [255 255 128] len = 3`

`<массив>[<индекс>]` - возвращает значение по индексу `<индекс>` или устанавливает его.

Переменные массивов можно присваивать друг другу, однако у них должен быть одинаковый тип, причем количество и тип элементов должны совпадать. В процессе присваивания выполняется полное копирование массива.

Функции:
- `len(<массив>)` - возвращает количество элементов в массиве.

#### <a id="Слайсы" href="#Слайсы">Слайсы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Слайс** (срез) - это последовательность переменной длины, состоящая из элементов одного типа.

Объявляется как: `[]<тип>`. Инициализирован по умолчанию значением `nil`.
> `var mySlice []int`

Слайс - это обертка над указателем массива и используется как структура следующего вида:
- **указатель на первый элемент** базового массива - `ptr`;
- **длина слайса** - `len`, количество элементов в слайсе;
- **емкость слайса** - `cap`, количество элементов в массиве.

Создается с помощью: `make([]<тип>, <длина>[, <емкость>])`.
> `mySlice := make([]int, 5, 10) // слайс [0 0 0 0 0], базовый массив [0 0 0 0 0 0 0 0 0 0]`

Функция `make` создает массив длиной `cap` и записывает указатель на него в структуру слайса. Также она заполняет поля `len` и `cap` в этой структуре и возвращает ее в виде переменной типа `[]<тип>`.

Создание из композитного литерала: `[]<тип>{<значение_1>[, ...]}`.
> `s := []int{1, 2, 3} // [1 2 3]`

Создание из существующего слайса или массива: `<слайс_или_массив>[[<индекс_от>]:[<индекс_до>][:<емкость>]]`, где `<индекс_от>` - индекс первого элемента нового слайса и если не указан равен `0`, `<индекс_до>` - индекс последнего элемента, не входящего в новый слайс и если не указан равен длине массива или слайса, `<емкость>` - емкость базового массива, необходимая для создания нового слайса.
```go
a := []int{1, 2, 3, 4}
b := a[1:3]
```

`<слайс>[<индекс>]` - возвращает значение по индексу `<индекс>` или устанавливает его.

Функции:
- `len(<слайс>)` - возвращает количество элементов в слайсе;
- `cap(<слайс>)` - возвращает емкость слайса;
- `append(<слайс>, <значение_1>[, ...])` - возвращает новый слайс, к которому добавлены значения, если емкость слайса не позволяет его увеличить, а иначе дабавляет к текущему и возвращает его; если добавляемое значение это слайс, то его можно распаковать с помощью `<слайс>...`, которая преобразует его элементы в список;
- `copy(<слайс_приемник>, <слайс_источник>)` - копирует все элементы из `<слайс_источник>` в `<слайс_приемник>`, при этом перезаписывая элементы, поэтому количество скопированных элементов будет равно меньшей длине из двух слайсов;

### <a id="Ассоциативный-массив" href="#Ассоциативный-массив">Ассоциативный массив</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Ассоциативный массив** (карта) - это набор пар вида "ключ-значение". Ключи уникальны: одному ключу соответствует только одно значение. Адрес значения для ключа, как правило, вычисляется хеш-функцией, поэтому такую структуру данных еще называют хеш-таблицей (hash table, hash map).

Хеш-функция — это любая функция, которая может однозначно перевести любое переданное значение в некоторое множество ограниченных значений.

Для ключей должны быть определены операторы `==` и `!=`, поэтому ключ не может быть функцией, хеш-таблицей или слайсом.

Объявляется как: `map[<тип_ключа>]<тип_значения>`. Инициализирован по умолчанию значением `nil`.
> `var m map[string]int`

Создается с помощью: `make(map[<тип_ключа>]<тип_значения>[, <количество_элементов>])`.
> `m := make(map[string]string, 5)`

Для установки произвольных значений используется: `map[<тип_ключа>]<тип_значения> {ключ_1>: <значение_1>[, ...]}`.
> `MyStringMap := map[string]string{"first": "первый", "second": "второй"}`

Если впоследствии количество элементов будет расти и перестанет умещаться в выделенной памяти, то выделится дополнительная память.

`<значение>[, <наличие>] = <карта>[<ключ>]` - извлекает значение `<значение>` по ключу `<ключ>` и булевый признак установки значения `<наличие>` - `true`, если ключ найден, и `false` в противном случае.. Значение всегда будет возвращено, так как типы имеет значение по умолчанию.

`<карта>[<ключ>] = <значение>` - устанавливает значение по ключу `<ключ>`.

Функции:
- `len(<карта>)` - возвращает количество элементов в карте;
- `delete(<карта>, <ключ>)` - удаляет элемент в карте по ключу;

<a id="Управление-потоком-выполнения" href="#Управление-потоком-выполнения">Управление потоком выполнения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=============================

## <a id="Операторы-ветвления" href="#Операторы-ветвления">Операторы ветвления</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Операторы сравнения:
- `>` - больше;
- `<` - меньше;
- `>=` - больше или равно;
- `<=` - меньше или равно;
- `==` - равно;
- `!=` - не равно.

Логические операторы:
- `&&` - логическое И;
- `||` - логическое ИЛИ;
- `!` - логическое НЕ.

Условия можно заключать в `()` для улучшения читаемости и группировки частей условий.

Условия проверяются лениво до получения первого `false` и прекращается, потому что проверять дальше нет смысла.

### <a id="Условие-if---else" href="#Условие-if---else">Условие if - else</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```go
if [<инструкция_инициализации_1>;] <логическое_выражение_1> {
    <блок_1>
} [else if [<инструкция_инициализации_2>;] <логическое_выражение_2> {
    <блок_2>
}][ else {
    <блок_3>
}]
```

Где `<инструкция_инициализации_1>` позволяет объявить локальную переменную, которую можно использовать только в рамках области видимости `if`.
```go
a := 0.10000001
if b := float32(a); b > float32(0.1) {
    fmt.Println("Var a is GT float32(0.1)")
}
```

### <a id="Условие-switch---case" href="#Условие-switch---case">Условие switch - case</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```go
switch [<инструкция_инициализации>;] [<необязательное_выражение>] {
case <выражение_1_1>[, <выражение_1_2>[, ...]]:
    <блок_1>
...
case <выражение_N_1>[, <выражение_N_2>[, ...]]:
    <блок_N>
[default:
    <блок_D>]
```

При совпадении `case` остальные случаи не проверяются.

Блок `default` выполнится, если ни одно из условий не отработало.

Чтобы досрочно прервать выполнение `case`, используют ключевое слово `break`.

Чтобы выполнить следующий блок `case`, используют ключевое слово `fallthrough` в последней строке блока. При использовании игнорирует условие следующего по порядку `case`.

Где:
- `<инструкция_инициализации>` позволяет объявить локальную переменную, которую можно использовать только в рамках области видимости `switch`;
- `<выражение>` - это может быть значение, которое сравнивается на равенство с `<необязательное_выражение>` или оператором сравнения.

```go
a := 6
switch b := a % 5; {
case b == 0:
    fmt.Println("Кратно 5")
default:
    fmt.Printf("Остаток от деления на 5: %d", b)
}
```

## <a id="Циклы" href="#Циклы">Циклы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Бесконечный цикл:
```go
for {
    // тело цикла
}
```

Цикл while:
```go
for <логическое_выражение> {
    // тело цикла
}
```

```go
for [<пред_инструкция>;] <логическое_выражение>[; <итеративная_инструкция>] {
    // тело цикла
}
```

Операнд `range` копирует значение во временную переменную, которая уже используется для обхода. Поэтому лучше использовать указатель для переменных.

Итерации по символам в строке:
```go
for <индекс>[, <символ>] := range <строка> {
    // символ, размер := utf8.DecodeRuneInString(строка[индекс:])
    // тело цикла
}
```

Итерации по массиву или срезу:
```go
for <индекс>[, <элемент>] := range <массив_или_срез> {
    // тело цикла
}
```

Итерации по элементам карты:
```go
for <ключ>[, <значение>] := range <карта> {
    // тело цикла
}
```

Итерации по элементам в канале:
```go
for <элемент> := range <канал> {
    // тело цикла
}
```

Выполнение цикла `for` можно прервать в любой момент с помощью инструкции `break`, передающей управление инструкции, следующей за инструкцией `for`. Имеется также возможность с помощью инструкции `continue` передать управление в начало инструкции `for` и вызвать итеративную инструкцию, если она есть.

### <a id="Метка" href="#Метка">Метка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Метка** - это идентификатор, за которым следует двоеточие: `<метка>:`. Метки могут применяться к циклам `for`, инструкциям `switch` и `select`, которые ставятся до инструкции.

Инструкции: `break <метка>` и `continue <метка>`, позволяют указывать метки и могут использоваться внутри циклов `for`.

<a id="Функции" href="#Функции">Функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

**Функция** - это логически целостный участок кода с одним входом и одним выходом в потоке управления. Этот участок можно использовать многократно, обращаясь к нему по имени.

Декларация функции:
```go
func <имя_функции>(<имя_агрумента_1> <тип>[, ...]) <тип_результата> {
    // тело функции
    return <результат>
}
```

Вызывается как: `<имя_функции>(<значение_1>[, ...])`.

Если параметры одинакового типа, то они могут быть записаны как: `<имя_агрумента_1>[, ...] <тип>`.

Если необходимо использовать переменное количество аргументов, то используется аргумент последним в списке: `<имя_агрумента> ...<тип>`, то тогда `<имя_агрумента>` будет слайсом указанного типа.

Если функция ничего не возвращает, то можно опустить написание `<тип_результата>`.

`<тип_результата>` может быть не одним значением, а множеством и определяется как: `(<тип_результата_1>[, ...])`. Тогда результат должен возвращаться как `return <значение_1>[, ...]`.

Результат функции тоже можно именовать: `(<имя_переменной_1> <тип_результата>[, ...])`, что позволяет ссылаться на него в теле функции.
```go
func Divide(x int) (half int) {
    half = x / 2
    return // тогда в инструкции return имя можно не указывать
}
```

Если `return` не используются, то возвращаются значения по умолчанию.

Если количество и тип возвращаемых функцией значений в точности соответствуют параметрам другой функции, то допускается такой синтаксис вызова: `<функция_1>(<функция_2>())`.

Функции не могут быть декларированы в функциях.

Функцию можно присвоить переменной, можно передать аргументом другой функции. Функция может возвращать в качестве значения другую функцию.

Определяется как: `func (<тип>[, ...]) <тип_результата>`. Если значение не присвоено, то имеет значение `nil`.
> `func(string) string`

Функцию можно создать по месту использую литеральную форму синтаксиса и присвоить переменной или передать в качестве аргумента при вызове в другую функцию:
```go
func(<имя_агрумента_1> <тип>[, ...]) <тип_результата> {
    // тело функции
    return <результат>
}
```

> `Print("dog", func(s string) string { return s })`

Аргументы передаются функции путем копирования значения, то есть функции не могут изменять переданные им переменные, то есть передача массива (как и переменной любого другого типа) в функцию - это копирование его значения в переменную аргумента функции.

Замыкание привязывает к себе внешнюю переменную в лексическая области видимости. Замыкание просто ссылается на его значение, повышая скорость работы программы и снижая вероятность ошибки.

## <a id="Особенные-функции" href="#Особенные-функции">Особенные функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Точка входа в программу** - функция `main()`. Она обязательно должна существовать в единственном виде и в любой исполняемой программе на Go. `main()` не принимает аргументов и не возвращает значений.

**Функция инициализатор пакета** - функция `init()`. Она может быть объявлена многократно и кажадая будет вызывана единожды при инициализации пакета в порядке поределения. `init()` не принимает аргументов и не возвращает значений.

## <a id="Оператор-отложенного-вызова" href="#Оператор-отложенного-вызова">Оператор отложенного вызова</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Оператор отложенного вызова** реализуется через оператор `defer`, который используется внутри функций, вычисляет аргументы для вызова, но вызов не делает. Вызов выполняется непосредственно перед тем, как отложившая его функция вернет управление через конструкцию `return`.

Отложенная функция может быть анонимной и заданной литерально.

Вызываются в порядке обратном порядку определения.

Использование: `defer <функция>()`.
> `defer fmt.Println("deferred")`

В функциях отложенного вызова можно перехватывать панику `panic`, через использование `recover`, так как все накопившиеся отложенные функции будут вызваны после вызова паники.

<a id="Пакеты" href="#Пакеты">Пакеты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

**Пакет** - это единица компиляции, пространства имен и импорта - все файлы c расширением `.go` в одной директории, кроме оканчивающихся на `_test.go`.

Все элементы кода (типы, константы, переменные, функции) доступны внутри пакета, как если бы они были объявлены в одном файле.

В директории у всех файлов должно быть одинаковое имя пакета, потому что компилятор будет обрабатывать сразу все файлы директории (если не указать на конкретный) и при разных именах пакетов возникнет ошибка.

Строго рекомендуется, чтобы название пакета совпадало с именем папки, так как с ними будет проще работать.

Если нужно создать исполняемый файл, у пакета должно быть имя `main` и одноименная функция в одном из файлов. В остальных случаях, если пакет будет использоваться как библиотека, желательно, чтобы имя пакета отражало его назначение.

`package <имя_пакета>` - устанавливает имя пакета. Пишется в самом верху файла.

**Экспортируемые** переменные, константы и функции определенного пакета доступны из тех пакетов, которые импортируют этот пакет с использованием: `import [<алиас> ]"<имя_пакета>"`. Если пакет не используется, а только его функции `init()`, то нужно использовать алиас `_`.
> `import "fmt"`

Полное имя пакета для импорта будет равно пути до него.

Доступ к экспортируемым объектам осуществляется конструкцией `<имя_пакета>.<Имя_сущности>`.
> `fmt.Println("Hello, world!")`

Групировочная нотация импорта пакетов:
```go
import (
    [<алиас> ]<имя_пакета_1>
    [...]
)
```

Если имя **глобальной** переменной, константы или функции начинается с прописной буквы, то она **экспортируемая**. Если со строчной, то **неэкспортируемая**. К неэкспортируемым сущностям нельзя обратиться за пределами пакета.

Правила именования:
- имя пакета должно быть написано строчными буквами;
- имя пакета должно быть уникально в рамках репозитория, а иначе придется использовать алиасы.

Порядок импорта:
1. При компиляции программы компилятор начинает с пакета `main`. Если в `main` есть импорты каких-либо пакетов, то он переходит к ним и компилирует их, до тех пор пока не скомпилируются все необходимые пакеты для сборки программы;
2. Затем компилятор компилирует пакет `main` и собирает основное приложение, а далее в процессе выполнения программы произойдет следующее:
    1. В том порядке, в котором пакеты были проимпортированы, будут инициализироваться переменные пакета;
    2. После будут выполнены функции `init()` внутри каждого пакета. Функций `init()` может быть несколько, и они выполнятся в том порядке, в котором были объявлены;
    3. И после их выполнения наступит очередь функции `main`.

## <a id="Структура-приложения" href="#Структура-приложения">Структура приложения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
<проект>
├──cmd # здесь лежат файлы запуска программ
|    └──<программа_1>
|         └──main.go # исходный код запуска программы <программа_1>
├──internal # содержит внутренние пакеты проекта
|    └──<пакет>
|         └──<под_пакеты>
|              └──<файл_пакета_1>.go # исходный код пакета
├──pkg # содержит пакеты для других проектов
├──vendor # содержит внешние пакеты
├──test # содержит тесты
├──docs # содержит документацию
├──api # содержит дополнительные файлы для сервисов с API
├──assets # содержит дополнительные файлы-ресурсы
├──build # содержит файлы для упаковки и непрерывной интеграции
├──configs # содержит файлы конфигураций
├──deployments/deploy # содержит файлы конфигураций и шаблоны для сервисов, операционных систем и контейнеров
├──examples # содержит примеры использования приложений и библиотек
├──sсripts # содержит скрипты для установки, настройки и других действий с проектом
├──tools # содержит инструменты для поддержки проекта
└──website # содержит файлы для веб-сайта проекта
```

## <a id="Модули" href="#Модули">Модули</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Модуль** - это законченная библиотека или приложение, которое может содержать внутренние пакеты и импортировать внешние.

Метаинформация о модуле содержится в файле `go.mod` в корневой директории модуля. С такой структурой:
```
module <имя_модуля>
go <версия>
replace <алиас> => <путь_к_пакету>
replace <пакет> [<версия>] => <другой_пакет> <версия>
require <пакет> <версия>
require <пакет> <версия> // indirect
```

Файл `go.sum` содержит хеш-суммы всех модулей и тем самым гарантирует воспроизводимую установку модулей на разных окружениях.

<a id="ООП" href="#ООП">ООП</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===

### <a id="Структуры" href="#Структуры">Структуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Структура** представляет собой тип данных с заданным набором атрибутов (полей), использующийся для описания составных объектов.

Объявляется как:
```go
type <Структура> struct {
    [<ВстраиваемаяСтруктура_1>]
    [...]
    <поле_1> <тип> [`<тег_1>:"<значение>"[ ...]`]
    [...]
}
```

Если указана `<ВстраиваемаяСтруктура>`, то это считается **композицией**, что означает, что все поля и методы `<ВстраиваемаяСтруктура>` будут переданы в структуру `<Структура>`, как если бы она сама их содержала. При этом объект типа `<Структура` не может быть приведен к типу `<ВстраиваемаяСтруктура>` с помощью приведения типов. При создании структуры `<Структура` нужно явно создавать стуктуру `<ВстраиваемаяСтруктура>`.

```go
type Person struct {
    Name string
    Year int
}
type Student struct {
    Person
    Group string
}
s := Student{
    Person: Person{
        Name: "John Doe",
        Year: 1980,
    }
    Group: "701",
}
```

Структура может встраиваться по указателю: `*<ВстраиваемаяСтруктура>`. Это может быть удобно, если встраивается в структуру какуя-то большая структуру и затем передается по значению.

```go
type LogExtended struct {
    *log.Logger
    logLevel LogLevel
}
func NewLogExtended() *LogExtended {
    return &LogExtended{
        Logger:   log.New(os.Stdout, "", 0),
        logLevel: LogLevelInfo,
    }
}
```

Поле или метод структуры, в которую встроен другой тип, не переопределяется, а затеняется. То есть при использовании поля или вызове метода с таким же именем сначала происходит попытка найти поле или метод среди полей и методов структуры, затем ищет его среди вложенных типов. Для вызова затененного поля или метода используется: `<переменная>.<ВстраиваемаяСтруктура>.<поле>`.

Если поле именуется с заглавной буквы, то значит, что оно экспортируемое (публичное) и доступно вне пакета.

**Теги** (tags) - это набор аннотаций для каждого поля структуры. Набор тегов с их значениями можно представить как набор ключей и значений, где ключи разделяются пробелами, а значения ключей - запятой.
> `` IsDeleted *bool `json:"is_deleted,omitempty" yaml:"is_deleted"` ``

Создается с помощью: `<Структура>{<поле_1>: <значение_1>[, ...]}`, при этом не проинициализированные поля будут проинициализированны значениями по умолчанию.

Анонимные структуры объявляются и используются непосредственно в коде:
```go
<переменная> := struct {
    <поле_1> <тип> [`<тег_1>:"<значение>"[ ...]`]
    [...]
}{
    <поле_1>: <значение_1>
    [, ...]
}
```

```go
req := struct {
    NameContains string `json:"name_contains"`
    Offset       int    `json:"offset"`
    Limit        int    `json:"limit"`
}{
    NameContains: "Иван",
    Limit:        50,
}
```

Конструктор описывается с помощью функции с префиксом `New`, которая возвращает структуру, если конструктор производит валидацию аргументов, функция должна возвращать ошибку последним аргументом.
```go
func NewPerson(name, email string, dobYear, dobMonth, dobDay int) Person {
    return Person{
        Name:        name,
        Email:       email,
        dateOfBirth: time.Date(dobYear, time.Month(dobMonth), dobDay, 0, 0, 0, 0, time.UTC),
    }
} 
```

`struct{}` - это пустая структура, которая имеет размер 0, при этом объект имеет адрес.
> `c := struct{}{}`

`<структура>.<поле>` - возвращает значение по полю `<поле>` или устанавливает его.

`new(<тип_структуры>)` - возвращает указатель на новую переменную типа `<тип_структуры>`.

## <a id="Методы" href="#Методы">Методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объявляются как:
```go
func (<получатель> <тип>) <имя_метода>(<имя_агрумента_1> <тип>[, ...]) <тип_результата> {
    // тело метода
    return <результат>
}
```

Где `<получатель>` - это **получатель** (receiver), с которым вызывается метод, еще один агрумент функции, `<тип>` - это тип или структура.

Используется:
- `<получатель> <тип>` - для получателей по значению, когда в переменную `<переменная_типа>` копируется экземпляр - эквивалентно вызову: `(&<переменная_типа>).<имя_метода>()`;
- `<получатель> *<тип>` - для получателей по указателю, для изменения экземпляра - эквивалентно вызову: `(*<переменная_типа>).<имя_метода>()`.

```go
type MyType int
func (m MyType) String() string {
    return fmt.Sprintf("MyType: %d", m)
}
```

Вызывается как: `<переменная_типа>.<имя_метода>(<значение_1>[, ...])`.

Если метод используется как функция первого рода для передачи куда-то, то она сохраняет контекс вызова - `<переменная_типа>`.

## <a id="Интерфейсы" href="#Интерфейсы">Интерфейсы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Интерфейс** - это набор методов, которые могут быть реализованы типом. Описывает поведение.

Объявляются как:
```go
type <Интерфейс> interface {
    [<ВстраиваемыйИнтерфейс_1>]
    [...]
    <Метод_1>(<имя_агрумента_1> <тип>[, ...]) <тип_результата>
    [...]
}
```

Если тип имеет методы, описанные в интерфейсе, то этот тип удовлетворяет интерфейсу. В типе явно не указывается, что он реализует интерфейс, так как интерфейс реализуется через утиную типизацию.

На этапе компиляции компилятор проверяет, можно ли определенной переменной присвоить переменной типа `<Интерфейс>`. Для этого проверяется, что тип имеет все методы интерфейса `<Интерфейс>`.

С точки зрения Go типы `<Структура>` и `*<стрСтруктурауктура>` (указатель) - разные, и получается что каждый тип должен реализовывать интерфейс `<Интерфейс>`.

`<ВстраиваемыйИнтерфейс>` работает как композиция интерфейсов, аналогично как для структур `<ВстраиваемыйСтруктура>`.

`var _ <Интерфейс> = (*<Структура>)(nil)` - используется для того, чтобы добавить явную проверку - реализует ли тип `<Структура>` интерфейс `<Интерфейс>`. Если данный тип не соответствует спецификации интерфейса, код не скомпилируется.

Переменной типа интерфейс может быть присвоен объект любого типа, если он удовлетворяет этому интерфейсу.

Интерфейс используется как тип во всех местах.

Интерфейсная переменная относится к ссылочному типу, то есть если ее передать в функцию, то она скопируется, но, так как указатели будут указывать на ту же исходную переменную, изменение переменной через вызов методов может изменить данные.

Интерфейс может быть `nil`, а может быть с `nil`-указателем на данные. Поэтому интерфейс, равный `nil`, и интерфейс, оборачивающий `nil`, - разные вещи.

Интерфейсы принято делать по возможности маленькими. Чем проще интерфейс, тем легче воспринимать код.

Если интерфейс содержит только один метод, то его именуют как `<Метод>er`.

### <a id="Пустой-интерфейс" href="#Пустой-интерфейс">Пустой интерфейс</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Пустой интерфейс** - это интерфейса без методов для того чтобы разрешить функции принимать произвольный параметр.

Имеет тип: `interface{}` или `any`.

`<значение> = <пустой_интерфейс>.(<тип>)` - возвращает пустой интерфейс `<пустой_интерфейс>`, который приведен к типу `<тип>`, а если его не возможно привести то вызывает `panic`.  
`<значение>, <успешность> = <пустой_интерфейс>.(<тип>)` - возвращает пустой интерфейс `<пустой_интерфейс>`, который приведен к типу `<тип>` и в `<успешность>` `true`, если удалось привести к типу, а иначе `false`.

Интерфейс состоит из двух указателей: на метаданные типа (itable) и на сами данные. При приведении типа используются эти метаданные, чтобы вычислить, какой конкретный тип представляет этот интерфейс и как правильно разыменовать указатель на данные.

#### <a id="switch-с-приведением-типов" href="#switch-с-приведением-типов">`switch` с приведением типов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для приведения пустого интерфейса к типам.

```go
switch <переменная> := <пустой_интерфейс>.(type) {
case <тип_1>:
    <блок_1> // в этом блоке переменная `<переменная>` имеет тип `<тип_1>`
...
[default:
    <блок_D>]
}
```

```go
func Mul(a interface{}, b int) interface{} {
    switch va := a.(type) {
    case int:
        return va * b
    case string:
        return strings.Repeat(va, b)
    case fmt.Stringer:
        return strings.Repeat(va.String(), b)
    default :
        return nil
    }
}
```

## <a id="Рефлексия" href="#Рефлексия">Рефлексия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Рефлексия** - это возможность получить информацию о типе из переменной этого типа. Рефлексия позволяет получать информацию о коде программы и менять его во время выполнения.

За рефлексию отвечает пакет `reflect`.

Функции:
- `reflect.DeepEqual(<переменная_1> any, <переменная_2> any) bool` - сравнивает значения всех элементов типа, включая вложенные, и возвращает `true` если они равны, а иначе `false`;
- `<value> = reflect.ValueOf(<переменная> any) Value` - принимает некоторое значение и возвращает `Value`. Методы `Value`:
    - `<value>.Kind() reflect.Kind` - возвращает базовый тип объекта, то есть не пользовательский тип, а один из встроенных в язык: структуру, канал, слайс, функцию, массив и другие;
    - `<value>.Type() reflect.Type` - возвращает тип объекта;
    - `<value>.IsNil() bool` - возвращает `true` если `<value>` равно `nil`, а иначе `false` и паникует если это не ссылочный тип;
    - `<value>.Elem() Value` - возвращает значение на которое указывает объект - разыменовывает указатель;
    - `<value>.Set(<value> reflect.Value)` - устанавливает значение, если `<value>` указатель;
    - `<value>.CanSet() bool` - возвращает `true` если `<value>` можно изменить, а иначе `false`;
    - `<value>.NumField() int` - возвращает количество полей у структуры;
    - `<value>.Field(<индекс> int) reflect.Value` - возвращает поле структуры;
    - `<value>.FieldByName(<имя> int) reflect.Value` - возвращает поле структуры по имени:
        - `<value>.Type.String() string` - возвращает тип структуры;
        - `<value>.Tag` - возвращает теги структуры;
    - `<value>.Type().Field(<индекс> int).Name string` - возвращает имя поля структуры;
- `reflect.TypeOf(<переменная> any) reflect.Type` - возвращает тип переданного объекта;

<a id="Обработка-ошибок" href="#Обработка-ошибок">Обработка ошибок</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
================

Для реализации собственной ошибки нужно реализовать интерфейс:
```go
type error interface {
    Error() string
}
```

Так как функции могут возвращать несколько значений, то возвращение ошибки происходит вместе с результатом выполнения функции в последнем возвращаемом значении функции. И если значение ошибки равно `nil`, то функция завершилась корректно.

Ошибки создаются статически, на этапе инициализации модуля для того, чтобы переменную ошибки можно было использовать многократно.

Принято начинать текст ошибок со строчной буквы, так как ошибки могут объединяться друг с другом.
> `fmt.Errorf(`не удалось прочитать файл (%s): %v`, filename, err)`

<a id="Стандартные-пакеты" href="#Стандартные-пакеты">Стандартные пакеты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==================

## <a id="Пакет-fmt" href="#Пакет-fmt">Пакет `fmt`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Интерфейс `fmt.Stringer` используется, когда нужно одной строчкой залогировать сложный объект:
```go
type Stringer interface {
    String() string
}
```

Функции:
- `fmt.Print(<аргумент_1>[, ...])` - выводит в консоль аргументы;
- `fmt.Println(<аргумент_1>[, ...])` - выводит в консоль аргументы и добавляет перевод строки;
- `fmt.Errorf(<аргумент_1>[, ...])` - формирует объект ошибки;
- `fmt.Errorf("... %w ...", <ошибка>[, ...])` - оборачивает ошибку в новую ошибку;

## <a id="Пакет-io" href="#Пакет-io">Пакет `io`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Интерфейс `io.Reader` описывает чтение из любого потока данных: сети, файловой системы или буфера. Метод `Read` считывает в переданный слайс байт данные из источника:
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

Интерфейс `io.Writer` описывает запись в любой возможный поток данных: сетевой сокет, файл или буфер:
```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

Функции:
- `io.Copy(<приемник> Writer, <источник> Reader) (written int64, err error)` - копирует все байты из `<источник>` до того момента пока `<источник>` не вернет в качестве ошибки `io.EOF` в `<приемник>` и возвращает количество скопированных в `written`;
- `io.CopyN(<приемник> Writer, <источник> Reader, <количество> int64) (written int64, err error)` - копирует все байты, но не более `<количество>` байт из `<источник>` до того момента пока `<источник>` не вернет в качестве ошибки `io.EOF` в `<приемник>` и возвращает количество скопированных в `written`;
- `io.ReadAll(<источник> Reader) ([]byte, error) ` - считывает все байты из `<источник>` до того момента пока `<источник>` не вернет в качестве ошибки `io.EOF` в `<приемник>` и возвращает их в слайсе;
- `io.ReadAtLeast(<источник> Reader, <буфер> []byte, <количество> int) (n int, error) ` - считывает `<количество>` байт из `<источник>` в буфер `<буфер>`;

## <a id="Пакет-errors" href="#Пакет-errors">Пакет `errors`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Функции:
- `errors.New(<текст_ошибки> string) Error` - создает ошибку;
- `errors.Unwrap(<ошибка> Error) Error` - разворачивает ошибку и возвращает ее;
- `errors.Is(<ошибка_1> Error, <ошибка_2> Error) bool` - сравнивает ошибки на равенство, включая обернутые;
- `errors.As(<ошибка> Error, <переменная> *<тип>) bool` - находит в ошибке `<ошибка>` тип ошибки `<тип>` и если он найден, то записывает в переменную `<переменная>` эту ошибку и возвращает `true`, а иначе `false`;