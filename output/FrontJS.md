[Содержание](#Содержание)
==========

- [Подключение](#user-content-Подключение)
    - [Использование в HTML](#user-content-Использование-в-HTML)
- [Документ, события, интерфейсы](#user-content-Документ-события-интерфейсы)
    - [Дерево DOM](#user-content-Дерево-DOM)
    - [Навигация по DOM-элементам](#user-content-Навигация-по-DOM-элементам)
    - [Поиск](#user-content-Поиск)
    - [Свойства узлов](#user-content-Свойства-узлов)
        - [Таблица](#user-content-Таблица)
    - [Полифиллы](#user-content-Полифиллы)
    - [Свои DOM-свойства](#user-content-Свои-DOM-свойства)
    - [Атрибуты](#user-content-Атрибуты)
    - [Относительное расположение узлов](#user-content-Относительное-расположение-узлов)
    - [Добавление и удаление узлов](#user-content-Добавление-и-удаление-узлов)
        - [Мультивставка](#user-content-Мультивставка)
        - [`DocumentFragment`](#user-content-DocumentFragment)
        - [Дополнительные методы](#user-content-Дополнительные-методы)
    - [Метод `document.write`](#user-content-Метод-documentwrite)
    - [Стили](#user-content-Стили)
        - [Полный стиль](#user-content-Полный-стиль)
        - [Медиа-запросы](#user-content-Медиа-запросы)
    - [Размеры и прокрутка элементов](#user-content-Размеры-и-прокрутка-элементов)
    - [Анимация](#user-content-Анимация)
    - [Размеры и прокрутка страницы](#user-content-Размеры-и-прокрутка-страницы)
        - [Ориентация экрана](#user-content-Ориентация-экрана)
        - [Видимость страницы](#user-content-Видимость-страницы)
    - [Координаты в окне](#user-content-Координаты-в-окне)
    - [Координаты в документе](#user-content-Координаты-в-документе)
    - [`MutationObserver`](#user-content-MutationObserver)
    - [`ResizeObserver`](#user-content-ResizeObserver)
    - [`IntersectionObserver`](#user-content-IntersectionObserver)
- [Основы работы с событиями](#user-content-Основы-работы-с-событиями)
    - [События мыши](#user-content-События-мыши)
    - [События на элементах управления](#user-content-События-на-элементах-управления)
    - [Клавиатурные события](#user-content-Клавиатурные-события)
    - [События манипулирования текстом](#user-content-События-манипулирования-текстом)
    - [События выделения текста](#user-content-События-выделения-текста)
    - [События перетаскивания Drag'n'Drop](#user-content-События-перетаскивания-DragnDrop)
    - [События печати](#user-content-События-печати)
    - [События CSS transition](#user-content-События-CSS-transition)
    - [События CSS анимации](#user-content-События-CSS-анимации)
    - [События `Frame` и `Object`](#user-content-События-Frame-и-Object)
    - [События касания](#user-content-События-касания)
    - [Другие события](#user-content-Другие-события)
    - [Обработка событий](#user-content-Обработка-событий)
        - [Специальные методы (Chrome)](#user-content-Специальные-методы-Chrome)
        - [AbortController](#user-content-AbortController)
        - [Очередь событий](#user-content-Очередь-событий)
            - [Порядок обработки событий](#user-content-Порядок-обработки-событий)
        - [Основные свойства и методы объекта события `Event`](#user-content-Основные-свойства-и-методы-объекта-события-Event)
        - [Всплытие](#user-content-Всплытие)
        - [Погружение](#user-content-Погружение)
        - [Делегирование событий](#user-content-Делегирование-событий)
        - [Прием проектирования "поведение"](#user-content-Прием-проектирования-поведение)
        - [Отмена действия браузера по умолчанию](#user-content-Отмена-действия-браузера-по-умолчанию)
        - [Генерация событий на элементах](#user-content-Генерация-событий-на-элементах)
        - [Свои события](#user-content-Свои-события)
        - [Старое API](#user-content-Старое-API)
        - [Мышь: Drag'n'Drop](#user-content-Мышь-DragnDrop)
- [Формы, элементы управления](#user-content-Формы-элементы-управления)
    - [Навигация и свойства элементов формы](#user-content-Навигация-и-свойства-элементов-формы)
        - [Проверки ошибок](#user-content-Проверки-ошибок)
    - [Файлы](#user-content-Файлы)
    - [Фокусировка](#user-content-Фокусировка)
    - [Изменение](#user-content-Изменение)
    - [Формы](#user-content-Формы)
    - [Диалог](#user-content-Диалог)
    - [Всплывающий элемент](#user-content-Всплывающий-элемент)
- [Обработка ошибок](#user-content-Обработка-ошибок)
- [Взаимодействие с пользователем: `alert`, `prompt`, `confirm`](#user-content-Взаимодействие-с-пользователем-alert-prompt-confirm)
- [Создание графических компонентов](#user-content-Создание-графических-компонентов)
    - [Основные принципы при создании виджета](#user-content-Основные-принципы-при-создании-виджета)
    - [Верстка графических компонентов](#user-content-Верстка-графических-компонентов)
    - [Создание анимации с помощью `requestAnimationFrame`](#user-content-Создание-анимации-с-помощью-requestAnimationFrame)
    - [Работа во время простоя `requestIdleCallback`](#user-content-Работа-во-время-простоя-requestIdleCallback)
    - [Шаблонизация](#user-content-Шаблонизация)
    - [Колбэки](#user-content-Колбэки)
- [Веб компоненты](#user-content-Веб-компоненты)
    - [`slot`](#user-content-slot)
    - [`ElementInternals`](#user-content-ElementInternals)
- [AJAX и COMET](#user-content-AJAX-и-COMET)
    - [`XMLHttpRequest`](#user-content-XMLHttpRequest)
        - [Событие `readystatechange`](#user-content-Событие-readystatechange)
        - [HTTP-заголовки](#user-content-HTTP-заголовки)
        - [POST](#user-content-POST)
            - [POST-запрос в кодировке multipart/form-data](#user-content-POST-запрос-в-кодировке-multipartform-data)
        - [`FormData`](#user-content-FormData)
        - [`URL`](#user-content-URL)
        - [`URLSearchParams`](#user-content-URLSearchParams)
    - [Кросс-доменные запросы](#user-content-Кросс-доменные-запросы)
        - [Стадия закачки](#user-content-Стадия-закачки)
    - [COMET с XMLHttpRequest: длинные опросы](#user-content-COMET-с-XMLHttpRequest-длинные-опросы)
    - [WebSocket](#user-content-WebSocket)
    - [Протокол JSONP](#user-content-Протокол-JSONP)
        - [Реестр CallbackRegistry](#user-content-Реестр-CallbackRegistry)
        - [Обнаружение ошибок](#user-content-Обнаружение-ошибок)
        - [COMET](#user-content-COMET)
    - [Server Sent Events - события с сервера](#user-content-Server-Sent-Events---события-с-сервера)
        - [Идентификатор id](#user-content-Идентификатор-id)
        - [Статус соединения `readyState`](#user-content-Статус-соединения-readyState)
        - [Кросс-доменость](#user-content-Кросс-доменость)
        - [Токен и AJAX](#user-content-Токен-и-AJAX)
    - [`Blob`](#user-content-Blob)
    - [Метод `fetch`: замена `XMLHttpRequest` (ES6)](#user-content-Метод-fetch-замена-XMLHttpRequest-ES6)
- [Куки, `document.cookie`](#user-content-Куки-documentcookie)
- [Локальное хранилище](#user-content-Локальное-хранилище)
- [Управление историей браузера](#user-content-Управление-историей-браузера)
- [Полноэкранный режим](#user-content-Полноэкранный-режим)
- [Stream API](#user-content-Stream-API)
    - [`ReadableStream`](#user-content-ReadableStream)
        - [`ReadableStreamDefaultController`](#user-content-ReadableStreamDefaultController)
        - [`ReadableStreamDefaultReader`](#user-content-ReadableStreamDefaultReader)
    - [`WritableStream`](#user-content-WritableStream)
        - [`WritableStreamDefaultController`](#user-content-WritableStreamDefaultController)
        - [`WritableStreamDefaultWriter`](#user-content-WritableStreamDefaultWriter)
    - [`TransformStream`](#user-content-TransformStream)
        - [`TransformStreamDefaultController`](#user-content-TransformStreamDefaultController)
    - [Пример](#user-content-Пример)
- [Кодировки](#user-content-Кодировки)
- [WebRTC](#user-content-WebRTC)
    - [Потоки от пользователя](#user-content-Потоки-от-пользователя)
    - [`RTCPeerConnection`](#user-content-RTCPeerConnection)
- [Worker](#user-content-Worker)
    - [Выделенные воркеры](#user-content-Выделенные-воркеры)
        - [Строение воркера](#user-content-Строение-воркера)
    - [Сервис-воркеры](#user-content-Сервис-воркеры)
        - [Кэш](#user-content-Кэш)
        - [Строение воркера](#user-content-Строение-воркера)
    - [Широковещательный канал передачи данных `BroadcastChannel`](#user-content-Широковещательный-канал-передачи-данных-BroadcastChannel)
- [Push API и Notifications API](#user-content-Push-API-и-Notifications-API)
    - [Push API](#user-content-Push-API)
    - [Notifications API](#user-content-Notifications-API)
- [`window.navigator`](#user-content-windownavigator)
    - [API разрешений](#user-content-API-разрешений)
    - [Clipboard API](#user-content-Clipboard-API)
    - [Web Share API](#user-content-Web-Share-API)
    - [Beacon API](#user-content-Beacon-API)
    - [Wake API](#user-content-Wake-API)
- [Performance API](#user-content-Performance-API)
- [jQuery](#user-content-jQuery)
    - [Команды jQuery](#user-content-Команды-jQuery)
        - [Загрузка кода после загрузки страницы](#user-content-Загрузка-кода-после-загрузки-страницы)
        - [Цепочки команд](#user-content-Цепочки-команд)
        - [Перебор выборки всех элементов](#user-content-Перебор-выборки-всех-элементов)
    - [Методы навигации по DOM](#user-content-Методы-навигации-по-DOM)
    - [Атрибуты элементов и CSS](#user-content-Атрибуты-элементов-и-CSS)
        - [CSS свойства](#user-content-CSS-свойства)
        - [CSS классы](#user-content-CSS-классы)
        - [Атрибуты](#user-content-Атрибуты)
        - [data-атрибуты](#user-content-data-атрибуты)
        - [Свойства элементов](#user-content-Свойства-элементов)
    - [События](#user-content-События)
        - [Пространство имен](#user-content-Пространство-имен)
    - [Анимация](#user-content-Анимация)
        - [`animate`](#user-content-animate)
            - [Остановка анимации](#user-content-Остановка-анимации)
    - [Манипуляции с DOM](#user-content-Манипуляции-с-DOM)
        - [Создания элементов](#user-content-Создания-элементов)
        - [Перемещение элементов](#user-content-Перемещение-элементов)
        - [Размеры элементов](#user-content-Размеры-элементов)
        - [Прокрутка](#user-content-Прокрутка)
    - [Работа с формами](#user-content-Работа-с-формами)
    - [AJAX](#user-content-AJAX)
        - [Префильтры](#user-content-Префильтры)
        - [Конвертеры](#user-content-Конвертеры)
        - [Транспорт](#user-content-Транспорт)
    - [Объект `Deferred` и подобные](#user-content-Объект-Deferred-и-подобные)
        - [Методы уведомлений](#user-content-Методы-уведомлений)
    - [`Callbacks`](#user-content-Callbacks)
    - [Дополнительные методы](#user-content-Дополнительные-методы)
    - [jQuery плагин](#user-content-jQuery-плагин)
        - [Публичные методы](#user-content-Публичные-методы)
- [Webpack](#user-content-Webpack)
    - [Включение зависимостей](#user-content-Включение-зависимостей)
        - [Сборка](#user-content-Сборка)
    - [Конфигурация](#user-content-Конфигурация)
    - [Свойства](#user-content-Свойства)
        - [Плагины](#user-content-Плагины)
            - [Плагин `webpack.EnviromentPlugin`](#user-content-Плагин-webpackEnviromentPlugin)
            - [Плагин `webpack.DefinePlugin`](#user-content-Плагин-webpackDefinePlugin)
            - [Плагин ` webpack.optimize.UglifyJsPlugin`](#user-content-Плагин--webpackoptimizeUglifyJsPlugin)
            - [Плагин `webpack.NormalModuleReplacementPlugin`](#user-content-Плагин-webpackNormalModuleReplacementPlugin)
            - [Плагин `webpack.NoErrorsPlugin`](#user-content-Плагин-webpackNoErrorsPlugin)
            - [Плагин `webpack.CommonsChunkPlugin`](#user-content-Плагин-webpackCommonsChunkPlugin)
- [Пример тестирования](#user-content-Пример-тестирования)

<a id="Подключение" href="#Подключение">Подключение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===========

## <a id="Использование-в-HTML" href="#Использование-в-HTML">Использование в HTML</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```html
<script>
    <JS_код>
</script>
```

```html
<script src="<путь_к_JS_коду.js>"></script>
```

Если указан атрибут `src`, то содержимое тега игнорируется.

Атрибут `async` - скрипт выполняется полностью асинхронно. То есть, при обнаружении браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен - он выполнится.

Атрибут `defer` - скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от `async`: первое - браузер гарантирует, что относительный порядок скриптов с `defer` будет сохранен; второе отличие - скрипт с `defer` сработает, когда весь HTML-документ будет обработан браузером.

При одновременном указании `async` и `defer` в современных браузерах будет использован только `async`.

Атрибуты `async`/`defer` работают только в том случае, если назначены на внешние скрипты, т.е. имеющие `src`.

<a id="Документ-события-интерфейсы" href="#Документ-события-интерфейсы">Документ, события, интерфейсы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=============================

## <a id="Дерево-DOM" href="#Дерево-DOM">Дерево DOM</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основным инструментом работы и динамических изменений на странице является **DOM** (*Document Object Model*) - объектная модель, используемая для XML/HTML-документов. Согласно DOM-модели, **документ** является иерархией, **деревом**. Каждый **HTML-тег** образует **узел** дерева с типом "**элемент**". Вложенные в него теги становятся **дочерними** узлами. Для представления текста создаются узлы с типом "**текст**". DOM - это представление документа в виде дерева объектов, доступное для изменения через JavaScript.

При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.

Все, что есть в HTML, находится и в DOM.

Всего различают 12 типов узлов, но на практике работают с четырьмя из них:
- **документ** - точка входа в DOM;
- **элементы** - основные строительные блоки;
- **текстовые узлы** - содержат текст;
- **комментарии** - иногда в них можно включить информацию, которая не будет показана, но доступна из JS.

DOM нужен для того, чтобы манипулировать страницей - читать информацию из HTML, создавать и изменять элементы.

## <a id="Навигация-по-DOM-элементам" href="#Навигация-по-DOM-элементам">Навигация по DOM-элементам</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Доступ к DOM начинается с объекта `document`. Из него можно добраться до любых узлов.
```
                          +----------+
                          | document |
                          +----------+
                                ^
                                |
                    +--------------------------+
                    | document.documentElement | <HTML>
                    +--------------------------+
                                ^
                                |
                        +---------------+
                        | document.body | (если внутри body)
                        +---------------+
    --------------------------------------------------------
                                ^
                                |
                            parentNode
                          (parentElement)
                                ^
                                |
        previousSibling      +--------+  nextSibling
    <----------------------  | <DIV>  |  ------------------->
    (previousElementSibling) +--------+  (nextElementSibling)
                            /childNodes\
                           / (children) \
                          /              \
                    firstChild         lastChild
           (firstElementChild)         (lastElementChild)
```

Самые верхние элементы дерева доступны напрямую из `document`:
- `document.documentElement` - это свойство ссылается на DOM-объект для тега `<html>`;
- `document.body` - соответствует тегу `<body>`;
- `document.head` - прямая ссылка на `<head>`.

В DOM в качестве значения, обозначающего "нет такого элемента" или "узел не найден", используется не `undefined`, а `null`.

**Дочерние элементы** (или дети) - элементы, которые лежат непосредственно внутри данного.

**Потомки** - все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, все поддерево DOM.

`<элемент>.childNodes` - псевдо-массив, который хранит все дочерние элементы, включая текстовые.  
`<элемент>.firstChild` и `<элемент>.lastChild` - обеспечивают быстрый доступ к первому и последнему элементу.

**DOM-коллекции** не являются JavaScript-массивами. В них нет методов массивов. Именно поэтому их и называют "**коллекция**" или "**псевдомассив**". Для перебора коллекции используется обычный цикл `for`.

`<элемент>.previousSibling` / `<элемент>.nextSibling` - элементы слева и справа от данного.  
`<элемент>.parentNode` - возвращает родитель.
`<элемент>.children` - только дочерние узлы-элементы, то есть соответствующие тегам.  
`<элемент>.firstElementChild`, `<элемент>.lastElementChild` - соответственно, первый и последний дети-элементы-узлы.  
`<элемент>.previousElementSibling`, `<элемент>.nextElementSibling` - соседи-элементы-узлы.  
`<элемент>.parentElement` - родитель-элемент-узел.

У конкретных элементов DOM могут быть свои дополнительные ссылки для большего удобства навигации.

## <a id="Поиск" href="#Поиск">Поиск</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Если элементу назначен специальный атрибут `id`, то можно получить его прямо по переменной с именем из значения `id` или через `window['<id>']`.

`document.getElementById("<идентификатор>")` - возвращает элемент по идентификатору.  
`<элемент>.getElementsByTagName("<тег>")` - ищет все элементы с заданным тегом внутри элемента и возвращает их в виде списка. Регистр тега не имеет значения. Можно получить всех потомков, передав звездочку `*` вместо тега.  
`document.getElementsByName("<name>")` - позволяет получить все элементы с данным атрибутом `name` в виде списка.  
`<элемент>.getElementsByClassName("<имя_класса>")` - возвращает коллекцию элементов с указанным классом. Находит элемент и в том случае, если у него несколько классов, а искомый - один из них.  
`<элемент>.querySelectorAll("<css_селектор>")` - возвращает все элементы внутри элемента, удовлетворяющие CSS-селектору. Псевдо-классы в CSS-селекторе также поддерживаются.  
`<элемент>.querySelector("<css_селектор>")` - возвращает не все, а только первый элемент, соответствующий CSS-селектору.  
`<элемент>.matches("<css_селектор>")` - ничего не ищет, а проверяет, удовлетворяет ли элемент селектору. Он возвращает `true` либо `false`.  
`<элемент>.closest("<css_селектор>")` - ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор. Сам элемент тоже включается в поиск.

Результаты поиска `getElementsBy*` - живые! При изменении документа - изменяется и результат запроса. Так как результат запросов `getElementsBy*` - это не массив, а специальный объект, имеющий тип `NodeList` или `HTMLCollection`. Он похож на массив, так как имеет нумерованные элементы и длину, но внутри это не готовая коллекция, а "живой поисковой запрос". Собственно поиск выполняется только при обращении к элементам коллекции или к ее длине.

`<NodeList>.item(<id>)` - возвращает элемент коллекции по `id`, аналогичен `<NodeList>[<id>]`.

`<NodeList>.forEach(function (elem, i, arr) {...})` - итеративно перебирает все элементы списка `<NodeList>`, по аналогии с циклом `forEach` у обычного массива.

## <a id="Свойства-узлов" href="#Свойства-узлов">Свойства узлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Самое главное различие между DOM-узлами - разные узлы являются объектами различных классов. Классы DOM образуют иерархию наследования. Основной объект в ней: **Node**, от которого наследуют остальные:
```
                             +-------------+
                             | EventTarget |
                             +-------------+
                                    |
                                    v
                                 +------+
        +----------------------- | Node | --------------------------+
        |                        +------+                           |
        |                           |                               |
        v                           v                               v
    +------+                    +---------+                     +---------+
    | Text |                    | Element | -------------+      | Comment |
    +------+                    +---------+              |      +---------+
                                    |                    |
                                    v                    v
                              +-------------+           +------------+
            +---------------- | HTMLElement | ------+   | SVGElement |
            |                 +-------------+       |   +------------+
            |                       |               |
            v                       v               v
    +------------------+    +-----------------+    +-------------------+
    | HTMLInputElement |    | HTMLBodyElement |    | HTMLAnchorElement |
    +------------------+    +-----------------+    +-------------------+
```

`<элемент>.nodeType` - возвращает тип узла элемента согласно таблице:
Константа                          | Значение | Описание
---------------------------------- | -------- | --------
`Node.ELEMENT_NODE`                | 1        | Узел элемента `<p>` или `<div>`
`Node.ATTRIBUTE_NODE`              | 2        | Атрибут элемента
`Node.TEXT_NODE`                   | 3        | Текст внутри элемента или атрибута
`Node.CDATA_SECTION_NODE`          | 4        | Секция `CDATASection` - `<!CDATA[[ ... ]]>`
`Node.PROCESSING_INSTRUCTION_NODE` | 7        | Процессорная инструкция XML документа - `<?xml-stylesheet ... ?>`.
`Node.COMMENT_NODE`                | 8        | Узел коментария - `<!-- ... -->`
`Node.DOCUMENT_NODE`               | 9        | Узел `Document`
`Node.DOCUMENT_TYPE_NODE`          | 10       | Узел `DocumentType` - `<!DOCTYPE html>`
`Node.DOCUMENT_FRAGMENT_NODE`      | 11       | Узел `DocumentFragment`

`<элемент>.nodeName`, `<элемент>.tagName` - содержат название (тег) элемента узла. Название HTML-тега всегда находится в **верхнем регистре**. Свойство `nodeName` определено для любых узлов Node, для элементов оно равно `tagName`, а для не-элементов обычно содержит строку с типом узла.  
`<элемент>.innerHTML` - позволяет получить HTML-содержимое элемента в виде строки. В `innerHTML` можно и читать и писать. Значение, возвращаемое `innerHTML` - всегда валидный HTML-код. Если в `innerHTML` есть тег `script` - он не будет выполнен.  
`<элемент>.outerHTML` - содержит HTML элемента целиком. Изменить `outerHTML` элемента невозможно.

Содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство `data`. Его тоже можно читать и обновлять.

`<элемент>.textContent` - содержит только текст внутри элемента, за вычетом всех `<тегов>`. Возвращает конкатенацию всех текстовых узлов внутри элемента. Есть возможность записать текст в элемент, причем именно как текст.

`<элемент>.hidden` - возвращает `true`, если узел не видим иначе `false`. Позволяет также устанавливать значение.

У DOM-узлов есть и другие свойства, зависящие от типа, например:
- `value` - значение для `INPUT`, `SELECT` или `TEXTAREA`;
- `id` - идентификатор;
- `href` - адрес ссылки;
- многие другие.

### <a id="Таблица" href="#Таблица">Таблица</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для таблицы используются дополнительные методы, которые значительно упрощают процесс конструирования таблиц.

`<элемент_таблицы>.createTHead()` - создает заголовочную секцию и возвращает ее.  
`<элемент_таблицы>.insertRow()` - создает строку и возвращает ее.  
`<элемент_строки>.insertCell()` - создает ячейку и возвращает ее.  

## <a id="Полифиллы" href="#Полифиллы">Полифиллы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

"**Полифилл**" (англ. *polyfill*) - это библиотека, которая добавляет в старые браузеры поддержку возможностей, которые в современных браузерах являются встроенными.

Общий вид этого полифилла довольно типичен. Обычно полифилл состоит из двух частей:
1. Проверка, есть ли встроенная возможность. Важная тонкость - элемент, который тестируем, должен по стандарту поддерживать такое свойство.
2. Эмуляция, если ее нет. Для добавления нужной возможности берется правильный класс и модифицируется его prototype.

## <a id="Свои-DOM-свойства" href="#Свои-DOM-свойства">Свои DOM-свойства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Узел DOM** - это объект, поэтому, как и любой объект в JavaScript, он может содержать пользовательские свойства и методы.

Нестандартные свойства и методы видны только в JavaScript и никак не влияют на отображение соответствующего тега. Пользовательские DOM-свойства:
- могут иметь любое значение;
- названия свойств чувствительны к регистру;
- работают за счет того, что DOM-узлы являются объектами JavaScript.

## <a id="Атрибуты" href="#Атрибуты">Атрибуты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Элементам DOM, с другой стороны, соответствуют HTML-теги, у которых есть текстовые атрибуты.

Доступ к атрибутам осуществляется при помощи стандартных методов:
- `<элемент>.hasAttribute(<имя>)` - проверяет наличие атрибута;
- `<элемент>.getAttribute(<имя>)` - возвращает значение атрибута;
- `<элемент>.setAttribute(<имя>, <значение>)` - устанавливает значение атрибута;
- `<элемент>.toggleAttribute(<имя>[, <force>])` - если атрибута нет, добавляет его, если есть - удаляет [, если `<force>` равно `true`, то он добавится, при `false` - удалится];
- `<элемент>.removeAttribute(<имя>)` - удаляет атрибут.

Эти методы работают со значением, которое находится в HTML.

`<элемент>.attributes` - возвращает все атрибуты элемента, которые содержится в псевдо-массиве объектов типа `Attr`.

В отличие от свойств, атрибуты:
- всегда являются строками;
- их имя нечувствительно к регистру (ведь это HTML);
- видны в `innerHTML` (за исключением старых IE).

Ссылка "как есть" из атрибута `href` - синхронизация не гарантирует одинакового значения в атрибуте и свойстве.

Изменение некоторых свойств обновляет атрибут. Чаще синхронизация - односторонняя: свойство зависит от атрибута, но не наоборот.

При изменении свойства `input.value` атрибут `input.getAttribute('value')` не меняется.

`<элемент>.className` - соответствует атрибуту `class`.

`<элемент>.classList` - это объект для работы с классами.

Методы `classList`:
- `<элемент>.classList.contains("<class>")` - возвращает `true`/`false`, в зависимости от того, есть ли у элемента класс;
- `<элемент>.classList.add("<class>")` - добавляет класс;
- `<элемент>.classList.remove("<class>")` - удаляет класс;
- `<элемент>.classList.toggle("<class>"[, <force>])` - если класса нет, добавляет его, если есть - удаляет [, если `<force>` равно `true`, то он добавится, при `false` - удалится].

Кроме того, можно перебрать классы через `for`, так как `classList` - это псевдо-массив.

Для нестандартных атрибутов DOM-свойство не создается. Стандартным свойство является, лишь если оно описано в стандарте именно для этого элемента.

С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript. Как правило, это делается при помощи атрибутов с названиями, начинающимися на `data-`. Стандарт HTML5 специально разрешает атрибуты `data-*` и резервирует их для пользовательских данных. К таким атрибутам можно обратиться не только как к атрибутам, но и как к свойствам, при помощи специального свойства `dataset`. Доступ к свойству: `<элемент>.dataset.<свойство>`. При этом kebab-case из HTML трансформируется в camelCase и наоборот.
> `data-abc-def` -> `dataset.abcDef`

## <a id="Относительное-расположение-узлов" href="#Относительное-расположение-узлов">Относительное расположение узлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<родитель>.contains(<ребенок>)` - возвращает `true`, если родитель содержит ребенка или родитель == ребенку.
`<узелА>.compareDocumentPosition(<узелВ>)` - возвращаемое значение - битовая маска, биты в которой означают следующее:

Константа                                        | Биты   | Число | Значение
------------------------------------------------ | ------ | ----- | -------
.                                                | 000000 | 0     | `<узелА>` и `<узелВ>` - один и тот же узел
`Node.DOCUMENT_POSITION_DISCONNECTED`            | 000001 | 1     | Узлы в разных документах (или один из них не в документе)
`Node.DOCUMENT_POSITION_PRECEDING`               | 000010 | 2     | `<узелВ>` предшествует `<узелА>` (в порядке обхода документа)
`Node.DOCUMENT_POSITION_FOLLOWING`               | 000100 | 4     | `<узелА>` предшествует `<узелВ>`
`Node.DOCUMENT_POSITION_CONTAINS`                | 001000 | 8     | `<узелВ>` содержит `<узелА>`
`Node.DOCUMENT_POSITION_CONTAINED_BY`            | 010000 | 16    | `<узелА>` содержит `<узелВ>`
`Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC` | 100000 | 32    | Зарезервировано для браузера

Понятие "*предшествует*" - означает не только "*предыдущий сосед при общем родителе*", но и имеет более общий смысл: "раньше встречается в порядке прямого обхода дерева документа. Могут быть и сочетания битов.

## <a id="Добавление-и-удаление-узлов" href="#Добавление-и-удаление-узлов">Добавление и удаление узлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`document.createElement('<тег>'[, {is: '<пользовательский_тег_элемента>}])` - создает новый элемент с указанным тегом [используя пользовательский элемент `<пользовательский_тег_элемента>`] и возвращает его.  
`document.createTextNode('<текст>')` - создает новый *текстовый* узел с данным текстом возвращает его.  
`<родитель>.appendChild(<элемент>)` - добавляет элемент в конец дочерних элементов родителя и возвращает вставленный элемент.  
`<родитель>.insertBefore(<вставляемый_элемент>, {<элемент_перед> | null})` - вставляет элемент в коллекцию детей родителя, перед указанным элементом `<элемент_перед>` (при `null` вставка будет после всех детей) и возвращает вставленный элемент.  
`<элемент>.cloneNode({true | false})` - создаст "глубокую" копию элемента и возвратит его - вместе с атрибутами, включая подэлементы, если `true`. Если же вызвать с аргументом `false`, то копия будет сделана без дочерних элементов. Это нужно гораздо реже.  
`<родитель>.removeChild(<элемент>)` - удаляет элемент из списка детей родителя и возвращает его.  
`<родитель>.replaceChild(<новый_элемент>, <элемент>)` - среди детей родителя удаляет элемент и вставляет на его место новый элемент и возвращает удаленный элемент.

Все методы вставки автоматически удаляют вставляемый элемент со старого места.

`<элемент>.remove()` - удаляет элемент напрямую, не требуя ссылки на родителя.

### <a id="Мультивставка" href="#Мультивставка">Мультивставка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<элемент>.insertAdjacentHTML("<куда>", "<html>")` - позволяет вставлять произвольный HTML в любое место документа, в том числе и между узлами, указанные в `<куда>`, который принимает значения:
- `beforebegin` - перед элементом;
- `afterbegin` - внутрь элемента, в самое начало;
- `beforeend` - внутрь элемента, в конец;
- `afterend` - после элемента.

`<элемент>.insertAdjacentElement("<куда>", <вставляемый_элемент>)` - вставляет в произвольное место элемент.  
`<элемент>.insertAdjacentText("<куда>", "<текст>")` - создает текстовый узел из строки и вставляет его в указанное место относительно элемента.  

### <a id="DocumentFragment" href="#DocumentFragment">`DocumentFragment`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это особенный кросс-браузерный DOM-объект, который похож на обычный DOM-узел, но им не является.

`document.createDocumentFragment()` - создает и возвращает объект.

В него можно добавлять другие узлы.

У `DocumentFragment` нет обычных свойств DOM-узлов, таких как `innerHTML`, `tagName` и т.п. Это не узел. Его главная цель заключается в том, что когда `DocumentFragment` вставляется в DOM - то он исчезает, а вместо него вставляются его дети. Это свойство является уникальной особенностью `DocumentFragment`.

### <a id="Дополнительные-методы" href="#Дополнительные-методы">Дополнительные методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<узел>.append(...<узлы>)` - вставляет узлы в конец узла.  
`<узел>.prepend(...<узлы>)` - вставляет узлы в начало узла.  
`<узел>.after(...<узлы>)` - вставляет узлы после узла узла.  
`<узел>.before(...<узлы>)` - вставляет узлы перед узлом узла.  
`<узел>.replaceWith(...<узлы>)` - вставляет узлы вместо узла.

Эти методы ничего не возвращают. Во всех этих методах узлы - DOM-узлы или строки, в любом сочетании и количестве. Причем строки вставляются именно как текстовые узлы.

## <a id="Метод-documentwrite" href="#Метод-documentwrite">Метод `document.write`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`document.write("<текст>")` - работает только пока HTML-страница находится в процессе загрузки. Он дописывает текст в текущее место HTML еще до того, как браузер построит из него DOM.  
`document.writeln("<текст>") `- работает аналогично `document.write`, но который добавляет после текста символ перевода строки `\n`.

Методы `document.write` и `document.writeln` пишут напрямую в текст документа, до того как браузер построит из него DOM, поэтому они могут записать в документ все, что угодно, любые стили и незакрытые теги. Попытка дописать что-то в закрытый документ открывает его заново. При этом все текущее содержимое удаляется.

## <a id="Стили" href="#Стили">Стили</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<элемент>.style` - возвращает объект, который дает доступ к стилю элемента на чтение и запись. Свойство `style` содержит лишь тот стиль, который указан в атрибуте элемента, без учета каскада CSS. С его помощью можно изменять большинство CSS-свойств:  
`<элемент>.style.<CSS_свойство> = <значение>` - при этом для свойств, названия которых состоят из нескольких слов: `часть1-часть2-часть3`, используется: `часть1Часть2Часть3`. Исключение: `style.cssFloat` вместо `style.float`. Если свойство с префиксами, то каждый дефис дает большую букву.

Чтобы сбросить поставленный стиль свойству, присваивают в `style` свойству пустую строку: `<элемент>.style.<CSS_свойство> = ""`. При сбросе свойства `style` стиль будет взят из CSS.

Стиль в `style` находится в формате браузера, а не в том, в котором его присвоили.

`<элемент>.style.cssText` - позволяет поставить стиль целиком в виде строки. При этом все предыдущие свойства `style` удаляются.

`<элемент>.style.getPropertyValue(<CSS_свойство>)` - возвращает значение указанного CSS свойства или переменной, если оно задано именно в `style` у элемента, а иначе пустую строку.

`<элемент>.style.setProperty(<CSS_свойство>, <значение>[, 'important'])` - устанавливает значение указанного CSS свойства или переменной[, и делает его с модификатором `!important`].

### <a id="Полный-стиль" href="#Полный-стиль">Полный стиль</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`getComputedStyle(<элемент>[, "<псевдо_элемент>"])` - возвращает объект с текущими используемыми значениями свойств элемента [или стиль псевдо-элемента], подобно `<элемент>.style`.

`getComputedStyle(<элемент>[, "<псевдо_элемент>"]).getPropertyValue(<CSS_свойство>)` - возвращает вычисленное свойство или значение переменной.

Для правильного получения значения нужно указать точное свойство.

### <a id="Медиа-запросы" href="#Медиа-запросы">Медиа-запросы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const mediaQueryList = window.matchMedia('<медиа_запрос>')` - возвращает объект типа `MediaQueryList`, который содержит:
- свойства:
    - `matches` со значением `true`, если документ соответствует мультимедийному запросу;
- методы:
    - `addEventListener('change', (mediaQueryList) => {/* ... */})` - добавляет обработчик для события `change` - который вызывается при изменении статуса медиа-запроса;
    - `removeEventListener('change', (mediaQueryList) => {/* ... */})` - удаляет обработчик для события `change`.

## <a id="Размеры-и-прокрутка-элементов" href="#Размеры-и-прокрутка-элементов">Размеры и прокрутка элементов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<элемент>.offsetParent` - находится ссылка на родительский элемент в смысле отображения на странице или `null`, если у элемента или родительского элемента установлено свойство `display` равное `none`, содержит первый элемент, у которого свойсво `position` не равен `static`.  
`<элемент>.offsetLeft` / `<элемент>.offsetTop` - задают смещение относительно `<элемент>.offsetParent`.
`<элемент>.offsetWidth` / `<элемент>.offsetHeight` - содержат "внешнюю" ширину / высоту элемента, то есть его полный размер, включая поля `padding` и рамки `border`.

Метрики для невидимых элементов равны нулю. Координаты и размеры в JavaScript устанавливаются только для видимых элементов.

`<элемент>.clientTop` / `<элемент>.clientLeft` - отступ внутренней части элемента от внешней, обычно толщина рамки `border`.  
`<элемент>.clientWidth` / `<элемент>.clientHeight` - размер элемента внутри рамок `border`. Они включают в себя ширину содержимого `width` вместе с полями `padding`, но без прокрутки. Если `padding` нет, то `<элемент>.clientWidth` / `<элемент>.clientHeight` в точности равны размеру области содержимого, внутри рамок и полосы прокрутки.

`<элемент>.scrollWidth` / `<элемент>.scrollHeight` - аналоги `<элемент>.clientWidth`/ `<элемент>.clientHeight`, но с учетом прокрутки. При этом если свойства `<элемент>.clientWidth` / `<элемент>.clientHeight` относятся только к видимой области элемента, а `<элемент>.scrollWidth` / `<элемент>.scrollHeight` добавляют к ней прокрученную (которую не видно) по горизонтали / вертикали.  
`<элемент>.scrollLeft` / `<элемент>.scrollTop` - ширина / высота невидимой, прокрученной в данный момент, части элемента слева и сверху. Их можно изменять.

Не стоит брать `width` / `height` из CSS.

## <a id="Анимация" href="#Анимация">Анимация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<элемент>.animate(<массив_из_объектов_css-свойств>, <опции>)` - производит анимацию элемента по аналогии с `@keyframes`. Где `<массив_из_объектов_css-свойств>` выглядит в виде:
- массива из объектов со свойствами:
    - `<css-свойство1>` - css свойство и его значение (свойство `offset` должно быть `cssOffset`);
    - `offset` - необязательное число от 0.0 до 1.0 отвечающее за процент в анимации;
    - `easing` - необязательное строка с функцией смягчения: `'linear'`, `'ease'`, `'ease-in'`, `'ease-out'`, `'ease-in-out'`, `'cubic-bezier(x,x,x,x)'`.
- объект со свойствами и значениями в виде массивов для описания кадров:
    - `<css-свойство1>` - css свойство и его значение массив значений для анимации(свойство `offset` должно быть `cssOffset`);
    - `offset` - необязательное массив чисел от 0.0 до 1.0 отвечающее за процент в анимации;
    - `easing` - необязательное массив строк с функциями смягчения как в css.
`<опции>` - число - время анимации или объект с необязательными свойствами для анимации:
- `id` - идентификатор анимации;
- `delay` - задержка перед анимацией в мс;
- `direction` - направление: `'normal'`, `'reverse'`, `'alternate'`, `'alternate-reverse`;
- `duration ` - продолжительность;
- `easing` - функциея смягчения: `'linear'`, `'ease'`, `'ease-in'`, `'ease-out'`, `'ease-in-out'`, `'cubic-bezier(x,x,x,x)'`;
- `endDelay` - задержка после анимации в мс;
- `fill` - режим воздействия анимации: `'none'`, `'forwards'`, `'backwards'`, `'both'`;
- `iterationStart` - смещение первой итерации анимации от 0.0 до 1.0;
- `iterations` - количество повторений анимации.

## <a id="Размеры-и-прокрутка-страницы" href="#Размеры-и-прокрутка-страницы">Размеры и прокрутка страницы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`document.documentElement.clientWidth` / `document.documentElement.clientHeight` - ширина / высота видимой области окна, то есть за вычетом полосы прокрутки.  
`document.documentElement.scrollWidth` / `document.documentElement.scrollHeight` - ширина / высота размера веб-страницы, включая в себя внутренние отступы страницы, но не включая границы, внешние отступы и полосы прокрутки.  
`window.pageXOffset`/`window.pageYOffset` - ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.  
`window.scrollBy(<x>, <y>)` - прокручивает страницу относительно текущих координат.  
`window.scrollTo(<pageX>, <pageY>)` - прокручивает страницу к указанным координатам относительно документа. Он эквивалентен установке свойств `scrollLeft`/`scrollTop`.  
`<элемент>.scrollIntoView({true | false})` - вызывается на элементе и прокручивает страницу так, чтобы элемент оказался вверху, если параметр равен `true`, и внизу, если равен `false`.  
`<элемент>.scrollIntoView({behavior: { 'auto' | 'smooth' }, block: { 'start' | 'center' | 'end' | 'nearest' } })` - вызывается на элементе и прокручивает страницу плавно при этом так, чтобы элемент оказался в начале, по центру, в конце или в ближайшей позиции.

Чтобы запретить прокрутку страницы, достаточно поставить `document.body.style.overflow = "hidden"`.

Размеры экрана хранятся в глобальной переменной `screen`:
- `window.screen.width` - содержит ширину экрана;
- `window.screen.height` - содержит высоту экрана;
- `window.screen.availWidth` - содержит доступную ширину экрана - без панели инструментов операционной системы;
- `window.screen.availHeight` - содержит доступную высоту экрана - без панели инструментов операционной системы.

Размеры окна:
- `window.outerWidth` - содержит ширину окна браузера, включая адресную строку, панель вкладок и другие панели браузера;
- `window.outerHeight` - содержит высоту окна браузера, включая адресную строку, панель вкладок и другие панели браузера;
- `window.innerWidth` - содержит ширину окна области просмотра (вьюпорта);
- `window.innerHeight` - содержит высоту окна области просмотра (вьюпорта).

### <a id="Ориентация-экрана" href="#Ориентация-экрана">Ориентация экрана</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`screen.orientation.lock("portrait" | "landscape");` - фиксирует ориентацию экрану и возвращает обещание, которое разрешится в случае успеха фиксации.

`screen.orientation.unlock();` - разблокирует ориентацию экрану.

`screen.orientation.type;` - возвращает текущую ориентацию экрана.

### <a id="Видимость-страницы" href="#Видимость-страницы">Видимость страницы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`document.hidden` - свойство для чтения, которое содержит `true`, если страница скрыта.  
`document.visibilityState` - свойство для чтения, которое возвращает состояние видимости страницы:
- `visible` - страница видима или страница не свернута и находится в текущей вкладке;
- `hidden` - страница скрыта;
- `prerender` - начальное состояние видимой страницы: предварительный рендеринг;
- `unloaded` - страница выгружена из памяти.

## <a id="Координаты-в-окне" href="#Координаты-в-окне">Координаты в окне</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<элемент>.getBoundingClientRect()` - возвращает координаты элемента, под которыми понимаются размеры "воображаемого прямоугольника", который охватывает весь элемент. Координаты относительно окна не учитывают прокрутку, они высчитываются от границ текущей видимой области. Координаты возвращаются в виде объекта со свойствами:
- `top` - Y-координата верхней границы элемента;
- `left` - X-координата левой границы;
- `right` - X-координата правой границы;
- `bottom` - Y-координата нижней границы;
- `x` - X-координата правого угла;
- `y` - Y-координата правого угла;
- `width` - ширина элемента;
- `height` - высота элемента.

`document.elementFromPoint(<x>, <y>)` - возвращает элемент, который находится на координатах [`<x>`, `<y>`] относительно окна. А для координат вне окна возвращает `null`.

## <a id="Координаты-в-документе" href="#Координаты-в-документе">Координаты в документе</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Система координат относительно страницы или, иначе говоря, относительно документа, начинается в левом-верхнем углу, но не окна, а именно страницы. И координаты в ней означают позицию по отношению не к окну браузера, а к документу в целом.

Координаты относительно экрана `window.screenX` / `window.screenY` отсчитываются от его левого-верхнего угла. Имеется в виду именно весь экран, а не окно браузера.

## <a id="MutationObserver" href="#MutationObserver">`MutationObserver`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`MutationObserver` предоставляет возможность получать уведомления об изменении определенных DOM-элементов.

`const <mutationObserver> = new MutationObserver(function (mutations, <mutationObserver>) {});` - создает новый `MutationObserver`, который принимает функцию, которая будет вызываться каждый раз, когда в DOM будут происходить изменения, где `mutations` - это коллекция всех произошедших мутаций в виде единого пакета. Где объект мутации содержит:
- `type` - возвращает `"attributes"` если это изменение атрибутов, `"characterData"` если это изменение узла `CharacterData`, и `"childList"` если это изменение дочернего дерева узлов;
- `target` - возвращает узел, который затронула мутация, в зависимости от типа `type`:
    - `attributes` - это элемент где произошли изменения;
    - `characterData` - это узел `CharacterData`;
    - `childList` - это узел где потомок был изменен;
- `addedNodes` - список добавленных узлов;
- `removedNodes` - список удаленных узлов;
- `previousSibling` - возвращает предыдущего соседа добавленных или удаленных узлов или `null`;
- `nextSibling` - возвращает следующего соседа добавленных или удаленных узлов или `null`;
- `attributeName` - возвращает имя измененного атрибута или `null`;
- `attributeNamespace` - возвращает пространство имен измененного атрибута или `null`;
- `oldValue` - возвращает значение, которое зависит от типа `type`:
    - `attributes` - это значение атрибута до изменений;
    - `characterData` - это данные `CharacterData` до изменений;
    - `childList` - это `null`.

`<mutationObserver>.observe(<элемент_наблюдения>, <объект_опций>)` - запускает процесс отслеживания изменений DOM за узлом DOM `<элемент_наблюдения>`, за которым нужно наблюдать, и объект с параметрами `<объект_опций>`:
- `childList` - `true`, если необходимо наблюдать за добавлением или удалением дочерних элементов (включая текстовые узлы (text nodes));
- `attributes` - `true`, если необходимо наблюдать за изменениями атрибутов целевого элемента;
- `characterData` - `true`, если необходимо наблюдать за изменениями значения текстового содержимого целевого узла (текстовых узлов дочернего элемента);
- `subtree` - `true`, если необходимо наблюдать за потомками целевого элемента;
- `attributeOldValue` - `true`, если необходимо возвращать предыдущее значение атрибута;
- `characterDataOldValue` - `true`, если необходимо возвращать предыдущее значение `Data` атрибута;
- `attributeFilter` - устанавливает массив названий атрибутов (без указания пространства имен), если требуется наблюдать за изменениями конкретных атрибутов.

Внутри себя содержит слабые ссылки на узлы за которыми смотрит, поэтому не перепятствуется их удалению сборщиком мусора.

Необходимо указать одно из cвойств: `childList`, `attributes`, `characterData`.

`<mutationObserver>.disconnect()` - останавливает наблюдение за изменениями.

`<mutationObserver>.takeRecords()` - возвращает текущую очередь экземпляра `MutationObserver`, после чего очищает ее.

## <a id="ResizeObserver" href="#ResizeObserver">`ResizeObserver`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`ResizeObserver` предоставляет возможность получать уведомления об изменении размеров DOM-элементов.

`const <resizeObserver> = new ResizeObserver(function (entries, <resizeObserver>) {});` - создает новый `ResizeObserver`, который принимает функцию, которая будет вызываться каждый раз, когда в DOM будут изменяться размеры, где `entries` - это массив всех объектов у которых изменился размер со свойствами:
- `borderBoxSize` - содержит новый размер с границами;
- `contentBoxSize` - содержит новый размер содержимого;
- `contentRect` - содержит размер в виде `<элемент>.getBoundingClientRect()`;
- `target` - элемент у которого произошли изменения.

`<resizeObserver>.observe(<элемент_наблюдения>)` - запускает процесс отслеживания изменений DOM за узлом DOM `<элемент_наблюдения>`, за которым нужно наблюдать.

`<resizeObserver>.unobserve(<элемент_наблюдения>)` - останавливает процесс отслеживания.

`<resizeObserver>.disconnect()` - останавливает наблюдение за изменениями.

## <a id="IntersectionObserver" href="#IntersectionObserver">`IntersectionObserver`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`IntersectionObserver` используется для наблюдения за положением элемента относительно родительского элемента или указанного.

`const <intersectionObserver> = new IntersectionObserver(function (entries, <intersectionObserver>) {}, <объект_опций>);` - создает новый `IntersectionObserver`, который принимает функцию, которая будет вызываться каждый раз, когда элемент будет изменять свое положение в зависимости от опций, где `entries` - это массив всех объектов у которых изменилось положение со свойствами:
- `boundingClientRect` - содержит положение эелемента;
- `intersectionRatio` - содержит соотношение пересечения;
- `intersectionRect` - содержит прямоугольник пересечения;
- `isIntersecting` - содержит `true`, если произошло пересечение, а иначе `false`;
- `rootBounds` - содержит границы корневого элемента;
- `target` - содержит элемент пересечения;
- `time` - содержит время пересечения.

А `<объект_опций>` - это объект со свойствами:
- `root` - элемент-контейнер для наблюдением за пересечением или `null`;
- `rootMargin` - отступы от элемента контейнера в виде css-свойства `margin`;
- `threshold` - число или массив чисел от 0 до 1 с пределами срабатывания обработчика.

`<intersectionObserver>.observe(<элемент_наблюдения>)` - запускает процесс отслеживания изменения положения за узлом DOM `<элемент_наблюдения>`.

`<intersectionObserver>.unobserve(<элемент_наблюдения>)` - останавливает процесс отслеживания.

`<intersectionObserver>.disconnect()` - останавливает наблюдение за изменениями.

<a id="Основы-работы-с-событиями" href="#Основы-работы-с-событиями">Основы работы с событиями</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========================

**Событие** - это сигнал от браузера о том, что что-то произошло. Существует много видов событий.

## <a id="События-мыши" href="#События-мыши">События мыши</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `click` - возникает, когда кликнули на элемент левой кнопкой мыши;
- `dblclick` - возникает, когда дважды кликнули на элемент левой кнопкой мыши;
- `contextmenu` - возникает, когда кликнули на элемент правой кнопкой мыши;
- `mouseover` и `mouseout` - возникает, когда на элемент наводится мышь или на один из его детей, или покидает его или одного из его детей;
- `mousedown` и `mouseup` - возникает, когда кнопку мыши нажали или отжали над элементом;
- `mousemove` - возникает при движении мыши;
- `mouseenter` и `mouseleave` - возникает, когда на элемент наводится мышь или покидает его, при этом не учитываются переходы внутри элемента и они не всплывают.

Основные свойства событий:
- `which` - содержит нажатую кнопку мыши (`1` - левая кнопка, `2` - средняя кнопка, `3` - правая кнопка);
- `shiftKey` - содержит `true`, если нажат `shift`;
- `altKey` - содержит `true`, если нажат `alt`;
- `ctrlKey` - содержит `true`, если нажат `ctrl`;
- `metaKey` - (для Mac) содержит `true`, если нажат `meta`;
- `clientX`/`clientY` - содержит координаты курсора относительно текущего окна;
- `pageX`/`pageY` - содержит координаты курсора относительно документа;
- `target` - элемент, на который пришла мышь для события `mouseover` и элемент, с которого ушла мышь для события `mouseout`, то есть на котором возникло событие;
- `relatedTarget` - элемент, с которого пришла мышь для события `mouseover` и элемент, на который перешла мышь для события `mouseout`, может быть равно `null`, если мышь пришла не с другого элемента, а из-за пределов окна (или ушла за окно).

## <a id="События-на-элементах-управления" href="#События-на-элементах-управления">События на элементах управления</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `submit` - возникает, когда пользователь отправляет форму `<form>`;
- `formdata` - возникает, когда форму передают в конструктор `FormData`;
- `blur` - возникает, когда элемент теряет фокус;
- `change` - возникает, когда содержимое элемента изменяется (для `<input>`, `<keygen>`, `<select>`, и `<textarea>`);
- `focus` - возникает, когда элемент получает фокус;
- `input` - возникает, когда у элемента изменяется значение;
- `beforeinput` - возникает перед тем, как у элемента изменится значение;
- `invalid` - возникает, когда элемент не валиден;
- `reset` - возникает, когда форма сбрасывается;
- `search` - возникает, когда печатается что-то в поле поиска (`<input="search">`);
- `select` - возникает, когда пользователь что-то выделяет в тексте (для `<input>` и `<textarea>`).

## <a id="Клавиатурные-события" href="#Клавиатурные-события">Клавиатурные события</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `keydown` - возникает, когда пользователь нажимает клавишу;
- `keypress` - возникает, когда пользователь нажал клавишу;
- `keyup` - возникает, когда пользователь отпускает клавишу.

Основные свойства событий:
- `keyCode` - содержит скан-код клавиши;
- `which` - содержит код символа;
- `charCode` - содержит код символа;
- `shiftKey` - содержит `true`, если нажат `shift`;
- `altKey` - содержит `true`, если нажат `alt`;
- `ctrlKey` - содержит `true`, если нажат `ctrl`;
- `metaKey` - (для Mac) содержит `true`, если нажат `meta`;
- `repeat` - `true` при долгом нажатии клавиши, когда возникает автоповтор.

Управляющие клавиши, такие как `Ctrl`, `Shift`, `F1`, `F2`... - `keypress` не генерируют. Появление символа можно предотвратить, если отменить действие браузера на `keydown`/`keypress` по умолчанию. Отменять можно не только символ, а любое действие клавиш. На момент срабатывания `keydown`/`keypress` клавиша еще не обработана браузером, поэтому значение еще старое.

## <a id="События-манипулирования-текстом" href="#События-манипулирования-текстом">События манипулирования текстом</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `copy` - возникает, когда пользователь копирует содержимое элемента;
- `cut` - возникает, когда пользователь вырезает содержимое элемента;
- `paste` - возникает, когда пользователь вставляет содержимое в элемент.

## <a id="События-выделения-текста" href="#События-выделения-текста">События выделения текста</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `selectstart` - возникает, когда пользователь начинает выделение на элементе;
- `selectionchange` - возникает каждый раз, когда область выделения меняется.

`window.getSelection()` - возвращает объект с информацией о текущем выделении текста на странице, который содержит:
- `anchorNode` - узел на котором началось выделение;
- `anchorOffset` - отступ на узле на котором началось выделение;
- `focusNode` - узел на котором выделение закончилось;
- `focusOffset` - отступ на узле на котором выделение закончилось.

## <a id="События-перетаскивания-DragnDrop" href="#События-перетаскивания-DragnDrop">События перетаскивания Drag'n'Drop</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Запускаются только у тех элементов, у которых есть атрибут `draggable="true"`:
- `drag` - возникает, когда элемент начинается перетаскиваться;
- `dragenter` - возникает, когда элемент входит в зону опускания;
- `dragleave` - возникает, когда элемент выходит из зоны опускания;
- `dragover` - возникает, когда элемент находится над зоной опускания элемента, необходимо отменять стандартное действие `event.preventDefault()`, для указания возможности опускания;
- `dragstart` - возникает, когда пользователь начинает перетаскивать элемент, тут можно назначать полезные данные для передачи, с помощью: `event.dataTransfer` у которого есть специальные методы и свойства:
    - `setData('<ключ>', <значение>)` - устанавливает данные по ключу;
    - `getData('<ключ>')` - возвращает данные по ключу;
    - `setDragImage(<img_элемент>, <x>, <y>)` - устанавливает изображение перемещения;
    - `files` - массив с файлами, если пользователь перетягивал файл в указанную область.
- `dragend` - возникает, когда пользователь заканчивает перетаскивать элемент.

Возникает над элементом, в котором прекращается перетаскивание:
- `drop` - возникает, когда пользователь опускает перетаскиваемый элемент в зону опускания, необходимо отменять стандартное действие `event.preventDefault()`, для указания возможности опускания, можно использовать `event.dataTransfer`.

## <a id="События-печати" href="#События-печати">События печати</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `beforeprint` - возникает, когда страница выводится на печать;
- `afterprint` - возникает, когда страница начинает печататься или диалог печати закрыт.

## <a id="События-CSS-transition" href="#События-CSS-transition">События CSS transition</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `transitionend` - возникает, когда `CSS-transition` завершен.

Основные свойства событий:
- `propertyName` - свойство, анимация которого завершилась;
- `elapsedTime` - время (в секундах), которое заняла анимация, без учета `transition-delay`.

## <a id="События-CSS-анимации" href="#События-CSS-анимации">События CSS анимации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `animationend` - возникает, когда CSS-анимация завершена;
- `animationiteration` - возникает, когда CSS-анимация повторяется;
- `animationstart` - возникает, когда CSS-анимация начинается.

## <a id="События-Frame-и-Object" href="#События-Frame-и-Object">События `Frame` и `Object`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `abort` - возникает при отмене загрузки ресурса;
- `beforeunload` - возникает перед выгрузкой документа, если назначено на `window`, то можно показать уведомление об уходе, для этого нужно присвоить `''` свойству `returnValue`;
- `error` - возникает при ошибки загрузки существующего файла;
- `hashchange` - возникает при смене хеша (якоря) документа;
- `load` - возникает после загрузки объекта;
- `pageshow` - возникает, когда пользователь просматривает страницу;
- `pagehide` - возникает, когда у пользователя страница скрыта;
- `resize` - возникает при изменении области вывода вида документа;
- `scroll` - возникает, когда пользователь прокручивает документ - генерируется всегда, при любой прокрутке, не обязательно "мышиной". Некоторые области применения `onscroll`:
    - показ дополнительных элементов навигации при прокрутке;
    - подгрузка и инициализация элементов интерфейса, ставших видимыми после прокрутки.
- `unload` - возникает, когда страница выгружена.

## <a id="События-касания" href="#События-касания">События касания</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `touchcancel` - возникает, когда касание прервано;
- `touchend` - возникает, когда касание окончено;
- `touchmove` - возникает, когда касание движется по экрану;
- `touchstart` - возникает, когда касание начато.

## <a id="Другие-события" href="#Другие-события">Другие события</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `DOMContentLoaded` - возникает, когда HTML загружен и обработан, DOM документа полностью построен и доступен - браузер полностью загрузил HTML, и построил DOM-дерево, все DOM-элементы разметки уже созданы, можно их искать, вешать обработчики, создавать интерфейс, но при этом, возможно, еще не догрузились какие-то картинки или стили. Вешается на `document`;
- `message` - возникает, когда принимается сообщение из `WebSocket`, `WebWorker`, `EventSource` или из родительского окна или из дочернего фрейма;
- `online` и `offline` - возникает, когда браузер начинает работать онлайн или оффлайн;
- `popstate` - возникает, когда изменяется история браузера;
- `storage` - возникает, когда `Web Storage` обновляется;
- `wheel` - возникает, когда колесико мыши прокручивается над элементом. При этом не важно, прокручиваемый он или нет. В частности, `overflow: hidden` никак не препятствует обработке колеса мыши. Свойства:
    - `<event>.deltaX`/`<event>.deltaY`/`<event>.deltaZ` - количество прокрученных пикселей по горизонтали и вертикали и оси Z. Возникает до прокрутки, поэтому в нем можно отменить саму прокрутку (действие браузера).
- `visibilitychange` - возникает, когда изменяется свойство `visibilityState`;
- `beforeprint` - возникает перед появлением окна печати;
- `afterprint` - возникает после печати или ее отмены.

## <a id="Обработка-событий" href="#Обработка-событий">Обработка событий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Событию можно назначить **обработчик**, то есть функцию, которая сработает, как только событие произошло.

`<элемент>.on<событие> = function (event) {...}` - только один обработчик, кросс-браузерный.  
Его можно убрать назначением `<элемент>.on<событие> = null`. Где `event` - это событие типа `Event`.

Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором он сработал. Это можно использовать, чтобы получить свойства или изменить элемент.

`<элемент>.addEventListener("<событие>", function (event) {...}[, {<фаза> | <опции>}])` - назначение обработчика, позволяет добавлять несколько обработчиков на одно событие одного элемента, где `<фаза>` обозначает фазу погружения при значении `true` или всплытия при значении `false`, а `<опции>` представляет собой объект со свойствами:
- `capture` - обозначет фазу погружения при `true` или всплытия при `false`;
- `once` - при значении `true` указывает, что слушатель должен быть вызван не более одного раза после добавления, слушатель автоматически удаляется при вызове слушателя;
- `passive` - указывает, что слушатель никогда не вызовет `preventDefault()`, если все же вызов будет произведен, браузер должен игнорировать его и генерировать консольное предупреждение;
- `signal` - принимает `AbortSignal` для отмены запроса.

`<элемент>.removeEventListener("<событие>", <функция>[, <фаза>])` - удаление обработчика события, для этого необходимо передать те же аргументы, что были у `addEventListener`, а именно одну и ту же функцию, т.е. ссылку на нее и фазу.

`<элемент>.addEventListener("<событие>", { handleEvent(event) {...} }[, {<фаза> | <опции>}])` - регистрирует объект для обработки события, у которого будет вызываться метод `handleEvent` при возникновении события в который будет передаваться событие.

`<элемент>.addEventListener("<событие>", <объект>[, {<фаза> | <опции>}])` - удаляет объект для обработки события.

### <a id="Специальные-методы-Chrome" href="#Специальные-методы-Chrome">Специальные методы (Chrome)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`monitorEvents(<HTML_элемент>, { '<событие>' | ['<событие1>'[, ...]] });` - устанавливает мониторинг событий элемента, при каждом вызове события выводит в консоль сведения об этих событиях.  
`unmonitorEvents(<HTML_элемент>, { '<событие>' | ['<событие1>'[, ...]] });` - убирает мониторинг событий элемента.

`getEventListeners(<HTML_элемент>);` - возвращает объект, где ключи это имена событий, а его значения - это список слушателей события элемента.

### <a id="AbortController" href="#AbortController">AbortController</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для отмены операций.

`const <abortController> = new AbortController();`  
`const <abortSignal> = <abortController>.signal;` - возвращяет связанный объект `AbortSignal`.  
`<abortController>.abort([<причина>]);` - вызывает прерывание в сигнале - то есть генерирует событие `abort` [с причиной `<причина>`] и сигнал вызывает прерывание там где он передан.  
`<abortSignal>.addEventListener('abort', () => {...});` - добавляет обработку сигнала прерывания;  
`<abortSignal>.aborted;` - содержит `true`, если был вызван `abort`, а иначе `false`.

`const <abortSignal> = AbortSignal.abort([<причина>]);` - возвращает `AbortSignal` который уже прерван [с причиной `<причина>`].  
`const <abortSignal> = AbortSignal.any(<итерируемый_объект>);` - возвращает `AbortSignal` который прервется, когда прервется любой из переданных `AbortSignal` в `<итерируемый_объект>`.  
`const <abortSignal> = AbortSignal.timeout(<количество_мс>);` - возвращает `AbortSignal` который уже прервется через `<количество_мс>` времени.

### <a id="Очередь-событий" href="#Очередь-событий">Очередь событий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Когда происходит событие, оно попадает в очередь. Внутри браузера непрерывно работает "**главный внутренний цикл**", который следит за состоянием очереди и обрабатывает события, запускает соответствующие обработчики и т.п. Иногда события добавляются в очередь сразу пачкой. Когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.

Отложенный вызов через `setTimeout(<функция>, 0)` используется не только в событиях, а вообще - всегда, когда необходимо, чтобы некая функция сработала после того, как текущий скрипт завершится.

#### <a id="Порядок-обработки-событий" href="#Порядок-обработки-событий">Порядок обработки событий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Стек вызовов** - это список, который отражает, какие функции сейчас вызываются и куда будет совершен переход, после окончания исполнения текущей функции.

1. Очередь **TaskQueue** - представляет собой очередь из **Task** - вызовов обработчиков событий, таймаутов, интервалов;
2. Очередь **MicroTaskQueue** - представляет собой очередь из **MicroTask** - обратных функций для `Promise` или для `MutationObserver`. Выполняется сразу же после освобождения очереди **TaskQueue**. Задачи в этой очереди могут порождать другие **MicroTask**, которые будут вызываться сразу же по освобождению стека вызовов;
3. Очередь **RenderQueue** - представляет собой очередь для отрисовки, состоит из этапов:
    1. **requestAnimationFrame** - вызываются все обратные функции переданые в `requestAnimationFrame`;
    2. **Style** - перерасчет всех стилей, которые должны примениться из-за изменений, запланированных JS (изменение свойств, классов, порядка элементов). Здесь же происходит вычисление активных media queries;
    3. **Layout** - происходит вычисление слоев, расчет положения элементов на странице, их размеров, взаимного влияния друг на друга. Чем больше DOM элементов на странице, тем тяжелее эта операция. Вычисляется каждый раз при чтении свойств влияющих на размер и положение элементов (`offsetWidth`, `offsetLeft`, `getBoundingClientRect`, и т.д.) и при записи свойств, влияющих на размер и положение элементов, за исключением некоторых свойств, вроде `transform` и `will-change`. Самая тяжелая операция;
    4. **Paint** - происходит отрисовка элементов;
    5. **Composition** - исполняются специфические CSS стили, например `transform`. Задача этой операции: совместить слои и получить готовый кадр. Анимация на `transform` позволяет нам не вызывать layout каждый кадр, и это экономит время.

При изменении размеров или получении размеров элемента из кода будет запущен процесс **force layout** в котором будут вызваны **requestAnimationFrame**, **Style**, **Layout** вне своей очереди событий и пока эти опрерации не завершаться, дальнейшее выполнение кода будет приостановлено. Для ускорения этих опраций лучше использовать групирование операций на изменение свойств и на чтение свойств.

### <a id="Основные-свойства-и-методы-объекта-события-Event" href="#Основные-свойства-и-методы-объекта-события-Event">Основные свойства и методы объекта события `Event`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `type` - тип события;
- `currentTarget` - элемент, на котором сработал обработчик. Значение - в точности такое же, как и у `this`, но бывают ситуации, когда обработчик является методом объекта и его `this` при помощи `bind` привязан к этому объекту, тогда можно использовать `currentTarget`;
- `clientX`/`clientY` - координаты курсора в момент клика (относительно окна);
- `target` - это исходный элемент, на котором произошло событие, в процессе всплытия он неизменен;
- `eventPhase` - на какой фазе он сработал (**погружение** = `1`, **всплытие** = `3`);
- `composed` - возвращает `true`, если событие должно проходить сквозь ShadowRoot, а иначе `false`;
- `composedPath()` - возвращает массив пройденых элементов, до текущего обработчика.

Кросс-браузерное решение: `event = event || window.event`.

### <a id="Всплытие" href="#Всплытие">Всплытие</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основной принцип всплытия: при наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.

Всплытие идет прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента `<html>`, а затем до `document`, а иногда даже до `window`, вызывая все обработчики на своем пути.

`<event>.stopPropagation()` - останавливает всплытие.  
`<event>.stopImmediatePropagation()` - останавливает всплытие, но и останавливает обработку событий на текущем элементе для всех последующих обработчиков.

### <a id="Погружение" href="#Погружение">Погружение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Событие сначала идет сверху вниз по DOM. Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент `addEventListener` `<фаза>`:
- если аргумент `true`, то событие будет перехвачено по дороге вниз;
- если аргумент `false`, то событие будет поймано при всплытии.

### <a id="Делегирование-событий" href="#Делегирование-событий">Делегирование событий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Всплытие событий позволяет реализовать один из самых важных приемов разработки - **делегирование**. Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому - мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент `<event>.target`, понять на каком именно потомке произошло событие и обработать его, иногда необходимо вверх по иерархии родителей от `<event>.target` и выше.

Делегирование позволяет использовать обработчик и для абсолютно разных действий, к примеру один обработчик на родителе вместо многих на детях.

### <a id="Прием-проектирования-поведение" href="#Прием-проектирования-поведение">Прием проектирования "поведение"</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Шаблон проектирования "**поведение**" (*behavior*) позволяет задавать хитрые обработчики на элементе декларативно, установкой специальных HTML-атрибутов и классов.

Прием проектирования "поведение" состоит из двух частей:
1. Элементу ставится атрибут, описывающий его поведение.
2. При помощи делегирования ставится обработчик на документ, который ловит все клики и, если элемент имеет нужный атрибут, производит нужное действие.

### <a id="Отмена-действия-браузера-по-умолчанию" href="#Отмена-действия-браузера-по-умолчанию">Отмена действия браузера по умолчанию</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Есть два способа отменить действие браузера:
- основной способ - это воспользоваться объектом события. Для отмены действия браузера существует стандартный метод `<event>.preventDefault()`:
- если же обработчик назначен через `on<событие>` (не через `addEventListener`), то можно просто вернуть `false` из обработчика.

Кросс-браузерное решение: `event.preventDefault ? event.preventDefault() : (event.returnValue = false);`

### <a id="Генерация-событий-на-элементах" href="#Генерация-событий-на-элементах">Генерация событий на элементах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var <событие> = new Event("<тип_события>"[, <флаги>])` - создание события, где `<флаги>` - объект вида `{ bubbles: {true | false}, cancelable: {true | false} }`, где свойство `bubbles` указывает, всплывает ли событие, а `cancelable` - можно ли отменить действие по умолчанию. Флаги по умолчанию: `{bubbles: false, cancelable: false}`.

`<элемент>.dispatchEvent(<событие>)` - инициирование события, возвращает `false` если было вызвано `<event>.preventDefault()`. При этом событие срабатывает наравне с браузерными, то есть обычные браузерные обработчики на него отреагируют. Если при создании указан флаг `bubbles`, то оно будет всплывать.

При создании события браузер автоматически ставит следующие свойства:
- `isTrusted: false` - означает, что событие сгенерировано скриптом, это свойство изменить невозможно;
- `target: null` - это свойство ставится автоматически позже при `dispatchEvent`;
- `type: <тип_события>` - первый аргумент `new Event`;
- `bubbles`, `cancelable` - по второму аргументу `new Event`.

Другие свойства события, если они нужны - можно присвоить в объект события позже:
`<событие>.<свойство> = <значение>`.

Для некоторых конкретных типов событий есть свои, специфические, конструкторы: `UIEvent`, `FocusEvent`, `MouseEvent`, `WheelEvent`, `KeyboardEvent`, `CompositionEvent`. Специфический конструктор позволяет указать стандартные свойства для данного типа события.

### <a id="Свои-события" href="#Свои-события">Свои события</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для генерации своих, нестандартных, событий, можно использовать конструктор `Event`, но существует и специфический конструктор `CustomEvent`. Технически, он абсолютно идентичен `Event`, кроме небольшой детали: у второго аргумента-объекта есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.

### <a id="Старое-API" href="#Старое-API">Старое API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`var <событие> = document.createEvent("<интерфейс_типа_события>")` - создание события, где интерфейс типа события может быть `Event` или `UIEvent`, `FocusEvent`, `MouseEvent`, `WheelEvent`, `KeyboardEvent`, `CompositionEvent`.  
`<событие>.initEvent("<тип_события>", <bubbles>, <cancelable>)` - инициализация события.

У конкретных типов событий, есть методы, которые позволяют указать стандартные свойства. Они называются по аналогии: `init<интерфейс_типа_события>`. Их можно использовать вместо базового `initEvent`, если нужно, чтобы свойства событий соответствовали встроенным браузерным.

### <a id="Мышь-DragnDrop" href="#Мышь-DragnDrop">Мышь: Drag'n'Drop</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Drag'n'Drop** - это возможность захватить мышью элемент и перенести его. Перенос мышкой может заменить целую последовательность кликов. И, самое главное, он упрощает внешний вид интерфейса: функции, реализуемые через Drag'n'Drop, в ином случае потребовали бы дополнительных полей, виджетов и т.п.

Основной алгоритм Drag'n'Drop выглядит так:
1. Отслеживают нажатие кнопки мыши на переносимом элементе при помощи события `mousedown`;
2. При нажатии - подготавливают элемент к перемещению;
3. Далее отслеживают движение мыши через `mousemove` и передвигают переносимый элемент на новые координаты путем смены `left`/`top` и `position: absolute`;
4. При отпускании кнопки мыши, то есть наступлении события `mouseup` - останавливают перенос элемента и производят все действия, связанные с окончанием Drag'n'Drop.

Также нужно отключить собственный Drag'n'Drop у браузера, который автоматически запускается и вступает в конфликт с нашим. Это происходит именно для картинок и некоторых других элементов:` <элемент>.ondragstart = function () { return false;};`

Еще одна особенность правильного Drag'd'Drop - событие `mousemove` отслеживается на `document`, а не на элементе.

При Drag'n'Drop везде используется координаты относительно документа, так как они подходят в большем количестве ситуаций.

"**Аватар**" - это DOM-элемент, который перемещается по экрану.

При Drag'n'Drop элемент перекрывает остальные элементы. Поэтому функция `document.elementFromPoint()` увидит на текущих координатах именно его, поэтому необходимо: спрятать элемент, вызывать `elementFromPoint`, показать элемент.

<a id="Формы-элементы-управления" href="#Формы-элементы-управления">Формы, элементы управления</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========================

## <a id="Навигация-и-свойства-элементов-формы" href="#Навигация-и-свойства-элементов-формы">Навигация и свойства элементов формы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Элементы `FORM` можно получить по имени или номеру, используя свойство `document.forms[{<имя_формы> | <index>}]` или `document.forms.<имя_формы>`, где `<имя_формы>` - это `id` формы.

Любой элемент формы можно получить, используя свойство `<форма>.elements[{<имя_элемента> | <index>}]` или `<форма>.elements.<имя_элемента>`. Может быть несколько элементов с одинаковым именем. В таком случае вернет коллекцию элементов. Эти ссылки не зависят от окружающих тегов. Элемент может быть "зарыт" где-то глубоко в форме, но он все равно доступен через `<форма>.elements`. Свойство `elements` также есть у элементов `<fieldset>`.

По элементу можно получить его форму, используя свойство `<элемент>.form`.

Для большинства типов `input` значение ставится/читается через свойство `value`.

У большинства элементов формы может присутствовать атрибут `form="<имя_формы>"`, который связывает элемент с указанной формой.

Для элементов `textarea` доступно свойство `innerHTML`, но оно хранит только HTML, изначально присутствовавший в элементе, и не меняется при изменении значения.

Текущее "отмеченное" состояние для `checkbox` и `radio` находится в свойстве `checked` (`true`/`false`).

Выделение для `select` в JavaScript можно установить двумя путями: поставив значение свойства `value`, либо установив свойство `selectedIndex` в номер нужной опции. Установка `selectedIndex = -1` очистит выбор. Список элементов-опций (`option`) доступен через свойство `options`. Если `select` допускает множественный выбор (атрибут `multiple`), то значения можно получить/установить, сделав цикл по свойству `options`. При этом выбранные опции будут иметь свойство `selected = true`. Есть у `option` также свойства: `index` - номер опции в списке селекта и `text` - текстовое содержимое опции.

Для объектов у которых есть выделяемый текст доступны свойства: `selectionStart` - начало выделения, `selectionEnd` - конец выделения текста.

### <a id="Проверки-ошибок" href="#Проверки-ошибок">Проверки ошибок</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<input>.checkValidity()` - возвращает `true`, если на элементе нет ошибок данных, а иначе `false` и отправляет событие `invalid` на элемент со свойством `cancelable = true`.  
`<input>.reportValidity()` - возвращает `true`, если на элементе нет ошибок данных, а иначе `false` и отправляет событие `invalid` на элемент со свойством `cancelable = true`, а также сообщает вне элемента что есть ошибка.  
`<input>.setCustomValidity(<message>)` - устанавливает произвольное сообщение об ошибке.

`<input>.validity` - содержит объект с ошибками проверок данных:
- `valueMissing` - при значении `true` обозначает, что нет значения (`required`) и добавляет CSS севдокласс `:invalid`;
- `typeMismatch` - при значении `true` обозначает, что значения не корректного типа (`type`) и добавляет CSS севдокласс `:invalid`;
- `patternMismatch` - при значении `true` обозначает, что значения не может удолетворить регулярному выражению (`pattern`) и добавляет CSS севдокласс `:invalid`;
- `tooLong` - при значении `true` обозначает, что значения слишком длинное (`maxlength`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
- `tooShort` - при значении `true` обозначает, что значения слишком короткое (`minlength`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
- `rangeUnderflow` - при значении `true` обозначает, что значения слишком маленькое (`min`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
- `rangeOverflow` - при значении `true` обозначает, что значения слишком большое (`max`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
- `stepMismatch` - при значении `true` обозначает, что значения не кратно шагу (`step`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
- `badInput` - при значении `true` обозначает, что значения не соответствует чему-то;
- `customError` - при значении `true` обозначает, что значения не соответствует какому-то пользовательскому условию, то есть было установлено с помощью метода `setCustomValidity(<message>)`;
- `valid` - при значении `true` обозначает, что значения удолетворяет всем проверкам.

`<input>.validationMessage` - содержит строку с текстом ошибки или пустую строку, если ошибки нет.

`<input>.willValidate ` - содержит `true` если элемент будет проверяться, а иначе `false` при аттрибуте `disabled` или аттрибуте `type` равным `hidden`, `reset`, `button`.

`<input>.form` - содержит элемент формы к которому привязан или `null` если формы нет.

## <a id="Файлы" href="#Файлы">Файлы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для `input` с типом `file` файлы можно получить через свойство `files`, которое вернет коллекцию `FileList`, если есть атрибут `multiple`, то доступна множественная загрузка файлов, состоящую из элементов `File`, у которого имеются такие свойства:
- `name` - имя файла;
- `lastModified` - дата последней модификации;
- `size` - размер файла в байтах;
- `type` - MIME тип файла.

Для открытия окна выбора файла необходимо вызвать событие `click` на элементе `input`.

Для чтения содержимого файла используется `FileReader`.  
`var <fileReader> = new FileReader();`

`<fileReader>.error` - ошибка чтения.  
`<fileReader>.result` - содержимое файла.  
`<fileReader>.readyState` - состояние чтения:
- `EMPTY` = `0` - данные еще не загружены;
- `LOADING` = `1` - данные загружаются;
- `DONE` = `2` - данные загружены и обработаны.

`<fileReader>.onerror = function (event) {...}` - вызывается при ошибки чтения.  
`<fileReader>.onload = function (event) {...}` - вызывается при завершении чтения и обработки.

`<fileReader>.readAsArrayBuffer(<file>)` - читает содержимое файла как `ArrayBuffer` в `result` и будет доступно после события `onload`.  
`<fileReader>.readAsText(<file>[, "<кодировка>"])` - читает содержимое файла как текст [, в указаной кодировке] в `result` и будет доступно после события `onload`.  
`<fileReader>.readAsDataURL(<file>)` - читает содержимое файла как строку в виде `data:[<MIME_тип>][;charset=<кодировка>][;base64],<base64_содержимое_файла>` в `result` и будет доступно после события `onload`.

## <a id="Фокусировка" href="#Фокусировка">Фокусировка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Событие `focus` вызывается тогда, когда пользователь фокусируется на элементе, а `blur` - когда фокус исчезает, например посетитель нажимает на другом месте экрана.

Методы `<элемент>.focus()`/`<элемент>.blur()` - переводят/уводят фокус с элемента.

Любой элемент поддерживает фокусировку, если у него есть атрибут `tabindex`. Его основной смысл - это указать номер по порядку элемента при переборе клавишей `Tab`. Исключением являются специальные значения: `tabindex="0"` делает элемент всегда последним; `tabindex="-1"` означает, что клавиша `Tab` будет элемент игнорировать.

События `focus` и `blur` не всплывают, но они могут быть пойманы на фазе перехвата.

Текущий элемент, на котором фокус, доступен как `document.activeElement`.

## <a id="Изменение" href="#Изменение">Изменение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Событие `change` происходит по окончании изменении значения элемента формы, когда это изменение зафиксировано. Для текстовых элементов это означает, что событие произойдет не при каждом вводе, а при потере фокуса. Для остальных же элементов: `select`, `input` `type=checkbox` / `type=radio` оно срабатывает сразу при выборе значения.

Событие `input` срабатывает тут же при изменении значения текстового элемента.

События `cut`, `copy`, `paste` - происходят при вырезании/вставке/копировании значения. На момент срабатывания события в элементе все еще старое значение, а новое недоступно.

## <a id="Формы" href="#Формы">Формы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Событие `submit` возникает при отправке формы.

Методы:
- `<форма>.submit()` позволяет инициировать отправку формы из JavaScript, без участия пользователя. При этом само событие `submit` не генерируется;
- `<форма>.requestSubmit(["<инициатор>"])` позволяет инициировать проверку всех элементов и в случае успеха проверки запускает отправку формы из JavaScript, без участия пользователя [с указанным инициатором отправки];
- `<форма>.reset()` сбрасывает состояние полей формы до исходных значений;
- `<форма>.checkValidity()` - возвращает `true` если все элементы формы удолетворяют внутренним проверкам, а иначе отправляет тем эелементам, которые не удолетворяют проверкам событие `invalid` и возвращает `false`;
- `<форма>.reportValidity()` - возвращает `true` если все элементы формы удолетворяют внутренним проверкам, а иначе отправляет тем эелементам, которые не удолетворяют проверкам событие `invalid`, а также отправляет ошибку вне и возвращает `false`.

## <a id="Диалог" href="#Диалог">Диалог</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Тег `dialog` используется для создания диалогового окна.

Атрибут `open` открывает диалог, но не делает его модальным.

Методы:
- `<dialog>.show()` / `<dialog>.showModal()` - показывает диалог модального вида;
- `<dialog>.close([<значение>])` - закрывает диалог.

Свойство `returnValue` содержит значение `value` кнопки `button` типа `submit` которой был закрыт диалог (при нажатии клавиши `ESC` будет значение `""`) в форме.

## <a id="Всплывающий-элемент" href="#Всплывающий-элемент">Всплывающий элемент</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Атрибут `popover` используется для создания всплывающего элемента, который будет находиться на верхнем уровне отображения. Имеет значения:
- `auto` (по умолчанию) - скрываются автоматом при клике вне области и показывается только один всплывающий элемент;
- `manual` - не скрывается автоматом и может быть отображено множество одновременно.

У других элементов могут быть атрибуты для управления всплывающим элементом:
- `popovertarget="<id_popover>"` - для `button` / `input` устанавливает при взаимодействии с элементом производить действия с всплывающим элементом с id = `<id_popover>`;
- `popovertargetaction="<action>"` - указывает какое действие нужно совершить:
    - `show` - показать;
    - `toggle` - переключить состояние отображения;
    - `hide` - скрыть.

Методы:
- `<popover>.showPopover()` - показывает всплывающий элемент;
- `<popover>.togglePopover([<force>])` - показывает / скрывает всплывающий элемент[, если `<force>` равно `true`, то он только покажется, при `false` - только скроется];
- `<popover>.hidePopover()` - скрывает всплывающий элемент.

<a id="Обработка-ошибок" href="#Обработка-ошибок">Обработка ошибок</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
================

`window.onerror` - если в него записать функцию `function (message, url, lineNo, columnNo, error) {...}`, то она выполнится при возникновении неперехваченной ошибки, где `message` - сообщение ошибки , `url` - текущий URL, `lineNo` - номер строки, `columnNo` - номер столбца, где "возникла" ошибка и `error` - объект ошибки.

`window.addEventListener('unhandledrejection', (event) => {...});` - выполнит указанную функцию при возникновении не перехваченного исключения, где `event` - событие со свойством `reason` - причиной возникновения ошибки.

<a id="Взаимодействие-с-пользователем-alert-prompt-confirm" href="#Взаимодействие-с-пользователем-alert-prompt-confirm">Взаимодействие с пользователем: `alert`, `prompt`, `confirm`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============================================================

`alert(<сообщение>);` - выводит на экран окно с сообщением и приостанавливает выполнение скрипта, пока пользователь не нажмет "ОК". Окно сообщения, которое выводится, является модальным окном. Слово "**модальное**" означает, что посетитель не может взаимодействовать со страницей, нажимать другие кнопки и т.п., пока не разберется с окном.

`prompt(<заголовок>, <значение_по_умолчанию>);` - выводит модальное окно с заголовком, полем для ввода текста, заполненным строкой по умолчанию и кнопками `OK`/`CANCEL`. Пользователь должен либо что-то ввести и нажать `OK`, либо отменить ввод кликом на `CANCEL` или нажатием `Esc` на клавиатуре. Вызов `prompt` возвращает то, что ввел посетитель - строку или специальное значение `null`, если ввод отменен (в Safari возвращает пустую строку).

`confirm(<вопрос>);` - `confirm` выводит модальное окно с вопросом с двумя кнопками: `OK` и `CANCEL`. Результатом будет `true` при нажатии `OK` и `false` - при `CANCEL`(`Esc`).

<a id="Создание-графических-компонентов" href="#Создание-графических-компонентов">Создание графических компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
================================

**Виджет** - это объект, который либо контролирует готовое дерево DOM, либо создает свое.

## <a id="Основные-принципы-при-создании-виджета" href="#Основные-принципы-при-создании-виджета">Основные принципы при создании виджета</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- вся разметка заключена в корневой элемент. Внутри корневого элемента - только классы, не `id`;
- для работы с разметкой создается объект (`new`) и передается ему корневой элемент. Все методы и свойства добавляются к переданному корневому элементу. В конструкторе он ставит необходимые обработчики для событий. У конструктора только один аргумент (иногда два, первый аргумент - сам элемент `elem`) - объект `options`, так как у графических компонентов обычно много настроек, большинство из которых имеют разумные значения "**по умолчанию**";
- обработчики назначаются через **делегирование**. Обработчики отделяются от реальных действий;
- создаются публичные методы для изменения состояния компонента;
- в конструкторе происходит генерация DOM, которая по возможности, должна быть "**ленивой**". Фаза инициализации очень чувствительна к производительности, так как обычно в сложном интерфейсе создается много всего. При инициализации, если существенный участок работы можно отложить до реального задействования виджета - откладывают его.

## <a id="Верстка-графических-компонентов" href="#Верстка-графических-компонентов">Верстка графических компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При создании графических компонент ("**виджетов**") в первую очередь придумывается их **HTML/CSS-структура**. При семантической верстке классы описывают **смысл** ("*что это*?" - меню, кнопка...) и **состояние** (открыто, закрыто, отключено...) компонента.

Зачастую компонент может иметь несколько состояний. Состояние должно добавляться CSS-классом не на тот элемент, который нужно скрыть/показать/..., а на тот, к которому оно "*по смыслу*" относится, обычно - на корневой элемент.

Чтобы избежать возможных проблем, все классы внутри виджета начинают с его имени. Двойное подчеркивание `__` служит "*стандартным*" разделителем.

Стили должны вешаться на **класс**, а не на тег.

## <a id="Создание-анимации-с-помощью-requestAnimationFrame" href="#Создание-анимации-с-помощью-requestAnimationFrame">Создание анимации с помощью `requestAnimationFrame`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const <requestID> = requestAnimationFrame(<функция>)` - указывает браузеру выполнить указанную функцию, в которой будет происходить отрисовка анимации при первой возможности, а не с заданным интервалом, все это зависит от частоты кадров браузера и компьютера. Передает в вызываемую функцию первым параметром *timestamp*, который содержит миллисекунды до запятой, и микросекунды - после, который является некой временной меткой с момента открытия браузера. Возвращает идентификатор с помощью которого можно отменить вызов функции: `cancelAnimationFrame(<requestID>)`.

Также `requestAnimationFrame` - группирует все анимации в одном браузерном *repaint*.

## <a id="Работа-во-время-простоя-requestIdleCallback" href="#Работа-во-время-простоя-requestIdleCallback">Работа во время простоя `requestIdleCallback`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const <requestID> = requestIdleCallback(<функция>[, { timeout: <макс_ожидание_в_мс> }])` - указывает браузеру выполнить указанную функцию, во время периодов простоя браузера. Возвращает идентификатор с помощью которого можно отменить вызов функции: `cancelIdleCallback(<requestID>)`.

## <a id="Шаблонизация" href="#Шаблонизация">Шаблонизация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Шаблон** - это строка в специальном формате, которая путем подстановки значений (текст сообщения, цена и т.п.) и выполнения встроенных фрагментов кода превращается в DOM/HTML.

Для работы с таким шаблоном используется специальная функция, которая преобразует текст в функцию, а затем уже в DOM/HTML, т. е. функция запускает "**компиляцию**" шаблона и возвращает результат в виде функции, которую далее можно запустить с данными и получить строку-результат.

**Шаблон** - это многострочный HTML-текст. Записывать его прямо в скрипте - неудобно. Один из альтернативных способов объявления шаблона - записать его в HTML, в тег `<script>` с нестандартным `type`, например `"text/template"`:

```html
<script type="text/template" id="<tempalate-id>">
    ...
</script>
```

Если `type` не знаком браузеру, то содержимое такого скрипта игнорируется, однако оно доступно при помощи `innerHTML` - `document.getElementById('<tempalate-id>').innerHTML`.

## <a id="Колбэки" href="#Колбэки">Колбэки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Колбэк** (от англ. *callback*) - это функция, которую передают куда-либо и ожидают, что она будет вызвана при наступлении события.

В современных браузерах DOM-элементы могут генерировать произвольные события при помощи встроенных методов: `<элемент>.dispatchEvent(<событие>)`.

Очень важно, что внешний код ставит обработчик на корневой элемент, но не на внутренние элементы меню. Такое правило позволяет не опасаться проблем при оптимизации, расширении и даже полной переделке DOM-структуры меню. Коль скоро события и методы сохраняются, внешний код будет работать как прежде. Внешний код не имеет права залезать внутрь DOM-структуры меню, ставить там обработчики и так далее.

<a id="Веб-компоненты" href="#Веб-компоненты">Веб компоненты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==============

Предназначены для создание собственных html-тегов со своим отображением и логикой.

```js
class <CustomElement> extends HTMLElement {
    /**
     * вызывается при инициализации
     */
    constructor() {
        super();
        const shadowRoot = this.attachShadow({ mode: 'open' | 'close'}); // возвращает (и добавляет при 'open') ShadowRoot для сокрытия содержимого элемента, где 'open' обозначает, что в свойстве `shadowRoot` будет содержаться ShadowRoot, а 'close' - что там его не будет
        this.shadowRoot; // возвращает ShadowRoot с которым можно взаимодействовать как с DOM-узлом, если был установлен режим 'open' иначе будет равен undefined
        shadowRoot.host; // возвращает HTMLElement в который помещен ShadowRoot
        const internals = this.attachInternals(); // создает объект ElementInternals для взаимодействия с формой
        this.isConnected; // равно `true`, если элемент добавлен в документ, а иначе равен `false`
    }
    /**
     * позволяет элементу взаимодействовать с формой `form`
     */
    static formAssociated = true;
    /**
     * должен быть массивом атрибутов за которыми нужно следить
     */
    static observedAttributes = ['<имя_атрибута_1>'];
    /**
     * вызывается при изменении атрибута за которым следят в `observedAttributes`
     * вызывается при использовании методов setAttribute / removeAttribute / toggleAttribute
     * @params {string} propertyName - имя атрибута
     * @params {string | null} oldValue - старое значение
     * @params {string | null} newValue - новое значение
     */
    attributeChangedCallback(propertyName, oldValue, newValue) {}
    /**
     * вызывается когда компонент вставляется в DOM
     * тут должена происходить отрисовка компонентов
     * а также навешивание обработчиков
     */
    connectedCallback() {}
    /**
     * вызывается когда компонент удаляется из DOM
     * тут должен происходить удаление обработчиков
     */
    disconnectedCallback() {}
    /**
     * вызывается когда компонент перемещается в другой компонент
     */
    adoptedCallback() {}
    /**
     * вызывается когда компонент добавляется в форму или удаляется из нее
     * @params form - элемент формы, если добавился в форму, а иначе null
     */
    formAssociatedCallback(form) {}
    /**
     * вызывается когда форма сбрасывается
     */
    formResetCallback() {}
    /**
     * вызывается когда `disabled` изменяется у компонента или fieldset в котором он находится, также вызывается когда происходит изначально `disabled` установлен
     * @params {boolean} disabled - новое значение `disabled` формы
     */
    formDisabledCallback(disabled) {}
    /**
     * вызывается когда форма востанавливается
     * @params value - значение
     * @params reason - причина "autocomplete" или "restore"
     */
    formStateRestoreCallback(value, reason) {}
}
```

`customElements.define("<custom-element>", <CustomElement>[, {extends: "<тег>"}]);` - регистрация элемента при этом имя компонента должно содержать символ `-`. Теперь его можно использовать в html как `<custom-element>`: `<custom-element></custom-element>` [, `"<тег>"` - указывает что элемент расширяет указанный тег и тогда при его использовании можно писать `<<тег> is="<custom-element>"></<тег>>`].
```js
<custom-element>
    <h1 slot="header">Header</slot>
    <pre>Some body text</pre>
</custom-element>
```

`customElements.whenDefined('<custom-element>');` - возвращает обещание, которое разрешится, когда будет зарегистрирован элемент `<custom-element>` с помощью функции `customElements.define`.

`customElements.get('<custom-element>');` - возвращает зарегистрированый элемент, его класс, если он есть, а иначе `undefined`.

`customElements.upgrade(<element>);` - производит обновление элемента до его `<custom-element>`, если он был создан до регистрации `<custom-element>`.

Для описания html для элемента используется тег `template` с идентификатором в котором располагается html, содержимое которого потом копируется:
```js
const <template> = document.createElement('template');
<template>.innerHTML = `
    <!--html код-->
`;
```

Для добавления его используется `this.shadowRoot.appendChild(<template>.content.cloneNode(true));` в конструкторе.

Для добавления стилей используется свойство `this.shadowRoot.adoptedStyleSheets`, которому присваивается массив объектов `CSSStyleSheet`.  
Еще можно добавить стили, с использованием тега `style` по аналогии с `template` или описать их внутри тега `template` в теге `style`.

Внутри тега `template` можно использовать тег `<slot [name="<имя_слота>"]></slot>` в который можно будет передавать внутренний html, который находится внутри элемента: `<custom-element>...</custom-element>`, для указания в какой слот рисовать у html-тега можно указать атрибут `slot="<имя_слота>"`, все что не содержит имя слота будет отображено в слоте по умолчанию (без имени или равным `""`).

Элементы с одинаковым именем слота могут повторяться и тогда они будут последовательно в порядке определения вставляться в слот.

Если существует два или более слота с одинаковым именем, то вставка будет производится в первый слот в дереве.

Назначать элементам слот можно только прямым потомкам компонента, если во вложеных узлах будет назначен слот, то он будет игнорироваться.

У слота может быть содержимое по умолчанию, которое будут отображено если в слот ничего не будет передано.

```html
<template id="hello-world">
  <slot name="msgtext" class="hw-text"></slot>
  <slot></slot>
</template>
```

Внутри тега `template` может располагаться тег `style` который будет влиять на внутренние элементы. Там доступен псевдоселектор `:host` - который указывает на текущий элемент.

Селектор `:not(:defined)` позволяет получить все элементы, которые не зарегистрированы.

`:host(<селектор>)` - используется для навешивания разнообразных обработчиков на корневой элемент.

Атрибут `part` у элементов со значением `<part1>[ ...]` позволяет прокидывать элементы за shadow-tree, что позволяет их использовать в селекторе `::part(<part1>)` вне shadow-tree.
> `<span part="title main">Title</span>`  
> `custom-element::part(title) {...}`

Атрибут `exportparts` со значением `<part1>[: <алиас1>][ ...]` на самом веб компоненте позволяет прокидывать внутреннии `part` на уровень выше.
> `<custom-element exportparts="title"></custom-element>`

Для ожидания регистрации всех вложеных элементом можно использовать ожидание их всех:
```js
const undefinedElements = container.querySelectorAll(":not(:defined)");
const promises = [...undefinedElements].map((element) =>
    customElements.whenDefined(element.localName)
);
await Promise.all(promises);
```

Для передачи значений могут использоваться атрибуты или свойства экземпляра.

События генерируемые на элементах внутри ShadowRoot пробрасываются наружу, при этом при режиме `closed` `target` у события будет равным `<custom-element>` внутри которого произошло событие.

По взаимодействию атрибутов можно смотреть на тег `input`.

## <a id="slot" href="#slot">`slot`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для передачи элементов в компонент. Для доступа к слотам можно использовать селектор по тегу `slot`.

Методы слота:
- `<slot>.assignedNodes([{ flatten: true }])` - который возвращает массив узлов находящихся в этом слоте [если вложенные `slot` присутствуют, то возвращается их содержимое в этом массиве];
- `<slot>.assignedElements([{ flatten: true }])` - который возвращает массив элементов находящихся в этом слоте [если вложенные `slot` присутствуют, то возвращается их содержимое в этом массиве];
- `<slot>.assign(<узел_1>[, ...])` - назначает вручную узлы в слот.

События слота:
- `slotchange` - вызывается, когда к слоту присоединяется или отсоединяется связанный со слотом элемент, также вызывается при первой вставке элементов.

У элемента связанного со слотом есть свойство `assignedSlot` - которое является ссылочным типом на слот, если он есть и при установленном `mode` равном `'open'` или `null`.

Для доступа к элементам слота для стилизации можно использовать селектор: `::slotted(<селектор>)`.

## <a id="ElementInternals" href="#ElementInternals">`ElementInternals`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержит свойства и методы для работы веб компонента с формой. Имеет методы и свойства для обычных элементов ввода и расширен дополнительными.

`const <internals> = this.attachInternals();` - создает объект ElementInternals для взаимодействия с формой.

`<internals>.setFormValue(<value>[, <state>])` - устанавливает значение формы (если оно равно `null` то значение участвует в отправке формы) [и состояние `<state>`] по имени равному значению атрибута `name` веб компонента при условии что `<value>` является типом `File` или `string`, а если типом `FormData`, то игнорирует значение атрибута `name` и устанавливает все из `FormData`.

`<internals>.setValidity(<flags>, <message> [, <anchor>])` - устанавливает что элемент не проходит проверку на входные данные, где:
- `<flags>` - объект с булевыми флагами, сообщающий о том, что именно не корректно про проверке. Имеются такие флаги:
    - `valueMissing` - при значении `true` обозначает, что нет значения (`required`) и добавляет CSS севдокласс `:invalid`;
    - `typeMismatch` - при значении `true` обозначает, что значения не корректного типа (`type`) и добавляет CSS севдокласс `:invalid`;
    - `patternMismatch` - при значении `true` обозначает, что значения не может удолетворить регулярному выражению (`pattern`) и добавляет CSS севдокласс `:invalid`;
    - `tooLong` - при значении `true` обозначает, что значения слишком длинное (`maxlength`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
    - `tooShort` - при значении `true` обозначает, что значения слишком короткое (`minlength`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
    - `rangeUnderflow` - при значении `true` обозначает, что значения слишком маленькое (`min`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
    - `rangeOverflow` - при значении `true` обозначает, что значения слишком большое (`max`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
    - `stepMismatch` - при значении `true` обозначает, что значения не кратно шагу (`step`) и добавляет CSS севдокласс `:invalid` и `:out-of-range`;
    - `badInput` - при значении `true` обозначает, что значения не соответствует чему-то;
    - `customError` - при значении `true` обозначает, что значения не соответствует какому-то пользовательскому условию;
- `<message>` - строка с текстом ошибки;
- `<anchor>` - это элемент `HTMLElement` в котором будет отображаться ошибка.

`<internals>.setValidity({})` - устанавливает что элемент проходит проверку на входные данные.

`<internals>.states` - это набор `Set`, который содержит состояния элемента. используется для модификации отображения через селектор `:state(<состояние>)` так как состояния доступны из вне.

<a id="AJAX-и-COMET" href="#AJAX-и-COMET">AJAX и COMET</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

**AJAX** (аббревиатура от "*Asynchronous Javascript And Xml*") - технология обращения к серверу без перезагрузки страницы. За счет этого уменьшается время отклика и веб-приложение по интерактивности больше напоминает десктоп. Под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.

**COMET** - общий термин, описывающий различные техники получения данных по инициативе сервера.

## <a id="XMLHttpRequest" href="#XMLHttpRequest">`XMLHttpRequest`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объект `XMLHttpRequest` (или, как его кратко называют, "**XHR**") дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы. `XMLHttpRequest` может работать с любыми данными, а не только с XML.

`var <xhr> = new XMLHttpRequest()` - создание.  
`<xhr>.open(<HTTP_метод>, <URL_адреса_запроса>, <async>[, <логин>, <пароль>])` - метод настройки открытия - как правило, вызывается первым после создания объекта `XMLHttpRequest`. Где `<async>`, если установлен в `false`, то запрос производится синхронно, если `true` - асинхронно [, а `<логин>` и `<пароль>` - логин и пароль для HTTP-авторизации, если нужен].

"**Синхронный запрос**" означает, что после вызова `<xhr>.send()` и до ответа сервера главный поток будет "заморожен". После получения ответа выполнение продолжится со следующей строки.

"**Асинхронный запрос**" означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики событий.

`<xhr>.send([<тело_запроса>])` - открывает соединение и отправляет запрос на сервер, так же можно отправить и содержимое файла.  
`<xhr>.abort()` - прерывает выполнение запроса.

Основные свойства, содержащие ответ сервера, которые содержатся в `<xhr>`:
- `status` - HTTP-код ответа: 200, 404, 403 и так далее. Может быть также равен 0, если сервер не ответил или при запросе на другой домен;
- `statusText` - текстовое описание статуса от сервера: `OK`, `Not Found`, `Forbidden` и так далее;
- `responseText` - текст ответа сервера;
- `responseXML` - если сервер вернул XML, снабдив его правильным заголовком `Content-type: text/xml`, то браузер создаст из него XML-документ.

### <a id="Событие-readystatechange" href="#Событие-readystatechange">Событие `readystatechange`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Событие `readystatechange` происходит несколько раз в процессе отсылки и получения ответа. При этом можно посмотреть "*текущее состояние запроса*" в свойстве `<xhr>.readyState`:
- `UNSENT = 0` - начальное состояние;
- `OPENED = 1` - вызван `open`;
- `HEADERS_RECEIVED = 2` - получены заголовки;
- `LOADING = 3` - загружается тело (получен очередной пакет данных), повторяется при каждом получении очередного пакета данных по сети;
- `DONE = 4` - запрос завершен.

### <a id="HTTP-заголовки" href="#HTTP-заголовки">HTTP-заголовки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для работы с HTTP-заголовками есть 3 метода:
`<xhr>.setRequestHeader('<заголовок>', <значение>)` - устанавливает заголовок запроса с указанным значением. При этом поставленный заголовок нельзя снять.  
`<xhr>.getResponseHeader('<заголовок>')` - возвращает значение заголовка ответа, кроме `Set-Cookie` и `Set-Cookie2`.  
`<xhr>.getAllResponseHeaders()` - возвращает все заголовки ответа, кроме `Set-Cookie` и `Set-Cookie2`. Заголовки возвращаются в виде единой строки. Между заголовками стоит перевод строки в два символа `\r\n` (не зависит от ОС), значение заголовка отделено двоеточием с пробелом `: `. Этот формат задан стандартом.

Максимальную продолжительность асинхронного запроса можно задать свойством `<xhr>.timeout` в миллисекундах.

При превышении этого времени запрос будет оборван и сгенерировано событие `<xhr>.ontimeout`.

Полный список событий по ходу обработки запроса:
- `loadstart` - запрос начат;
- `progress` - браузер получил очередной пакет данных, можно прочитать текущие полученные данные в `<xhr>.responseText`. Объект типа `ProgressEvent` со свойствами:
    - `loaded` - сколько байт уже переслано, только тело запроса, заголовки не учитываются;
    - `lengthComputable` - если `true`, то известно полное количество байт для пересылки, и оно хранится в свойстве `total`;
    - `total` - общее количество байт для пересылки, если известно.
- `abort` - запрос был отменен вызовом `<xhr>.abort()`;
- `error` - произошла ошибка;
- `load` - запрос был успешно (без ошибок) завершен;
- `timeout` - запрос был прекращен по таймауту;
- `loadend` - запрос был завершен (успешно или неуспешно).

### <a id="POST" href="#POST">POST</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При POST обязателен заголовок `Content-Type`, содержащий кодировку:
`Content-Type: application/x-www-form-urlencoded`

Это указание для сервера - как обрабатывать (раскодировать) пришедший запрос.

#### <a id="POST-запрос-в-кодировке-multipartform-data" href="#POST-запрос-в-кодировке-multipartform-data">POST-запрос в кодировке multipart/form-data</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Достаточно указать в заголовке `Content-Type` кодировку и границу:  
`Content-Type: multipart/form-data; boundary=<разделитель>`  
и далее сформировать тело запроса, удовлетворяющее требованиям кодировки, каждую секцию для каждого элемента в теле запроса начинать с:
```
--<разделитель>
Content-Disposition: form-data; name="<имя_секции>"
<пустая_строка>
<значения>
```

Для отправки каждого файла используется:
```
--<разделитель>
Content-Disposition: form-data; name="<имя_секции>"; filename="<имя_файла>"
Content-Type: <MIME_тип_файла>
<пустая_строка>
<содержимое_файла>
```

В конце присутствует "эпилог" о завершении передачи:
```
--<разделитель>--
<пустая_строка>
```

### <a id="FormData" href="#FormData">`FormData`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это объект, который кодирует формы для отправки на сервер.

`var <formData> = new FormData([<элемент_формы>]);` - создание [с определеннымы элементами по элементам формы `form`, с `name` и `value`].  
`<formData>.set('<ключ>', <значение>[, '<имя_файла_для_отправки>']);` - устанавливает значение по ключу.  
`<formData>.has('<ключ>');` - возвращает `true` если есть ключ со значением или `false` если его нет.  
`<formData>.append('<ключ>', <значение>);` - добавление значение ключу.
`<formData>.append('<ключ>', <значение>[, '<имя_файла_для_отправки>']);` - добавление значение ключу, таким обазом можно добавлять и файлы.  
`<formData>.get('<ключ>');` - возвращает первое значение по ключу или `null` если его нет.  
`<formData>.getAll('<ключ>');` - возвращает массив значений ключа.  
`<formData>.delete('<ключ>');` - удаляет значение ключа и сам ключ.

`<formData>.keys()` - возвращает итерируемый объект для ключей.  
`<formData>.values()` - возвращает итерируемый объект для значений.  
`<formData>.entries()` - возвращает итерируемый объект для записей `[<ключ>, <значение>]`.

Объект `<formData>` можно сразу отсылать, интеграция `FormData` с `XMLHttpRequest` встроена в браузер. Кодировка при этом будет `multipart/form-data`.

Для обмена данными JS <-> сервер можно использовать и просто `JSON`, желательно с указанием кодировки в заголовке `Content-Type`.

### <a id="URL" href="#URL">`URL`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это объект, который содержит параметры URL и методы для работы с ним.

`const <url> = new URL(<URL_строка>[, <URL_основа>]);` - создает `URL` на основе переданной строки `<URL_строка>` [с основой `<URL_основа>` когда `<URL_строка>` относительная, а не абсолютная].

Свойства:
- `<url>.href` - строка содержащая URL целиком. При изменении, соответствующий документ переходит на новую страницу;
- `<url>.protocol` - строка содержащая протокол текущего URL, включая `:`;
- `<url>.host` - строка содержащая хост, а именно имя хоста, `:` и порт;
- `<url>.hostname` - строка содержащая домен текущего URL;
- `<url>.port` - строка содержащая номер порта текущего URL;
- `<url>.pathname` - строка содержащая первый `/` после хоста с последующим текстом URL;
- `<url>.search` - строка содержащая `?` с последующими параметрами URL;
- `<url>.hash` - строка содержащая `#` с последующим идентификатором;
- `<url>.username` - строка содержащая имя пользователя, указанное перед именем домена;
- `<url>.password` - строка содержащая пароль, указанный перед именем домена;
- `<url>.origin` - строка содержащая протокол, хост и порт текущего URL;
- `<url>.searchParams` - объект `URLSearchParams`;

Методы:
- `<url>.toString();` - возвращает строку URL - аналогично `<url>.href`.

`URL.canParse(<URL_строка>[, <URL_основа>])` - возвращает `true`, если строка `<URL_строка>` [с основой `<URL_основа>`] - это валидная URL, а иначе `false`.  
`URL.parse(<URL_строка>[, <URL_основа>])` - возвращает объект `URL`, если строка `<URL_строка>` [с основой `<URL_основа>`] - это валидная URL, а иначе `null`.  
`URL.createObjectURL(<объект>)` - создает из объекта `<объект>` типа `File` или `Blob` строку вида `blob:` в которой объект будет закодирован;.  
`URL.revokeObjectURL(<строка>)` - создает объект типа `File` или `Blob` из строки `<строка>` вида `blob:` в которой объект был закодирован.

### <a id="URLSearchParams" href="#URLSearchParams">`URLSearchParams`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это объект, который кодирует или раскодирует параметры для отправки на сервер.

`var <urlSearchParams> = new URLSearchParams(['<параметры>']);` - создание [с определеннымы параметрами после `?` для запроса `GET` или тело запроса `POST`].

По методам идентичен `FormData` с дополнительными методами:
- `<urlSearchParams>.toString();` - возвращает строку запроса с правильно сформированным URL.  

## <a id="Кросс-доменные-запросы" href="#Кросс-доменные-запросы">Кросс-доменные запросы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Спецификация **CORS** налагает специальные ограничения на кросс-доменные запросы. Их виды:
1. **Простые** - считаются запросы, если они удовлетворяют следующим двум условиям:
    - простой метод: `GET`, `POST` или `HEAD`;
    - простые заголовки - только из списка:
        - `Accept`;
        - `Accept-Language`;
        - `Content-Language`;
        - `Content-Type` со значением `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.
2. **Непростые** - т.е. все остальные.

В кросс-доменный запрос браузер автоматически добавляет заголовок `Origin`, содержащий домен, с которого осуществлен запрос.

Сервер должен, со своей стороны, ответить специальными заголовками, разрешает ли он такой запрос к себе. Если сервер разрешает кросс-доменный запрос с этого домена - он должен добавить к ответу заголовок `Access-Control-Allow-Origin`, содержащий домен запроса или звездочку `*`. Только при наличии такого заголовка в ответе - браузер сочтет запрос успешным, а иначе JavaScript получит ошибку. При таких запросах не передаются куки и заголовки HTTP-авторизации.

Чтобы JavaScript мог прочитать HTTP-заголовки ответа, сервер должен указать их имя в `Access-Control-Expose-Headers` через запятую.

Чтобы браузер передал вместе с запросом куки и HTTP-авторизацию, нужно поставить запросу `<xhr>.withCredentials = true`. При таком запросе сервер должен вернуть уже не один, а два заголовка:
- `Access-Control-Allow-Origin: <домен>`;
- `Access-Control-Allow-Credentials: true`.

Для запросов с "**непростым**" методом или особыми заголовками браузер делает предзапрос `OPTIONS`, указывая их в `Access-Control-Request-Method` и `Access-Control-Request-Headers`. Браузер ожидает ответ со статусом `200`, без тела, со списком разрешенных методов и заголовков в `Access-Control-Allow-Method` и `Access-Control-Allow-Headers`. Дополнительно можно указать `Access-Control-Max-Age` для кэширования предзапроса. Дополнительно: названия нестандартных заголовков ответа сервер должен указать в `Access-Control-Expose-Headers`, если хочет, чтобы клиент мог их прочитать.

### <a id="Стадия-закачки" href="#Стадия-закачки">Стадия закачки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

На стадии закачки для получения информации используем объект `<xhr>.upload`. У этого объекта нет методов, он только генерирует события в процессе закачки, их значение аналогично стадии загрузки: `loadstart`, `progress`, `abort`, `error`, `load`, `timeout`, `loadend`.

## <a id="COMET-с-XMLHttpRequest-длинные-опросы" href="#COMET-с-XMLHttpRequest-длинные-опросы">COMET с XMLHttpRequest: длинные опросы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Длинные опросы** - отличная альтернатива частым опросам, которые проводятся с некоторым интервалом. Они также удобны в реализации, и при этом сообщения доставляются без задержек. Схема:
1. Отправляется запрос на сервер;
2. Соединение не закрывается сервером, пока не появится сообщение;
3. Когда сообщение появилось - сервер отвечает на запрос, пересылая данные;
4. Браузер тут же делает новый запрос.

Ситуация, когда браузер отправил запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений. При этом если соединение рвется само, например, из-за ошибки в сети, то браузер тут же отсылает новый запрос.

## <a id="WebSocket" href="#WebSocket">WebSocket</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Протокол WebSocket** предназначен для решения любых задач и снятия ограничений обмена данными между браузером и сервером. Он позволяет пересылать любые данные, на любой домен, безопасно и почти без лишнего сетевого трафика. Протокол WebSocket работает над HTTP.

`var <socket> = new WebSocket("ws[s]://<url>"[, "soap"][, "wamp"])` - создание соединения.

Основные события:
- `open` - при открытии;
- `close` - при закрытии; при чистом закрытии: `<event>.wasClean = true`;
- `message` - при получении данных, где данные находятся в `event.data`;
- `error` - при ошибки соединения.

`<socket>.send(<данные>)` - посылка данных на сервер.

## <a id="Протокол-JSONP" href="#Протокол-JSONP">Протокол JSONP</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Если создать тег `<script src>`, то при добавлении в документ запустится процесс загрузки `src`. В ответ сервер может прислать скрипт, содержащий нужные данные. Таким образом можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок.

**Протокол JSONP** - это "надстройка" над таким способом коммуникации.

```javascript
var elem = document.createElement("script");
elem.src = "<url>";
document.head.appendChild(elem);
```

Обработка ответа:
1. Вместе с запросом клиент в специальном, заранее оговоренном, параметре передает название функции, которая должна быть глобальной. Обычно такой параметр называется `callback`;
2. Сервер кодирует данные в JSON и оборачивает их в вызов функции, название которой получает из параметра `callback` запроса: `<url>?callback=<функция_колбэк>`.

Это и называется JSONP ("*JSON with Padding*").

### <a id="Реестр-CallbackRegistry" href="#Реестр-CallbackRegistry">Реестр CallbackRegistry</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Чтобы не загрязнять глобальное пространство имен, или по крайней мере свести загрязнение к минимуму, для этого создают один глобальный объект "**реестр**", который как правило называется `CallbackRegistry`. Далее для каждого запроса в нем генерируется временная функция.  
`<url>?callback= CallbackRegistry.<временная_функция_колбэк>`

### <a id="Обнаружение-ошибок" href="#Обнаружение-ошибок">Обнаружение ошибок</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При запросе данных при помощи SCRIPT возможны различные ошибки:
- скрипт может не загрузиться: отказ в соединении, разрыв связи...;
- ошибка HTTP, например 500;
- скрипт загрузился, но внутри некорректен и не вызывает функцию. Например, на сервере произошла ошибка и в ответе передан ее текст, а вовсе не данные.

Чтобы отловить их все "одним махом", используется следующий алгоритм:
1. Создается `<script>`.
2. На `<script>` ставятся обработчики `onreadystatechange` (для старых IE) и `onload`/`onerror` (для остальных браузеров).
3. При загрузке скрипт выполняет функцию-колбэк. Пусть она при запуске ставит флажок "все ок". А затем в обработчиках проверяют - если флага нет, то функция не вызывалась - стало быть, ошибка при загрузке или содержимое скрипта некорректно.

### <a id="COMET" href="#COMET">COMET</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

COMET через SCRIPT реализуется при помощи длинных опросов. То есть, создается тег `<script>`, браузер запрашивает скрипт у сервера и... Сервер оставляет соединение висеть, пока не появится, что сказать. Когда сервер хочет отправить сообщение - он отвечает, используя формат JSONP. И после этого сразу, создается новый запрос.

## <a id="Server-Sent-Events---события-с-сервера" href="#Server-Sent-Events---события-с-сервера">Server Sent Events - события с сервера</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Современный стандарт **Server-Sent Events** позволяет браузеру создавать специальный объект `EventSource`, который сам обеспечивает соединение с сервером, делает пересоединение в случае обрыва и генерирует события при поступлении данных.

При создании объекта `EventSource` браузер автоматически подключается к указанному адресу и начинает получать с него события:  
`var <eventSource> = new EventSource("<url>")` - создание объекта.

Чтобы соединение успешно открылось, сервер должен ответить с заголовком `Content-Type: text/event-stream`, а затем оставить соединение висящим и писать в него сообщения в специальном формате:
- каждое сообщение пишется после `data:`. Если после двоеточия есть пробел, то он игнорируется;
- сообщения разделяются двумя строками `\n\n`;
- если нужно переслать перевод строки, то сообщение разделяется. Каждая следующая строка пересылается отдельным `data:`.

При создании объекта браузер автоматически подключается к серверу, а при обрыве - пытается его возобновить.

Закрытие соединения на стороне браузера: ответ со статусом не 200 или ответ с `Content-Type`, не совпадающим с `text/event-stream`.

Между попытками возобновить соединение будет пауза, начальное значение которой зависит от браузера (1-3 секунды) и может быть изменено сервером через указание в ответе `retry: <задержка_в_мс>`.

`<eventSource>.close() `- закрытие соединения, при этом дальнейших попыток соединения не будет. Открыть обратно этот объект тоже нельзя, можно создать новый `EventSource`.

### <a id="Идентификатор-id" href="#Идентификатор-id">Идентификатор id</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для того, чтобы продолжить получение событий с места разрыва, стандарт предусматривает идентификацию событий через `id: <номер>`. Сервер может указать его в ответе.

При получении `id:` браузер:
- устанавливает свойство `<eventSource>.lastEventId` в его значение;
- при пересоединении пошлет заголовок `Last-Event-ID` с этим `id`, так что сервер сможет переслать последующие, пропущенные, сообщения.

При этом: `id` шлется не перед сообщением, а после него, чтобы обновление `lastEventId` произошло, когда браузер все уже точно получил.

### <a id="Статус-соединения-readyState" href="#Статус-соединения-readyState">Статус соединения `readyState`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

У объекта `EventSource` есть свойство `readyState`, которое содержит одно из значений: `CONNECTING` = `0` - в процессе (пере-)соединения, `OPEN` = `1` - соединение установлено, `CLOSED` = `2` - соединение закрыто.

События:
- `onopen` - при успешном установлении соединения;
- `onerror` - при ошибке соединения;
- `onmessage` - пришло сообщение, доступно как `event.data`, по умолчанию на события срабатывает обработчик `onmessage`, но можно сделать и свои события. Для этого сервер должен указать перед событием его имя после `event: <событие>`. Сообщение по умолчанию имеет имя `message`. Для обработки своих имен событий необходимо ставить обработчик при помощи `addEventListener`.

```
data: Сообщение 1
id: 1
event: join
data: Сообщение 2
id: 2
event: leave
retry: 15000
data: Сообщение 3
data: из двух строк
id: 3
```

### <a id="Кросс-доменость" href="#Кросс-доменость">Кросс-доменость</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`EventSource` поддерживает кросс-доменные запросы, аналогично `XMLHttpRequest`. Для этого у конструктора есть второй аргумент - объект, который нужно передать так:  
`{withCredentials: true}`

Сервер при этом получит заголовок `Origin` с доменом запроса и должен ответить с заголовком `Access-Control-Allow-Origin` (и `Access-Control-Allow-Credentials`, если стоит `withCredentials`).

При кросс-доменных запросах у событий `event` также появится дополнительное свойство `origin`, содержащее адрес источника, откуда пришли данные. Его можно использовать для дополнительной проверки со стороны браузера.

### <a id="Токен-и-AJAX" href="#Токен-и-AJAX">Токен и AJAX</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Как и в случае с формой, нужно "**подписать**" запрос токеном, чтобы гарантировать, что его содержимое прислано на сервер именно интерфейсом сайта, а не "злой страницей".

Здесь возможны варианты, самый простой - это дополнительная кука:
- при авторизации сервер устанавливает куку с именем `CSRF-TOKEN`, и пишет в нее токен;
- код, осуществляющий `XMLHttpRequest`, получает куку и ставит заголовок `X-CSRF-TOKEN` с ней;
- сервер проверяет, есть ли заголовок и содержит ли он правильный токен.

Защита действует потому, что прочитать куку может только JavaScript с того же домена. "Злая страница" не сможет "переложить" куку в заголовок.

Если нужно сделать не `XMLHttpRequest`, а, к примеру, динамически сгенерировать форму из JavaScript - она также подписывается аналогичным образом, скрытое поле или дополнительный URL-параметр генерируется по куке.

## <a id="Blob" href="#Blob">`Blob`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объект `Blob` представляет из себя подобный файлу объект с неизменяемыми, необработанными данными; они могут читаться как текст или двоичные данные.

`let <blob> = new Blob([[<элемент1>[, ...]]][, {type: '<MIME_тип>'}]);` - создает `Blob` объект с элементами [и определенным MIME типом].

`<blob>.size` - возвращает размер в байтах.  
`<blob>.type` - возвращает MIME тип если он был задан.

`<blob>.slice([<начало>[, <конец>[, '<новый_MIME_тип>']]])` - возвращает новый `Blob` объект, содержащий данные в указанном диапазоне байтов от и до исходного [с новым MIME типом].

`<blob>.stream()` - возвращает `ReadableStream` типом `Uint8Array`, с помощью которого можно прочитать `Blob` объект.

`<blob>.text()` - возвращает промис с содержимым `Blob` объекта в виде текста.  
`<blob>.arrayBuffer()` - возвращает промис с содержимым `Blob` объекта в виде `ArrayBuffer`.  
`<blob>.bytes()` - возвращает промис с содержимым `Blob` объекта в виде `Uint8Array`.

## <a id="Метод-fetch-замена-XMLHttpRequest-ES6" href="#Метод-fetch-замена-XMLHttpRequest-ES6">Метод `fetch`: замена `XMLHttpRequest` (ES6)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Метод `fetch` - это `XMLHttpRequest` нового поколения. Он предоставляет улучшенный интерфейс для осуществления запросов к серверу: как по части возможностей и контроля над происходящим, так и по синтаксису, так как построен на промисах.

`let <promise> = fetch(<url>[, <options>]);` - где:
- `<url>` - URL, на который нужно сделать запрос;
- `<options>` - необязательный объект с настройками запроса. Свойства `<options>`:
    - `method` - метод запроса;
    - `headers` - заголовки запроса (объект);
    - `body` - тело запроса: `FormData`, `Blob`, строка и т.п.;
    - `mode` - одно из: `"same-origin"`, `"no-cors"`, `"cors"`, указывает, в каком режиме кросс-домености предполагается делать запрос;
    - `credentials` - одно из: `"omit"`, `"same-origin"`, `"include"`, указывает, пересылать ли куки и заголовки авторизации вместе с запросом;
    - `cache` - одно из `"default"`, `"no-store"`, `"reload"`, `"no-cache"`, `"force-cache"`, `"only-if-cached"`, указывает, как кэшировать запрос;
    - `redirect` - можно поставить `"follow"` для обычного поведения при коде 30x (следовать редиректу) или `"error"` для интерпретации редиректа как ошибки;
    - `signal` - принимает `AbortSignal` для отмены запроса.

При вызове `fetch` возвращает промис, который, когда получен ответ, выполняет колбэки с объектом `Response` или с ошибкой, если запрос не удался.

Объект `<response>` содержит свойства:
- `status` - код статуса;
- `statusText` - строка, которая соответствует HTTP коду статуса;
- `ok` - будет содержаться `true` при кодах статуса от 200 до 299;
- `headers` - объект заголовков.

Для прочитения тела ответа в желаемом формате используются метода, которые описаны в спецификации `Body`, они включают в себя:
- `<response>.arrayBuffer()`;
- `<response>.blob()`;
- `<response>.formData()`;
- `<response>.json()`;
- `<response>.text()`.

Соответствующие вызовы возвращают промис, который, когда ответ будет получен, промис разрешиться с результатом.

```javascript
// GET запрос
fetch('<url>')
    .then(response => response.json())
    .then(json => console.log(json));
// POST запрос
fetch('<url>', {
    method: 'POST',
    body: JSON.stringify({/*<data>*/})
})
    .then(response => response.json())
    .then(json => console.log(json));
```

`AbortError` - это ошибка, которая произведена при прерывании с помощью `AbortSignal`.

<a id="Куки-documentcookie" href="#Куки-documentcookie">Куки, `document.cookie`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====================

`document.cookie` - возвращает все куки в виде строки, которая состоит из пар `<ключ>=<значение>`, которые перечисляются через точку с запятой с пробелом `; `.

В `document.cookie` можно писать, при этом запись не перезаписывает существующие cookie, а дополняет к ним:  
`<ключ>=<значение>[; path=/<путь_страниц_сайта>][; domain=<домен_действия>][; expires=<дата_истечения_куки_в_формате_GMT>][; secure]`

Если `secure` - то cookie можно передавать только по `HTTPS`.

Чтобы удалить cookie:  
`document.cookie = "<ключ>=; path=/; expires=" + (new Date(0)).toUTCString();`

Сервер может поставить cookie с дополнительным флагом `HttpOnly`. Cookie с таким параметром передается только в заголовках, оно никак не доступно из JavaScript.

Отловить то, что если отключены cookie можно проверкой свойства `navigator.cookieEnabled`.

Сессионная кука не имеет аттрибутов `Expires` или `Max-Age`.

<a id="Локальное-хранилище" href="#Локальное-хранилище">Локальное хранилище</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===================

HTML5-хранилище базируется на именах пар ключ/значение.

Для локального хранилища используется глобальный объект `localStorage`.

Основные методы:
`localStorage.setItem("<ключ>", <значение>) `- устанавливает значение ключа.  
`localStorage.getItem("<ключ>")` - возвращает значение ключа по его имени.  
`localStorage.removeItem("<ключ>")` - удаляет ключ из хранилища и его значение.  
`localStorage.length` - возвращает количество ключей в хранилище.  
`localStorage.key(<номер>)` - возвращает значение ключа по номеру.  
`localStorage.clear()` - очищает хранилище.

"5 мегабайт" - сколько места для хранения выдается по умолчанию. `"QUOTA_EXCEEDED_ERR"` это исключение, если будет превышена квота в 5 Мб.

Событие `storage` возникает в объекте `window`, когда `setItem()`, `removeItem()` или `clear()` вызываются и что-то изменяют. имеет указанные свойства:
- `key` - ключ может быть добавлен, удален или изменен;
- `oldValue` - предыдущее значение (если переписано) или `null`, если добавлено новое значение;
- `newValue` - новое значение или `null`, если удалено;
- `url` - страница, которая вызывает метод, приведший к изменению.

Также существует сессионное хранилище `sessionStorage`, которое полностью аналогично `localStorage`, только распространяется на одну вкладку или окно браузера и каждая вкладка имеет свой уникальный `sessionStorage`, который очищается при закрытии вкладки или браузера.

<a id="Управление-историей-браузера" href="#Управление-историей-браузера">Управление историей браузера</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============================

DOM `window` объект предоставляет доступ к истории браузера через объект `history`. Он расширяет полезные свойства и методы, которые позволяют двигаться вперед и назад по истории пользователя, а также манипулировать содержимым стека истории.

`window.history.back();` - перемещает назад по истории.  
`window.history.forward();` - перемещает вперед по истории.  
`window.history.go(<количество>);` - перемещает на указаное `<количество>` позиций относительно текущей, который равен 0, по истории вперед, если число положительное и назад, если отрицательное.  
`window.history.length;` - количество страниц в стеке истории.

`history.pushState(<объект_состояния>, "<заголовок>", "<URL>");` - помещает новую запись в историю, где `<объект_состояния>` - может быть всем, что может сериализироваться, `"<заголовок>"` - заголовок записи истории, `"<URL>"` - URL новой записи истории, при этом браузер не пытается загрузить этот URL после вызова `pushState()`. Новый URL может любым в пределах домена, порта и протокола.

`history.replaceState(<объект_состояния>, "<заголовок>", "<URL>");` - работает аналогично `history.pushState()`, но заменяет последнюю запись истории вместо создания новой.

При изменении истории вызывается событие `popstate` у `window`, у него есть свойство `state` которое содержит копию записи истории, если запись истории была создана с помощью вызова `pushState` или `replaceState`.

`history.state;` - содержит объект состояния текущей записи истории, если он есть.

`window.location` - возвращает объект `Location` с информацией о текущем расположении документа, представляет собой объект только для чтения, но ему можно присвоить значение, что будет аналогично присвоению `window.location.href = "<url>"`.

Свойства (как и у `URL`):
- `href` - строка содержащая URL целиком. При изменении, соответствующий документ переходит на новую страницу;
- `protocol` - строка содержащая протокол текущего URL, включая `:`;
- `host` - строка содержащая хост, а именно имя хоста, `:` и порт;
- `hostname` - строка содержащая домен текущего URL;
- `port` - строка содержащая номер порта текущего URL;
- `pathname` - строка содержащая первый `/` после хоста с последующим текстом URL;
- `search` - строка содержащая `?` с последующими параметрами URL;
- `hash` - строка содержащая `#` с последующим идентификатором;
- `username` - строка содержащая имя пользователя, указанное перед именем домена;
- `password` - строка содержащая пароль, указанный перед именем домена;
- `origin` - строка содержащая протокол, хост и порт текущего URL.

Методы:
- `assign("<url>")` - загружает ресурс по URL, указанному URL;
- `reload([true])` - перезагружает ресурс по текущему URL[, страница будет заново загружена с сервера];
- `replace("<url>")` - заменяет текущий ресурс на новый по URL, указанному в качестве параметра, текущая страница не будет сохранена в `History`, и пользователь не сможет использовать кнопку назад, чтобы вернуться к ней.

`document.referrer` - возвращает URI страницы, с которой был совершен переход на текущую, пустую строку, если перешел напрямую.

`window.open(<url>[, "_black"])` - открывает указаную ссылку `<url>` [в новом окне].

<a id="Полноэкранный-режим" href="#Полноэкранный-режим">Полноэкранный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===================

`<элемент>.requestFullscreen()` - возвращает промис, который разрешается успешно, если удалось установить `<элемент>` в полноэранный режим, при этом все что находилось выше него по иерархии и элементы браузера будут скрыты.

`document.exitFullscreen()` - возвращает промис, который разрешается успешно, если удалось выйти из полноэкранного режима.  
`document.fullscreenElement` - содержит элемент, который в полноэкранном режиме.

<a id="Stream-API" href="#Stream-API">Stream API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========

Используется для потоковой передачи и обработки данных.

## <a id="ReadableStream" href="#ReadableStream">`ReadableStream`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для чтения данных.

`const <readable_stream> = new ReadableStream([<опции>[, <стратегия>]]);` - создает поток для чтения, где `<опции>` - это объект со свойствами и значениями:
- `type` - опциональное свойство, которое может принимать значение `"bytes"`, что подразумевает передачу байтов, а не строк;
- `start(<controller>)` - опциональный метод, который принимает контроллер `<controller>` типа `ReadableStreamDefaultController` или `ReadableByteStreamController` в зависимости от типа `type`, и вызывается сразу после конструктора, может возвращать промис, который должен разрешиться для сигнализации о успехе инициализации;
- `pull(<controller>)` - опциональный метод, который принимает контроллер `<controller>` типа `ReadableStreamDefaultController` или `ReadableByteStreamController` в зависимости от типа `type`, и вызывается каждый раз, когда количество доступных мест в очереди изменяется и больше 0, может возвращать промис, который должен разрешиться тогда, когда можно вызывать повторно метод `pull`;
- `cancel(<reason>)` - опциональный метод, который принимает причину `<reason>` в виде строки, и вызывается при отмене (вызова метода `<readable_stream>.cancel()`).

И `<стратегия>` - это объект, со свойствами и методами:
- `highWaterMark` - положительное число, обозначающее общее количество элементов в очереди, которые могут содержаться в очереди;
- `size(<chunk>)` - метод, который должен возвращать размер `<chunk>` в байтах.

`<readable_stream>.locked;` - возвращает `true`, если чтец был возвращен, а иначе `false`.

`const <reader> = <readable_stream>.getReader([{mode: "byob"}]);` - возвращает чтеца `ReadableStreamDefaultReader` [`ReadableStreamBYOBReader `] и переводит стрим в режим блокировки - устанавливает `locked` - равным `true`.

`<readable_stream>.cancel();` - отменяет стрим и возвращает промис который разрешится при отмене стрима.

`<readable_stream>.pipeThrough(<transform_stream>);` - устанавливает передачу данных в стрим `<transform_stream>` типа `TransformStream` и возвращает `<transform_stream>.readable`.  
`<readable_stream>.pipeTo(<writable_stream>);` - устанавливает передачу данных в стрим `<writable_stream>` типа `WritableStream` и возвращает промис, который разрешится когда передача будет завершена.

`const [<readable_stream_1>, <readable_stream_2>] = <readable_stream>.tee();` - возвращает два новых `ReadableStream`, которые работают с теми же входящими данными, что и оригинальный `<readable_stream>`.

### <a id="ReadableStreamDefaultController" href="#ReadableStreamDefaultController">`ReadableStreamDefaultController`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержит методы для управления потоком чтения:
- `<controller>.close()` - закрывает поток;
- `<controller>.enqueue(<chunk>)` - записывает данные в поток;
- `<controller>.error(<error>)` - вызывает ошибку в потоке.

И свойства:
- `desiredSize` - содержит количество доступных мест в очереди = `highWaterMark - <количество_элементов_в_очереди>`.

### <a id="ReadableStreamDefaultReader" href="#ReadableStreamDefaultReader">`ReadableStreamDefaultReader`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержит методы для потока чтения:
- `<controller>.cancel()` - закрывает поток и возвращает промис, который разрешится после закрытия;
- `<controller>.read()` - возвращает промис, который разрешится со структурой `{value: <chunk>, done: false}` при поступлении данных в поток или `{value: undefined, done: true}` если поток закрыт, или отвергнется если была ошибка в потоке;
- `<controller>.releaseLock()` - освобождает поток.

И свойства:
- `closed` - возвращает промис, который разрешится, когда поток закроется или отвергнется при возникновении ошибки или освобождением потока с помощью `releaseLock`.

## <a id="WritableStream" href="#WritableStream">`WritableStream`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для записи данных.

`const <writable_stream> = new WritableStream([<опции>[, <стратегия>]]);` - создает поток для записи, где `<опции>` - это объект со свойствами и значениями:
- `start(<controller>)` - опциональный метод, который принимает контроллер `<controller>` типа `WritableStreamDefaultController`, и вызывается сразу после конструктора, может возвращать промис, который должен разрешиться для сигнализации о успехе инициализации;
- `write(<chunk>, <controller>)` - опциональный метод, который принимает данные `<chunk>` и контроллер `<controller>` типа `WritableStreamDefaultController`, и вызывается при готовности `<chunk>` к записи, может возвращать промис, который должен разрешиться тогда, когда можно вызывать повторно метод `write`;
- `close(<controller>)` - опциональный метод, который принимает контроллер `<controller>` типа `WritableStreamDefaultController`, и вызывается при завершении записи в поток, может возвращать промис, который должен разрешиться тогда, когда закончатся асинхронные операции;
- `abort(<reason>)` - опциональный метод, который принимает причину `<reason>` в виде строки, и вызывается при отмене (вызова метода `<writable_stream>.abort()`), может возвращать промис, который должен разрешиться тогда, когда закончатся асинхронные операции.

И `<стратегия>` - это объект, аналогичный в `ReadableStream`.

`<writable_stream>.locked;` - возвращает `true`, если писец был возвращен, а иначе `false`.

`const <writer> = <writable_stream>.getReader();` - возвращает писца `WritableStreamDefaultWriter` и переводит стрим в режим блокировки - устанавливает `locked` - равным `true`.

`<writable_stream>.close();` - закрывает стрим (аналогично `<writer>.close()`) и возвращает промис который разрешится при закрытие стрима.

`<writable_stream>.cancel();` - отменяет стрим и возвращает промис который разрешится при отмене стрима.

### <a id="WritableStreamDefaultController" href="#WritableStreamDefaultController">`WritableStreamDefaultController`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержит методы для управления потоком записи:
- `<controller>.error(<error>)` - вызывает ошибку в потоке.

И свойства:
- `signal` - возвращает `AbortSignal` для отмены.

### <a id="WritableStreamDefaultWriter" href="#WritableStreamDefaultWriter">`WritableStreamDefaultWriter`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержит методы для потока записи:
- `<controller>.abort()` - отменяет поток;
- `<controller>.close()` - закрывает поток и возвращает промис, который разрешится после закрытия;
- `<controller>.write(<chunk>)` - записывает данные `<chunk>` в поток и возвращает промис, который разрешится после успешной записи, или отвергнется если была ошибка в потоке;
- `<controller>.releaseLock()` - освобождает поток.

И свойства:
- `closed` - возвращает промис, который разрешится, когда поток закроется или отвергнется при возникновении ошибки или освобождением потока с помощью `releaseLock`;
- `ready` - возвращает промис, который разрешится, когда появляется в потоке место для записи в очередь;
- `desiredSize` - содержит количество доступных мест в очереди.

## <a id="TransformStream" href="#TransformStream">`TransformStream`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для преобразования данных.

`const <transform_stream> = new TransformStream([<опции>[, <стратегия_записи>[, <стратегия_чтения>]]]);` - создает поток для преобразования данных, где `<опции>` - это объект со свойствами и значениями:
- `start(<controller>)` - опциональный метод, который принимает контроллер `<controller>` типа `TransformStreamDefaultController`, и вызывается сразу после конструктора, может возвращать промис, который должен разрешиться для сигнализации о успехе инициализации;
- `transform(<chunk>, <controller>)` - опциональный метод, который принимает данные `<chunk>` и контроллер `<controller>` типа `TransformStreamDefaultController`, и вызывается при готовности `<chunk>` к преобразованию, может возвращать промис, который должен разрешиться тогда, когда можно вызывать повторно метод `transform`;
- `flush(<controller>)` - опциональный метод, который принимает контроллер `<controller>` типа `TransformStreamDefaultController`, и вызывается при завершении записи в поток, может возвращать промис, который должен разрешиться тогда, когда закончатся асинхронные операции.

И `<стратегия_записи>` - это объект, аналогичный в `ReadableStream`, а `<стратегия_чтения>` - это объект, аналогичный в `WritableStream`.

`const <readable_stream> = <transform_stream>.readable;` - содержит `ReadableStream`.  
`const <writable_stream> = <transform_stream>.writable;` - содержит `WritableStream`.

### <a id="TransformStreamDefaultController" href="#TransformStreamDefaultController">`TransformStreamDefaultController`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержит методы для управления потоком чтения:
- `<controller>.terminate()` - закрывает поток чтения и выбрасывает ошибку в поток записи;
- `<controller>.enqueue(<chunk>)` - записывает данные в поток;
- `<controller>.error(<error>)` - вызывает ошибку в потоке.

И свойства:
- `desiredSize` - содержит количество доступных мест в очереди.

## <a id="Пример" href="#Пример">Пример</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```js
function delay(ms) {
    return new Promise((res) => setTimeout(res, ms));
}
let i = 0;
const readableStream = new ReadableStream({
    start(controller) {
        for (; controller.desiredSize; i++) {
            controller.enqueue(`${i}`);
        }
    },
    pull(controller) {
        for (; controller.desiredSize; i++) {
            controller.enqueue(`${i}`);
            if (i > 10) {
                controller.close();
                break;
            }
        }
        return delay(1000);
    },
}, {highWaterMark: 6});
const transformStream = new TransformStream({
    transform(chunk, controller) {
        const number = Number(chunk);
        controller.enqueue(number);
        return delay(1000);
    },
}, {highWaterMark: 4}, {highWaterMark: 2});
const writableStream = new WritableStream({
    write(chunk) {
        console.log(chunk);
        return delay(1000);
    },
}, {highWaterMark: 6});
readableStream
   .pipeThrough(transformStream)
   .pipeTo(writableStream);
```

<a id="Кодировки" href="#Кодировки">Кодировки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

`const <encoder> = new TextEncoder();` - создает кодировщик, который преобразует строки в кодировке `utf-8` в массив байт.  
`const <array> = <encoder>.encode(<string>)` - возвращает массив типа `Uint8Array`, который состоит из байтов `utf-8` из строки `<string>`.

`const <decoder> = new TextDecoder([<кодировка>]);` - создает декодировщик, который преобразует массив байт [из определенной кодировки `<кодировка>`] в строки в кодировке `utf-8`.  
`const <string> = <decoder>.decode(<массив>)` - возвращает строку в кодировке `utf-8` из массива типа `Uint8Array`, `Int8Array`, `Uint16Array`, `Int16Array`, `Int32Array`.

<a id="WebRTC" href="#WebRTC">WebRTC</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Это коллекция стандартов, протоколов и JavaScript API, которые все вместе обеспечивают peer-to-peer видео-аудио коммуникации в реальном времени, а также могут быть использованы для передачи любых бинарных данных.

## <a id="Потоки-от-пользователя" href="#Потоки-от-пользователя">Потоки от пользователя</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```javascript
navigator.mediaDevices.getUserMedia({
    video: true, // для захвата видео
    audio: true, // для захвата аудио
})
    .then(stream => {
        const tracks = stream.getTracks(); // содержит массив треков из потока от пользователя
    });
```

## <a id="RTCPeerConnection" href="#RTCPeerConnection">`RTCPeerConnection`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для установки соединения. С помощью ICE протокола узнается ip собеседника, если он находится за NAT.

```javascript
const peerConnection = new RTCPeerConnection({
    iceServers: [{
        urls: '<stun_сервер>' // 'stun:stun.l.google.com:19302'
    }]
});
```

`peerConnection.addTrack(<track>)` - присоединяет трек к соединению.

Событие `negotiationneeded` - срабатывает сразу при добавлении медиапотока в peerConnection.
```javascript
peerConnection.onnegotiationneeded = (event) => {
      peerConnection.createOffer() // Создает и назначает SDP (Session Description Protocol)) offer
        .then((offer) => peerConnection.setLocalDescription(offer))
    };
```

`peerConnection.iceConnectionState` - содержит строку состояния peerConnection. Состояния:
- `'connected'` - соединен.

Событие `iceconnectionstatechange` - срабатывает при изменении ICE состояния peerConnection.
```javascript
peerConnection.oniceconnectionstatechange = (event) => {
    // ...
}
```

Событие `icegatheringstatechange` - срабатывает каждый раз, как появляется ICE кандидат.
```javascript
peerConnection.onicegatheringstatechange = (event) => {
    const connection = event.target; // соединение с новым кандидатом
    connection.iceGatheringState; // содержит состояние соединения с кандидатом, 'complete' - соединен.
    // ...
}
```

<a id="Worker" href="#Worker">Worker</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

**Веб-воркеры** - это потоки, принадлежащие браузеру, которые можно использовать для выполнения JS-кода без блокировки цикла событий. Виды:
- **Выделенные воркеры** - экземпляры выделенных веб-воркеров создаются главным процессом. Обмениваться данными с ними может только он;
- **Разделяемые воркеры** - доступ к разделяемому воркеру может получить любой процесс, имеющий тот же источник, что и воркер (например - разные вкладки браузера, iframe, и другие разделяемый воркеры);
- **Сервис-воркеры** - это воркеры, управляемые событиями, зарегистрированные с использованием источника их происхождения и пути. Они могут контролировать веб-страницу, с которой связаны, перехватывая и модифицируя команды навигации и запросы ресурсов, и выполняя кэширование данных, которым можно очень точно управлять.

Возможности, доступные веб-воркерам:
- объект `navigator`;
- объект `location` (только для чтения);
- `XMLHttpRequest`;
- `setTimeout()`/`clearTimeout()` и `setInterval()`/`clearInterval()`;
- кэш приложения;
- импорт внешних скриптов с использованием `importScripts()`;
- создание других веб-воркеров.

В контексте воркера и `self`, и `this`, указывают на глобальное пространство имен для воркера.

## <a id="Выделенные-воркеры" href="#Выделенные-воркеры">Выделенные воркеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const <worker> = new Worker('<путь_к_js_файлу>');` - создает воркера с его кодом, если файл существует и к нему есть доступ, браузер создаст новый поток, который асинхронно загрузит этот файл. После того, как загрузка будет завершена, начнется выполнение кода воркера. Если при попытке загрузки файла браузер получит сообщение об ошибке `404`, файл загружен не будет, при этом сообщения об ошибках не выводятся.

`<worker>.postMessage(<данные> [, <массив_передаваемых_объектов>]);` - передает в воркер указанные данные `<данные>` [, а также передает во влвдение все объекты из массива `<массив_передаваемых_объектов>`, эти объекты становятся непригодные в текущем контексте и становятся доступны только в воркере, объекты могут быть экземплярами классов `ArrayBuffer`, `MessagePort` или `ImageBitmap`. Для удобства использования на них должна передаваться ссылка в объекте `<данные>`].

`<worker>.addEventListener('message', function (e) {...}, false);` - регистрирует функцию принимающую данные от воркера, где `e` - это событие, со свойствами:
- `data` - это переданные данные.

`<worker>.addEventListener('error', function (e) {...}, false);` - регистрирует функцию, которая вызовется при ошибке в воркере, где `e` - это событие, со свойствами:
- `filename` - имя файла, в котором содержится скрипт воркера, вызвавший ошибку;
- `lineno` - номер строки, в которой произошла ошибка;
- `message` - описание ошибки.

`<worker>.terminate();` - уничтожает воркера.

`const <worker> = new Worker(URL.createObjectURL(new Blob(['<js_код>'])));` - позволяет создать воркера с произвольным кодом.

### <a id="Строение-воркера" href="#Строение-воркера">Строение воркера</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Воркеры могут создавать новых воркеров, если нужно.

`this.postMessage(<данные> [, <массив_передаваемых_объектов>]);` - передает указанные данные `<данные>` тому, кто запустил воркера [, а также передает во влвдение все объекты из массива `<массив_передаваемых_объектов>`, эти объекты становятся непригодные в текущем контексте и становятся доступны только в том кто запустил воркера, объекты могут быть экземплярами классов `ArrayBuffer`, `MessagePort` или `ImageBitmap`. Для удобства использования на них должна передаваться ссылка в объекте `<данные>`].

`this.addEventListener('message', function (e) {...}, false);` - регистрирует функцию принимающую данные от того, кто запустил воркера, где `e` - это событие `MessageEvent`, со свойствами:
- `data` - это копия переданных данных.

`onmessage = function (e) {...}` - аналогично.

`this.close();` - уничтожает воркера, т.е. самого себя.

Внутри воркера можно подключать внешние скрипты с помощью:  
`importScripts([<url1>[, ...]]);`

## <a id="Сервис-воркеры" href="#Сервис-воркеры">Сервис-воркеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`navigator.serviceWorker.register('<путь_к_js_файлу>');` - регистрирует сервис воркера, если он не был уже зарегистрирован и возвращает `Promise` для сообщения о результате регистрации, который завершается успешно с объектом `registration` класса `ServiceWorkerRegistration`. Сервис воркер будет получать события `fetch` в рамках своего пути подключения, т.е. воркер по пути `<путь>/<js_файл>` будет получать только все события `<путь>/` и не выше.

После активации сервис-воркер сможет управлять всеми страницами, которые попадают в его область видимости. Он пока эта страница не будет перезагружена. Может находиться в состояниях:
- **Обработка событий** - ожидает поступления событий `fetch` и `message`;
- **Остановлен** - когда система останавливает сервис-воркер для экономии ресурсов.

### <a id="Кэш" href="#Кэш">Кэш</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Представляет собой глобальный объект: `caches`.

`caches.open('<имя_кэша>');` - возвращает `Promise`, который завершается успешно с объектом `cache` - который представляет кэш и имеет методы:
- `cache.add(<url>)` - возвращает `Promise`, который завершается успешно когда указанная ссылка будет добавлена в кэш;
- `cache.addAll([<url1>[, ...]])` - возвращает `Promise`, который завершается успешно когда все указанные ссылки из масссива будут добавлены в кэш;
- `cache.put(<request>, <response>)` - возвращает `Promise`, который завершается успешно когда запрос `<request>` и ответ `<response>` на него будут добавлены в кэш;
- `cache.match(<request>)` - возвращает `Promise`, который завершается успешно после после поиска запроса в этом кэше `<request>` с ответом или без него, если его нет.

`caches.keys();` - возвращает `Promise`, который завершается успешно с массивом имен кэшей.

`caches.delete('<имя_кэша>');` - возвращает `Promise`, который завершается успешно после удаления кэша с именем `<имя_кэша>`.

`caches.match(<request>);` - возвращает `Promise`, который завершается успешно после после поиска запроса в кэшах `<request>` с ответом или без него, если его нет.

### <a id="Строение-воркера" href="#Строение-воркера">Строение воркера</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`self.addEventListener('install', (event) => {...});` - регистрирует функцию, которая вызовется при установки сервис воркера, где `event` - это событие, со свойствами:
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
event.waitUntil(
    caches.open('<имя_кэша>') // открывает кэш
        .then((cache) => cache.addAll([ // загружает ресурсы по указаным url
                '<url>',
                '<another_url>'
            ])
        )
);
```

Это событие подходит для кэширования стилей, изображений, скриптов, и для любых статических файлов, используемых на странице.

После того, как сервис-воркер будет установлен и пользователь перейдет на другую страницу приложения или обновит страницу, на которой он находится, сервис-воркер начнет получать события `fetch`.

`self.addEventListener('fetch', (event) => {...});` - регистрирует функцию, которая вызовется при получении события `fetch`, где `event` - это событие, со свойствами:
- `respondWith` - принимает промис для того, чтобы определить то, как нужно отвечать на события `fetch` либо из кэша, либо запросом, либо ответом. Внутри можно выполнять работу с кэшем `caches`:
```javascript
event.respondWith(
    caches.match(event.request)// ищет кэшированные результаты в любом из созданных сервис-воркером кэшей
        .then((response) => {
            if (response) { // если в кэше данные найдены, то они возвращаются
                return response;
            }
            const fetchRequest = event.request.clone(); // клонируется запрос, так как он поток
            return fetch(fetchRequest) // загружаются данные напрямую
                .then((response) => {
                    if(!response || response.status !== 200 || response.type !== 'basic') {
                        return response; // если данные не правильные, то они возвращаются
                    }
                    var responseToCache = response.clone(); // клонируется ответ, так как он поток
                    caches.open('<имя_кэша>')
                        .then((cache) => {
                            cache.put(event.request, responseToCache); // добавляется ответ в кэш для последующего использования
                        });
                    return response;
                });
    })
);
```

Пример запросов через кэш:
```javascript
self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request)
            .then(response => response || fetch(event.request))
    );
});
```

`self.addEventListener('activate', (event) => {...});` - регистрирует функцию, которая вызовется при установки новой версии сервис воркера, где `event` - это событие, со свойствами:
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
event.waitUntil(
    caches.keys() // возвращает все ключи из кэша
        .then((cacheNames) => Promise.all(
            cacheNames.map((cacheName) => { // проходит по всем кэшированным файлам
                return caches.delete(cacheName); // удаляет файл из кэша
            })
        ))
);
```

`self.addEventListener('push', (event) => {...});` - регистрирует функцию, которая вызовется при приеме push-уведомления, где `event` - это событие, со свойствами:
- `data` - объект с данными, который может существовать и иметь методы:
    - `text()` - возвращает данные в текстовом формате;
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
self.addEventListener('push', (event) => {
    if (event.data.text() === 'new-email') {
        event.waitUntil(
            caches.open('<имя_кэша>')
                .then(cache => fetch('/inbox.json')
                    .then(response => {
                        cache.put('/inbox.json', response.clone());
                        return response.json();
                    })).then(emails => {
                        registration.showNotification('New email', {
                            body: `From ${emails[0].from.name}`,
                            tag: 'new-email'
                        });
                    });
        );
    }
});
```

`self.addEventListener('notificationclick', (event) => {...});` - регистрирует функцию, которая вызовется при нажатии на push-уведомления, где `event` - это событие, со свойствами:
- `notification` - объект с данными, который содержит:
    - `tag` - тег уведомления;
    - `close()` - закрывает уведомление;
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
self.addEventListener('notificationclick', (event) => {
    if (event.notification.tag === 'new-email') {
        new WindowClient('/inbox/');
    }
});
```

`self.addEventListener('sync', (event) => {...});` - регистрирует функцию, которая вызовется при синхронизации, где `event` - это событие, со свойствами:
- `id` - идентификатор;
- `waitUntil` - принимает промис для того, чтобы узнать, сколько времени займет установка, и успешно или нет она завершилась, если промис будет отклонен, воркер не будет установлен. Внутри можно выполнять работу с кэшем `caches`:
```javascript
self.addEventListener('sync', event => {
    if (event.id === 'update-leaderboard') {
        event.waitUntil(
            caches.open('mygame-dynamic')
                .then(cache => cache.add('/leaderboard.json'))
        );
    }
});
```

Воркер может показывать уведомления:
```javascript
registration.showNotification('<Заголовок>', {
    body: `<тело>`,
    tag: '<тег>'
})
```

## <a id="Широковещательный-канал-передачи-данных-BroadcastChannel" href="#Широковещательный-канал-передачи-данных-BroadcastChannel">Широковещательный канал передачи данных `BroadcastChannel`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объект `BroadcastChannel` представляет собой более универсальное API для передачи данных. Он позволяет передавать сообщения, которые можно принять во всех контекстах, имеющих один и тот же источник. Все вкладки браузера, `iframe` или воркеры, относящиеся к одному источнику, могут передавать и принимать широковещательные сообщения.

`var <broadcastChannel> = new BroadcastChannel('<имя_канала>');` - создает подключение к широковещательному каналу.

`<broadcastChannel>.postMessage(<данные>);` - отправляет сообщение (данные) всем подписавшимся.

`<broadcastChannel>.onmessage = function (e) {...}` - подписывает (регистрирует) функцию на прием сообщений, где `e` - это событие, со свойствами:
- `data` - это переданные данные.

`<broadcastChannel>.addEventListener('message', function (e) {...});` - аналогично предыдущему.

`<broadcastChannel>.close();` - отписывание (отключение) от канала.

<a id="Push-API-и-Notifications-API" href="#Push-API-и-Notifications-API">Push API и Notifications API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============================

**Push API** - используется, когда сервер передает сообщение сервис-воркеру.  
**Notifications API** - применяется, когда сервис-воркер, или скрипт в самом веб-приложении, намеревается показать пользователю уведомление.

## <a id="Push-API" href="#Push-API">Push API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для использования необходимо зарегистрировать сервис-воркер.

`let <promise> = Notification.requestPermission();` - запускает процедуру для получения разрешения пользователя на отправку ему push-сообщений (приводит к показу окна) и возвращает промис, который выполняется успешно с результатом разрешения, если `'granted'`, то пользователь дал свое разрешение, `'denied'` - отказал (окно больше не покажется) или `'default'` - проигнорировал.

`registration.pushManager.subscribe({userVisibleOnly: true, applicationServerKey: '<key>'});` - оформляет подписку, где `'<key>'` это открытый ключ в кодировке Base64, или объект `ArrayBuffer`, который push-сервер будет использовать для аутентификации сервера приложения и возвращает промис, который завершается успешно с `pushSubscription`, который имеет свойства:
- `endpoint` - представляет собой URL сервиса push-уведомлений, точку входа в API, для того, чтобы отправить уведомление, надо выполнить POST-запрос по этому URL;
- `keys`: - содержит сведения, используемые для шифрования данных сообщения, отправляемых в push-уведомлении:
    - `p256dh`;
    - `auth`.

Браузер передает `applicationServerKey` (открытый ключ) push-сервису в ходе оформления подписки, что означает, что push-сервис сможет связать открытый ключ приложения с подпиской, `PushSubscription`.

## <a id="Notifications-API" href="#Notifications-API">Notifications API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const <notification> = new Notification("<заголовок>", <опции>);` - создает уведомление с указанным заголовком и отображает его, где `<опции>` - это объект со свойствами:
- `body` - текст тела уведомления;
- `icon` - ссылка на иконку;
- `tag` - тег, используемый для идентификации уведомления, что позволяет обновлять уведомления без их отображения, что может быть полезным при большом количестве уведомлений;
- `image` - ссылка на изображение;
- `data` - данные, ассоциированные с уведомлением и др.

`<notification>.close();` - закрывает уведомление.

Объект `Notification` создает события:
- `show` - отображение уведомления;
- `close` - закрытие уведомления;
- `click` - нажатие на уведомление;
- `error` - ошибка.

<a id="windownavigator" href="#windownavigator">`window.navigator`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==================

## <a id="API-разрешений" href="#API-разрешений">API разрешений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`let <promise> = window.navigator.permissions.query({ name: '<тип_разрешения>' });` - возвращает промис с запросом на разрешение указаного типа, который разрешиться с объектом со свойствами:
- `state` - при разрешении будет равно `'granted'` или `'prompt'`.

## <a id="Clipboard-API" href="#Clipboard-API">Clipboard API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`let <promise> = window.navigator.clipboard.writeText('<текст>');` - копирует текст в буфер обмена и возвращает промис, которые может отклониться если нет разрешения копировать текст в буфер обмена.

`const <clipboardItem> = new ClipboardItem({ [<blob>.type]: <blob> });` - создает объект для буфера обмена из Blob объекта `<blob>`.

`let <promise> = window.navigator.clipboard.write([<clipboardItem>]);` - копирует Blob объект в буфер обмена и возвращает промис, которые может отклониться если нет разрешения копировать текст в буфер обмена.

`let <promise> = window.navigator.clipboard.readText();` - возвращает промис, который разрешится с текстовым содержимым, которое есть в буфере обмена.

`document.addEventListener('copy', function (e) {...}, false);` - добавляет обработчик, который сработает при копировании в буфер обмена, где `e` - это событие, со свойствами:
- `clipboardData` - это объект с буфером данных, с методами:
    - `setData('text', '<текст>')` - установка текста в буфер обмена;
    - `files` - массив файлов.

`let <promise> = window.navigator.permissions.query({ name: 'clipboard-read' });` - возвращает промис с запросом на разрешение чтения буфера обмена.  
`let <promise> = window.navigator.permissions.query({ name: 'clipboard-write' });` - возвращает промис с запросом на разрешение записи в буфер обмена.

## <a id="Web-Share-API" href="#Web-Share-API">Web Share API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет делиться содержимым страницы или копировать его в буфер обмена пользователя.

`navigator.canShare(<data>)` - возвращает `true`, если данными можно поделиться.  
`navigator.share(<data>)` - возвращает промис, который разрешается в случае успешного шаринга (sharing) данных.

Где `<data>` - это объект с полями:
- `url` - ссылка для шаринга;
- `text` - текст;
- `title` - заголовок;
- `files` - массив объектов `File`.

## <a id="Beacon-API" href="#Beacon-API">Beacon API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет отправлять на сервер асинхронные и неблокирующие запросы (методом POST), которые гарантированно завершаются до выгрузки страницы. Используется для логгирования активности пользователей или отправки аналитических данных на сервер.

`navigator.sendBeacon("<url>"[, <data>])` - отправляет на указанный url `<url>` данные [с указанным телом `<data>`] и возвращает `true` если данные были поставленны в очередь для передачи.

## <a id="Wake-API" href="#Wake-API">Wake API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет избежать выключения экрана.

`const <wakeLock> = await navigator.wakeLock.request("screen");` - предотвращает выключение экрана (можно вызвать только на активной вкладке) и разрешает обещание с блокировщиком в случае успеха.

`await <wakeLock>.release();` - разблокирует блокировку экрана.

<a id="Performance-API" href="#Performance-API">Performance API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===============

Используется для высокоточного вычисления производительности.

`const <time> = performance.now();` - возвращает отметку высокоточную отметку времени в виде числа.

<a id="jQuery" href="#jQuery">jQuery</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

Добавление jQuery на страницы:

```html
<script type="text/javascript" src="jquery.min.js"></script>
```

## <a id="Команды-jQuery" href="#Команды-jQuery">Команды jQuery</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$()` - это синоним для `jQuery()`.
`$('<селектор>')` - возвращает jQuery выборку элементов. Может принимать также стандартные элементы JS и `this`. Ее принято начинать именовать с `$`. Знак `$` сообщает, что символы идущие после него являются jQuery кодом;

Селектор позволяет выбрать элемент на странице, должен быть похожим на селектор CSS и позволяет указать дополнительные комманды:
- `:first` - первый элемент;
- `:last` - последний элемент;
- `:even` - все элементы списка с четными индексами;
- `:odd` - все элементы с нечетными индексами;
- `:eq(<номер>)` - элемент списка с указаным индексом, нумерация начинается с 0, если индекс меньше нуля, то с конца;
- `:gt(<номер>)` - все элементы списка, которые больше по индексу указанного, нумерация начинается с 0;
- `:lt(<номер>)` - все элементы списка, которые меньше по индексу указанного, нумерация начинается с 0;
- `:animated` - все анимированные элементы;
- `:contains('<строка>')` - все элементы содержащиеуказанную строку;
- `:empty` - все элементы не имеющие узлов потомков;
- `:hidden`- все скрытые элементы;
- `:visible` - все видимые элементы.

Стандартный синтаксис jQuery команд:  
`$('<селектор>').<метод>();`

Метод задает действие, которое необходимо совершить над выбранным элементом, подразделяются на следующие группы:
- методы для манипулирования DOM;
- методы для оформления элементов;
- методы для создания AJAX запросов;
- методы для создания эффектов;
- методы для привязки обработчиков событий.

### <a id="Загрузка-кода-после-загрузки-страницы" href="#Загрузка-кода-после-загрузки-страницы">Загрузка кода после загрузки страницы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого можно использовать один из вариантов:
- `$(document).ready(function () {<код>});`;
- `$().ready(function () {<код>});`;
- `$(function () {<код>});`.

### <a id="Цепочки-команд" href="#Цепочки-команд">Цепочки команд</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Можно соединять команды jQuery в цепочки, если они возвращают jQuery выборку элементов. Команды в цепочке будут выполняться поочередно слева направо.

`$('<селектор>').<метод1>()[.<метод2>()[....]];`

### <a id="Перебор-выборки-всех-элементов" href="#Перебор-выборки-всех-элементов">Перебор выборки всех элементов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.each(function ([index[, element]]) {...})` - вызывает указанную функцию для каждого элемента в выборке, где `this` в контексте функции это элемент [`index` номер элемента в выборке [`element` сам элемент]], если функция возвратит `false`, то прервется цикл по элементам выборки.

## <a id="Методы-навигации-по-DOM" href="#Методы-навигации-по-DOM">Методы навигации по DOM</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.find('<селектор>')` - возвращает jQuery выборку элементов, которые выбраны по указанному селектору с указанной выборки.  
`<$_выборка>.closest('<селектор>')` - возвращает выборку из элементов для каждого текущего элемента обходя вверх по DOM дереву, до тех пор пок не найдет первое совпадение для заданного селектора.

`<$_выборка>.prev(['<селектор>'])` - возвращает выборку предыдущих элементов от текущих, [которые соответствуют указаному селектору].  
`<$_выборка>.next(['<селектор>'])` - возвращает выборку следующих элементов от текущих, [которые соответствуют указаному селектору].

`<$_выборка>.children(['<селектор>'])` - возвращает выборку всех детей текущих элементов, [которые соответствуют указаному селектору].  
`<$_выборка>.parent()` - возвращает выборку всех прямых родителей текущих элементов.  
`<$_выборка>.parents(['<селектор>']) `- возвращает выборку всех родителей текущих элементов, [которые соответствуют указаному селектору].

`<$_выборка>.filter('<селектор>')` - возвращает выборку из всех элементов, которые соответствуют указаному селектору.

`<$_выборка>.eq(<номер>)` - возвращает указанный `<номер>` элемента в выборке.  
`<$_выборка>.get(<номер>)` - возвращает указанный `<номер>` элемента в выборке в виде стандартного элемента.  
`<$_выборка>.get()` - возвращает все элементы выборки как массив в виде стандартных элементов.

`<$_выборка>.add({'<селектор>' | <$_выборка>})` - возвращает новую выборку с добавленными элементами.

`<$_выборка>.end()` - возвращает предыдущую выборку по стеку выборок.

## <a id="Атрибуты-элементов-и-CSS" href="#Атрибуты-элементов-и-CSS">Атрибуты элементов и CSS</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="CSS-свойства" href="#CSS-свойства">CSS свойства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.css('<свойство>')` - получение значения CSS свойства, возвращает текущее значение, а не прописанное в CSS файле.  
`<$_выборка>.css('<свойство>', <значение>)` - установка значения CSS свойства.  
`<$_выборка>.css({'<свойство1>': <значение>[, ...]})` - установка нескольких значений CSS свойств через структуру.  
`<$_выборка>.css('<свойство>', function (index, value) {return <новое_значение>})` - для установки значения используется функция обратного вызова,где `index` это порядковый номер элемента в выборке, `value` - старое значение свойства. Должна возвращать новое значение.

### <a id="CSS-классы" href="#CSS-классы">CSS классы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.addClass('<имя_класса>')` - добавление класса элементу.  
`<$_выборка>.addClass(function (index, classList) {return '<имя_класса>'})` - добавление класса используя функцию обратного вызова, `classList` - список классов у элемента.  
`<$_выборка>.hasClass('<имя_класса>')` - проверка на причастность к определенному классу.  
`<$_выборка>.removeClass('<имя_класса>')` - удаление класса.  
`<$_выборка>.removeClass(function (index, classList) {return '<имя_класса>'})` - удаление класса используя функцию обратного вызова.  
`<$_выборка>.toggleClass('<имя_класса>')` - переключение класса.  
`<$_выборка>.toggleClass('<имя_класса>', <switch>)` - переключение класса по флагу `<switch>`, если равно `true`, то он добавиться, при `false` - удалиться.  
`<$_выборка>.toggleClass(function (index, classList, switch) {return '<имя_класса>'}, <switch>)` - переключение класса используя функцию обратного вызова.

В приведенных функциях в качестве `<имя_класса>` может быть строка содержащая список классов через пробел.

### <a id="Атрибуты" href="#Атрибуты">Атрибуты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Атрибуты - это все то, что находится внутри самого тега.

`<$_выборка>.attr('<имя_атрибута>')` - получение значения атрибута.  
`<$_выборка>.attr('<имя_атрибута>', <значение_атрибута>)` - установка значения атрибута (также можно использовать объект, либо функцию обратного вызова, как у CSS свойств).  
`<$_выборка>.removeAttr('<имя_атрибута>')` - удаление атрибута.

### <a id="data-атрибуты" href="#data-атрибуты">data-атрибуты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.data()` - возвращает объект со всеми ключами и значениями из реестра данных.  
`<$_выборка>.data('<ключ>')` - получение значения ключа из реестра данных, если его там нет то возвращается из атрибута тега `data-<ключ>`.  
`<$_выборка>.data('<ключ>', <значение>)` - установка значения ключа.  
`<$_выборка>.data({'<ключ1>': <значение>[, ...]})` - установка нескольких значений ключей через структуру.  
`<$_выборка>.removeData('<ключ>')` - удаление ключа из реестра данных.

### <a id="Свойства-элементов" href="#Свойства-элементов">Свойства элементов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

К ним относится `selectedIndex`, `checked`, `selected`, `tagName`, `nodeName`, `nodeType`, `ownerDocument`, `defaultChecked` и `defaultSelected`.

`<$_выборка>.prop('<имя_свойства>')` - получение значения свойства.  
`<$_выборка>.prop('<имя_свойства>', <значение_свойства>)` - установка значения свойства (также можно использовать объект, либо функцию обратного вызова, как у CSS свойств).  
`<$_выборка>.removeProp('<имя_свойства>')` - удаление свойства.

## <a id="События" href="#События">События</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные события JavaScript:
- `change` - изменение значения элемента (значение, при потери фокуса, элемента отличается от изначального, при получении фокуса);
- `click` - клик по элементу (порядок событий: `mousedown`, `mouseup`, `click`);
- `dblclick` - двойной щелчок мышки;
- `resize` - изменение размеров элементов;
- `scroll` - скроллинг элемента;
- `select` - выбор текста (только для `input[type=text]` и `textarea`);
- `submit` - отправка формы;
- `focus` - фокус на элементе;
- `blur` - фокус ушел с элемента;
- `focusin` - фокус на элементе, данное событие срабатывает на предке элемента, для которого произошло событие `focus`;
- `focusout` - фокус ушел с элемента, данное событие срабатывает на предке элемента, для которого произошло событие `blur`;
- `keydown` - нажатие клавиши на клавиатуре;
- `keypress` - нажатие клавиши на клавиатуре (`keydown` -> `keypress` -> `keyup`);
- `keyup` - отжатие клавиши на клавиатуре;
- `load` - загрузка элемента;
- `unload` - выгрузка элемента;
- `mousedown` - нажатие клавиши мыши;
- `mouseup` - отжатие клавиши мыши;
- `mousemove` - движение курсора;
- `mouseenter` - наведение курсора на элемент, не срабатывает при переходе фокуса на дочерние элементы;
- `mouseleave` - вывод курсора из элемента, не срабатывает при переходе фокуса на дочерние элементы;
- `mouseover` - наведение курсора на элемент;
- `mouseout` - вывод курсора из элемента.

Методы для работы с событиями:  
`<$_выборка>.<событие>()` - вызов события на элементах выборки.

Установка обработчика события:

```javascript
<$_выборка>.<событие>(function (event) {
    ...
    event.stopImmediatePropagation() //останавливает цепочку вызова событий для последующих слушателей DOM элемента, то есть события оставшихся слушателей вызваны не будут
    event.preventDefault(); //отменяет стандартное действие
    event.stopPropagation(); //отменяет всплытие события
    return false; //совмещает две предыдущие инструкции
});
```

`<$_выборка>.on('<событие>'[, '<селектор>'][, <данные>], function (event) {...})` - установка обработчика события (`'<событие>'` - может быть списком событий разделенных пробелом: `'<событие1>[ <событие2>[ ...]]'`) для элементов (аналогично `addEventListener`) [динамически для указанных `<селектор>` внутри элементов выборки, при условии что к ним будет относиться событие] [где `<данные>` будут доступны в `event.data`, когда событие вызовется].  
`<$_выборка>.off('<событие>'[, '<селектор>'][, <функция_обработчика>])` - удаления обработчиков события на элементах.

`<$_выборка>.trigger('<событие>'[, <данные>])` - вызов указаного события [где `<данные>` должны быть массивом или объектом и они перададутся в функцию обработки как дополнительные параметры].

`<$_выборка>.bind('<событие>'[, <данные>], function (event) {...})` - привязывает функцию обработчик к событию.  
`<$_выборка>.unbind(['<событие>'])` - удаления обработчиков события на элементах.

Можно повесить обработчик событий практически на любой объект.

### <a id="Пространство-имен" href="#Пространство-имен">Пространство имен</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Задаются как дополнение к `'<событие>'` после точки `.`:  
`'<событие>.<пространство_имен>'`

Могут использоваться для вызова обработчиков:  
`'<событие>.<пространство_имен>[.<пространство_имен>[...]]'`

Можно удалить все обработчики с определенного пространства имен:  
`'.<пространство_имен>'`

## <a id="Анимация" href="#Анимация">Анимация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.hide([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - скрывает элементы, оперирует лишь CSS атрибутом `display`, переключая его из текущего состояния в `none`[, оперирует `width`, `height`, `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`) [и вызывает указаную функцию после завершения анимации]].  
`<$_выборка>.show([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - показывает элементы.  
`<$_выборка>.toggle([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - работает как переключатель `hide` -> `show` или `show` -> `hide`.  
`<$_выборка>.toggle({true | false})` - отображает элемент при `true`, скрывает при `false`.

Функции анимации из семейства `slide` - оперирует `height`, `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`, по ум. = `200`):  
`<$_выборка>.slideUp([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - скрывает.  
`<$_выборка>.slideDown([{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - показывает.  
`<$_выборка>.slideToggle([{'slow' | 'fast' | <количество_мс>}[, function () {..}]])` - скрывает или показывает в зависимости от состояния.

Функции анимации из семейства `fade` - оперирует `opacity` и прочими с заданой скоростью (`'slow'` = `600`, `'fast'` = `200`, по ум. = `200`):  
`<$_выборка>.fadeIn([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - изменяет `opacity` от `0` до предыдущего.  
`<$_выборка>.fadeOut([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - изменяет `opacity` от текущего до `0`.  
`<$_выборка>.fadeToggle([{{'slow' | 'fast' | <количество_мс>}[, function () {...}]])` - переключатель между `In` и `Out`.  
`<$_выборка>.fadeTo([{{'slow' | 'fast' | <количество_мс>}, <прозрачность>[, function () {...}]])` - изменяет значение `opacity` до требуемого значения.

### <a id="animate" href="#animate">`animate`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Данная функция берет один или несколько CSS-свойств элемента и изменяет их от исходного до заданного за N-ое количество итераций (количество итераций зависит от указанного времени, но не реже одной итерации в 13мс).

```javascript
<$_выборка>.animate({
        '<свойство1>': <значение>, //изменяет текущее значение до указаного
        '<свойство2>': {'show' | 'hide' | 'toggle'}, //изменяет текущее значение по указаной схеме
        '<свойство3>': {+=<значение> | -=<значение>} //изменяет на указаное значение
        [, ...]
    },
    {'slow' | 'fast' | <количество_мс>} //скоростью изменения
    [, {'linear' | 'swing'} //функция для изменения значений процесса анимации
    [, function () {...}]] //функция обратного вызова после завершения анимации
)
```

Второй вариант:  
`<$_выборка>.animate(<CSS_свойства>, <опции>)`, где у опции может быть:
- `duration` - скоростью изменения - `'slow'` | `'fast'` | `<количество_мс>`;
- `easing` - функция для изменения значений процесса анимации: `'linear'` | `'swing'`;
- `complete` - функция обратного вызова после завершения анимации: `function () {...}`;
- `step` - функция, которая будет вызвана на каждом шаге анимации: `function (now, obj) {...}`. Где у `obj` имеются свойства:
    - `elem` - объект анимации;
    - `prop` - параметр, который анимируется;
    - `start` - начальное значение;
    - `end` - конечное значение;
    - `pos` - коэффициент, изменяется от 0 до 1;
    - `options` - опции настроек анимации.
    `now` - текущее значение анимированного параметра, вычисляется как: `now = (obj.end - obj.start) * obj.pos`;
- `queue` - флаг/параметр очереди, при значении строки равной `<имя_очереди_анимации>`, то укажет имя очереди анимации и автоматомически при это не стартует, при значении `false` анимации будут выполняться параллельно;
- `specialEasing` - объект в котором можно описать какую именно `easing` функцию следует использовать для изменения определенных параметров.

Если `animate` указывать за `animate`, то будет выполняться последовательный вызов анимаций, сразу после завершения предыдущей.

`$('html').animate({scrollTop: $('.class').offset().top})`

`<$_выборка>.dequeue(<имя_очереди_анимации>)` - запускает указаную очередь анимации.

#### <a id="Остановка-анимации" href="#Остановка-анимации">Остановка анимации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.stop([<имя_очереди_анимации>, ][<очистка_очереди>[, <применение_результата>]])` - останавливает анимацию [указанной очереди, по ум `'fx'`] [с очищением очереди всех последующих анимаций, если `true` [и применением результата анимации, если `true`]].

`jQuery.fx.off = true;` - отключает всю анимацию

## <a id="Манипуляции-с-DOM" href="#Манипуляции-с-DOM">Манипуляции с DOM</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Создания-элементов" href="#Создания-элементов">Создания элементов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$('<<имя_тега>>'[, <объект_атрибутов_элемента>])` - создает jQuery элемент.

### <a id="Перемещение-элементов" href="#Перемещение-элементов">Перемещение элементов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.after('<контент>')` - вставляет контент после каждого элемента из выборки.  
`<$_выборка>.insertAfter({'<селектор>' | <элементы>})` - вставляет элементы из выборки после каждого элемента переданного в качестве аргумента.  
`<$_выборка>.before('<контент>')` - вставляет контент перед каждым выбранным элементом.  
`<$_выборка>.insertBefore({'<селектор>' | <элементы>})` - вставляет элементы из выборки перед каждым элементом переданным в качестве аргумента.

`<$_выборка>.append('<контент>')` - вставляет контент в конец каждого элемента из выборки.  
`<$_выборка>.appendTo({'<селектор>' | <элементы>}) `- вставляет выбранный контент в конец каждого элемента переданного в качестве аргумента.  
`<$_выборка>.prepend('<контент>')` - вставляет контент в начало каждого элемента из выборки.  
`<$_выборка>.prependTo({'<селектор>' | <элементы>})` - вставляет выбранный контент в начало каждого элемента переданного в качестве аргумента.

`<$_выборка>.replaceWith('<контент>')` - заменяет найденные элементы новым контентом.  
`<$_выборка>.replaceAll({'<селектор>' | <элементы>})` - вставляет элементы в замен найденному.

`<$_выборка>.wrap({'<селектор>' | <элементы>})` - оборачиваем каждый найденный элемент новым элементом.  
`<$_выборка>.wrapAll({'<селектор>' | <элементы>})` - оборачивает все найденные элементы новым элементом.  
`<$_выборка>.wrapInner({'<селектор>' | <элементы>})` - оборачивает контент каждого найденного элемента новым элементом, оставляя при этом элементы на своих местах.  
`<$_выборка>.unwrap()` - удаляет родительский элемент у найденных элементов.

`<$_выборка>.clone([true])` - клонирует выбранные элементы, для дальнейшей вставки копий назад в DOM, позволяет так же копировать и обработчики событий.

`<$_выборка>.detach()` - удаляет элемент из DOM, но при этом сохраняет все данные о нем в jQuery, используется, если надо удалить элемент, а потом вернуть его обратно.  
`<$_выборка>.empty()` - удаляет текст и дочерние DOM элементы.  
`<$_выборка>.remove()` - удаляет элемент из DOM, насовсем.

`<$_выборка>.html()` - возвращает HTML заданного элемента.  
`<$_выборка>.html(<html>)` - заменяет HTML в заданном элементе.  
`<$_выборка>.text()` - возвращает текст заданного элемента, если внутри элемента будут другие HTML тэги, то вернется текст всех элементов.  
`<$_выборка>.text(<text>)` - заменяет текст внутри выбранных элементов, при попытке вставить таким образом HTML, будет получен текст, где тэги будут приведены к `HTML entities`.

### <a id="Размеры-элементов" href="#Размеры-элементов">Размеры элементов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.offset()` - возвращает позицию DOM элемента относительно `document`'а, данные будут получены в виде объекта: `{top: <поз_сверху>, left: <поз_слева>}`.  
`<$_выборка>.offset({top: <поз_сверху>, left: <поз_слева>})` - устанавливает расположение DOM элемента по указанным координатам.

`<$_выборка>.position()` - возвращает позицию DOM элемента относительно родительского элемента.

`<$_выборка>.height([<высота>])` - возвращает высоту элемента за вычетом отступов и границ; если у нас несколько элементов в выборке, возвратит первое; значение, в отличии от метода `css('height')`, возвращается без указания единиц измерения [, устанавливает высоту всех элементов в выборке, если значение высоты передано без указания единиц измерения, то это будут "px"].  
`$(window).height()` - высота окна.  
`$(document).height()` - высота HTML документа.  
`<$_выборка>.width([<ширина>])` - возвращает ширину элемента [, устанавливает ширину всех элементов в выборке].  
Методы `height()` и `width()` не изменяют своего поведения в зависимости от выбранной блочной модели, т.е. они всегда возвращают параметры области внутри `margin`, `padding` и `border`'а элемента.

`<$_выборка>.innerHeight()` и `<$_выборка>.innerWidth()` - возвращают высоту и ширину элемента, включая `padding`.  
`<$_выборка>.outerHeight([true])` и `<$_выборка>.outerWidth([true])` - возвращают высоту и ширину элемента, включая `padding`, `border` [и `margin`].

### <a id="Прокрутка" href="#Прокрутка">Прокрутка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.scrollLeft([<значение>])` - возвращает значение "проскроленности" по горизонтали первого элемента из выборки [, устанавливает значение горизонтального скрола для каждого элемента из выборки].  
`<$_выборка>.scrollTop([<значение>])` - возвращает значение "проскроленности" по вертикали первого элемента из выборки [, устанавливает значение вертикального скрола для каждого элемента из выборки]

Значение `"scrollTop"` и `"scrollLeft"` поддаются анимации и не работают для спрятанных элементов DOM.

## <a id="Работа-с-формами" href="#Работа-с-формами">Работа с формами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.serialize()` - возвращает данные с формы в виде строки: `<name>=<value>[&...]`.  
`<$_выборка>.serializeArray()` - возвращает данные с формы в виде массива объектов.

## <a id="AJAX" href="#AJAX">AJAX</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<$_выборка>.load("<url>"[, <данные>][, function (<строка_ответа>, <текст_статуса>, <jqXHR>) {...}])` - загружает данные с указанного адреса [, передавая дополнительные данные] в элемент [и вызывая после этого функцию обратного вызова].

`$.ajax(<опции>)` - где `<опции>` - объект со свойствами:
- `url` - в виде `"<url>"` - адрес запроса;
- `method` - метод запроса, один из `"POST"` | `"GET"` | `"PUT"`;
- `dataType` - тип загружаемых данных, один из `"html"` | `"xml"` | `"text"` | `"json"` | `"script"` | `"jsonp"`;
- `success` - функция вызова при удачном запросе: `function (data) {...}`, где `data` - пришедшие данные в указаном формате;
- `data` - данные для передачи, должны быть в виде массива, объекта или строки;
- `error` - возникает в случае ошибки: `function (error) {...}`, где `error` - ошибка.

События AJAX для элементов, для которых можно установить обработчики в объекте `<опции>`:
- `ajaxStart` - данное событие возникает в случае когда начался первый AJAX запрос, и при этом других активных AJAX запросов в данный момент нет;
- `beforeSend` - возникает до отправки запроса, позволяет редактировать `XMLHttpRequest`, локальное событие;
- `ajaxSend` - возникает до отправки запроса, аналогично `beforeSend`;
- `success` - возникает по возвращению ответа, когда нет ошибок ни сервера, ни вернувшихся данных, локальное событие;
- `ajaxSuccess` - возникает по возвращению ответа, аналогично `success`;
- `error` - возникает в случае ошибки, локальное событие;
- `ajaxError` - возникает в случае ошибки;
- `complete` - возникает по завершению текущего AJAX запроса (с ошибкой или без - срабатывает всегда), локальное событие;
- `ajaxComplete` - глобальное событие, аналогичное `complete`;
- `ajaxStop` - данное событие возникает в случае, когда больше нету активных запросов.

Эти имена событий могут использоваться в `$.ajax`, тогда они будут глобальными.

### <a id="Префильтры" href="#Префильтры">Префильтры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Префильтр** - это функция, которая будет вызвана до `ajaxStart`, в можно изменить как объект `jqXHR`, так и любые сопутствующие настройки.

`$.ajaxPrefilter(['<типы_возвращаемых_ajax_данных>',] function (options, originalOptions, jqXHR) {...});`. Где:
- `options` - настройки запроса (то что указывается при вызове "$.ajax()");
- `originalOptions` - "чистые" настройки, даже без учета изменений "по умолчанию";
- `jqXHR` - объект "jQuery XMLHttpRequest".

Их можно использовать для кэшрования результата или перенаправлении запросов на другой адрес.

### <a id="Конвертеры" href="#Конвертеры">Конвертеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Конвертор** - функция обратного вызова, которая вызывается в том случае, когда полученный типа данных не совпадает с ожидаемым.

`$.ajaxSetup({converters: <конвертеры>})` - где `<конвертеры>` - объект, который должен содержать свойства в указаном формате:  
`"{<входящий_тип> | *} <тип_преобразования>": function (textValue) {... return <newValue>}` - должна возвращать значение в типе преобразования или бросать исключение.

### <a id="Транспорт" href="#Транспорт">Транспорт</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Транспорт** - это объект, который предоставляет два метода - `send()` при отправке и `abort()` при отмене - они будут использоваться внутри метода `$.ajax()`.

`$.ajaxTransport(['<типы_возвращаемых_ajax_данных>',] function (options, originalOptions, jqXHR) {...})`, где тело функции может быть:

```javascript
if (<необходим_транспорт>) {
    return {
        send: function (headers //заголовки запроса в виде связки ключ-значение
            , function (status //HTTP статус ответа
                , statusText //текстовая интерпретация ответа
                , responses //объект содержащий ответы сервера во всех форматах, которые поддерживает транспорт
                , headers //строка содержащие заголовки ответа сервера, если конечно транспорт может их получить
            ) {...} /// функция обратного вызова, используется для оповещения о завершении запроса
        ) {...},
        abort: function () {...}
    };
}
```

## <a id="Объект-Deferred-и-подобные" href="#Объект-Deferred-и-подобные">Объект `Deferred` и подобные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`Deferred` используется чтобы заставлять асинхронный JavaScript работать синхронно.

`var <Deferred> = $.Deferred()` - инициализация `Deferred` объекта со статусом "ожидает выполнение".

`<Deferred>.done(function (data) {...}[, ...])` - добавление одного обработчика для успеха, где `data` - данные, которые были переданы с помощью метода `<Deferred>.resolve(<данные>)`, возвращает самого себя - `<Deferred>`.  
`<Deferred>.fail(function (error) {...}[, ...])` - добавление одного обработчика для ошибки, где `error` - данные, которые были переданы с помощью метода `<Deferred>.reject(<данные>)`, возвращает самого себя - `<Deferred>`.  
`<Deferred>.always(function (data) {...}[, ...])` - добавление одного обработчика для любого исхода, возвращает самого себя - `<Deferred>`.  
`<Deferred>.then(function (data) {...}, function (error) {...})` - добавление одного обработчика для успеха и для ошибки, возвращает самого себя - `<Deferred>`.

`<Deferred>.resolve([<данные>])` - изменения статуса на "выполнен успешно" и вызов всех обработчиков для успеха в порядки очереди, но они будут выполняться параллелено.  
`<Deferred>.reject([<ошибка>])` - изменения статуса на "выполнен с ошибкой" и вызов всех обработчиков для ошибки.

Если будут подключены обработчики после вызова метода который меняет статус, то он сразу выполнится.

`<Deferred>.promise()` - возвращает искомый объект в режиме "read only".

`$.when(<Deferred>[, ...])` - реализует интерфейс `Deferred`, возвращает проекцию `Deferred` объекта, принимает в качестве параметров произвольное множество `Deferred` объектов, когда все из них отработают, объект `when` изменит свое состояние в "выполнено", с последующим вызовом всех подписавшихся.

Также методы `ajax()` и `animate()` реализуют интерфейс `Deferred`.

### <a id="Методы-уведомлений" href="#Методы-уведомлений">Методы уведомлений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<Deferred>.progress(function (data) {...}[, ...])` - регистрирует функцию для получения уведомлений.  
`<Deferred>.notify([<данные>])` - посылает уведомления во все зарегистрированные функции, т.е вызывает их [и передает в них указанные данные].

## <a id="Callbacks" href="#Callbacks">`Callbacks`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`Callbacks` - позволяет составлять списки функций обратного вызова и вызывать их всех по надобности.

`var <Callbacks> = $.Callbacks([<флаги>])` - где `<флаги>` могут быть:
- `'once'` - все функции будут вызваны единожды (аналогично как в Deferred);
- `'memory'` - сохранять значение с последнего вызова `fire()`, и передача его в ново-зарегистрированные функции обратного вызова, и лишь потом обрабатывает новое значение (как в `Deferred`);
- `'unique'` - список функций обратного вызова фильтруется по уникальности;
- `'stopOnFalse'` - как только какая-нить функция вернет `false`, процесс запуска остановится.

`<Callbacks>.add(function (data) {...}[, ...])` - регистрирует функцию обратного вызова.  
`<Callbacks>.fire([<данные_для_функций>])` - вызывает все зарегистрированные функции обратного вызова в порядке их добавления.

## <a id="Дополнительные-методы" href="#Дополнительные-методы">Дополнительные методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$.extend([true, ]{{} | <object1>}[, <object2>[, ...]])` - сливает содержимое двух и более объектов в первый и возвращает его [и включая вложенные объекты].

## <a id="jQuery-плагин" href="#jQuery-плагин">jQuery плагин</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$.fn.<имя_плагина> = function (params) {...}` - объявление плагина, при этом `this` содержит jQuery объект с коллекцией всех элементов, а `params` - объект параметров инициализации, используется такая схема объявления плагина:

```javascript
(function ($) {
    var defaults = {'<параметр1>': <значение>[, ...]}; //параметры по умолчанию
    var options; //актуальные настройки, глобальные
    $.fn.<имя_плагина> = function (params) {
        options = $.extend({}, defaults, options, params); //при многократном вызове настройки будут сохранятся и замещаться при необходимости
        ...
        return this;
    };
})(jQuery);
```

`<$_выборка>.<имя_плагина>([<объект_параметров_инициализации>])` - создание плагина.

### <a id="Публичные-методы" href="#Публичные-методы">Публичные методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Методы объявляются в отдельном объекте, где **ключ** - это названия метода, а его **значение** - это реализация метода.

Для использования метода необходимо изменить функцию инициализатор плагина, при таком подходе будет происходить вызов метода, если он есть, со всем списком аргументов, иначе будет выполняться инициализация:

```javascript
    var methods = {...}; //описание методов.
    $.fn.<имя_плагина> = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else {
            ...//метод инициализации
        }
        ...
    }
```

`<$_выборка>.<имя_плагина>([<имя_метода>][, <аргум1>[, ...]])` - вызов метода.

Если плагин вешает какой-либо обработчик, то лучше всего всегда данный обработчик повесить в своем собственном пространстве имен `namespace`.

<a id="Webpack" href="#Webpack">Webpack</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

`npm i -g webpack` - инсталляция.  
`npm i webpack` - инсталляция локальная, для установки всех дополнительных модулей.

## <a id="Включение-зависимостей" href="#Включение-зависимостей">Включение зависимостей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Базовая конфигурация представляет собой импорт и экспорт как в NodeJs. Для включения файла в файл необходимо написать:  
`var <модуль> = require('<имя_файла>');`

### <a id="Сборка" href="#Сборка">Сборка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`webpack <имя_входного_файла> <имя_выходного_файла>` - запуск, - эта команда скомпилирует модуль `<имя_входного_файла>` и соберет все необходимые зависимости в один файл `<имя_выходного_файла>`, готовый к использованию в браузере.

Параметр `--watch` позволяет Webpack наблюдать за файлами от которых зависит модуль и пересобирать модуль по мере изменения файлов.

## <a id="Конфигурация" href="#Конфигурация">Конфигурация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В файле `webpack.config.js` помещается код, внутри можно использовать любой код из NodeJs или Js. Это - модуль, экспортирующий объект конфигурации, который читает Webpack при вызове его из командной строки без аргументов. Сам конфигурационный модуль должен экспортировать объект опций:  
`module.exports = <объект_опций>;`

`const NODE_ENV = process.env.NODE_ENV || 'developer';` - позволяет взять переменную окружения, для дальнейшего использования в конфигурирование.

`const webpack = require('webpack');` - используется для установки плагинов

`webpack` - запуск, с использованием файла `webpack.config.js`.

Пример использования библиотек:  
`npm install jquery` - установка.  
`const $ = require('jquery');` - подключение и использование.

## <a id="Свойства" href="#Свойства">Свойства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Пример конфигурации:

```javascript
const path = require('path');
module.exports = {
    entry: path.join(__dirname, "src", "main.js"),
    output: {
        path: path.join(__dirname, "dist"),
        filename: "bundle.js"
    },
    module: {
        loaders: [
            {
                test: path.join(__dirname, "src"),
                loader: 'babel-loader',
                query: {
                    presets: ['es2015']
                }
            }
        ]
    },
    plugins: [definePlugin, uglifyJsPlugin]
};
```

Основные свойства:
- `entry` - отвечает за входной файл, точку входа, задается в виде `"<путь_к_модулю>"`;
- `context` - означает базовое нахождение модулей (для точки входа, `entry`), задается в виде `"<путь_к_модулям>"`;
- `output` - отвечает за выходной файл, задается в виде объекта со свойствами:
    - `filename` - имя выходного файла, задается в виде `"<имя_конечного_файла>"`;
    - `path` - путь к каталогу выходного файла, задается в виде `"<путь>"`;
    - `library` - в этот объект поместится все то что экспортируется из входного файла (для точки входа, `entry`): `exports.<имя> = <значение>`, и тогда онобудет доступно как `<имя_библиотеки>.<имя>`, задается в виде `"<имя_библиотеки>"`;
- `module` - отвечает за утилиты для сборки, задается в виде объекта со свойствами:
    - `loaders` - массив загрузчиков, каждый из которых выполняет конкретное преобразование, задается в виде массива, который содержит объекты определенной структуры:
        - `test` - маска соответствия загрузчику, задается в виде строки или регулярного выражения;
        - `include` - включает только файлы, которые соответствуют указанному пути, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
        - `exclude` - исключает файлы, которые соответствуют указанному пути, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
        - `loader` - имя загрузчика, задается в виде `"<имя_модуля>"`;
    - `noParse` - используется для исключения файлов из обработки, которые соответствуют указаным маскам, задается в виде массива регулярных выражений или регулярным выражением или строкой пути;
- `plugins` - отвечает за плагины, задается в виде массива, который содержит объекты плагинов;
- `watch` - указывает при значении `true` что нужно наблюдать за файлами и пересобирать их по их изменению (сохранению), после этого `webpack` будет запущен и наблюдать за файлами;
- `watchOptions` - отвечает за опции наблюдения, задается в виде объекта со свойствами:
    - `aggregateTimeout` - указывает время ожидания для пересборки в мс (по ум. 300), задается в виде числа `<время_мс>`;
- `devtool` - отвечает за "карту модулей" в файле `<имя_конечного_файла>.map` для удобной отладки по модулям, задается в виде одного из значений: `"source-map"`, `"cheap-source-map"`, `"cheap-module-eval-source-map"`;
- `resolve` - используется для поиска входных модулей, задается в виде объекта со свойствами:
    - `modules` - отвечает за каталоги поиска, задается в виде массива, должен включать `"node_modules"`;
    - `extensions` - отвечает за расширения файлов, задается в виде массива, должен включать `""`;
    - `root` - отвечает за дополнительный, корневой каталог поиска модулей;
    - `alias` - используется для указания алиасов путям подключения файлов, задается в виде объекта, где ключ - это алиас, а значение - это путь к модулю.

### <a id="Плагины" href="#Плагины">Плагины</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Плагины можно повторять.

#### <a id="Плагин-webpackEnviromentPlugin" href="#Плагин-webpackEnviromentPlugin">Плагин `webpack.EnviromentPlugin`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет в скрипты передавать значения переменных окружения, и тогда их можно использовать как: `process.env.<имя_переменной_окружения>`.

`const EnviromentPlugin = new webpack.EnviromentPlugin('<имя_переменной_окружения>'[, ...]);`.

#### <a id="Плагин-webpackDefinePlugin" href="#Плагин-webpackDefinePlugin">Плагин `webpack.DefinePlugin`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет заменить отдельные фрагменты исходного кода динамическим кодом или постоянными значениями.

`const definePlugin = new webpack.DefinePlugin(<объект_замен>);` - где `<объект_замен>` - представляет собой объект, где ключи - это то что нужно заменить, а значение - это то на что нужно заменить.

#### <a id="Плагин--webpackoptimizeUglifyJsPlugin" href="#Плагин--webpackoptimizeUglifyJsPlugin">Плагин ` webpack.optimize.UglifyJsPlugin`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Применяется для обфускации и минификации JavaScript-кода в файле пакета с помощью `UglifyJs`.

`const uglifyJsPlugin = new webpack.optimize.UglifyJsPlugin(<объект_опций>);` - где `<объект_опций>` - представляет собой объект с опциями и свойствами:
- `beautify` - при значении `true` помогает избежать удаления всех отступов и пробельных символов, чтобы проще было читать получившийся файл пакета, по умолчанию `false`;
- `dead_code` - при значении `true`, удаляет все, что сочтет "мертвым кодом", поэтому текущий код чистится, по умолчанию `false`;
- `compress` - отвечает за сжатие, представляет собой объект с опциями и свойствами:
    - `warnings` - при значении `true` убирает предупреждения, по умолчанию `false`;
    - `drop_console` - при значении `true` убирает вывод в консоль, по умолчанию `false`;
    - `unsafe` - при значении `true` позволяет использовать не безопасные возможности во время сжатия, по умолчанию `false`.

#### <a id="Плагин-webpackNormalModuleReplacementPlugin" href="#Плагин-webpackNormalModuleReplacementPlugin">Плагин `webpack.NormalModuleReplacementPlugin`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет заменять ресурсы, которые соответствуют регулярному выражению другим ресурсом.

`const NormalModuleReplacementPlugin = new webpack.NormalModuleReplacementPlugin(/<рег_выражение_поиска>/, "<путь_к_ресурсу>");` - если ресурс соответствует регулярному выражению `/<рег_выражение_поиска>/`, он заменяется ресурсом, указанным в `"<путь_к_ресурсу>"`.

#### <a id="Плагин-webpackNoErrorsPlugin" href="#Плагин-webpackNoErrorsPlugin">Плагин `webpack.NoErrorsPlugin`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет не собирать сборку, если есть какая-то ошибка в сборке.

`const NoErrorsPlugin = new webpack.NoErrorsPlugin();`.

#### <a id="Плагин-webpackCommonsChunkPlugin" href="#Плагин-webpackCommonsChunkPlugin">Плагин `webpack.CommonsChunkPlugin`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет вынести общую часть из всех модулей в один файл. Также можно объявить в `entry`: `"common": "<путь_к_общему_модулю>"`. Тогда в файл внесется и еще указанный модуль.

`const CommonsChunkPlugin = new webpack.CommonsChunkPlugin(<объект_опций>);` - где `<объект_опций>` - представляет собой объект с опциями и свойствами:
- `name` - имя общего файла;
- `minChunks` - минимальное количество файлов использования общей части, по умолчанию все, задается в виде числа.

<a id="Пример-тестирования" href="#Пример-тестирования">Пример тестирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===================

```html
Пример HTML-страницы для тестов:
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- подключаем стили Mocha, для отображения результатов -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">
    <!-- подключаем библиотеку Mocha -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"></script>
    <!-- настраиваем Mocha: предстоит BDD-тестирование -->
    <script>
        mocha.setup('bdd');
    </script>
    <!-- подключаем chai -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"></script>
    <!-- в chai есть много всего, выносим assert в глобальную область -->
    <script>
        var assert = chai.assert;
    </script>
</head>
<body>
    <script>
    function <тестируемая_функция>(...) {
        /* код функции, пока что пусто */
    }
    </script>
    <!-- в этом скрипте находятся специализации -->
    <script src="test.js"></script>
    <!-- в элементе с id="mocha" будут результаты тестов -->
    <div id="mocha"></div>
    <!-- запустить тесты! -->
    <script>
        mocha.run();
    </script>
</body>
</html>
```

Страницу можно условно разделить на четыре части:
- **блок `<head>`** - в нем подключаются библиотеки и стили для тестирования, кода там нет;
- **блок `<script>`** с реализацией спецификации, с кодом тестируемых функций;
- далее подключаются тесты, файл `test.js` содержит `describe("<имя_тестируемой_функции>", ...)`, для тестирования функций. Методы `describe` и `it` принадлежат библиотеке Mocha;
- элемент `<div id="mocha">` будет использоваться библиотекой Mocha для вывода результатов. Запуск тестов инициируется командой `mocha.run()`.