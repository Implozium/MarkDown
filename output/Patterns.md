[Содержание](#Содержание)
==========

- [Паттерны программирования](#user-content-Паттерны-программирования)
    - [Принципы паттернов](#user-content-Принципы-паттернов)
        - [Основной принцип построения паттернов](#user-content-Основной-принцип-построения-паттернов)
        - [Принцип проектирования: предпочтение композиции перед наследованием](#user-content-Принцип-проектирования-предпочтение-композиции-перед-наследованием)
        - [Принцип инверсии зависимостей](#user-content-Принцип-инверсии-зависимостей)
        - [Принцип минимальной информированости](#user-content-Принцип-минимальной-информированости)
        - [Голливудский принцип](#user-content-Голливудский-принцип)
        - [Принцип одной обязанности](#user-content-Принцип-одной-обязанности)
    - [Паттерны](#user-content-Паттерны)
        - [Порождающие шаблоны проектирования](#user-content-Порождающие-шаблоны-проектирования)
            - [Паттерн Простая Фабрика (Factory)](#user-content-Паттерн-Простая-Фабрика-Factory)
            - [Паттерн Фабричный Метод (Factory method)](#user-content-Паттерн-Фабричный-Метод-Factory-method)
            - [Паттерн Абстрактная фабрика (Abstract factory)](#user-content-Паттерн-Абстрактная-фабрика-Abstract-factory)
            - [Паттерн Строитель (Builder)](#user-content-Паттерн-Строитель-Builder)
            - [Паттерн Прототип (Prototype)](#user-content-Паттерн-Прототип-Prototype)
            - [Паттерн Одиночка (Singleton)](#user-content-Паттерн-Одиночка-Singleton)
        - [Структурные шаблоны проектирования](#user-content-Структурные-шаблоны-проектирования)
            - [Паттерн Адаптер (Adapter)](#user-content-Паттерн-Адаптер-Adapter)
            - [Паттерн Мост (Bridge)](#user-content-Паттерн-Мост-Bridge)
            - [Паттерн Компоновщик (Composite)](#user-content-Паттерн-Компоновщик-Composite)
            - [Паттерн Декоратор (Decorator)](#user-content-Паттерн-Декоратор-Decorator)
            - [Паттерн Фасад (Facade)](#user-content-Паттерн-Фасад-Facade)
            - [Паттерн Приспособленец (Flyweight)](#user-content-Паттерн-Приспособленец-Flyweight)
            - [Паттерн Заместитель (Proxy)](#user-content-Паттерн-Заместитель-Proxy)
        - [Поведенческие шаблоны проектирования](#user-content-Поведенческие-шаблоны-проектирования)
            - [Паттерн Цепочка обязанностей (Chain of responsibility)](#user-content-Паттерн-Цепочка-обязанностей-Chain-of-responsibility)
            - [Паттерн Команда (Command)](#user-content-Паттерн-Команда-Command)
            - [Паттерн Интерпретатор (Interpreter)](#user-content-Паттерн-Интерпретатор-Interpreter)
            - [Паттерн Итератор (Iterator)](#user-content-Паттерн-Итератор-Iterator)
            - [Паттерн Посредник (Mediator)](#user-content-Паттерн-Посредник-Mediator)
            - [Паттерн Хранитель (Memento)](#user-content-Паттерн-Хранитель-Memento)
            - [Паттерн Наблюдатель (Observer)](#user-content-Паттерн-Наблюдатель-Observer)
            - [Паттерн Посетитель (Visitor)](#user-content-Паттерн-Посетитель-Visitor)
        - [Паттерн Стратегия (Strategy)](#user-content-Паттерн-Стратегия-Strategy)
        - [Паттерн Состояние (State)](#user-content-Паттерн-Состояние-State)
        - [Паттерн Шаблонный метод (Template method)](#user-content-Паттерн-Шаблонный-метод-Template-method)
    - [Составные паттерны](#user-content-Составные-паттерны)
        - [Паттерн Модель-Представление-Контроллер](#user-content-Паттерн-Модель-Представление-Контроллер)
- [Основные шаблоны](#user-content-Основные-шаблоны)
    - [Декомпозиция сложных приложений](#user-content-Декомпозиция-сложных-приложений)
    - [Шаблоны интеграции в архитектуре на микрослужбах](#user-content-Шаблоны-интеграции-в-архитектуре-на-микрослужбах)
        - [Прокси-сервер для служб](#user-content-Прокси-сервер-для-служб)
        - [Координация служб](#user-content-Координация-служб)
        - [Интеграция с помощью брокера сообщений](#user-content-Интеграция-с-помощью-брокера-сообщений)
    - [Шаблоны обмена сообщениями и интеграции](#user-content-Шаблоны-обмена-сообщениями-и-интеграции)
        - [Шаблоны однонаправленного обмена и вида "Запрос/ответ"](#user-content-Шаблоны-однонаправленного-обмена-и-вида-Запросответ)
            - [Очереди сообщений](#user-content-Очереди-сообщений)
            - [Обмен сообщениями через брокера](#user-content-Обмен-сообщениями-через-брокера)
        - [Шаблон "Публикация/подписка"](#user-content-Шаблон-Публикацияподписка)
            - [Протокол AMQP](#user-content-Протокол-AMQP)
        - [Шаблоны "Запрос/ответ"](#user-content-Шаблоны-Запросответ)
    - [Шаблон обработки ошибок (**Circuit Breaker**)](#user-content-Шаблон-обработки-ошибок-Circuit-Breaker)
    - [Шаблон источник событий (**Event Sourcing**)](#user-content-Шаблон-источник-событий-Event-Sourcing)
    - [Шаблон Душитель (**Strangler**)](#user-content-Шаблон-Душитель-Strangler)
- [Принципы проектирования](#user-content-Принципы-проектирования)
    - [SOLID](#user-content-SOLID)
        - [Принцип единственной ответственности (Single Responsibility Principle, SRP)](#user-content-Принцип-единственной-ответственности-Single-Responsibility-Principle-SRP)
        - [Принцип открытости/закрытости (Open/Closed Principle, OCP)](#user-content-Принцип-открытостизакрытости-OpenClosed-Principle-OCP)
        - [Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)](#user-content-Принцип-подстановки-Барбары-Лисков-Liskov-Substitution-Principle-LSP)
        - [Принцип разделения интерфейса (Interface Segregation Principle, ISP)](#user-content-Принцип-разделения-интерфейса-Interface-Segregation-Principle-ISP)
        - [Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)](#user-content-Принцип-инверсии-зависимостей-Dependency-Inversion-Principle-DIP)
    - [KISS (Keep it short and simple)](#user-content-KISS-Keep-it-short-and-simple)
    - [Чем хуже, тем лучше](#user-content-Чем-хуже-тем-лучше)
    - [DRY (Don't repeat yourself)](#user-content-DRY-Dont-repeat-yourself)
    - [YAGNI (You ain't gonna need it)](#user-content-YAGNI-You-aint-gonna-need-it)
    - [GIGO (Garbage In, Garbage Out)](#user-content-GIGO-Garbage-In-Garbage-Out)
- [Связность компонентов](#user-content-Связность-компонентов)
    - [Принцип эквивалентности повторного использования и выпусков (REP: Reuse/Release Equivalence Principle)](#user-content-Принцип-эквивалентности-повторного-использования-и-выпусков-REP-ReuseRelease-Equivalence-Principle)
    - [Принцип согласованного изменения (CCP: Common Closure Principle)](#user-content-Принцип-согласованного-изменения-CCP-Common-Closure-Principle)
    - [Принцип совместного повторного использования (CRP: Common Reuse Principle)](#user-content-Принцип-совместного-повторного-использования-CRP-Common-Reuse-Principle)
    - [Связь принципов](#user-content-Связь-принципов)
- [Сочетаемость компонентов](#user-content-Сочетаемость-компонентов)
    - [Принцип ацикличности зависимостей](#user-content-Принцип-ацикличности-зависимостей)
    - [Принцип устойчивых зависимостей](#user-content-Принцип-устойчивых-зависимостей)
        - [Метрики устойчивости](#user-content-Метрики-устойчивости)
    - [Принцип устойчивости абстракций](#user-content-Принцип-устойчивости-абстракций)
        - [Мера абстрактности](#user-content-Мера-абстрактности)
    - [Зоны](#user-content-Зоны)
    - [Зона боли](#user-content-Зона-боли)
    - [Зона бесполезности](#user-content-Зона-бесполезности)
    - [Зона главной последовательности](#user-content-Зона-главной-последовательности)
- [Архитектура](#user-content-Архитектура)
    - [Сущности](#user-content-Сущности)
    - [Кричащая архитектура](#user-content-Кричащая-архитектура)
    - [Правило зависимостей](#user-content-Правило-зависимостей)
        - [Неполные границы](#user-content-Неполные-границы)
    - [Шаблон проектирования "Скромный объект"](#user-content-Шаблон-проектирования-Скромный-объект)
    - [Главный компонент](#user-content-Главный-компонент)
    - [Архитектура на основе сервисов](#user-content-Архитектура-на-основе-сервисов)
    - [Тесты](#user-content-Тесты)
    - [Три шага в создании программного обеспечения](#user-content-Три-шага-в-создании-программного-обеспечения)
    - [Чистая встраиваемая архитектура](#user-content-Чистая-встраиваемая-архитектура)
    - [Детали архитектуры](#user-content-Детали-архитектуры)
        - [База Данных](#user-content-База-Данных)
        - [Веб](#user-content-Веб)
        - [Фреймворки](#user-content-Фреймворки)
    - [Подходы к проектированию и организации кода](#user-content-Подходы-к-проектированию-и-организации-кода)
        - [Упаковка по уровням](#user-content-Упаковка-по-уровням)
        - [Упаковка по особенностям](#user-content-Упаковка-по-особенностям)
        - [Упаковка по компонентам](#user-content-Упаковка-по-компонентам)
- [Рекомендации по проектированию HTTP API](#user-content-Рекомендации-по-проектированию-HTTP-API)
    - [Основные принципы](#user-content-Основные-принципы)
        - [Принцип разделения ответственности](#user-content-Принцип-разделения-ответственности)
        - [Требование использования защищенных соединений](#user-content-Требование-использования-защищенных-соединений)
        - [Требование наличие версии в заголовке `Accept`](#user-content-Требование-наличие-версии-в-заголовке-Accept)
        - [Использовать заголовок `ETags` для кэширования](#user-content-Использовать-заголовок-ETags-для-кэширования)
        - [Использовать `Request-ID` для интроспекции](#user-content-Использовать-Request-ID-для-интроспекции)
        - [Необходимо разбивать большие ответы сервера на несколько небольших при помощи заголовка `Range`](#user-content-Необходимо-разбивать-большие-ответы-сервера-на-несколько-небольших-при-помощи-заголовка-Range)
    - [Запросы](#user-content-Запросы)
        - [Соответствующие коды состояний](#user-content-Соответствующие-коды-состояний)
        - [Предоставление полных версии ресурсов](#user-content-Предоставление-полных-версии-ресурсов)
        - [API должен принимать сериализованный JSON в теле запроса](#user-content-API-должен-принимать-сериализованный-JSON-в-теле-запроса)
    - [Конструировании пути к ресурсу](#user-content-Конструировании-пути-к-ресурсу)
        - [Названия ресурсов](#user-content-Названия-ресурсов)
        - [Действия](#user-content-Действия)
        - [Названия компонентов пути и атрибутов](#user-content-Названия-компонентов-пути-и-атрибутов)
        - [API должен поддерживать доступ к ресурсу не только по его id](#user-content-API-должен-поддерживать-доступ-к-ресурсу-не-только-по-его-id)
        - [Необходимо свести к минимуму количество вложений в пути для доступа к ресурсу](#user-content-Необходимо-свести-к-минимуму-количество-вложений-в-пути-для-доступа-к-ресурсу)
    - [Ответы](#user-content-Ответы)
        - [Необходимо предоставлять UUID запрашиваемых ресурсов](#user-content-Необходимо-предоставлять-UUID-запрашиваемых-ресурсов)
        - [Необходимо предоставлять информацию о дате создания и изменения ресурса](#user-content-Необходимо-предоставлять-информацию-о-дате-создания-и-изменения-ресурса)
        - [Временные величины должны быть форматированы согласно ISO8601](#user-content-Временные-величины-должны-быть-форматированы-согласно-ISO8601)
        - [Отношения с внешними сущностями должны быть вынесены во вложенный объект](#user-content-Отношения-с-внешними-сущностями-должны-быть-вынесены-во-вложенный-объект)
        - [Необходимо создавать структурированные ответы в случае возникновения ошибок](#user-content-Необходимо-создавать-структурированные-ответы-в-случае-возникновения-ошибок)
        - [Необходимо показывайть ограничение по количеству запросов](#user-content-Необходимо-показывайть-ограничение-по-количеству-запросов)
        - [JSON во всех ответах должен быть минимизирован](#user-content-JSON-во-всех-ответах-должен-быть-минимизирован)
    - [Артефакты](#user-content-Артефакты)
        - [Необходимо предоставлять удобную для обработки JSON-схему](#user-content-Необходимо-предоставлять-удобную-для-обработки-JSON-схему)
        - [Необходимо предоставлять удобочитаемую документацию](#user-content-Необходимо-предоставлять-удобочитаемую-документацию)
        - [Необходимо предоставлять примеры запросов, которые можно протестировать](#user-content-Необходимо-предоставлять-примеры-запросов-которые-можно-протестировать)
        - [Стабильность API](#user-content-Стабильность-API)
- [Масштабирование приложений](#user-content-Масштабирование-приложений)
    - [Доступность](#user-content-Доступность)
        - [Измерение доступности](#user-content-Измерение-доступности)
        - [Автоматизация ручных процессов](#user-content-Автоматизация-ручных-процессов)
    - [Управление рисками](#user-content-Управление-рисками)
        - [Принципы управления рисками](#user-content-Принципы-управления-рисками)
        - [Матрица рисков](#user-content-Матрица-рисков)
        - [Смягчение рисков](#user-content-Смягчение-рисков)
        - [Избыточность](#user-content-Избыточность)
        - [Сложность](#user-content-Сложность)
        - [Самовосстановление](#user-content-Самовосстановление)
    - [Сервисы и микросервисы](#user-content-Сервисы-и-микросервисы)
        - [Обработка отказов сервисов](#user-content-Обработка-отказов-сервисов)
- [Общие паттерны](#user-content-Общие-паттерны)
    - [Кэширование](#user-content-Кэширование)
    - [Паттерн RORO](#user-content-Паттерн-RORO)
    - [Паттерн Ice Factory](#user-content-Паттерн-Ice-Factory)
    - [Паттерн BIF](#user-content-Паттерн-BIF)
    - [Паттерн Модуль](#user-content-Паттерн-Модуль)
    - [Внедрение зависимостей Dependency Injection](#user-content-Внедрение-зависимостей-Dependency-Injection)
    - [Локатор служб](#user-content-Локатор-служб)
    - [Контейнер внедрения зависимостей, DI-контейнер](#user-content-Контейнер-внедрения-зависимостей-DI-контейнер)
    - [Плагины](#user-content-Плагины)
    - [Подключение модулей, инициализируемых асинхронно](#user-content-Подключение-модулей-инициализируемых-асинхронно)
    - [Группировка асинхронных операций](#user-content-Группировка-асинхронных-операций)
    - [Кэширование асинхронных запросов](#user-content-Кэширование-асинхронных-запросов)
    - [Использование нескольких процессов](#user-content-Использование-нескольких-процессов)
    - [Масштабирование приложений](#user-content-Масштабирование-приложений)
        - [Клонирование и распределение нагрузки](#user-content-Клонирование-и-распределение-нагрузки)
        - [Динамическое распределение нагрузки с помощью http-proxy и Consul](#user-content-Динамическое-распределение-нагрузки-с-помощью-http-proxy-и-Consul)
        - [Одноранговое распределение нагрузки](#user-content-Одноранговое-распределение-нагрузки)
    - [Примитивная одержимость](#user-content-Примитивная-одержимость)

<a id="Паттерны-программирования" href="#Паттерны-программирования">Паттерны программирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========================

**Паттерн** - решение задачи в контексте.

Где:
- **Контекстом** называется ситуация, в которой применяется паттерн. Ситуация должна быть достаточно типичной и распространенной;
- **Задачей** называется цель, которой вы хотите добиться в контексте, в совокупности со всеми ограничениями, присущими контексту;
- **Решением** называется обобщенная архитектура, которая достигает заданной цели при соблюдении набора ограничений.

## <a id="Принципы-паттернов" href="#Принципы-паттернов">Принципы паттернов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Основной-принцип-построения-паттернов" href="#Основной-принцип-построения-паттернов">Основной принцип построения паттернов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Основной принцип построения паттернов** - если некий аспект кода изменяется (допустим, с введением новых требований), то его необходимо отделить от тех аспектов, которые остаются неизменными - выделить переменные составляющие и инкапсулировать их, чтобы позднее их можно было изменять или расширять без воздействия на постоянные составляющие - **инкапсулировать то что изменяется**.

Все паттерны обеспечивают возможность изменения некоторой части системы независимо от других частей.

### <a id="Принцип-проектирования-предпочтение-композиции-перед-наследованием" href="#Принцип-проектирования-предпочтение-композиции-перед-наследованием">Принцип проектирования: предпочтение композиции перед наследованием</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Принцип проектирования**: отдавать предпочтение композиции перед наследованием, то есть делегирование соответствующих операций (поведения) другим объектам, что позволяет делать системы более гибче и изменять поведение во время выполнения - при условии, что объект, подключенный посредством композиции, реализует правильный интерфейс.

Необходимо предпочитать композицию наследованию где возможно. Наследование имеет больше смысла, чем композиция в таких случаях:
- Наследование представляет собой "is-a" отношения а не "has-a" отношения:
    > Human->Animal vs. User->UserDetails
- Можно повторно использовать код из базовых классов:
    > Люди могут двигаться как все животные
- Есть возможность внести глобальные изменения в производные классы, изменив базовый класс:
    > Изменение расхода калорий у всех животных при их перемещении

Если два объекта могут взаимодействовать, не обладая практически никакой информацией друг о друге, такие объекты называют **слабосвязанными**. На базе слабосвязанных архитектур строятся гибкие ОО-системы, которые хорошо адаптируются к изменениям благодаря минимальным зависимостям между объектами.

Необходимо стремиться к слабой связанности взаимодействующих объектов.

Классы должны быть открыты для расширения, но закрыты для изменения - это дает архитектуры, устойчивые к изменениям и достаточно гибкие для поддержки новой функциональности в соответствии с изменившимися требованиями.

Главные свойства компонентов и подсистем программного обеспечения, в которые входит и модуль:
- **сцепленность** (*cohesion*): мера корреляции функций компонента между собой. Например, модуль, предназначенный для выполнения только одного действия, когда все его элементы подчинены решению одной задачи, обладает высокой сцепленностью:
    > Модуль, содержащий функции для сохранения объектов любого типа в базу данных, такие как saveProduct(), saveInvoice(), saveUser() и т. д., имеет низкую сцепленность;
- **связанность** (*coupling*): мера зависимости от других компонентов системы. Кроме того, два модуля, взаимодействующих через глобальное или общее состояние, также тесно связаны. С другой стороны, два модуля, взаимодействующих только через передачу параметров, слабо связаны:
    > Например, модуль тесно связан с другим модулем, если непосредственно читает или изменяет данные другого модуля.

Наиболее желательна высокая сцепленность при слабой связанности, что обеспечивает наглядность, возможность повторного использования и расширяемость модулей.

### <a id="Принцип-инверсии-зависимостей" href="#Принцип-инверсии-зависимостей">Принцип инверсии зависимостей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Принцип инверсии зависимостей** - код должен зависеть от абстракций, а не от конкретных классов. Он требует, чтобы высокоуровневые компоненты не зависели от низкоуровневых компонентов; вместо этого и те, и другие должны зависеть от абстракций.  
"*Высокоуровневым*" компонентом называется класс, поведение которого определяется в контексте других, "*низкоуровневых*" компонентов.

Рекомендации для избегания нарушения принципа инверсии зависимостей в архитектурах:
- ссылки на конкретные классы не должны храниться в переменных;
- в архитектуре не должно быть классов, производных от конкретных классов;
- методы не должны переопределять методы, реализованные в каких-либо из его базовых классов.

### <a id="Принцип-минимальной-информированости" href="#Принцип-минимальной-информированости">Принцип минимальной информированости</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Принцип минимальной информированости** - сокращение взаимодействия между объектами до несколький ближайших объектов. Это препятствует созданию архитектур с большим количеством тесно связанных классов, в которых изменение в одной части системы каскадно распространяется в другие части. При формировании многочисленных зависимостей между классами система теряет гибкость и становится сложной для понимания, а затраты на ее сопровождение возрастают.

Согласно принципу, из любого метода этого объекта должны вызываться только методы, принадлежащие:
- самому объекту;
- объектам, переданным в параметрах метода;
- любому объекту, созданному внутри метода.

То есть запрещают вызывать методы для объектов полученых в результате вызова других методов.

И любым компонентам объекта - любым объектам, на которые ссылается переменная экземпляра (связаны отношением типа содержит).

### <a id="Голливудский-принцип" href="#Голливудский-принцип">Голливудский принцип</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Голливудский принцип** - позволяет компонентам низкого уровня подключаться к системе, но компоненты высокого уровня сами определяют, когда и как они должны использоваться. Иначе говоря, компоненты высокого уровня запрещают компонентам низкого уровня "проявлять инициативу".

Этот принцип помогает предотвратить "разложение зависимостей" - явление, при котором компоненты высокого уровня зависят от компонентов низкого уровня, которые зависят от компонентов низкого уровня, которые зависят... и т. д. Разобраться в архитектуре такой системы очень трудно.

### <a id="Принцип-одной-обязанности" href="#Принцип-одной-обязанности">Принцип одной обязанности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Принцип одной обязанности** - класс должен иметь только одну причину для изменения. То есть изменений в классах следует по возможности избегать, так как модификация кода обычно сопровождается массой проблем. Наличие двух причин для изменения повышает вероятность того, что класс изменится в будущем, а если это все же произойдет - изменения повлияют на два аспекта архитектуры.

Принцип указывает на то, что каждому классу должна быть выделена одна - и только одна! - обязанность. Каждая обязанность класса является областью потенциальных изменений. Несколько обязанностей несколько причин для изменения. Принцип рекомендует ограничить каждый класс одной обязанностью.

## <a id="Паттерны" href="#Паттерны">Паттерны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Порождающие-шаблоны-проектирования" href="#Порождающие-шаблоны-проектирования">Порождающие шаблоны проектирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Порождающие шаблоны описывают создание (instantiate) объекта или группы связанных объектов.*

Это шаблоны, которые используют механизмы создания объектов, чтобы создавать объекты подходящим для данной ситуации способом. Базовый способ создания может привести к проблемам в архитектуре или к ее усложнению. Порождающие шаблоны пытаются решать эти проблемы, управляя способом создания объектов.

#### <a id="Паттерн-Простая-Фабрика-Factory" href="#Паттерн-Простая-Фабрика-Factory">Паттерн Простая Фабрика (Factory)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Простая фабрика просто генерирует экземпляр для клиента без предоставления какой-либо логики экземпляра.*

В объектно ориентированном программировании фабрикой называется объект, создающий другие объекты. Формально фабрика - это функция или метод, возвращающая объекты разных прототипов или классов из вызова какого-то метода, который считается новым.

**Использование**

Когда создание объекта подразумевает какую-то логику, а не просто несколько присваиваний, то имеет смысл делегировать задачу выделенной фабрике, а не повторять повсюду один и тот же код.

[Пример паттерна Простая Фабрика](../assets/Patterns/Factory.js)  
[Пример паттерна Простая Фабрика 2](../assets/Patterns/Factory.ts)

#### <a id="Паттерн-Фабричный-Метод-Factory-method" href="#Паттерн-Фабричный-Метод-Factory-method">Паттерн Фабричный Метод (Factory method)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Это способ делегирования логики создания объектов (instantiation logic) дочерним классам.*

В классо-ориентированном программировании (class-based programming) фабричным методом называют порождающий шаблон проектирования, использующий генерирующие методы (factory method) для решения проблемы создания объектов без указания для них конкретных классов. Объекты создаются посредством вызова не конструктора, а генерирующего метода, определенного в интерфейсе и реализованного дочерними классами либо реализованного в базовом классе и, опционально, переопределенного (overridden) производными классами (derived classes).

**Назначение**

Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать. Фабричный метод позволяет классу делегировать инстанцирование подклассам.

**Применимость**:
- когда классу заранее неизвестно, объекты каких классов ему нужно создавать;
- когда класс спроектирован так, чтобы объекты, которые он создает, специфицировались подклассами;
- когда класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и вы планируете локализовать знание о том, какой класс принимает эти обязанности на себя.

**Изображение**

![](../assets/Patterns/FactoryMethod.png)

**Участники**:
- `Product` - продукт:
    - определяет интерфейс объектов, создаваемых фабричным методом;
- `ConcreteProduct` - конкретный продукт:
    - реализует интерфейс `Product`;
- `Creator` - создатель:
    - объявляет фабричный метод, возвращающий объект типа `Product`. `Creator` может также определять реализацию по умолчанию фабричного метода, который возвращает объект `ConcreteProduct`;
    - может вызывать фабричный метод для создания объекта `Product`.
- `ConcreteCreator` - конкретный создатель:
    - замещает фабричный метод, возвращающий объект `ConcreteProduct`.

**Отношения**:
Создатель "полагается" на свои подклассы в определении фабричного метода, который будет возвращать экземпляр подходящего конкретного продукта.

**Плюсы**:
- создание объектов, независимо от их типов и сложности процесса создания;
- предоставляет подклассам операции-зацепки (hooks). Создание объектов внутри класса с помощью фабричного метода всегда оказывается более гибким решением, чем непосредственное создание. Фабричный метод создает в подклассах операции-зацепки для предоставления расширенной версии объекта;
- соединяет параллельные иерархии. Параллельные иерархии возникают в случае, когда класс делегирует часть своих обязанностей другому классу, не являющемуся производным от него. В нем локализуется знание о том, какие классы способны работать совместно.

**Минусы**:
- даже для одного объекта необходимо создать соответствующую фабрику, что увеличивает код.

[Пример паттерна Фабричный Метод](../assets/Patterns/FactoryMethod.js)  
[Пример паттерна Фабричный Метод 2](../assets/Patterns/FactoryMethod.ts)

#### <a id="Паттерн-Абстрактная-фабрика-Abstract-factory" href="#Паттерн-Абстрактная-фабрика-Abstract-factory">Паттерн Абстрактная фабрика (Abstract factory)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Это фабрика фабрик. То есть фабрика, группирующая индивидуальные, но взаимосвязанные/взаимозависимые фабрики без указания для них конкретных классов.*

Шаблон "Абстрактная фабрика" описывает способ инкапсулирования группы индивидуальных фабрик, объединенных некой темой, без указания для них конкретных классов.

**Назначение**

Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.

**Применимость**:
- когда система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты;
- когда входящие в семейство взаимосвязанные объекты должны использоваться вместе и вам необходимо обеспечить выполнение этого ограничения;
- когда система должна конфигурироваться одним из семейств составляющих ее объектов;
- когда можно предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию.

**Изображение**

![](../assets/Patterns/AbstractFactory.png)

**Участники**:
- `AbstractFactory` - абстрактная фабрика:
    - объявляет интерфейс для операций, создающих абстрактные объекты-продукты;
- `ConcreteFactory` - конкретная фабрика:
    - реализует операции, создающие конкретные объекты-продукты;
- `AbstractProduct` - абстрактный продукт:
    - объявляет интерфейс для типа объекта-продукта;
- `ConcreteProduct` - конкретный продукт:
    - определяет объект-продукт, создаваемый соответствующей конкретной фабрикой;
    - реализует интерфейс `AbstractProduct`;
- `Client` - клиент:
    - пользуется исключительно интерфейсами, которые объявлены в классах `AbstractFactory` и `AbstractProduct`.

**Отношения**:
- обычно во время выполнения создается единственный экземпляр класса `ConcreteFactory`. Эта конкретная фабрика создает объекты-продукты, имеющие вполне определенную реализацию. Для создания других видов объектов клиент должен воспользоваться другой конкретной фабрикой;
- `AbstractFactory` передоверяет создание объектов-продуктов своему подклассу `ConcreteFactory`.

**Плюсы**:
- изолирует конкретные классы. Помогает контролировать классы объектов, создаваемых приложением. Поскольку фабрика инкапсулирует ответственность за создание классов и сам процесс их создания, то она изолирует клиента от деталей реализации классов. Клиенты манипулируют экземплярами через их абстрактные интерфейсы. Имена изготавливаемых классов известны только конкретной фабрике, в коде клиента они не упоминаются;
- упрощает замену семейств продуктов. Класс конкретной фабрики появляется в приложении только один раз: при инстанцировании. Это облегчает замену используемой приложением конкретной фабрики;
- гарантирует сочетаемость продуктов. Если продукты некоторого семейства спроектированы для совместного использования, то важно, чтобы приложение в каждый момент времени работало только с продуктами единственного семейства.

**Минусы**:
- сложно добавить поддержку нового вида продуктов.

[Пример паттерна Абстрактная фабрика](../assets/Patterns/AbstractFactory.js)  
[Пример паттерна Абстрактная фабрика 2](../assets/Patterns/AbstractFactory.ts)

#### <a id="Паттерн-Строитель-Builder" href="#Паттерн-Строитель-Builder">Паттерн Строитель (Builder)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон позволяет создавать разные свойства объекта, избегая загрязнения конструктора (constructor pollution). Это полезно, когда у объекта может быть несколько свойств. Или когда создание объекта состоит из большого количества этапов.*

Шаблон "Строитель" предназначен для поиска решения проблемы антипаттерна Telescoping constructor (когда в конструкторе количество параметров может быстро разрастись, и станет трудно разобраться в их структуре и они имеют много не обязательных значений).

**Назначение**

Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.

**Применимость**:
- когда алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;
- когда процесс конструирования должен обеспечивать различные представления конструируемого объекта.

**Изображение**

![](../assets/Patterns/Builder.png)

**Участники**:
- `Builder` - строитель:
    - задает абстрактный интерфейс для создания частей объекта `Product`;
- `ConcreteBuilder` - конкретный строитель:
    - конструирует и собирает вместе части продукта посредством реализации интерфейса `Builder`;
    - определяет создаваемое представление и следит за ним;
    - предоставляет интерфейс для доступа к продукту;
- `Director` - распорядитель:
    - конструирует объект, пользуясь интерфейсом `Builder`;
- `Product` - продукт:
    - представляет сложный конструируемый объект. `ConcreteBuilder` строит внутреннее представление продукта и определяет процесс его сборки;
    - включает классы, которые определяют составные части, в том числе интерфейсы для сборки конечного результата из частей.

**Отношения**:
- клиент создает объект-распорядитель `Director` и конфигурирует его нужным объектом-строителем `Builder`;
- распорядитель уведомляет строителя о том, что нужно построить очередную часть продукта;
- строитель обрабатывает запросы распорядителя и добавляет новые части к продукту;
- клиент забирает продукт у строителя.

**Плюсы**:
- позволяет изменять внутреннее представление продукта. Объект `Builder` предоставляет распорядителю абстрактный интерфейс для конструирования продукта, за которым он может скрыть представление и внутреннюю структуру продукта, а также процесс его сборки. Поскольку продукт конструируется через абстрактный интерфейс, то для изменения внутреннего представления достаточно всего лишь определить новый вид строителя;
- изолирует код, реализующий конструирование и представление. Паттерн строитель улучшает модульность, инкапсулируя способ конструирования и представления сложного объекта. Клиентам ничего не надо знать о классах, определяющих внутреннюю структуру продукта, они отсутствуют в интерфейсе строителя;
- дает более тонкий контроль над процессом конструирования, чем другие порождающие паттерны.

[Пример паттерна Строитель](../assets/Patterns/Builder.js)  
[Пример паттерна Строитель 2](../assets/Patterns/Builder.ts)

#### <a id="Паттерн-Прототип-Prototype" href="#Паттерн-Прототип-Prototype">Паттерн Прототип (Prototype)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Объект создается посредством клонирования существующего объекта.*

Шаблон "Прототип" используется, когда типы создаваемых объектов определяются экземпляром-прототипом, клонированным для создания новых объектов.

То есть шаблон позволяет дублировать существующий объект и модифицировать копию в соответствии с потребностями. Без заморочек с созданием объекта с нуля и его настройкой.

**Назначение**

Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.

**Применимость**:
- когда инстанцируемые классы определяются во время выполнения, например с помощью динамической загрузки;
- для того чтобы избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов;
- когда экземпляры класса могут находиться в одном из не очень большого числа различных состояний. Может оказаться удобнее установить соответствующее число прототипов и клонировать их, а не инстанцировать каждый раз класс вручную в подходящем состоянии.

**Изображение**

![](../assets/Patterns/Prototype.png)

**Участники**:
- `Prototype` - прототип:
    - объявляет интерфейс для клонирования самого себя;
- `ConcretePrototype` - конкретный прототип:
    - реализует операцию клонирования себя;
- `Client` - клиент:
    - создает новый объект, обращаясь к прототипу с запросом клонировать себя.

**Отношения**:
- клиент обращается к прототипу, чтобы тот создал свою копию.

**Плюсы**:
- скрывает от клиента конкретные классы продуктов, уменьшая тем самым число известных клиенту имен;
- позволяет клиентам работать со специфичными для приложения классами без модификаций;
- позволяет добавление и удаление продуктов во время выполнения.  Прототип позволяет включать новый конкретный класс продуктов в систему, просто сообщив клиенту о новом экземпляре-прототипе. Это несколько более гибкое решение по сравнению с тем, что удастся сделать с помощью других порождающих паттернов, ибо клиент может устанавливать и удалять прототипы во время выполнения;
- спецификация новых объектов путем изменения значений.  Динамичные системы позволяют определять поведение за счет композиции объектов - например, путем задания значений переменных объекта, - а не с помощью определения новых классов. По сути дела, вы определяете новые виды объектов, инстанцируя уже существующие классы и регистрируя их экземпляры как прототипы клиентских объектов. Клиент может изменить поведение, делегируя свои обязанности прототипу;
- специфицирование новых объектов путем изменения структуры. Многие приложения строят объекты из крупных и мелких составляющих;
- уменьшение числа подклассов. Прототип позволяет клонировать прототип, а не запрашивать фабричный метод создать новый объект;
- динамическое конфигурирование приложения классами. Некоторые среды позволяют динамически загружать классы в приложение во время его выполнения.

**Минусы**:
- каждый подкласс класса `Prototype` должен реализовывать операцию `clone`, а это далеко не всегда просто. Проблемы возникают и в случае, если во внутреннем представлении объекта есть другие объекты или наличествуют круговые ссылки.

[Пример паттерна Прототип](../assets/Patterns/Prototype.js)  
[Пример паттерна Прототип 2](../assets/Patterns/Prototype.ts)

#### <a id="Паттерн-Одиночка-Singleton" href="#Паттерн-Одиночка-Singleton">Паттерн Одиночка (Singleton)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон позволяет удостовериться, что создаваемый объект - единственный в своем классе.*

Шаблон "Одиночка" позволяет ограничивать создание класса единственным объектом. Это удобно, когда для координации действий в рамках системы требуется, чтобы объект был единственным в своем классе.

**Назначение**

Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

**Применимость**:
- когда должен быть ровно один экземпляр некоторого класса, легко доступный всем клиентам;
- когда единственный экземпляр должен расширяться путем порождения подклассов, и клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода.

**Изображение**

![](../assets/Patterns/Singleton.png)

**Участники**:
- `Singleton` - одиночка:
    - определяет операцию `instance`, которая позволяет клиентам получать доступ к единственному экземпляру. `instance` - это операция класса, то есть метод класса или статическая функция-член;
    - может нести ответственность за создание собственного уникального экземпляра.

**Отношения**:
- клиенты получают доступ к экземпляру класса `Singleton` только через его операцию `instance`.

**Плюсы**:
- контролируемый доступ к единственному экземпляру. Поскольку класс `Singleton` инкапсулирует свой единственный экземпляр, он полностью контролирует то, как и когда клиенты получают доступ к нему;
- уменьшение числа имен. Паттерн одиночка - шаг вперед по сравнению с глобальными переменными. Он позволяет избежать засорения пространства имен глобальными переменными, в которых хранятся уникальные экземпляры;
- допускает уточнение операций и представления. От класса `Singleton` можно порождать подклассы, а приложение легко сконфигурировать экземпляром расширенного класса. Можно конкретизировать приложение экземпляром того класса, который необходим во время выполнения;
- допускает переменное число экземпляров. Паттерн позволяет вам легко изменить свое решение и разрешить появление более одного экземпляра класса `Singleton`. Вы можете применять один и тот же подход для управления числом экземпляров, используемых в приложении. Изменить нужно будет лишь операцию, дающую доступ к экземпляру класса `Singleton`;
- большая гибкость, чем у операций класса.

**Минусы**:
- глобальные объекты могут быть вредны для объектного программирования, в некоторых случаях приводя к созданию немасштабируемого проекта;
- делает код сильно связанным;
- усложняет написание модульных тестов.

[Пример паттерна Одиночка](../assets/Patterns/Singleton.js)  
[Пример паттерна Одиночка 2](../assets/Patterns/Singleton.ts)

### <a id="Структурные-шаблоны-проектирования" href="#Структурные-шаблоны-проектирования">Структурные шаблоны проектирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Эти шаблоны в основном посвящены компоновке объектов (object composition). То есть тому, как сущности могут друг друга использовать. Структурные шаблоны помогают ответить на вопрос "Как построить программный компонент?"*

Структурными называют шаблоны, которые облегчают проектирование, определяя простой способ реализации взаимоотношений между сущностями.

#### <a id="Паттерн-Адаптер-Adapter" href="#Паттерн-Адаптер-Adapter">Паттерн Адаптер (Adapter)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Адаптер" позволяет помещать несовместимый объект в обертку, чтобы он оказался совместимым с другим классом.*

Шаблон проектирования "Адаптер" позволяет использовать интерфейс существующего класса как другой интерфейс. Этот шаблон часто применяется для обеспечения работы одних классов с другими без изменения их исходного кода.

**Назначение**
Преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты. Адаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которая без него была бы невозможна.

**Применимость**:
- когда можно использовать существующий класс, но его интерфейс не соответствует потребностям;
- когда можно создать повторно используемый класс, который должен взаимодействовать с заранее неизвестными или не связанными с ним классами, имеющими несовместимые интерфейсы;
- (только для адаптера объектов!) когда нужно использовать несколько существующих подклассов, но непрактично адаптировать их интерфейсы путем порождения новых подклассов от каждого. В этом случае адаптер объектов может приспосабливать интерфейс их общего родительского класса.

**Изображение**

![](../assets/Patterns/Adapter.png)

**Участники**:
- `Adapter` - целевой:
    - определяет зависящий от предметной области интерфейс, которым пользуется `Client`;
- `Client` - клиент:
    - вступает во взаимоотношения с объектами, удовлетворяющими интерфейсу `Adapter`;
- `Adaptee` - адаптируемый:
    - определяет существующий интерфейс, который нуждается в адаптации;
- `ConcreteAdapter` - адаптер:
    - адаптирует интерфейс `Adaptee` к интерфейсу `Adapter`.

**Отношения**:
- клиенты вызывают операции экземпляра адаптера `Adapter`. В свою очередь адаптер вызывает операции адаптируемого объекта или класса `Adaptee`, который и выполняет запрос.

**Плюсы**:
- инкапсуляция реализации внешних классов (компонентов, библиотек), система становится независимой от интерфейса внешних классов;
- позволяет адаптеру `Adapter` заместить некоторые операции адаптируемого класса `Adaptee`, так как `Adapter` есть не что иное, как подкласс `Adaptee`.;
- позволяет одному адаптеру `Adapter` работать со многим адаптируемыми объектами `Adaptee`, то есть с самим `Adaptee` и его подклассами (если таковые имеются). Адаптер может добавить новую функциональность сразу всем адаптируемым объектам;
- переход на использование других внешних классов не требует переделки самой системы, достаточно реализовать один класс `Adapter`.

**Минусы**:
- затрудняет замещение операций класса `Adaptee`. Для этого потребуется породить от `Adaptee` подкласс и заставить `Adapter` ссылаться на этот подкласс, а не на сам `Adaptee`.

[Пример паттерна Адаптер](../assets/Patterns/Adapter.js)
[Пример паттерна Адаптер 2](../assets/Patterns/Adapter.ts)

#### <a id="Паттерн-Мост-Bridge" href="#Паттерн-Мост-Bridge">Паттерн Мост (Bridge)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Мост" - это предпочтение компоновки наследованию. Подробности реализации передаются из одной иерархии другому объекту с отдельной иерархией.*

Шаблон "Мост" означает отделение абстракции от реализации, чтобы их обе можно было изменять независимо друг от друга.

**Назначение**

Отделить абстракцию от ее реализации так, чтобы то и другое можно было изменять независимо.

**Применимость**:
- когда можно избежать постоянной привязки абстракции к реализации;
- когда и абстракции, и реализации должны расширяться новыми подклассами. В таком случае паттерн мост позволяет комбинировать разные абстракции и реализации и изменять их независимо;
- когда изменения в реализации абстракции не должны сказываться на клиентах, то есть клиентский код не должен перекомпилироваться;
- когда число классов начинает быстро расти. Это признак того, что иерархию следует разделить на две части;
- когда можно разделить одну реализацию между несколькими объектами (быть может, применяя подсчет ссылок), и этот факт необходимо скрыть от клиента.

**Изображение**

![](../assets/Patterns/Bridge.png)

**Участники**:
- `Abstraction` - абстракция:
    - определяет интерфейс абстракции;
    - хранит ссылку на объект типа `Implementor`;
- `Implementor` - реализатор:
    - определяет интерфейс для классов реализации. Он не обязан точно соответствовать интерфейсу класса `Abstraction`. На самом деле оба интерфейса могут быть совершенно различны. Обычно интерфейс класса `Implementor` предоставляет только примитивные операции, а класс `Abstraction` определяет операции более высокого уровня, базирующиеся на этих примитивах;
`Concretelmplementor` - конкретный реализатор:
    - содержит конкретную реализацию интерфейса класса `Implementor`.

**Отношения**:
- объект `Abstraction` перенаправляет своему объекту `Implementor` запросы клиента.

**Плюсы**:
- отделение реализации от интерфейса. Реализация больше не имеет постоянной привязки к интерфейсу. Реализацию абстракции можно конфигурировать во время выполнения. Объект может даже динамически изменять свою реализацию;
- повышение степени расширяемости. Можно расширять независимо иерархии классов `Abstraction` и `Implementor`;
- сокрытие деталей реализации от клиентов. Клиентов можно изолировать от таких деталей реализации, как разделение объектов класса `Implementor`.

[Пример паттерна Мост](../assets/Patterns/Bridge.js)

#### <a id="Паттерн-Компоновщик-Composite" href="#Паттерн-Компоновщик-Composite">Паттерн Компоновщик (Composite)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Компоновщик" позволяет клиентам обрабатывать отдельные объекты в едином порядке.*

Шаблон "Компоновщик" описывает общий порядок обработки группы объектов, словно это одиночный экземпляр объекта. Суть шаблона - компонование объектов в древовидную структуру для представления иерархии от частного к целому. Шаблон позволяет клиентам одинаково обращаться к отдельным объектам и к группам объектов.

**Назначение**

Компонует объекты в древовидные структуры для представления иерархий часть-целое. Позволяет клиентам единообразно трактовать индивидуальные и составные объекты.

**Применимость**:
- когда можно представить иерархию объектов вида часть-целое;
- когда можно, чтобы клиенты единообразно трактовали составные и индивидуальные объекты.

**Изображение**

![](../assets/Patterns/Composite.png)

**Участники**:
- `Component` - компонент:
    - объявляет интерфейс для компонуемых объектов;
    - предоставляет подходящую реализацию операций по умолчанию, общую для всех классов;
    - объявляет интерфейс для доступа к потомкам и управления ими;
    - определяет интерфейс для доступа к родителю компонента в рекурсивной структуре и при необходимости реализует его. Описанная возможность необязательна;
- `Leaf` - лист:
    - представляет листовые узлы композиции и не имеет потомков;
    - определяет поведение примитивных объектов в композиции;
- `Composite` - составной объект:
    - определяет поведение компонентов, у которых есть потомки;
    - хранит компоненты-потомки;
    - реализует относящиеся к управлению потомками операции в интерфейсе класса `Component`.

**Отношения**:
- клиенты используют интерфейс класса `Component` для взаимодействия с объектами в составной структуре. Если получателем запроса является листовый объект `Leaf`, то он и обрабатывает запрос. Когда же получателем является составной объект `Composite`, то обычно он перенаправляет запрос своим потомкам, возможно, выполняя некоторые дополнительные операции до или после перенаправления.

**Плюсы**:
- определяет иерархии классов, состоящие из примитивных и составных объектов. Из примитивных объектов можно составлять более сложные, которые, в свою очередь, участвуют в более сложных композициях и так далее;
- упрощает архитектуру клиента. Клиенты могут единообразно работать с индивидуальными и объектами и с составными структурами;
- облегчает добавление новых видов компонентов. Новые подклассы классов `Composite` или `Leaf` будут автоматически работать с уже существующими структурами и клиентским кодом.

**Минусы**:
- способствует созданию общего дизайна. Однако такая простота добавления новых компонентов имеет и свои отрицательные стороны: становится трудно наложить ограничения на то, какие объекты могут входить в состав композиции.

[Пример паттерна Компоновщик](../assets/Patterns/Composite.js)
[Пример паттерна Компоновщик 2](../assets/Patterns/Composite.ts)

#### <a id="Паттерн-Декоратор-Decorator" href="#Паттерн-Декоратор-Decorator">Паттерн Декоратор (Decorator)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Декоратор" позволяет во время выполнения динамически изменять поведение объекта, обертывая его в объект класса "декоратора".*

Шаблон "Декоратор" позволяет подключать к объекту дополнительное поведение (статически или динамически), не влияя на поведение других объектов того же класса. Шаблон часто используется для соблюдения принципа единственной обязанности (**Single Responsibility Principle**), поскольку позволяет разделить функциональность между классами для решения конкретных задач.

**Назначение**

Динамически добавляет объекту новые обязанности. Является гибкой альтернативой порождению подклассов с целью расширения функциональности.

**Применимость**:
- для динамического, прозрачного для клиентов добавления обязанностей объектам;
- для реализации обязанностей, которые могут быть сняты с объекта;
- когда расширение путем порождения подклассов по каким-то причинам неудобно или невозможно. Иногда приходится реализовывать много независимых расширений, так что порождение подклассов для поддержки всех возможных комбинаций приведет к комбинаторному росту их числа. В других случаях определение класса может быть скрыто или почему-либо еще недоступно, так что породить от него подкласс нельзя.

**Изображение**

![](../assets/Patterns/Decorator.png)

**Участники**:
- `Component` - компонент:
    - определяет интерфейс для объектов, на которые могут быть динамически возложены дополнительные обязанности;
- `ConcreteComponent` - конкретный компонент:
    - определяет объект, на который возлагаются дополнительные обязанности;
- `Decorator` - декоратор:
    - хранит ссылку на объект `Component` и определяет интерфейс, соответствующий интерфейсу `Component`;
- `ConcreteDecorator` - конкретный декоратор:
    - возлагает дополнительные обязанности на компонент.

**Отношения**:
- `Decorator` переадресует запросы объекту `Component`. Может выполнять и дополнительные операции до и после переадресации.

**Плюсы**:
- большая гибкость, нежели у статического наследования. Паттерн декоратор позволяет более гибко добавлять объекту новые обязанности, чем было бы возможно в случае статического (множественного) наследования. Декоратор может добавлять и удалять обязанности во время выполнения программы;
- позволяет избежать перегруженных функциями классов на верхних уровнях иерархии. Декоратор разрешает добавлять новые обязанности по мере необходимости.

**Минусы**:
- декоратор и его компонент не идентичны. Декоратор действует как прозрачное обрамление. Но декорированный компонент все же не идентичен исходному;
- множество мелких объектов. При использовании в проекте паттерна декоратор нередко получается система, составленная из большого числа мелких объектов, которые похожи друг на друга и различаются только способом взаимосвязи, а не классом и не значениями своих внутренних переменных.

[Пример паттерна Декоратор](../assets/Patterns/Decorator.js)  
[Пример паттерна Декоратор 2](../assets/Patterns/Decorator.ts)

#### <a id="Паттерн-Фасад-Facade" href="#Паттерн-Фасад-Facade">Паттерн Фасад (Facade)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Фасад" предоставляет упрощенный интерфейс для сложной подсистемы.*

"Фасад" - это объект, предоставляющий упрощенный интерфейс для более крупного тела кода, например библиотеки классов.

**Назначение**

Предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы. Фасад определяет интерфейс более высокого уровня, который упрощает использование подсистемы.

**Применимость**:
- когда можно предоставить простой интерфейс к сложной подсистеме;
- когда между клиентами и классами реализации абстракции существует много зависимостей;
- когда вы можете разложить подсистему на отдельные слои.

**Изображение**

![](../assets/Patterns/Facade.png)

Участники
- `Facade` - фасад:
    - "знает", каким классам подсистемы адресовать запрос;
    - делегирует запросы клиентов подходящим объектам внутри подсистемы;
- классы подсистемы:
    - реализуют функциональность подсистемы;
    - выполняют работу, порученную объектом `Facade`;
    - ничего не "знают" о существовании фасада, то есть не хранят ссылок на него.

**Отношения**:
- клиенты общаются с подсистемой, посылая запросы фасаду. Он переадресует их подходящим объектам внутри подсистемы. Хотя основную работу выполняют именно объекты подсистемы, фасаду, возможно, придется преобразовать свой интерфейс в интерфейсы подсистемы;
- клиенты, пользующиеся фасадом, не имеют прямого доступа к объектам подсистемы.

**Плюсы**:
- изолирует клиентов от компонентов подсистемы, уменьшая тем самым число объектов, с которыми клиентам приходится иметь дело, и упрощая работу с подсистемой;
- позволяет ослабить связанность между подсистемой и ее клиентами. Слабая связанность позволяет видоизменять компоненты, не затрагивая при этом клиентов. Фасады помогают разложить систему на слои и структурировать зависимости между объектами, а также избежать сложных и циклических зависимостей.;
- фасад не препятствует приложениям напрямую обращаться к классам подсистемы, если это необходимо.

[Пример паттерна Фасад](../assets/Patterns/Facade.js)

#### <a id="Паттерн-Приспособленец-Flyweight" href="#Паттерн-Приспособленец-Flyweight">Паттерн Приспособленец (Flyweight)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон применяется для минимизирования использования памяти или вычислительной стоимости за счет общего использования как можно большего количества одинаковых объектов.*

"Приспособленец" - это объект, минимизирующий использование памяти за счет общего с другими, такими же объектами использования как можно большего объема данных. Это способ применения многочисленных объектов, когда простое повторяющееся представление приведет к неприемлемому потреблению памяти.

**Назначение**

Использует разделение для эффективной поддержки множества мелких объектов.

**Применимость**:
- когда в приложении используется большое число объектов;
- когда из-за этого накладные расходы на хранение высоки;
- когда большую часть состояния объектов можно вынести вовне;
- когда многие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено;
- когда приложение не зависит от идентичности объекта. Поскольку объекты-приспособленцы могут разделяться, то проверка на идентичность возвратит "истину" для концептуально различных объектов.

**Изображение**

![](../assets/Patterns/Flyweight.png)

**Участники**:
- `Flyweight` - приспособленец:
    - объявляет интерфейс, с помощью которого приспособленцы могут получать внешнее состояние или как-то воздействовать на него;
- `ConcreteFlyweight` - конкретный приспособленец:
    - реализует интерфейс класса `Flyweight` и добавляет при необходимости внутреннее состояние. Объект класса `ConcreteFlyweight` должен быть разделяемым. Любое сохраняемое им состояние должно быть внутренним, то есть не зависящим от контекста;
- `UnsharedConcreteFlyweight` - неразделяемый конкретный приспособленец:
    - не все подклассы `Flyweight` обязательно должны быть разделяемыми. Интерфейс `Flyweight` допускает разделение, но не навязывает его. Часто у объектов `UnsharedConcreteFlyweight` на некотором уровне структуры приспособленца есть потомки в виде объектов класса `ConcreteFlyweight`;
- `FlyweightFactory` - фабрика приспособленцев:
    - создает объекты-приспособленцы и управляет ими;
    - обеспечивает должное разделение приспособленцев. Когда клиент запрашивает приспособленца, объект `FlyweightFactory` предоставляет существующий экземпляр или создает новый, если готового еще нет;
- `Client` - клиент:
    - хранит ссылки на одного или нескольких приспособленцев;
    - вычисляет или хранит внешнее состояние приспособленцев.

**Отношения**:
- состояние, необходимое приспособленцу для нормальной работы, можно охарактеризовать как внутреннее или внешнее. Первое хранится в самом объекте `ConcreteFlyweight`. Внешнее состояние хранится или вычисляется клиентами. Клиент передает его приспособленцу при вызове операций;
- клиенты не должны создавать экземпляры класса `ConcreteFlyweight` напрямую, а могут получать их только от объекта `FlyweightFactory`. Это позволит гарантировать корректное разделение.

**Плюсы**:
- уменьшение общего числа экземпляров;
- сокращение объема памяти, необходимого для хранения внутреннего состояния;
- вычисление, а не хранение внешнего состояния (если это действительно так).

**Минусы**:
- затраты на передачу, поиск или вычисление внутреннего состояния, особенно если раньше оно хранилось как внутреннее.

[Пример паттерна Приспособленец](../assets/Patterns/Flyweight.js)

#### <a id="Паттерн-Заместитель-Proxy" href="#Паттерн-Заместитель-Proxy">Паттерн Заместитель (Proxy)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*С помощью шаблона "Заместитель" класс представляет функциональность другого класса.*

В наиболее общей форме "Заместитель" - это класс, функционирующий как интерфейс к чему-либо. Это оболочка или объект-агент, вызываемый клиентом для получения доступа к другому, "настоящему" объекту. "Заместитель" может просто переадресовывать запросы настоящему объекту, а может предоставлять дополнительную логику: кэширование данных при интенсивном выполнении операций или потреблении ресурсов настоящим объектом; проверка предварительных условий (preconditions) до вызова выполнения операций настоящим объектом.

**Назначение**

![](../assets/Patterns/Proxy.png)

Является суррогатом другого объекта и контролирует доступ к нему.

**Применимость**:
- удаленный заместитель предоставляет локального представителя вместо объекта, находящегося в другом адресном пространстве;
- виртуальный заместитель создает "тяжелые" объекты по требованию;
- защищающий заместитель контролирует доступ к исходному объекту;
- "умная" ссылка - это замена обычного указателя. Она позволяет выполнить дополнительные действия при доступе к объекту;
- проверка данных: прокси проверяет допустимость входных данных перед отправкой субъекту;
- безопасность: прокси проверяет наличие у клиента достаточных прав для выполнения операции и передает запрос субъекту только при положительном результате такой проверки;
- кэширование: прокси хранит внутренний кэш, вызывая субъекта, только если затребованные данные еще отсутствуют в кэше;
- отложенная инициализация: если создание субъекта сопряжено с большими накладными расходами, прокси может отложить эту операцию до момента, когда это станет действительно необходимо;
- журналирование: прокси перехватывает вызовы методов и их параметры, регистрируя их в журнале;
- обращение к удаленным объектам: прокси может обеспечить работу с удаленным объектом как с локальным.

**Изображение**

**Участники**:
- `Proxy` - заместитель:
    - хранит ссылку, которая позволяет заместителю обратиться к реальному субъекту. Объект класса `Proxy` может обращаться к объекту класса `Subject`, если интерфейсы классов `RealSubject` и `Subject` одинаковы;
    - предоставляет интерфейс, идентичный интерфейсу `Subject`, так что заместитель всегда может быть подставлен вместо реального субъекта;
    - контролирует доступ к реальному субъекту и может отвечать за его создание и удаление;
    - прочие обязанности зависят от вида заместителя:
    - удаленный заместитель отвечает за кодирование запроса и его аргументов и отправление закодированного запроса реальному субъекту в другом адресном пространстве;
    - виртуальный заместитель может кэшировать дополнительную информацию о реальном субъекте, чтобы отложить его создание;
    - защищающий заместитель проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права;
- `Subject` - субъект:
    - определяет общий для `RealSubject` и `Proxy` интерфейс, так что класс `Proxy` можно использовать везде, где ожидается `RealSubject`;
- `RealSubject` - реальный субъект:
    - определяет реальный объект, представленный заместителем.

**Отношения**:
- `Proxy` при необходимости переадресует запросы объекту `RealSubject`. Детали зависят от вида заместителя.

**Плюсы**:
- удаленный заместитель может скрыть тот факт, что объект находится в другом адресном пространстве;
- виртуальный заместитель может выполнять оптимизацию, например создание объекта по требованию;
- защищающий заместитель и "умная" ссылка позволяют решать дополнительные задачи при доступе к объекту;
- копированием при записи (copy-on-write).

**Минусы**:
- резкое увеличение времени отклика.

[Пример паттерна Заместитель](../assets/Patterns/Proxy.js)

### <a id="Поведенческие-шаблоны-проектирования" href="#Поведенческие-шаблоны-проектирования">Поведенческие шаблоны проектирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Они связаны с присвоением обязанностей (responsibilities) объектам. От структурных шаблонов они отличаются тем, что не просто описывают структуру, но и очерчивают шаблоны передачи данных, обеспечения взаимодействия. То есть поведенческие шаблоны позволяют ответить на вопрос "Как реализовать поведение в программном компоненте?"*

Поведенческие шаблоны проектирования определяют алгоритмы и способы реализации взаимодействия различных объектов и классов. Они обеспечивают гибкость взаимодействия между объектами.

#### <a id="Паттерн-Цепочка-обязанностей-Chain-of-responsibility" href="#Паттерн-Цепочка-обязанностей-Chain-of-responsibility">Паттерн Цепочка обязанностей (Chain of responsibility)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Цепочка обязанностей" позволяет создавать цепочки объектов. Запрос входит с одного конца цепочки и движется от объекта к объекту, пока не будет найден подходящий обработчик.*

Шаблон "Цепочка обязанностей" содержит исходный управляющий объект и ряд обрабатывающих объектов. Каждый обрабатывающий объект содержит логику, определяющую типы командных объектов, которые он может обрабатывать, а остальные передаются по цепочке следующему обрабатывающему объекту.

**Назначение**

Позволяет избежать привязки отправителя запроса к его получателю, давая шанс обработать запрос нескольким объектам. Связывает объекты-получатели в цепочку и передает запрос вдоль этой цепочки, пока его не обработают.

**Применимость**:
- когда есть более одного объекта, способного обработать запрос, причем настоящий обработчик заранее неизвестен и должен быть найден автоматически;
- когда можно отправить запрос одному из нескольких объектов, не указывая явно, какому именно;
- когда набор объектов, способных обработать запрос, должен задаваться динамически.

**Изображение**

![](../assets/Patterns/ChainOfResponsibility.png)

**Участники**:
- `Handler` - обработчик:
    - определяет интерфейс для обработки запросов;
    - (необязательно) реализует связь с преемником;
- `ConcreteHandler` - конкретный обработчик:
    - обрабатывает запрос, за который отвечает;
    - имеет доступ к своему преемнику;
    - если `ConcreteHandler` способен обработать запрос, то так и делает, если не может, то направляет его - его своему преемнику;
- `Client` - клиент:
    - отправляет запрос некоторому объекту `ConcreteHandler` в цепочке.

**Отношения**:
- когда клиент инициирует запрос, он продвигается по цепочке, пока некоторый объект `ConcreteHandler` не возьмет на себя ответственность за его обработку.

**Плюсы**:
- ослабление связанности. Этот паттерн освобождает объект от необходимости "знать", кто конкретно обработает его запрос;
- дополнительная гибкость при распределении обязанностей между объектами.

**Минусы**:
- получение не гарантировано. Поскольку у запроса нет явного получателя, то нет и гарантий, что он вообще будет обработан: он может достичь конца цепочки и пропасть.

[Пример паттерна Цепочка обязанностей](../assets/Patterns/ChainOfResponsibility.js)

[Пример паттерна Цепочка обязанностей (функции)](../assets/Patterns/ChainOfResponsibilityFunction.js)

#### <a id="Паттерн-Команда-Command" href="#Паттерн-Команда-Command">Паттерн Команда (Command)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Команда" позволяет инкапсулировать действия в объекты. Ключевая идея - предоставить средства отделения клиента от получателя.*

В шаблоне "Команда" объект используется для инкапсуляции всей информации, необходимой для выполнения действия либо для его инициирования позднее. Информация включает в себя имя метода; объект, владеющий методом; значения параметров метода.

**Назначение**

Инкапсулирует запрос как объект, позволяя тем самым задавать параметры клиентов для обработки соответствующих запросов, ставить запросы в очередь или протоколировать их, а также поддерживать отмену операций.

**Применимость**:
- когда можно параметризовать объекты выполняемым действием. В процедурном языке такую параметризацию можно выразить с помощью функции обратного вызова, то есть такой функции, которая регистрируется, чтобы быть вызванной позднее. Команды представляют собой объектно-ориентированную альтернативу функциям обратного вызова;
- когда можно определять, ставить в очередь и выполнять запросы в разное время. Время жизни объекта `Command` необязательно должно зависеть от времени жизни исходного запроса;
- когда можно поддержать отмену операций. Операция `execute` объекта `Command` может сохранить состояние, необходимое для отката действий, выполненных командой. В этом случае в интерфейсе класса `Command` должна быть дополнительная операция `unexecute`, которая отменяет действия, выполненные предшествующим обращением к `execute`. Выполненные команды хранятся в списке истории;
- когда можно поддержать протоколирование изменений, чтобы их можно было выполнить повторно после аварийной остановки системы;
- когда можно структурировать систему на основе высокоуровневых операций, построенных из примитивных. Такая структура типична для информационных систем, поддерживающих транзакции. Транзакция инкапсулирует набор изменений данных. У всех команд есть общий интерфейс, что дает возможность работать одинаково с любыми транзакциями, так можно легко добавлять в систему новые виды транзакций.

**Изображение**

![](../assets/Patterns/Command.png)

**Участники**:
- `Command` - команда:
    - объявляет интерфейс для выполнения операции;
- `ConcreteCommand` - конкретная команда:
    - определяет связь между объектом-получателем `Receiver` и действием;
    - реализует операцию `execute` путем вызова соответствующих операций объекта `Receiver`;
- `Client` - клиент:
    - создает объект класса `ConcreteCommand` и устанавливает его получателя;
- `Invoker` - инициатор:
    - обращается к команде для выполнения запроса;
- `Receiver` - получатель:
    - располагает информацией о способах выполнения операций, необходимых для удовлетворения запроса. В роли получателя может выступать любой класс.

**Отношения**:
- клиент создает объект `ConcreteCommand` и устанавливает для него получателя;
- инициатор `Invoker` сохраняет объект `ConcreteCommand`;
- инициатор отправляет запрос, вызывая операцию команды `execute`. Если поддерживается отмена выполненных действий, то `ConcreteCommand` перед вызовом `execute` сохраняет информацию о состоянии, достаточную для выполнения отката;
- объект `ConcreteCommand` вызывает операции получателя для выполнения запроса.

**Плюсы**:
- команда разрывает связь между объектом, инициирующим операцию, и объектом, имеющим информацию о том, как ее выполнить;
- команды - это самые настоящие объекты. Допускается манипулировать ими и расширять их точно так же, как в случае с любыми другими объектами;
- из простых команд можно собирать составные. В общем случае составные команды описываются паттерном компоновщик;
- добавлять новые команды легко, поскольку никакие существующие классы изменять не нужно.

[Пример паттерна Команда](../assets/Patterns/Command.js)

#### <a id="Паттерн-Интерпретатор-Interpreter" href="#Паттерн-Интерпретатор-Interpreter">Паттерн Интерпретатор (Interpreter)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Интерпретатор - паттерн поведения классов.*

**Назначение**

Для заданного языка определяет представление его грамматики, а также интерпретатор предложений этого языка.

**Применимость**:
- когда есть язык для интерпретации, предложения которого можно представить в виде абстрактных синтаксических деревьев;
- когда грамматика проста. Для сложных грамматик иерархия классов становится слишком громоздкой и неуправляемой;
- когда эффективность не является главным критерием. Наиболее эффективные интерпретаторы обычно не работают непосредственно с деревьями, а сначала транслируют их в другую форму.

**Изображение**

![](../assets/Patterns/Interpreter.png)

**Участники**:
- `AbstractExpression` - абстрактное выражение:
    - объявляет абстрактную операцию `Interpret`, общую для всех узлов в абстрактном синтаксическом дереве;
- `TerminalExpression` - терминальное выражение:
    - реализует операцию `Interpret` для терминальных символов грамматики;
    - необходим отдельный экземпляр для каждого терминального символа в предложении;
- `NonterminaIExpression` - нетерминальное выражение:
    - по одному такому классу требуется для каждого грамматического правила `R :: = R1 R2 ... Rn`;
    - хранит переменные экземпляра типа `AbstractExpression` для каждого символа от `R1` до `Rn`;
    - реализует операцию `Interpret` для нетерминальных символов грамматики. Эта операция рекурсивно вызывает себя же для переменных, представляющих `R1 R2 ... Rn`;
- `Context` - контекст:
    - содержит информацию, глобальную по отношению к интерпретатору;
- `Client` - клиент:
    - строит (или получает в готовом виде) абстрактное синтаксическое дерево, представляющее отдельное предложение на языке с данной грамматикой. Дерево составлено из экземпляров классов `NonterminalExpression` и `TerminalExpression`;
    - вызывает операцию `Interpret`.

**Отношения**:
- клиент строит (или получает в готовом виде) предложение в виде абстрактного синтаксического дерева, в узлах которого находятся объекты классов `NonterminalExpression` и `TerminalExpression`. Затем клиент инициализирует контекст и вызывает операцию `Interpret`;
- в каждом узле вида `NonterminalExpression` через операции `Interpret` определяется операция `Interpret` для каждого подвыражения. Для класса `TerminalExpression` операция `Interpret` определяет базу рекурсии;
- операции `Interpret` в каждом узле используют контекст для сохранения и доступа к состоянию интерпретатора.

**Плюсы**:
- грамматику легко изменять и расширять. Поскольку для представления грамматических правил в паттерне используются классы, то для изменения или расширения грамматики можно применять наследование;
- простая реализация грамматики. Реализации классов, описывающих узлы абстрактного синтаксического дерева, похожи;
- добавление новых способов интерпретации выражений, позволяет легко изменить способ вычисления выражений.

**Минусы**:
- сложные грамматики трудно сопровождать.

[Пример паттерна Интерпретатор]()

#### <a id="Паттерн-Итератор-Iterator" href="#Паттерн-Итератор-Iterator">Паттерн Итератор (Iterator)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон -- это способ доступа к элементам объекта без раскрытия базового представления.*

В этом шаблоне итератор используется для перемещения по контейнеру и обеспечения доступа к элементам контейнера. Шаблон подразумевает отделение алгоритмов от контейнера. В каких-то случаях алгоритмы, специфичные для этого контейнера, не могут быть отделены.

**Назначение**

Предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления.

**Применимость**:
- для доступа к содержимому агрегированных объектов без раскрытия их внутреннего представления;
- для поддержки нескольких активных обходов одного и того же агрегированного объекта;
- для предоставления единообразного интерфейса с целью обхода различных агрегированных структур (то есть для поддержки полиморфной итерации).

**Изображение**

![](../assets/Patterns/Iterator.png)

**Участники**:
- `Iterator` - итератор:
    - определяет интерфейс для доступа и обхода элементов;
- `Concretelterator` - конкретный итератор:
    - реализует интерфейс класса `Iterator`;
    - следит за текущей позицией при обходе агрегата;
- `Aggregate` - агрегат:
    - определяет интерфейс для создания объекта-итератора;
- `ConcreteAggregate` - конкретный агрегат:
    - реализует интерфейс создания итератора и возвращает экземпляр подходящего класса `Concretelterator`.

**Отношения**:
- `Concretelterator` отслеживает текущий объект в агрегате и может вычислить идущий за ним.

**Плюсы**:
- поддерживает различные виды обхода агрегата. Сложные агрегаты можно обходить по-разному;
- итераторы упрощают интерфейс класса `Aggregate`;
- одновременно для данного агрегата может быть активно несколько обходов.

[Пример паттерна Итератор](../assets/Patterns/Iterator.js)

[Пример паттерна Итератор с использованием стандартных итераторов](../assets/Patterns/IteratorStandart.js)

#### <a id="Паттерн-Посредник-Mediator" href="#Паттерн-Посредник-Mediator">Паттерн Посредник (Mediator)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Посредник" подразумевает добавление стороннего объекта ("посредника") для управления взаимодействием между двумя объектами ("коллегами"). Шаблон помогает уменьшить связанность (coupling) классов, общающихся друг с другом, ведь теперь они не должны знать о реализациях своих собеседников.*

Шаблон определяет объект, который инкапсулирует способ взаимодействия набора объектов.

**Назначение**

Определяет объект, инкапсулирующий способ взаимодействия множества объектов. Посредник обеспечивает слабую связанность системы, избавляя объекты от необходимости явно ссылаться друг на друга и позволяя тем самым независимо изменять взаимодействия между ними.

**Применимость**:
- когда имеются объекты, связи между которыми сложны и четко определены. Получающиеся при этом взаимозависимости не структурированы и трудны для понимания;
- когда нельзя повторно использовать объект, поскольку он обменивается информацией со многими другими объектами;
- когда поведение, распределенное между несколькими классами, должно поддаваться настройке без порождения множества подклассов.

**Изображение**

![](../assets/Patterns/Mediator.png)

**Участники**:
- `Mediator` - посредник;
    - определяет интерфейс для обмена информацией с объектами `Colleague`;
- `ConcreteMediator` - конкретный посредник:
    - реализует кооперативное поведение, координируя действия объектов `Colleague`;
    - владеет информацией о коллегах и подсчитывает их;
- классы `Colleague` - коллеги:
    - каждый класс `Colleague` "знает" о своем объекте `Mediator`;
    - все коллеги обмениваются информацией только с посредником, так как при его отсутствии им пришлось бы общаться между собой напрямую.

**Отношения**:
- коллеги посылают запросы посреднику и получают запросы от него. Посредник реализует кооперативное поведение путем переадресации каждого запроса подходящему коллеге (или нескольким коллегам).

**Плюсы**:
- снижает число порождаемых подклассов. Посредник локализует поведение, которое в противном случае пришлось бы распределять между несколькими объектами;
- устраняет связанность между коллегами. Посредник обеспечивает слабую связанность коллег;
- упрощает протоколы взаимодействия объектов. Посредник заменяет дисциплину взаимодействия "все со всеми" дисциплиной "один со всеми", то есть один посредник взаимодействует со всеми коллегами;
- абстрагирует способ кооперирования объектов. Выделение механизма посредничества в отдельную концепцию и инкапсуляция ее в одном объекте позволяет сосредоточиться именно на взаимодействии объектов, а не на их индивидуальном поведении.

**Минусы**:
- централизует управление. Паттерн посредник переносит сложность взаимодействия в класс-посредник.  В результате сам посредник становится монолитом, который трудно сопровождать.

[Пример паттерна Посредник](../assets/Patterns/Mediator.js)

#### <a id="Паттерн-Хранитель-Memento" href="#Паттерн-Хранитель-Memento">Паттерн Хранитель (Memento)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Хранитель" фиксирует и хранит текущее состояние объекта, чтобы оно легко восстанавливалось.*

Шаблон "Хранитель" позволяет восстанавливать объект в его предыдущем состоянии (отмена через откат - undo via rollback).

Обычно шаблон применяется, когда нужно реализовать функциональность отмены операции.

**Назначение**
Не нарушая инкапсуляции, фиксирует и выносит за пределы объекта его внутреннее состояние так, чтобы позднее можно было восстановить в нем объект.

**Применимость**:
- когда необходимо сохранить мгновенный снимок состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии;
- когда прямое получение этого состояния раскрывает детали реализации и нарушает инкапсуляцию объекта.

**Изображение**

![](../assets/Patterns/Memento.png)

Участники:
- `Memento` - хранитель:
    - сохраняет внутреннее состояние объекта `Originator`. Объем сохраняемой информации может быть различным и определяется потребностями хозяина;
    - запрещает доступ всем другим объектам, кроме хозяина. По существу, у хранителей есть два интерфейса. "Посыльный" `Caretaker` "видит" лишь "узкий" интерфейс хранителя - он может только передавать хранителя другим объектам. Напротив, хозяину доступен "широкий" интерфейс, который обеспечивает доступ ко всем данным, необходимым для восстановления в прежнем состоянии. Идеальный вариант - когда только хозяину, создавшему хранитель, открыт доступ к внутреннему состоянию последнего;
- `Originator` - хозяин:
    - создает хранитель, содержащего снимок текущего внутреннего состояния;
    - использует хранитель для восстановления внутреннего состояния;
- `Caretaker` - посыльный:
    - отвечает за сохранение хранителя;
    - не производит никаких операций над хранителем и не исследует его внутреннее содержимое.

**Отношения**:
- посыльный запрашивает хранитель у хозяина, некоторое время держит его у себя, а затем возвращает хозяину. Иногда этого не происходит, так как последнему не нужно восстанавливать прежнее состояние;
- хранители пассивны. Только хозяин, создавший хранитель, имеет доступ к информации о состоянии.

**Плюсы**:
- сохранение границ инкапсуляции. Хранитель позволяет избежать раскрытия информации, которой должен распоряжаться только хозяин, но которую тем не менее необходимо хранить вне последнего;
- упрощение структуры хозяина. При перекладывании заботы о запрошенном состоянии на клиентов упрощается структура хозяина, а клиентам дается возможность не информировать хозяина о том, что они закончили работу.

**Минусы**:
- значительные издержки при использовании хранителей. С хранителями могут быть связаны заметные издержки, если хозяин должен копировать большой объем информации для занесения в память хранителя или если клиенты создают и возвращают хранителей достаточно часто;
- определение "узкого" и "широкого" интерфейсов;
- скрытая плата за содержание хранителя. Посыльный отвечает за удаление хранителя, однако не располагает информацией о том, какой объем информации о состоянии скрыт в нем.

[Пример паттерна Хранитель]()

#### <a id="Паттерн-Наблюдатель-Observer" href="#Паттерн-Наблюдатель-Observer">Паттерн Наблюдатель (Observer)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон определяет зависимость между объектами, чтобы при изменении состояния одного из них его "подчиненные" узнавали об этом.*

В шаблоне "Наблюдатель" есть объект ("**субъект**"), ведущий список своих "**подчиненных**" ("**наблюдателей**") и автоматически уведомляющий их о любом изменении своего состояния, обычно с помощью вызова одного из их методов.

**Назначение**

Определяет зависимость типа "**один ко многим**" между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом и автоматически обновляются.

**Применимость**:
- когда у абстракции есть два аспекта, один из которых зависит от другого. Инкапсуляции этих аспектов в разные объекты позволяют изменять и повторно использовать их независимо;
- когда при модификации одного объекта требуется изменить другие и вы не знаете, сколько именно объектов нужно изменить;
- когда один объект должен оповещать других, не делая предположений об уведомляемых объектах. Другими словами, вы не хотите, чтобы объекты были тесно связаны между собой.

**Изображение**

![](../assets/Patterns/Observer.png)

**Участники**:
- `Subject` - субъект:
    - располагает информацией о своих наблюдателях. За субъектом может "следить" любое число наблюдателей;
    - предоставляет интерфейс для присоединения и отделения наблюдателей;
- `Observer` - наблюдатель:
    - определяет интерфейс обновления для объектов, которые должны быть уведомлены об изменении субъекта;
- `ConcreteSubject` - конкретный субъект:
    - сохраняет состояние, представляющее интерес для конкретного наблюдателя `ConcreteObserver`;
    - посылает информацию своим наблюдателям, когда происходит изменение;
- `ConcreteObserver` - конкретный наблюдатель:
    - хранит ссылку на объект класса `ConcreteSubject`;
    - сохраняет данные, которые должны быть согласованы с данными субъекта;
    - реализует интерфейс обновления, определенный в классе `Observer`, чтобы поддерживать согласованность с субъектом.

**Отношения**:
- объект `ConcreteSubject` уведомляет своих наблюдателей о любом изменении, которое могло бы привести к рассогласованности состояний наблюдателя и субъекта;
- после получения от конкретного субъекта уведомления об изменении объект `ConcreteObserver` может запросить у субъекта дополнительную информацию, которую использует для того, чтобы оказаться в состоянии, согласованном с состоянием субъекта.

**Плюсы**:
- абстрактная связанность субъекта и наблюдателя. Субъект имеет информацию лишь о том, что у него есть ряд наблюдателей, каждый из которых подчиняется простому интерфейсу абстрактного класса `Observer`. Субъекту неизвестны конкретные классы наблюдателей;
- поддержка широковещательных коммуникаций. В отличие от обычного запроса для уведомления, посылаемого субъектом, не нужно задавать определенного получателя. Уведомление автоматически поступает всем подписавшимся на него объектам.

**Минусы**:
- неожиданные обновления. Поскольку наблюдатели не располагают информацией друг о друге, им неизвестно и о том, во что обходится изменение субъекта.

[Пример паттерна Наблюдатель](../assets/Patterns/Observer.js)

#### <a id="Паттерн-Посетитель-Visitor" href="#Паттерн-Посетитель-Visitor">Паттерн Посетитель (Visitor)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Посетитель" позволяет добавлять будущие операции для объектов без их модифицирования.*

Шаблон "Посетитель" - это способ отделения алгоритма от структуры объекта, в которой он оперирует. Результат отделения - возможность добавлять новые операции в существующие структуры объектов без их модифицирования. Это один из способов соблюдения принципа открытости/закрытости (open/closed principle).

**Назначение**

Описывает операцию, выполняемую с каждым объектом из некоторой структуры. Паттерн посетитель позволяет определить новую операцию, не изменяя классы этих объектов.

**Применимость**:
- когда в структуре присутствуют объекты многих классов с различными интерфейсами и вы хотите выполнять над ними операции, зависящие от конкретных классов;
- когда над объектами, входящими в состав структуры, надо выполнять разнообразные, не связанные между собой операции и вы не хотите "засорять" классы такими операциями. Посетитель позволяет объединить родственные операции, поместив их в один класс. Если структура объектов является общей для нескольких приложений, то паттерн посетитель позволит в каждое приложение включить только относящиеся к нему операции;
- когда  классы, устанавливающие структуру объектов, изменяются редко, но новые операции над этой структурой добавляются часто. При изменении классов, представленных в структуре, нужно будет переопределить интерфейсы всех посетителей, а это может вызвать затруднения. Поэтому если классы меняются достаточно часто, то, вероятно, лучше определить операции прямо в них.

**Изображение**

![](../assets/Patterns/Visitor.png)

**Участники**:
- `Visitor` - посетитель:
    - объявляет операцию `visit` для каждого класса `ConcreteElement` в структуре объектов. Имя и сигнатура этой операции идентифицируют класс, который посылает посетителю запрос `visit`. Это позволяет посетителю определить, элемент какого конкретного класса он посещает. Владея такой информацией, посетитель может обращаться к элементу напрямую через его интерфейс;
    `ConcreteVisitor` - конкретный посетитель:
    - реализует все операции, объявленные в классе `Visitor`. Каждая операция реализует фрагмент алгоритма, определенного для класса соответствующего объекта в структуре. Класс `ConcreteVisitor` предоставляет контекст для этого алгоритма и сохраняет его локальное состояние. Часто в этом состоянии аккумулируются результаты, полученные в процессе обхода структуры;
- `Element` - элемент:
    - определяет операцию `accept`, которая принимает посетителя в качестве аргумента;
- `ConcreteElement` - конкретный элемент:
    - реализует операцию `accept`, принимающую посетителя как аргумент;
- `ObjectStructure` - структура объектов:
    - может перечислить свои элементы;
    - может предоставить посетителю высокоуровневый интерфейс для посещения своих элементов;
    - может быть как составным объектом, так и коллекцией, например списком или множеством.

**Отношения**:
- клиент, использующий паттерн посетитель, должен создать объект класса `ConcreteVisitor`, а затем обойти всю структуру, посетив каждый ее элемент;
- при посещении элемента последний вызывает операцию посетителя, соответствующую своему классу. Элемент передает этой операции себя в качестве аргумента, чтобы посетитель мог при необходимости получить доступ к его состоянию.

**Плюсы**:
- упрощает добавление новых операций. С помощью посетителей легко добавлять операции, зависящие от компонентов сложных объектов. Для определения новой операции над структурой объектов достаточно просто ввести нового посетителя;
- объединяет родственные операции и отсекает те, которые не имеют к ним отношения. Родственное поведение не разносится по всем классам, присутствующим в структуре объектов, оно локализовано в посетителе;
- посещение различных иерархий классов. Посетителю разрешено посещать объекты, не имеющие общего родительского класса. В интерфейс класса `Visitor` можно добавить операции для объектов любого типа;
- аккумулирование состояния. Посетители могут аккумулировать информацию о состоянии при посещении объектов структуры.

**Минусы**:
- добавление новых классов `ConcreteElement` затруднено. Каждый новый конкретный элемент требует объявления новой абстрактной операции в классе `Visitor`, которую нужно реализовать в каждом из существующих классов `ConcreteVisitor`;
- нарушение инкапсуляции. Применение посетителей подразумевает, что у класса `ConcreteElement` достаточно развитый интерфейс для того, чтобы посетители могли справиться со своей работой.

[Пример паттерна Посетитель]()

### <a id="Паттерн-Стратегия-Strategy" href="#Паттерн-Стратегия-Strategy">Паттерн Стратегия (Strategy)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон "Стратегия" позволяет переключаться между алгоритмами или стратегиями в зависимости от ситуации.*

Шаблон "Стратегия" позволяет при выполнении выбирать поведение алгоритма.

**Назначение**

Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента. Поведение инкапсулируется в отдельном наборе классов, который легко расширяется и изменяется даже во время выполнения.

**Применимость**:
- когда имеется много родственных классов, отличающихся только поведением. Стратегия позволяет сконфигурировать класс, задав одно из возможных поведений;
- когда вам нужно иметь несколько разных вариантов алгоритма. Например, можно определить два варианта алгоритма, один из которых требует больше времени, а другой - больше памяти. Стратегии разрешается применять, когда варианты алгоритмов реализованы в виде иерархии классов;
- когда в алгоритме содержатся данные, о которых клиент не должен "знать". Используется, чтобы не раскрывать сложные, специфичные для алгоритма структуры данных;
- когда в классе определено много поведений, что представлено разветвленными условными операторами. В этом случае проще перенести код из ветвей в отдельные классы стратегий.

**Изображение**

![](../assets/Patterns/Strategy.png)

**Участники**:
- `Strategy` - стратегия:
    - объявляет общий для всех поддерживаемых алгоритмов интерфейс. Класс `Context` пользуется этим интерфейсом для вызова конкретного алгоритма, определенного в классе `ConcreteStrategy`;
- `ConcreteStrategy` - конкретная стратегия:
    - реализует алгоритм, использующий интерфейс, объявленный в классе `Strategy`;
- `Context` - контекст:
    - конфигурируется объектом класса `ConcreteStrategy`;
    - хранит ссылку на объект класса `Strategy`;
    - может определять интерфейс, который позволяет объекту `Strategy` получить доступ к данным контекста.

**Отношения**:
- классы `Strategy` и `Context` взаимодействуют для реализации выбранного алгоритма. Контекст может передать стратегии все необходимые алгоритму данные в момент его вызова. Вместо этого контекст может позволить обращаться к своим операциям в нужные моменты, передав ссылку на самого себя операциям класса `Strategy`;
- контекст переадресует запросы своих клиентов объекту-стратегии. Обычно клиент создает объект `ConcreteStrategy` и передает его контексту, после чего клиент "общается" исключительно с контекстом. Часто в распоряжении клиента находится несколько классов `ConcreteStrategy`, которые он может выбирать.

**Плюсы**:
- семейства родственных алгоритмов. Иерархия классов `Strategy` определяет семейство алгоритмов или поведений, которые можно повторно использовать в разных контекстах;
- альтернатива порождению подклассов. Избавляет от порождения от `Context` подклассов с различными поведениями и разделяет контекст от алгоритмов;
- с помощью стратегий можно избавиться от условных операторов;
- выбор реализации. Стратегии могут предлагать различные реализации одного и того же поведения. Клиент вправе выбирать подходящую стратегию в зависимости от своих требований к быстродействию и памяти.

**Минусы**:
- клиенты должны "знать" о различных стратегиях. Потенциальный недостаток этого паттерна в том, что для выбора подходящей стратегии клиент должен понимать, чем отличаются разные стратегии;
- обмен информацией между стратегией и контекстом. Интерфейс класса `Strategy` разделяется всеми подклассами `ConcreteStrategy` - неважно, сложна или тривиальна их реализация. Поэтому вполне вероятно, что некоторые стратегии не будут пользоваться всей передаваемой им информацией, особенно простые;
- увеличение числа объектов. Применение стратегий увеличивает число объектов в приложении. Иногда эти издержки можно сократить, если реализовать стратегии в виде объектов без состояния, которые могут разделяться несколькими контекстами.

[Пример паттерна Стратегия](../assets/Patterns/Strategy.js)

### <a id="Паттерн-Состояние-State" href="#Паттерн-Состояние-State">Паттерн Состояние (State)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*Шаблон позволяет менять поведение класса при изменении состояния.*

Шаблон "Состояние" реализует машину состояний объектно ориентированным способом. Это достигается с помощью:
- реализации каждого состояния в виде производного класса интерфейса шаблона "Состояние";
- реализации переходов состояний (state transitions) посредством вызова методов, определенных вышестоящим классом (superclass).

Шаблон "Состояние" - это в некотором плане шаблон "Стратегия", при котором возможно переключение текущей стратегии с помощью вызова методов, определенных в интерфейсе шаблона.

**Назначение**

Позволяет объекту варьировать свое поведение в зависимости от внутреннего состояния. Извне создается впечатление, что изменился класс объекта.

**Применимость**:
- когда поведение объекта зависит от его состояния и должно изменяться во время выполнения;
- когда в коде операций встречаются состоящие из многих ветвей условные операторы, в которых выбор ветви зависит от состояния. Обычно в таком случае состояние представлено перечисляемыми константами. Часто одна и та же структура условного оператора повторяется в нескольких операциях. Паттерн состояние предлагает поместить каждую ветвь в отдельный класс. Это позволяет трактовать состояние объекта как самостоятельный объект, который может изменяться независимо от других.

**Изображение**

![](../assets/Patterns/State.png)

**Участники**:
- `Context` - контекст:
    - определяет интерфейс, представляющий интерес для клиентов;
    - хранит экземпляр подкласса `ConcreteState`, которым определяется текущее состояние;
- `State` - состояние:
    - определяет интерфейс для инкапсуляции поведения, ассоциированного  с конкретным состоянием контекста `Context`;
- подклассы `ConcreteState` - конкретное состояние:
    - каждый подкласс реализует поведение, ассоциированное с некоторым состоянием контекста `Context`.

**Отношения**:
- класс `Context` делегирует зависящие от состояния запросы текущему объекту `ConcreteState`;
- контекст может передать себя в качестве аргумента объекту `State`, который будет обрабатывать запрос. Это дает возможность объекту-состоянию при необходимости получить доступ к контексту;
- `Context` - это основной интерфейс для клиентов. Клиенты могут конфигурировать контекст объектами состояния `State`. Один раз сконфигурировав контекст, Клиенты уже не должны напрямую связываться с объектами состояния;
- либо `Context`, либо подклассы `ConcreteState` могут решить, при какихусловиях и в каком порядке происходит смена состояний.

**Плюсы**:
- локализует зависящее от состояния поведение и делит его на части, соответствующие состояниям. Паттерн состояние помещает все поведение, ассоциированное с конкретным состоянием, в отдельный объект. Поскольку зависящий от состояния код целиком находится в одном из подклассов класса `State`, то добавлять новые состояния и переходы можно просто путем порождения новых подклассов;
- делает явными переходы между состояниями;
- объекты состояния можно разделять. Если в объекте состояния `State` отсутствуют переменные экземпляра, то есть представляемое им состояние кодируется исключительно самим типом, то разные контексты могут разделять один и тот же объект `State`.

[Пример паттерна Состояние](../assets/Patterns/State.js)

### <a id="Паттерн-Шаблонный-метод-Template-method" href="#Паттерн-Шаблонный-метод-Template-method">Паттерн Шаблонный метод (Template method)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

*"Шаблонный метод" определяет каркас выполнения определенного алгоритма, но реализацию самих этапов делегирует дочерним классам.*

"Шаблонный метод" - это поведенческий шаблон, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.

**Назначение**

Шаблонный метод определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма, не изменяя его структуру в целом.

**Применимость**:
- чтобы однократно использовать инвариантные части алгоритма, оставляя реализацию изменяющегося поведения на усмотрение подклассов;
- когда можно вычленить и локализовать в одном классе поведение, общее для всех подклассов, дабы избежать дублирования кода. Сначала идентифицируются различия в существующем коде, а затем они выносятся в отдельные операции. В конечном итоге различающиеся фрагменты кода заменяются шаблонным методом, из которого вызываются новые операции;
- для управления расширениями подклассов. Можно определить шаблонный метод так, что он будет вызывать операции-зацепки - в определенных точках, разрешив тем самым расширение только в этих точках.

**Изображение**

![](../assets/Patterns/TemplateMethod.png)

**Участники**:
- `AbstractClass` - абстрактный класс:
    - определяет абстрактные примитивные операции, замещаемые в конкретных подклассах для реализации шагов алгоритма;
    - реализует шаблонный метод, определяющий скелет алгоритма. Шаблонный метод вызывает примитивные операции, а также операции, определенные в классе `AbstractClass` или в других объектах;
- `ConcreteClass` - конкретный класс:
    - реализует примитивные операции, выполняющие шаги алгоритма способом, который зависит от подкласса.

**Отношения**:
- `ConcreteClass` предполагает, что инвариантные шаги алгоритма будут выполнены в `AbstractClass`.

**Плюсы**:
- предоставляют возможность вынести общее поведение в подклассы.

[Пример паттерна Шаблонный метод](../assets/Patterns/TemplateMethod.js)

## <a id="Составные-паттерны" href="#Составные-паттерны">Составные паттерны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Паттерн-Модель-Представление-Контроллер" href="#Паттерн-Модель-Представление-Контроллер">Паттерн Модель-Представление-Контроллер</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер - таким образом, что модификация каждого компонента может осуществляться независимо.

**Изображение**

![](../assets/Patterns/MVC.png)

**Участники**:
- `Модель` - хранит все данные, информацию состояния и логику приложения. Она не знает о существовании представления и контроллера, хотя и предоставляет интерфейс для получения/изменения состояния, а также может отправлять оповещения об изменениях состояния наблюдателям;
- `Представление` - определяет представление модели. Как правило, представление получает состояние и данные для отображения непосредственно от модели;
- `Контроллер` - получает данные, вводимые пользователем, и определяет их смысл для модели. Ответственны лишь за:
    - прием запроса от пользователя;
    - анализ запроса;
    - выбор следующего действия системы, соответственно результатам анализа (например, передача запроса другим элементам системы).

**Отношения**:
1. **Пользователь взаимодействует с моделью**. `Представление` - "окно", через которое пользователь воспринимает модель. Когда делается что-то с представлением, представление сообщает `контроллеру`, какая операция была выполнена. `Контроллер` должен обработать это действие;
2. **Контроллер обращается к модели с запросами об изменении состояния**. `Контроллер` получает действия пользователя и интерпретирует их. Если действие происходит на `представлении`, то `контроллер` должен разобраться, что это значит и какие операции с `моделью` должны быть выполнены при данном действии;
3. **Контроллер также может обратиться к представлению с запросом об изменении**. Когда `контроллер` получает действие от представления, в результате его обработки он может обратиться к `представлению` с запросом на изменение;
4. **Модель оповещает представление об изменении состояния**. Когда в `модели` что-то изменяется (вследствие действий пользователя или других внутренних изменений), модель оповещает представление об изменении состояния;
5. **Представление запрашивает у модели информацию состояния**. `Представление` получает отображаемую информацию состояния непосредственно от `модели`. Например, когда модель оповещает `представление`, `представление` запрашивает данные и отображает их. `Представление` также может запросить у `модели` информацию состояния в результате запроса на изменение состояния со стороны `контроллера`.

**Включаемые паттерны**:
- **стратегия** - `Представление` и `контроллер` реализуют этот классический паттерн. `Представление` - объект со сменной стратегией, `контроллер` эту стратегию предоставляет. `Представление` интересуют только визуальные аспекты приложения, а все решения относительно поведения интерфейса делегируются `контроллеру`. Применение паттерна Стратегия также сохраняет логическую изоляцию `представления` от `модели`, потому что все взаимодействия с `моделью` для выполнения пользовательских запросов осуществляются `контроллером`. `Представлению` о них ничего не известно;
- **компоновщик** - представление является комбинацией компонентов GUI. Когда `контроллер` приказывает представлению обновиться, он обращается к верхнему компоненту, а паттерн Компоновщик делает все остальное;
- **наблюдатель** - `Модель` реализует паттерн Наблюдатель для оповещения заинтересованных объектов об изменениях состояния. Паттерн Наблюдатель обеспечивает полную независимость `модели` от `представлений` и `контроллеров`. Он позволяет использовать разные `представления` с одной `моделью`, или даже несколько `представлений` одновременно.

[Пример паттерна MVC](../assets/Patterns/MVC.js)

<a id="Основные-шаблоны" href="#Основные-шаблоны">Основные шаблоны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
================

## <a id="Декомпозиция-сложных-приложений" href="#Декомпозиция-сложных-приложений">Декомпозиция сложных приложений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные минусы **монолитной архитектуры**:
- все модули, по сути, являются частью одной и той же базы кода и запускаются как часть единого приложения;
- сбой в любом из компонентов, например не перехваченное исключение, может привести к краху всего приложения;
- модули находятся в тесной взаимосвязи, потому что границы между ними не всегда явно очерчены и часто игнорируются;
- сложный граф зависимостей означает, что каждый компонент системы является критически важным; он должен поддерживаться на протяжении всего срока существования приложения, и внесение в него любых изменений необходимо тщательно продумывать.

**Архитектура на микрослужбах** - основная идея заключается в том, чтобы разделить приложение на основные компоненты, поместив их в отдельные, независимые приложения - *любая программа должна делать что-то одно, но делать это хорошо*.

Основные факторы при проектировании архитектуры на микрослужбах:
- слабая связанность;
- высокая сцепленность;
- сложность интеграции.

Плюсы микрослужб:
- **снижение важности служб** - изоляция системы в целом от сбоев и ошибок и возможность внесения важных изменений, создании полностью независимых небольших служб, которые легко изменять и можно даже создавать заново на другом языке и при этом остальные службы и приложение от этого не пострадает;
- **повторное использование на разных платформах и языках** - позволяет создавать независимые единицы, которые без особых усилий могут повторно использоваться;
- **уровень сокрытия информации обычно намного выше** - благодаря тому, что взаимодействие обычно происходит через удаленный интерфейс, например через вебслужбу или брокера сообщений, что значительно упрощает сокрытие деталей реализации и ограждает клиента от влияния изменений в реализации или развертывании службы;
- **легкость масштабирования**.

Минусы микрослужб:
- высокая сложность интеграции, развертывания и совместного использования кода;
- взаимодействие служб.

## <a id="Шаблоны-интеграции-в-архитектуре-на-микрослужбах" href="#Шаблоны-интеграции-в-архитектуре-на-микрослужбах">Шаблоны интеграции в архитектуре на микрослужбах</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Прокси-сервер-для-служб" href="#Прокси-сервер-для-служб">Прокси-сервер для служб</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Прокси-сервер для служб** (**шлюз доступа к службам**) - это сервер, который управляет взаимодействиями между клиентом и рядом удаленных служб. Основным назначением является обеспечение единой точкой доступа для нескольких служб, но также может поддерживать распределение нагрузки, кэширование, аутентификацию и ограничение трафика, что иногда очень полезно для реализации полноценного решения. Это, по сути, обратный прокси-сервер. Не вникает в детали служб. Применение прокси-сервера помогает скрыть сложность базовой инфраструктуры.

```
                        |   |   |   |   |           <- запросы
                    +-------------------------+
                    | Прокси-сервер для служб |
                    +-------------------------+
                        |           |   ...     
        +---------------+           |
        |                 +---------+-----+
        |                 |               |
    +---------+     +-----------+   +-----------+
    | Служба1 |     | Служба2.1 |   | Служба2.1 |
    +---------+     +-----------+   +-----------+
```

### <a id="Координация-служб" href="#Координация-служб">Координация служб</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Координация служб** - идея заключается в том, чтобы создать абстракции для объединения обобщенных элементов данных и функций в реализации конкретных служб. Т.е. берутся операции из различных служб и собирается новый программный интерфейс, координирующий работу служб для поддержания всей системы в согласованном состоянии. Координатор занимается семантической интеграцией служб и часто поддерживает программный интерфейс, отличающийся от интерфейсов базовых служб. Основной минус его в том, что слишком много знает и за слишком многое отвечает, что обычно приводит к образованию жестких связей, слабой сцеплености и, самое главное, к большой сложности.

```
    +----------------------------------------+
    | Внешний интерфейс                      |  <- Приложение
    +----------------------------------------+
                        |
                        v
    +----------------------------------------+
    | Программный интерфейс слоя координации |  <- Координатор служб
    | Методы:                                |
    | +----------+  +----------+  +--------+ |
    | | Метод1() |  | Метод2() |  |   ...  | |
    | +-|-|-|----+  +----------+  +--------+ |
    +---|-|-|--------------------------------+
        | | |                                   <- Запросы операций служб
        | | +---------------------------+       
        | +-------------+               |       
        v               v               v
    +---------+    +---------+    +---------+
    | Служба1 |    | Служба2 |    | Служба3 |
    +---------+    +---------+    +---------+
```

### <a id="Интеграция-с-помощью-брокера-сообщений" href="#Интеграция-с-помощью-брокера-сообщений">Интеграция с помощью брокера сообщений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Брокер сообщений** - система, отделяющая отправителей сообщений от получателей, - позволяющего реализовать шаблон централизованной публикации/подписки, практически шаблон наблюдателя для распределенных систем. Распределяет между службами ответственность за синхронизацию информации во всей системе. Цель прежде всего заключается в том, чтобы каждая служба была изолированной, имела возможность работать отдельно от остальных служб или в сочетании с новыми службами и узлами.

Ответственность за распространение информации для согласования данных распределена между службами. Здесь нет вездесущей службы, обязанной знать механизм всей системы, и каждая служба отвечает за свой участок интеграции. Является основополагающим элементом для отделения служб и снижения сложности их взаимодействий.

```
    +----------------------------------------+
    | Внешний интерфейс                      |  <- Приложение
    +----------------------------------------+
            |                                   <- Запросы операций служб
            v
    +-----------------------+   +---------+
    | Служба1               |   | Служба2 |
    | Методы:               |   | Методы: |
    | +----------+  +-----+ |   | ...     |
    | | Метод1() |  | ... | |   |         |
    | +-|--------+  +-----+ |   |         |
    +---|-------------------+   +---------+
        |                            ^       
        | <- Публикация события      | <- Оповещение о событии
        |                            |
        v                            |
    +----------------------------------------+
    | Брокер сообщений                       |  
    +----------------------------------------+
```

## <a id="Шаблоны-обмена-сообщениями-и-интеграции" href="#Шаблоны-обмена-сообщениями-и-интеграции">Шаблоны обмена сообщениями и интеграции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Шаблоны-однонаправленного-обмена-и-вида-Запросответ" href="#Шаблоны-однонаправленного-обмена-и-вида-Запросответ">Шаблоны однонаправленного обмена и вида "Запрос/ответ"</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основополагающим свойством системы обмена сообщениями является направленность связи, которая обычно определяется ее семантикой.

```
    +-----------+    запрос  +------+
    | Инициатор | ---------> | Узел |
    |           |    ответ   |      |
    |           | <--------- |      |
    +-----------+            +------+
```

**Сообщения** - являются средством связи между различными программными компонентами. Содержимое сообщения также может меняться в зависимости от его назначения.

Типы сообщений:
- **сообщение-команда** - является сериализованным объектом команды. Цель - инициировать выполнение действия или задания в приемнике. Для этого сообщение должно содержать информацию, необходимую для выполнения задания, которая, как правило, состоит из имени операции и списка аргументов. Сообщения-команды можно использовать при реализации системы **вызова удаленных процедур** (*Remote Procedure Call*, *RPC*), распределенных вычислений или просто для запроса данных;
- **сообщение-событие** - используется для уведомления другого компонента о происходящем. Обычно такие сообщения содержат тип события и иногда некоторые подробности, такие как контекст, тема или вовлеченный участник. Использование событий является очень важным механизмом интеграции в распределенных приложениях, поскольку позволяет сохранить все узлы системы в согласованном состоянии;
- **сообщения-документы** - главным образом предназначены для передачи данных между компонентами и компьютерами. Основным отличием сообщений-документов от сообщений-команд (которые тоже могут содержать данные) является отсутствие какой-либо информации, указывающей получателю, что делать с данными. С другой стороны, главное отличие сообщений-документов от сообщений-событий заключается в отсутствии в документах привязки к конкретному происшедшему событию. Зачастую ответами на команды являются документы, поскольку они обычно содержат только запрашиваемые данные или результаты операции.

#### <a id="Очереди-сообщений" href="#Очереди-сообщений">Очереди сообщений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Очереди сообщений** - компоненты, которые являются посредниками между отправителем и получателем, хранящими сообщения, пока они не будут доставлены до места назначения.

Если по какой-либо причине получатель завершит работу, отключится от сети или окажется под высокой нагрузкой, сообщения будут накапливаться в очереди и переданы получателю, когда он вернется в сеть и восстановит свою работоспособность.

Очередь может находиться внутри отправителя, охватывать отправителя и получателя или быть помещена в выделенную внешнюю систему, действующую независимо, как промежуточное программное обеспечение для организации связи.

#### <a id="Обмен-сообщениями-через-брокера" href="#Обмен-сообщениями-через-брокера">Обмен сообщениями через брокера</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Брокер избавляет узлы за доставку сообщения получателю и о том что узлы должны знать адрес и порт приемника, а также согласовать форматы протоколов и сообщений, делая их независимыми и способными общаться с произвольным количеством других узлов, о которых им ничего не известно. Кроме того, брокер может служить мостом при использовании разных протоколов.

Протоколы прикладного уровня и основаны на протоколе TCP/IP:
- **MQTT** (*Message Queue Telemetry Transport*) - легковесный протокол обмена сообщениями, специально разработанный для связи между компьютерами;
- **AMQP** (*Advanced Message Queuing Protocol*) - более сложный протокол, который проектировался как открытая альтернатива проприетарной реализации обмена сообщениями;
- **STOMP** (*Simple/Streaming Text Orientated Messaging Protocol*) - легковесный текстовый протокол в стиле HTTP.

Уровни качества обслуживания:
- **QoS0, не более одного раза** - по-другому называется "послать и забыть", то есть сообщение не сохраняется и доставка не подтверждается. Это означает, что сообщение может быть потеряно в случае сбоя или отключения получателя;
- **QoS1, не менее одного раза** - сообщение гарантированно будет получено хотя бы один раз, но может быть продублировано, например если получатель завершит работу из-за ошибки до того, как уведомит отправителя. Это означает, что сообщения сохраняются, только если возникает необходимость повторной отправки;
- **QoS2, строго один раз** - это самый надежный из уровней QoS, поскольку он гарантирует, что сообщение будет получено один и только один раз. Это достигается за счет использования более медленного и громоздкого механизма подтверждения доставки сообщений.

Кроме организации взаимодействий, брокер может предлагать дополнительные возможности, такие как хранимые очереди, маршрутизация, преобразования сообщений и мониторинг.

Причины избегания брокеров:
- исключение элемента, отказ которого приведет к сбою всей системы;
- брокер должен масштабироваться, в то время как при использовании прямой передачи сообщений требуется масштабировать только отдельные узлы;
- переход на непосредственный обмен сообщениями может значительно ускорить их передачу.

Реализация прямого обмена сообщениями дает больше гибкости и возможностей, поскольку отсутствует привязка к конкретной технологии, протоколу или архитектуре.

### <a id="Шаблон-Публикацияподписка" href="#Шаблон-Публикацияподписка">Шаблон "Публикация/подписка"</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это всего лишь вариант шаблона "Наблюдатель" для распределенной архитектуры. Имеется ряд подписчиков, регистрирующихся для получения сообщений конкретного вида, а издатель генерирует сообщения, распределяемые по соответствующим подписчикам.

Главная особенность в том, что издатель не знает заранее, кто подпишется на получение сообщений. Подписчики являются абонентами, зарегистрировавшимися на получение конкретного сообщения, что позволяет издателю работать с произвольным количеством получателей. Другими словами, обе стороны слабо связаны друг с другом, что делает этот шаблон идеальным для интеграции узлов эволюционирующей распределенной системы.

Присутствие брокера еще больше ослабляет связанность узлов системы, поскольку абоненты взаимодействуют только с брокером и им не нужно знать, какой из узлов является отправителем.

Подписка, гарантирующая доставку всех сообщений, даже тех, что были отправлены, когда подписчик был отключен, называется **надежной подпиской**. Система надежной доставки сообщений должна использовать очередь сообщений для их хранения в то время, когда подписчики отключены.

#### <a id="Протокол-AMQP" href="#Протокол-AMQP">Протокол AMQP</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Протокол AMQP** - открытый стандартный протокол, поддерживаемый многими системами сообщений с очередями. Помимо общего коммуникационного протокола, он также определяет модель для описания маршрутизации, фильтрации, организации очередей, надежности и безопасности. В AMQP имеются три основных компонента.

**Очередь** - структура данных, отвечающая за хранение сообщений, извлекаемых получателями. Сообщения из очереди передаются одному или нескольким получателям, которыми, по сути, являются наши приложения. Если к одной очереди подключится несколько получателей, сообщения будут распределяться между ними. Очереди могут быть следующих видов:
- **надежные** - очередь автоматически восстанавливается при перезапуске брокера. Надежность не означает, что будет сохранено все содержимое очереди; на диск будут сохранены только сообщения, отмеченные как хранимые, и они же будут восстановлены в случае перезагрузки;
- **эксклюзивные** - к очереди может быть подключен только один конкретный подписчик. После закрытия соединения очередь уничтожается;
- **автоматически удаляемые** - очередь удаляется после отключения последнего подписчика.

**Коммутатор** - место публикации сообщений. Коммутатор направляет сообщения в одну или несколько очередей в зависимости от реализуемого алгоритма:
- **прямое коммутирование** - выбор маршрута определяется путем сопоставления полного ключа маршрутизации (например, chat.msg);
- **тематическое коммутирование** - выбор маршрута определяется путем сопоставления ключа с шаблоном (например, chat.# соответствует всем ключам маршрутизации, начинающимся с chat);
- **разветвляющее коммутирование** - сообщения рассылаются во все подключенные очереди, независимо от ключа маршрутизации.

**Связь** - между коммутаторами и очередями. Также определяет ключ маршрутизации или шаблон для фильтрации сообщений, поступающих от коммутатора.

Эти компоненты управляются брокером, предоставляющим программный интерфейс для создания и управления ими. Подключаясь к брокеру, клиент создает канал - абстракцию соединения, - который отвечает за поддержание связи с брокером.

```
          Брокер -> +-----------------------------------------------+
                    |                       Связи        Очереди    |
    +----------+    |   +------------+  +-> [===] --> [-][-][+][+] ---+-> [Подписчик]
    | Издатель | -----> | Коммутатор | -+                           | v
    +----------+    |   +------------+  +-> [***] --> [-][-][-][+] -----> [Подписчик]
                    |                                               |
                    +-----------------------------------------------+
```

К коммутатору можно присоединять единственного слушателя на определенные сообщения, при этом при регистрации нового слушателя на это сообщение, старому отправиться сообщение что он больше не будет получать сообщения и теперь все новые сообщения будут перенаправляться только новому слушателю.

### <a id="Шаблоны-Запросответ" href="#Шаблоны-Запросответ">Шаблоны "Запрос/ответ"</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Идея шаблона заключается в маркировке каждого запроса идентификатором, который затем получатель прикрепляет к ответу. Таким образом, отправитель запроса может сопоставить два сообщения и вернуть ответ соответствующему обработчику. Это решает проблему использования только однонаправленного асинхронного канала, позволяя передавать сообщения в любом направлении.

**Идентификатор корреляции** - уникальный идентификатором (маркер) запроса.

**Тип точка-точка** - прямое соединение двух узлов системы.

```
    +---------------+                                     +------------+
    | Запрашивающий | ----------[ID: 1][Запрос]---------> | Отвечающий |
    |               |                                     |            |
    |               | ----------[ID: 2][Запрос]---------> |            |
    |               |                                     |            |
    |               | <---------[Ответ][ID: 2 ]---------- |            |
    |               |                                     |            |
    |               | ----------[ID: 3][Запрос]---------> |            |
    |               |                                     |            |
    |               | <---------[Ответ][ID: 1 ]---------- |            |
    |               |                                     |            |
    |               | <---------[Ответ][ID: 3 ]---------- |            |
    +---------------+                                     +------------+
```

**Обратный адрес** - это сведения, которые позволят отвечающей стороне вернуть ответ исходному от правителю запроса.

## <a id="Шаблон-обработки-ошибок-Circuit-Breaker" href="#Шаблон-обработки-ошибок-Circuit-Breaker">Шаблон обработки ошибок (**Circuit Breaker**)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Паттерн **Circuit Breaker** предотвращает попытки приложения выполнить операцию, которая скорее всего завершится неудачно, что позволяет продолжить работу дальше не тратя важные ресурсы, пока известно, что проблема не устранена. Приложение должно быстро принять сбой операции и обработать его.

**Circuit Breaker** выступает как прокси-сервис между приложением и удаленным сервисом. Прокси-сервис мониторит последние возникшие ошибки, для определения, можно ли выполнить операцию или просто сразу вернуть ошибку.

Паттерн **Circuit Breaker** добавляет стабильности, когда система восстанавливается после падения и минимизирует влияние этого падения на производительность.

Если на сервисе **B** что-то пошло не так, то он возвращает сервису **А** ошибку и запоминает, что там есть ошибки, и просто последующие запросы не отправит на сервис **B**. То есть он не тратит ресурсы сервера в таком случае.

У него есть 3 состояния:
1. **Closed** - запрос от приложения направляется напрямую к сервису. Счетчик ошибок = 0 и приложение спокойно функционирует и перенаправляет запрос из сервиса **А** в сервис **B**.  
Прокси-сервис увеличивает счетчик ошибок, если операция завершилась неуспешно. Если количество ошибок за некоторый промежуток времени превышает заранее заданный порог значений, то прокси-сервис переходит в состояние **Open** и запускает таймер времени ожидания. Когда таймер истекает, он переходит в состояние **Half-Open**.  
**Назначение таймера** - дать сервису время для решения проблемы, прежде чем разрешить приложению попытаться выполнить операцию еще раз.
2. **Open** - запрос от приложения немедленно завершает с ошибкой и исключение возвращается в приложение.
3. **Half-Open** - ограниченному количеству запросов от приложения разрешено обратиться к сервису. Если эти запросы успешны, то считается что предыдущая ошибка исправлена и прокси-сервис переходит в состояние **Closed** (счетчик ошибок сбрасывается на **0**). Если любой из запросов завершился ошибкой, то считается, что ошибка все еще присутствует, тогда прокси-сервис возвращается в состояние **Open** и перезапускает таймер, чтобы дать системе дополнительное время на восстановление после сбоя.  
Состояние **Half-Open** помогает предотвратить быстрый рост запросов к сервису. Т.к. после начала работы сервиса, некоторое время он может быть способен обрабатывать ограниченное число запросов до полного восстановления.

```
    +-----+       +---------+       +-----+  Closed
    |     | --1-> |         | --1-> |     |
    |     | <=1== | Circuit | <=1== |     |
    |  A  |       |         |       |  B  |
    |     | --2-> | Breaker | --2-> |     |
    |     | <=2== |         | <=2== |     |
    +-----+       +---------+       +-----+
    +-----+       +---------+       +-----+  Open
    |     | --1-> |         |   x   |     |
    |     | <=1== | Circuit |   x   |     |
    |  A  |       |         |       |  B  |
    |     | --2-> | Breaker |   x   |     |
    |     | <=2== |         |   x   |     |
    +-----+       +---------+       +-----+
    +-----+       +---------+       +-----+  Half-Open
    |     | --1-> |         | --1-> |     |
    |     | <=1== | Circuit | <=1== |     |
    |  A  |       |         |       |  B  |
    |     | --2-> | Breaker |   x   |     |
    |     | <=2== |         |   x   |     |
    +-----+       +---------+       +-----+
```

## <a id="Шаблон-источник-событий-Event-Sourcing" href="#Шаблон-источник-событий-Event-Sourcing">Шаблон источник событий (**Event Sourcing**)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Источник событий** - это шаблон проектирования, в котором последовательность доменных событий хранится в виде журнала, а агрегированный вид журнала дает текущее состояние приложения.

Этот шаблон обычно используется для систем, которые не могут позволить себе блокировки хранилищ данных, и которые должны поддерживать аудит и историю событий - например, такие приложения, как гостиница/конференция/заказ сидений.

Его стоит использовать когда существует потребность в сильном аудите и воспроизведении событий для создания текущего и прошлого состояния приложений.

## <a id="Шаблон-Душитель-Strangler" href="#Шаблон-Душитель-Strangler">Шаблон Душитель (**Strangler**)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Strangler** выступает за создание надстройки фасада поверх устаревшего кода и нового кода, предоставляя потребителям возможность взглянуть на вещи объективно. Этот шаблон отделяет клиентов от миграционной активности между старыми и новыми частями приложения.

<a id="Принципы-проектирования" href="#Принципы-проектирования">Принципы проектирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======================

## <a id="SOLID" href="#SOLID">SOLID</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Мнемонический акроним, введенный Майклом Фэзерсом для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования.

Эти принципы, когда применяются вместе, предназначены для повышения вероятности того, что программист создаст систему, которую будет легко поддерживать и расширять в течение долгого времени. Принципы SOLID - это руководства, которые могут применяться во время работы над программным обеспечением для удаления "кода с запашком" предписывая программисту выполнять рефакторинг исходного кода, пока тот не станет разборчиво написанным и расширяемым. Это часть общей стратегии гибкой и адаптивной разработки.

### <a id="Принцип-единственной-ответственности-Single-Responsibility-Principle-SRP" href="#Принцип-единственной-ответственности-Single-Responsibility-Principle-SRP">Принцип единственной ответственности (Single Responsibility Principle, SRP)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для изменения класса никогда не должно быть более одной причины.

Обозначает, что каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности. К примеру класс не должен манипулировать свойствами и одновременно отвечать за работу с хранилищем данных этого класса.

Принцип SRP можно применить только в том случае, когда:
- объекту класса становится позволительно слишком много;
- доменная логика концентрируется только в одном классе;
- любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это не подразумевалось изначально;
- приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за их работоспособность отвечает третья сторона;
- невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные зависимости.

Правильное применение принципа единственной ответственности приводит к высокой степени связности элементов внутри модуля, то есть к тому, что задачи, решаемые внутри него, хорошо соответствуют его главной цели.

Для соблюдения этого принципа можно разбить класс на отдельные, изолированные классы, которые будут отвечать за что-то одно и использовать их в главном классе в виде фасада и композиции.

### <a id="Принцип-открытостизакрытости-OpenClosed-Principle-OCP" href="#Принцип-открытостизакрытости-OpenClosed-Principle-OCP">Принцип открытости/закрытости (Open/Closed Principle, OCP)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Программные сущности** (классы, модули, функции и т. д.) должны быть открыты для расширения, но закрыты для модифицирования.

Принцип открытости/закрытости означает, что программные сущности должны быть:
- открыты для расширения: означает, что поведение сущности может быть расширено путем создания новых типов сущностей;
- закрыты для изменения: в результате расширения поведения сущности, не должны вноситься изменения в код, который эти сущности использует.

### <a id="Принцип-подстановки-Барбары-Лисков-Liskov-Substitution-Principle-LSP" href="#Принцип-подстановки-Барбары-Лисков-Liskov-Substitution-Principle-LSP">Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Если `S` - это подтип `Т`, то объекты типа `Т` могут быть заменены объектами типа `S` (например, вместо объектов типа `Т` можно подставить объекты типа `S`) без изменения каких-либо свойств программы (корректность, задачи и т. д.).

Также принцип LSP подразумевает, что методы подкласса не могут генерировать никаких дополнительных исключений, кроме тех, которые сами являются подклассами исключений, генерируемых методами надкласса.

Функции, которые используют ссылки на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом.

### <a id="Принцип-разделения-интерфейса-Interface-Segregation-Principle-ISP" href="#Принцип-разделения-интерфейса-Interface-Segregation-Principle-ISP">Принцип разделения интерфейса (Interface Segregation Principle, ISP)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Клиенты не должны зависеть от интерфейсов, которые не используют.

Клиенты не должны зависеть от методов, которые они не используют. Принцип разделения интерфейсов говорит о том, что слишком "толстые" интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

### <a id="Принцип-инверсии-зависимостей-Dependency-Inversion-Principle-DIP" href="#Принцип-инверсии-зависимостей-Dependency-Inversion-Principle-DIP">Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объектом зависимости должна быть абстракция, а не что-то конкретное.

Этот принцип гласит:
- высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида должны зависеть от абстракций;
- абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

## <a id="KISS-Keep-it-short-and-simple" href="#KISS-Keep-it-short-and-simple">KISS (Keep it short and simple)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

keep it simple, stupid - "делай это проще, тупой"

Принцип, запрещающий использование более сложных средств, чем необходимо. Принцип декларирует простоту системы в качестве основной цели и/или ценности.

## <a id="Чем-хуже-тем-лучше" href="#Чем-хуже-тем-лучше">Чем хуже, тем лучше</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Подход к разработке программного обеспечения, объявляющий простоту реализации и простоту интерфейса более важными, чем любые другие свойства системы.

Описывается этот подход так:
- **простота** - реализация и интерфейс должны быть простыми. Простота реализации даже несколько важнее простоты интерфейса. Простота - самое важное требование при выборе дизайна;
- **правильность** - дизайн должен быть правильным во всех видимых проявлениях. Простой дизайн немного лучше, чем правильный;
- **логичность** (последовательность) - дизайн не должен быть слишком нелогичным. Иногда можно пожертвовать логичностью ради простоты, но лучше отказаться от тех частей дизайна, которые полезны лишь в редких случаях, чем усложнить реализацию или пожертвовать логичностью;
- **полнота** - дизайн должен охватывать как можно больше важных ситуаций. Полнотой можно жертвовать в пользу остальных качеств и обязательно нужно жертвовать, если она мешает простоте. Логичностью можно жертвовать в пользу полноты, если сохраняется простота (особенно бесполезна логичность интерфейса).

## <a id="DRY-Dont-repeat-yourself" href="#DRY-Dont-repeat-yourself">DRY (Don't repeat yourself)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоев абстрагирования. Принцип DRY формулируется так:  
"*У каждого фрагмента знаний должно быть единственное, недвусмысленное, непререкаемое представление в системе.*".

Знания часто могут дублироваться в спецификациях, процессах и разрабатываемых программах и тогда возникает трудность их сопровождения.

Основные моменты применения этого правила:
- если должно быть изменено какое-нибудь свойство кода, то сколько прийдется вносить изменений во многих разных местах и в самых разных форматах;
- если знания кода дублируется в комментарии к нему, то в какой-то момент коментарии не будут согласововаными с кодом. Для избавления необходимо изменить компоновку кода и иенования.

Не всякое дублирование кода является дублированием знаний, так как разный код может отвечать за разные знания и изменяться в дальнейшем по разному. В начале это может быть просто **совпадением**, а не дублированием.

Иногда может происходить дублирование в данных, когда от одного поля зависят другие поля и при изменении этого поля, необходимо изменять другие.

**Принцип единообразия доступа** - все службы, предоставляемые модулем, должны быть доступны с помощью единообразной системы обозначений, которая не зависит от того, как они реализуются: через хранение в памяти или вычисление.

## <a id="YAGNI-You-aint-gonna-need-it" href="#YAGNI-You-aint-gonna-need-it">YAGNI (You ain't gonna need it)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, - то есть отказ добавления функциональности, в которой нет непосредственной надобности.

## <a id="GIGO-Garbage-In-Garbage-Out" href="#GIGO-Garbage-In-Garbage-Out">GIGO (Garbage In, Garbage Out)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Принцип в информатике, означающий, что при неверных входящих данных будут получены неверные результаты, даже если сам по себе алгоритм правилен.

<a id="Связность-компонентов" href="#Связность-компонентов">Связность компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====================

## <a id="Принцип-эквивалентности-повторного-использования-и-выпусков-REP-ReuseRelease-Equivalence-Principle" href="#Принцип-эквивалентности-повторного-использования-и-выпусков-REP-ReuseRelease-Equivalence-Principle">Принцип эквивалентности повторного использования и выпусков (REP: Reuse/Release Equivalence Principle)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Классы и модули, составляющие компонент, должны принадлежать связной группе. Компонент не может просто включать случайную смесь классов и модулей; должна быть какая-то тема или цель, общая для всех модулей.

Классы и модули, объединяемые в компонент, должны выпускаться вместе.

## <a id="Принцип-согласованного-изменения-CCP-Common-Closure-Principle" href="#Принцип-согласованного-изменения-CCP-Common-Closure-Principle">Принцип согласованного изменения (CCP: Common Closure Principle)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время. В разные компоненты должны включаться классы, изменяющиеся в разное время и по разным причинам.

Этот принцип требует собирать вместе все классы, которые может понадобиться изменить по одной, общей причине. Если два класса тесно связаны, физически или концептуально, настолько, что всегда будут изменяться вместе, они должны принадлежать одному компоненту.

## <a id="Принцип-совместного-повторного-использования-CRP-Common-Reuse-Principle" href="#Принцип-совместного-повторного-использования-CRP-Common-Reuse-Principle">Принцип совместного повторного использования (CRP: Common Reuse Principle)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Указывает, что в компонент должны включаться классы и модули, используемые совместно.

## <a id="Связь-принципов" href="#Связь-принципов">Связь принципов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Принципы эквивалентности повторного использования** и **согласованного изменения** являются включительными: оба стремятся сделать компоненты как можно крупнее. **Принцип повторного использования** - исключительный, стремящийся сделать компоненты как можно мельче.

Например, на ранних этапах разработки проекта принцип CCP намного важнее, чем REP, удобство разработки важнее удобства повторного использования.

<a id="Сочетаемость-компонентов" href="#Сочетаемость-компонентов">Сочетаемость компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========================

## <a id="Принцип-ацикличности-зависимостей" href="#Принцип-ацикличности-зависимостей">Принцип ацикличности зависимостей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит в разделении проекта на компоненты, которые могут выпускаться независимо. Компоненты становятся единицами работы, ответственность за которые можно возложить на одного разработчика или на небольшую группу. Когда разработчики добиваются работоспособности компонента, они выпускают новую версию для использования другими разработчиками. Они присваивают этой версии номер и помещают в каталог, доступный другим разработчикам. Затем продолжают разработку компонента, изменяя свои локальные копии. А все остальные используют выпущенную версию.

Когда появляется новая версия компонента, другие команды могут выбирать - сразу же задействовать новую версию или подождать. Если принято решение подождать, они просто продолжают использовать предыдущую версию. Но как только они решат, что готовы, они начинают использовать новую версию.

В структуре компонентов не должно быть циклических зависимостей.

## <a id="Принцип-устойчивых-зависимостей" href="#Принцип-устойчивых-зависимостей">Принцип устойчивых зависимостей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Компоненты, с большим трудом поддающиеся изменению, не должны зависеть от любых изменчивых компонентов.

Компонент с множеством входящих зависимостей очень **устойчив**, потому что согласование изменений со всеми зависящими компонентами требует значительных усилий - он независим.

### <a id="Метрики-устойчивости" href="#Метрики-устойчивости">Метрики устойчивости</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- **fan-in** (число входов) - количество входящих зависимостей;
- **fan-out** (число выходов) - количество исходящих зависимостей;
- **I** - неустойчивость = `<fan-out> / (<fan-in> + <fan-out>)`. Значение этой метрики;
изменяется в диапазоне [0, 1]. I = 0 соответствует максимальной устойчивости компонента, I = 1 - максимальной неустойчивости.

Отсутствие зависящих компонентов означает, что он не может служить причиной изменения других компонентов, а его собственная зависимость может послужить веским основанием для изменения самого компонента.

Принцип устойчивых зависимостей говорит, что метрика **I** компонента должна быть больше метрик **I** компонентов, которые от него зависят. То есть метрики **I** должны уменьшаться в направлении зависимости.

## <a id="Принцип-устойчивости-абстракций" href="#Принцип-устойчивости-абстракций">Принцип устойчивости абстракций</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Устанавливает связь между устойчивостью и абстрактностью. То есть стабильный компонент должен состоять из интерфейсов и абстрактных классов, чтобы его легко было расширять. Устойчивые компоненты, доступные для расширения, обладают достаточной гибкостью, чтобы не накладывать чрезмерные ограничения на архитектуру.

### <a id="Мера-абстрактности" href="#Мера-абстрактности">Мера абстрактности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- **Nc** - число классов в компоненте;
- **Na** - число абстрактных классов и интерфейсов в компоненте;
- **A** - абстрактность. `A = Na / Nc`. Значение метрики **A** изменяется в диапазоне от 0 до 1. 0 означает полное отсутствие абстрактных классов в компоненте, а 1 означает, что компонент не содержит ничего, кроме абстрактных классов.

## <a id="Зоны" href="#Зоны">Зоны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

## <a id="Зона-боли" href="#Зона-боли">Зона боли</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Компоненты близкие к I = 0 и A = 0 находятся в зоне **боли** - это очень устойчивые и конкретные компоненты. Такие компоненты нежелательны, потому что слишком жесткие. Их нельзя расширить, потому что они неабстрактные, и очень трудно изменить из-за большой устойчивости.

К примеру это база данных.

## <a id="Зона-бесполезности" href="#Зона-бесполезности">Зона бесполезности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Компоненты близкие к I = 1 и A = 1 находятся в зоне **бесполезности**. Такие компоненты также нежелательны, потому что они максимально абстрактны и не имеют входящих зависимостей. Они бесполезны.

Часто это оставшиеся абстрактные классы, которые так и не были реализованы.

## <a id="Зона-главной-последовательности" href="#Зона-главной-последовательности">Зона главной последовательности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Находится между зонами **боли** и **бесполезности**.

**D** - расстояние до главной последовательности. `D = | A + I - 1 |`. Значение 0 указывает, что компонент находится прямо на главной последовательности. Значение 1 сообщает, что компонент располагается на максимальном удалении от главной последовательности.

<a id="Архитектура" href="#Архитектура">Архитектура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===========

Программная система состоит из:
- **политики** - это истинная ценность системы, которая воплощает все бизнес-правила и процедуры;
- **деталей** - это все остальное, что позволяет людям, другим системам и программистам взаимодействовать с **политикой**, никак не влияя на ее поведение. К ним можно отнести устройства ввода/вывода, базы данных, веб-системы, серверы, фреймворки, протоколы обмена данными и т.д.

**Архитектура** должна иметь такую форму системы, которая делает политику самым важным элементом, а детали - не относящимися к политике. Это позволяет откладывать и задерживать принятие решений о деталях.

## <a id="Сущности" href="#Сущности">Сущности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Бизнес-правила** - это правила или процедуры, делающие или экономящие деньги. Еще строже говоря, бизнес-правила - это правила, делающие или экономящие деньги независимо от наличия или отсутствия их реализации на компьютере. Они делают или экономят деньги, даже когда выполняются вручную.

**Сущность** - это объект в компьютерной системе, воплощающий небольшой набор критических бизнес-правил, оперирующих критическими бизнес-данными. **Объект-сущность** или содержит критические бизнес-правила в себе, или имеет простой доступ к ним. **Интерфейс сущности** состоит из функций, реализующих критические бизнес-правила и оперирующих этими данными.

**Сущность** - это бизнес в чистом виде и больше ничего.

Если разрабатывается одно приложение и не для предприятия, то эти сущности становятся бизнес-объектами приложения. Они инкапсулируют наиболее общие и высокоуровневые правила. Их изменение маловероятно под влиянием внешних изменений. Никакие изменения в работе любого конкретного приложения не должны влиять на уровень сущностей.

**Вариант использования** описывает способ использования автоматизированной системы. Он определяет, что должен ввести пользователь, что должно быть выведено в ответ и какие действия должны быть выполнены для получения выводимой информации. В отличие от критических бизнес-правил внутри сущностей, вариант использования описывает бизнес-правила, характерные для конкретного приложения.

**Варианты использования** определяют, как и когда вызываются критические
бизнес-правила в сущности. Варианты использования управляют действиями сущности. Варианты использования не описывают пользовательский интерфейс, они лишь неформально определяют входные и выходные данные, поступающие и возвращаемые через интерфейс. Варианты использования не описывают, как выглядит система для пользователя.

**Вариант использования** - это объект. Он имеет одну или несколько функций, реализующих конкретные прикладные бизнес-правила. Он также имеет элементы данных, включая входные данные, выходные данные и ссылки на соответствующие сущности, с которыми он взаимодействует.

Класс варианта использования принимает простые структуры данных на входе и возвращает простые структуры данных на выходе. Эти структуры данных ни от чего не зависят.

## <a id="Кричащая-архитектура" href="#Кричащая-архитектура">Кричащая архитектура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Архитектура** не связана (и не должны быть связана) с фреймворками. Архитектура не должна определяться фреймворками. **Фреймворки** - это инструменты, а вовсе не аспекты, определяющие черты архитектуры. Если архитектура опирается на фреймворки, она не сможет опираться на варианты использования.

Архитектура должна позволять строить систему, которая обладает свойствами:
- **независимость от фреймворков**. Архитектура не зависит от наличия какой-либо библиотеки. Это позволяет рассматривать фреймворки как инструменты, вместо того чтобы стараться втиснуть систему в их рамки.
- **простота тестирования**. Бизнес-правила можно тестировать без пользовательского интерфейса, базы данных, веб-сервера и любых других внешних элементов.
- **независимость от пользовательского интерфейса**. Пользовательский интерфейс можно легко изменять, не затрагивая остальную систему. Например, веб-интерфейс можно заменить консольным интерфейсом, не изменяя бизнес-правил.
- **независимость от базы данных**. Можео поменять Oracle или SQL Server на Mongo, BigTable, CouchDB или что-то еще. Бизнес-правила не привязаны к базе данных.
- **независимость от любых внешних агентов**. Бизнес-правила ничего не знают об интерфейсах, ведущих во внешний мир.

## <a id="Правило-зависимостей" href="#Правило-зависимостей">Правило зависимостей</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Уровни (круги):
1. **Сущности** - бизнес-правила уровня предприятия - политики.
2. **Варианты использования** - прикладные бизнес-правила - инкапсулируют и реализуют все варианты использования системы. Варианты использования организуют поток данных в сущности и из них и требуют от этих сущностей использовать их критические бизнес-правила для достижения своих целей.
3. **Контроллеры / Презентаторы / Шлюзы** - адаптеры интерфейсов, преобразующие данные из формата, наиболее удобного для вариантов использования и сущностей, в формат, наиболее удобный для некоторых внешних агентов, таких как база данных или веб-интерфейс. Именно на этом уровне целиком находится архитектура MVC.
4. **Устройства / Веб / Внешние интерфейсы / Пользовательский интерфейс** - фреймворки и драйверы.

Ничто во внутреннем круге ничего не знает о внешних кругах. Например, имена, объявленные во внешних кругах, не должны упоминаться в коде, находящемся во внутренних кругах. Сюда относятся функции, классы, переменные и любые другие именованные элементы программы. Зависимости в исходном коде всегда должны быть направлены внутрь. По мере движения внутрь уровень абстракции и политик увеличивается.

Для взаимодействия через границы используются интерфейсы.

Данные для передачи через границы уровней (кругов) должны быть **простыми, изолированными структурами данных** - ассоциативные массивы или объекты. При передаче через границу данные всегда должны принимать форму, наиболее удобную для внутреннего круга.

Полная реализация границ обходится дорого.

### <a id="Неполные-границы" href="#Неполные-границы">Неполные границы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Один из способов сконструировать неполную границу - проделать все, что необходимо для создания независимо компилируемых и развертываемых компонентов, и затем просто оставить их в одном компоненте. В этом компоненте будут присутствовать парные интерфейсы, структуры входных и выходных данных и все остальное, но все это будет компилироваться и развертываться как один компонент.

## <a id="Шаблон-проектирования-Скромный-объект" href="#Шаблон-проектирования-Скромный-объект">Шаблон проектирования "Скромный объект"</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Его идея: разделить поведение на два модуля или класса. Один из модулей, который называется **"скромным"**, содержит все, что с трудом поддается тестированию, в виде, упрощенном до предела. Второй - все, что было выброшено из "скромного" модуля.

**Представление (View)** - это "скромный" объект, сложный для тестирования. Код в этом объекте упрощается до предела. К примеру он просто переносит данные в графический интерфейс, никак не обрабатывая их.

**Презентатор (Presenter)** - это легко тестируемый объект. Его задача - получить данные от приложения и преобразовать их так, чтобы **Представление (View)** могло просто переместить их на экран. Например, если приложению потребуется отобразить дату в некотором поле, оно должно передать Презентатору объект Date. Презентатор затем должен преобразовать дату в строку и поместить ее в простую структуру данных, которую называют **Моделью представления (View Model)**, где Представление сможет найти ее.

Все, что отображается на экране и чем так или иначе управляет приложение, представлено в Модели представления строкой, или логическим значением, или элементом перечисления. На долю Представления остается только перенести данные из Модели представления на экран. То есть Представление играет скромную роль.

## <a id="Главный-компонент" href="#Главный-компонент">Главный компонент</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Главный компонент** (Main) - это конечная деталь, политика самого низкого уровня. Он является точкой входа в систему. От него ничего не зависит, кроме работоспособности системы. Его задача - создать все Фабрики, Стратегии и другие глобальные средства и затем передать управление высокоуровневым абстракциям в системе.

Именно в главном компоненте должны внедряться все зависимости с использованием инфраструктуры внедрения зависимостей. После этого главный компонент должен распространить эти зависимости, обычно без использования инфраструктуры.

Главный компонент можно считать самым грязным из всех грязных компонентов.

Для удобства главный компонент делается плагином для приложения - плагином, который настраивает начальное окружение, загружает все внешние ресурсы и затем передает управление политике верхнего уровня. Так как это плагин, может иметься множество главных компонентов, по одному для каждой конфигурации приложения. Если главный компонент плагине, то он находится
за архитектурной границей и проблемы настройки решаются намного проще.

## <a id="Архитектура-на-основе-сервисов" href="#Архитектура-на-основе-сервисов">Архитектура на основе сервисов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Службы, просто делят приложение на функциональные элементы, по сути, являются лишь функциями, вызовы которых обходятся довольно дорого и не обязательно имеют важное архитектурное значение. Некоторые из этих служб действительно являются архитектурно значимыми, а другие - нет.

Службы не обязательно должны быть маленькими монолитами. Службы также могут проектироваться в соответствии с принципами SOLID и данной структурой компонентов, чтобы иметь возможность добавлять в них новые компоненты, не изменяя существующие.

## <a id="Тесты" href="#Тесты">Тесты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Тесты, недостаточно хорошо интегрированные в дизайн системы, обычно оказываются хрупкими и делают систему жесткой и неудобной для изменения.

**Хрупкие тесты** - когда изменения в общих системных компонентах могут нарушить работу сотен и даже тысяч тестов часто оказывают отрицательное влияние, делая систему жесткой. В этом случае простые изменения в системе вызывают массовые отказы тестов, то тогда такие изменения будут стараться не вносить и это плохо.

Так как пользовательские интерфейсы переменчивы, то наборы тестов, осуществляющие проверки посредством пользовательского интерфейса, должны быть хрупкими.

Система и тесты должны проектироваться так, чтобы работу бизнес-правил можно было проверить без пользовательского интерфейса.

Для достижения изолированости тестов от системы следует создать специальный программный интерфейс для тестов, чтобы дать им возможность проверить все бизнесправила. Этот API должен защищать тесты от проблем с ограничениями безопасности, не использовать дорогостоящие ресурсы (таких, как базы данных) и заставлять систему входить в особые тестируемые состояния. Такой API должен быть надмножеством **интеракторов** и **адаптеров интерфейсов**, которые используются пользовательским интерфейсом.

**Цель API тестирования** - отделить тесты от приложения. Под отделением подразумевается не только отделение тестов от пользовательского интерфейса: цель - отделить структуру тестов от структуры приложения.

**Роль API тестирования** - скрыть структуру приложения от тестов. Это позволит развивать прикладной код, не влияя на тесты. Это также позволит развивать тесты, не влияя на прикладной код. Такая возможность независимого развития абсолютно необходима, потому что с течением времени тесты становятся все более конкретными, а прикладной код, напротив, - все более абстрактным и обобщенным.

Тесты, которые не проектируются как часть системы, получаются хрупкими и сложными в сопровождении.

## <a id="Три-шага-в-создании-программного-обеспечения" href="#Три-шага-в-создании-программного-обеспечения">Три шага в создании программного обеспечения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

1. **Сначала заставьте его работать**. *Вы останетесь не у дел, если он не работает*.
2. **Затем перепишите его правильно**. *Реорганизуйте код, чтобы вы и другие смогли понимать и развивать его, когда потребуется что-то изменить или понять*.
3. **Затем заставьте его работать быстро**. *Реорганизуйте код, чтобы добиться "необходимой" производительности*.

## <a id="Чистая-встраиваемая-архитектура" href="#Чистая-встраиваемая-архитектура">Чистая встраиваемая архитектура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**HAL** (Hardware Abstraction Layer) - это слой аппаратных абстракций предоставляет услугу доступа к оборудованию и не раскрывает программному обеспечению, как она работает.

**OSAL** (Operating System Abstraction Layer) - это слой абстракции операционной системы по аналогии с **HAL** предоставляет услугу доступа к операционной системе и не раскрывает программному обеспечению, как она работает.

## <a id="Детали-архитектуры" href="#Детали-архитектуры">Детали архитектуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="База-Данных" href="#База-Данных">База Данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**База данных** - это часть программного обеспечения. База данных - это утилита, обеспечивающая доступ к данным. С архитектурной точки зрения эта утилита не имеет никакого значения, это низкоуровневая деталь - механизм.

Данные - значимы, а база данных - это деталь.

### <a id="Веб" href="#Веб">Веб</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Веб** - это деталь. Веб - это устройство ввода/вывода.

### <a id="Фреймворки" href="#Фреймворки">Фреймворки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Фреймворк** - это деталь, которая несет риски:
- наследование кода в бизнес-объектах (сущностях);
- изначально сильный симбиоз с фреймворком и дальнейшая борьба с ним;
- неконтролируемое развитие (некоторые старые сущности могут изменятся и приходится изменять много кода);
- тяжелая смена на другой.

Для изоляции используются прокси-классы, которые содержатся в компонентах, являющихся плагинами для ваших бизнес-правил.

Фреймворки не должны проникать в основной код.

## <a id="Подходы-к-проектированию-и-организации-кода" href="#Подходы-к-проектированию-и-организации-кода">Подходы к проектированию и организации кода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Упаковка-по-уровням" href="#Упаковка-по-уровням">Упаковка по уровням</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Упаковка по уровням** - организация традиционной многоуровневой архитектуры, в которой код разделяется по функциональному признаку. В такой многоуровневой архитектуре один уровень выделяется для вебкода, один уровень - для "бизнес-логики" и один уровень - для работы с хранилищем данных. В ней уровни должны зависеть только от следующего смежного уровня.

Каждый уровень реализуется в виде отдельного пакета.

### <a id="Упаковка-по-особенностям" href="#Упаковка-по-особенностям">Упаковка по особенностям</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Упаковка по особенностям** - разделение по вертикали, основанное на объединении связанных особенностей, предметных понятий и общих корней (если использовать терминологию предметно-ориентированного проектирования). В типичных реализациях все типы помещаются в один пакет, имя которого отражает идею группировки.

### <a id="Упаковка-по-компонентам" href="#Упаковка-по-компонентам">Упаковка по компонентам</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В настоящей многоуровневой архитектуре стрелки зависимостей всегда должны быть направлены вниз. Уровни должны зависеть только от соседнего, нижележащего уровня.

В случае если позволено перепрыгивать через смежные, соседние уровни то такую архитектуру называют **нестрогой многоуровневой архитектурой**.

**Упаковка по компонентам** - упаковака всех обязанностей, связанных с одним крупным компонентом, в единый пакет. Где **компонент** - это группа функциональных возможностей, находящихся за общим чистым интерфейсом, которые постоянно находятся внутри среды выполнения, такой как приложение.

<a id="Рекомендации-по-проектированию-HTTP-API" href="#Рекомендации-по-проектированию-HTTP-API">Рекомендации по проектированию HTTP API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======================================

## <a id="Основные-принципы" href="#Основные-принципы">Основные принципы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Принцип-разделения-ответственности" href="#Принцип-разделения-ответственности">Принцип разделения ответственности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо стараться сохранять простоту системы, разделяя ответственность между различными частями цикла "запрос-ответ". Запросы и ответы выполняются для получения доступа к определенному ресурсу или набору ресурсов. Для определения сущности, которую необходимо получить, нужно использовать путь и тело ответа для передачи содержимого, а заголовки - для передачи метаданных.

### <a id="Требование-использования-защищенных-соединений" href="#Требование-использования-защищенных-соединений">Требование использования защищенных соединений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для получения данных при помощи API нужно использовать только защищенные соединения с TLS.

Перенаправления не приветствуются, поскольку они допускают некорректное поведение клиента, не предоставляя при этом никаких четких объяснений. Клиенты, которые полагаются на редиректы, удваивают таким образом трафик сервера и использование TLS в этом случае бесполезно, поскольку важные данные оказываются незащищенными при первом вызове.

### <a id="Требование-наличие-версии-в-заголовке-Accept" href="#Требование-наличие-версии-в-заголовке-Accept">Требование наличие версии в заголовке `Accept`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Наличие нескольких версий и переходы между ними может быть одним из самых сложных аспектов проектирования и использования API.

Для того, чтобы клиент не пользовался нестабильным API, лучше всего проверять наличие его версии в каждом запросе. При этом стоит избегать указания версии по умолчанию, поскольку это значительно усложняет заголовок, и эта версия также может меняться в будущем.
Лучше всего - добавить версию в заголовок вместе с другими метаданными, используя заголовок `Accept` с пользовательским типом содержимого:  
`Accept: application/vnd.heroku+json; version=3`

### <a id="Использовать-заголовок-ETags-для-кэширования" href="#Использовать-заголовок-ETags-для-кэширования">Использовать заголовок `ETags` для кэширования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо включать заголовок `ETags` во все запросы, определяя при этом версию возвращаемого ресурса. Это позволит пользователям кэшировать ресурсы и реализовывать условные запросы при помощи использования заголовка `If-None-Match`, который поможет определить, нужно обновлять кэш или нет.

### <a id="Использовать-Request-ID-для-интроспекции" href="#Использовать-Request-ID-для-интроспекции">Использовать `Request-ID` для интроспекции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо включать заголовок `Request-Id`, содержащий в себе **UUID** (*Universally Unique Identifier* - представляет собой 16-байтный (128-битный) номер) значение, в каждый ответ сервера. Регистрируя эти значения на клиенте, сервере или другом сервисе, вы получаете возможность отлаживать и диагностировать проблемы, связанные с запросами.

### <a id="Необходимо-разбивать-большие-ответы-сервера-на-несколько-небольших-при-помощи-заголовка-Range" href="#Необходимо-разбивать-большие-ответы-сервера-на-несколько-небольших-при-помощи-заголовка-Range">Необходимо разбивать большие ответы сервера на несколько небольших при помощи заголовка `Range`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Большие ответы необходимо разбивать на более мелкие, используя заголовок `Range`.

## <a id="Запросы" href="#Запросы">Запросы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Соответствующие-коды-состояний" href="#Соответствующие-коды-состояний">Соответствующие коды состояний</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо возвращать соотвествующий код состояния HTTP в каждом ответе.

**Успешные ответы должны содержать такие коды состояний**:
- **200** - **GET** запрос завершился успешно, синхронный **DELETE** или **PATCH** запрос завершился успешно или синхронный **PUT** запрос обновил существующий ресурс;
- **201** - синхронный **POST** запрос завершился, синхронный **PUT** запрос создал новый ресурс;
- **202** - принят **POST**, **PUT**, **DELETE** или **PATCH** запрос, который будет обработан асинхронно;
- **206** - **GET** запрос завершился успешно, но будет возвращен частичный ответ (заголовок `Range`).

**Состояния ошибок авторизации и аутентификации**:
- **401 Unauthorized** - запрос завершился с ошибкой, поскольку пользователь не прошел аутентификацию;
- **403 Forbidden** - запрос завершился с ошибкой, так как пользователь не авторизовался для получения доступа к определенному ресурсу.

**Коды ошибок для предоставления дополнительной информации об их причинах**:
- **422 Unprocessable Entity** - запрос был распознан, но содержит неверные параметры;
- **429 Too Many Requests** - превышен лимит запросов, попробуйте позже;
- **500 Internal Server Error** - проблема на стороне сервера, проверьте состояние сайта и/или сообщите о проблеме.

### <a id="Предоставление-полных-версии-ресурсов" href="#Предоставление-полных-версии-ресурсов">Предоставление полных версии ресурсов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо возвращать пользователям **API** полное представление ресурса (то есть объект со всеми атрибутами) во всех ответах, где это возможно. Всегда необходимо предоставлять полную версию ресурса в ответах на запросы с кодами состояния **200** и **201**, включая **PUT**, **PATCH** и **DELETE** запросы.

Ответы на запросы с кодом состояния **202** не должны содержать все поля объекта.

### <a id="API-должен-принимать-сериализованный-JSON-в-теле-запроса" href="#API-должен-принимать-сериализованный-JSON-в-теле-запроса">API должен принимать сериализованный JSON в теле запроса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

API должен предусматривать возможность передачи сереализованного **JSON** в теле **PUT** / **PATCH** / **POST** запросов вместо, либо в дополнение к передаваемым данным формы. Таким образом создается симметрия в **JSON**-ответах.

## <a id="Конструировании-пути-к-ресурсу" href="#Конструировании-пути-к-ресурсу">Конструировании пути к ресурсу</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Названия-ресурсов" href="#Названия-ресурсов">Названия ресурсов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо использовать множественную форму названия ресурса, за исключением тех случаев, когда запрашиваемый ресурс в системе всегда один. Такой подход помогает сохранять единообразие при доступе к конкретному ресурсу.

### <a id="Действия" href="#Действия">Действия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо проектировать такие конечные **url**, которые не требуют дополнительных действий для отдельных ресурсов. В случаях, когда это необходимо, добавляйте в общий путь компонент **"action"** для того, чтобы четко определить эти действия:  
`/resources/:resource/actions/:action`
> `/runs/{run_id}/actions/stop`

### <a id="Названия-компонентов-пути-и-атрибутов" href="#Названия-компонентов-пути-и-атрибутов">Названия компонентов пути и атрибутов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для названий компонентов пути к ресурсу необходимо использовать нижний регистр и разделять их при помощи дефиса.
> `service-api.com/app-setups`

Названия атрибутов лучше писать в нижнем регистре, а в качестве разделителя лучше использовать нижнее подчеркивание - таким образом названия полей можно писать без скобок в Javascript.
> `service_class: "first"`

### <a id="API-должен-поддерживать-доступ-к-ресурсу-не-только-по-его-id" href="#API-должен-поддерживать-доступ-к-ресурсу-не-только-по-его-id">API должен поддерживать доступ к ресурсу не только по его id</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В некоторых случаях для конечных пользователей неудобен доступ к ресурсу по его идентификатору. В таких случаях нужно организовать доступ как по имени, так и по идентификатору.
> `https://service.com/apps/{app_id_or_name}`  
> `https://service.com/apps/97addcf0-c182`  
> `https://service.com/apps/www-prod`

### <a id="Необходимо-свести-к-минимуму-количество-вложений-в-пути-для-доступа-к-ресурсу" href="#Необходимо-свести-к-минимуму-количество-вложений-в-пути-для-доступа-к-ресурсу">Необходимо свести к минимуму количество вложений в пути для доступа к ресурсу</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В моделях данных, в которых присутствуют родительские отношения между сущностями, пути доступа к ресурсам могут иметь большой уровень вложенности, чтобы ограничить глубину вложенности, необходимо размещать ресурсы в корневой директории. Вложенность лучше использовать для обозначения доступа к коллекциям ресурсов.

## <a id="Ответы" href="#Ответы">Ответы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Необходимо-предоставлять-UUID-запрашиваемых-ресурсов" href="#Необходимо-предоставлять-UUID-запрашиваемых-ресурсов">Необходимо предоставлять UUID запрашиваемых ресурсов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

У каждого ресурса по умолчанию должен быть атрибут **id**. В качестве значений идентификатора ресурса необходимо старатса всегда использовать **UUID**. Не нужно использовать идентификаторы, которые не будут уникальными в масштабе сервиса, особенно автоинкрементные идентификаторы.

**UUID** ресурса выводите в формате **8-4-4-4-12**.
> `"id": "01234567-89ab-cdef-0123-456789abcdef"`

### <a id="Необходимо-предоставлять-информацию-о-дате-создания-и-изменения-ресурса" href="#Необходимо-предоставлять-информацию-о-дате-создания-и-изменения-ресурса">Необходимо предоставлять информацию о дате создания и изменения ресурса</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

По умолчанию ресурс должен хранить информацию о дате его создания `created_at` и обновления `updated_at`.

### <a id="Временные-величины-должны-быть-форматированы-согласно-ISO8601" href="#Временные-величины-должны-быть-форматированы-согласно-ISO8601">Временные величины должны быть форматированы согласно ISO8601</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо принимать и возвращать временные данные только в **UTC**, а выводить в формате **ISO8601**.

### <a id="Отношения-с-внешними-сущностями-должны-быть-вынесены-во-вложенный-объект" href="#Отношения-с-внешними-сущностями-должны-быть-вынесены-во-вложенный-объект">Отношения с внешними сущностями должны быть вынесены во вложенный объект</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Внешние отношения должны быть сериализованы как вложенный объект, а не как поле объекта. Такой подход позволяет добавить больше информации о связанном объекте без необходимости менять структуру ответа.

### <a id="Необходимо-создавать-структурированные-ответы-в-случае-возникновения-ошибок" href="#Необходимо-создавать-структурированные-ответы-в-случае-возникновения-ошибок">Необходимо создавать структурированные ответы в случае возникновения ошибок</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо отдавать последовательное, структурированное тело ответа в случае возникновения ошибок. Ответ при этом должен содержать удобочитаемое сообщение об ошибке и, опционально, **url**, который указывает клиенту где можно получить дополнительную информацию о проблеме и способах ее решения.

### <a id="Необходимо-показывайть-ограничение-по-количеству-запросов" href="#Необходимо-показывайть-ограничение-по-количеству-запросов">Необходимо показывайть ограничение по количеству запросов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Ограничение по количеству запросов вводится для поддержания работоспособности системы и возможности качественного обслуживания других клиентов. Нужно возвращать оставшееся количество запросов для каждого запроса в заголовке ответа `RateLimit-Remaining`.

### <a id="JSON-во-всех-ответах-должен-быть-минимизирован" href="#JSON-во-всех-ответах-должен-быть-минимизирован">JSON во всех ответах должен быть минимизирован</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Лишний пробел увеличивает размер ответа и многие Javascript клиенты для удобочитаемости автоматически отформатируют JSON. Поэтому лучше минимизировать JSON ответы.

## <a id="Артефакты" href="#Артефакты">Артефакты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это отчуждаемый результат организованной деятельности, предусмотренный методологией ведения проекта.

### <a id="Необходимо-предоставлять-удобную-для-обработки-JSON-схему" href="#Необходимо-предоставлять-удобную-для-обработки-JSON-схему">Необходимо предоставлять удобную для обработки JSON-схему</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для точного описания API необходимо предоставлять JSON-схему. Для управления схемой можно использовать **prmd**, также нужно удостовериться в том, что она проходит валидацию при помощи команды **prmd verify**.

### <a id="Необходимо-предоставлять-удобочитаемую-документацию" href="#Необходимо-предоставлять-удобочитаемую-документацию">Необходимо предоставлять удобочитаемую документацию</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для того, чтобы разработчики разбирались в принципах работы вашего API, необходимо предоставлять им удобную документацию.

Если JSON-схема была создана, используя **prmd**, можно легко сгенерировать Markdown документацию для всех конечных url, используя команду **prmd doc**.

Вдобавок к описанию конечных **url**, необходимо предоставите обзор API, включая туда следующую информацию:
- процесс аутентификации - получение и использование пользовательского токена;
- стабильность API и его версию, а также информацию о том, как выбрать нужную версию API;
- общие заголовки запросов и ответов;
- формат выдачи ошибки;
- примеры использования API с клиентами на разных языках.

### <a id="Необходимо-предоставлять-примеры-запросов-которые-можно-протестировать" href="#Необходимо-предоставлять-примеры-запросов-которые-можно-протестировать">Необходимо предоставлять примеры запросов, которые можно протестировать</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Необходимо предоставлять примеры запросов, которые пользователи могут протестировать. Для тестирования этих запросов пользователь должен выполнить минимум действий.

Если используется **prmd** для создания документации, то такие примеры будут сгенерированы автоматически для каждого конечного **url**.

### <a id="Стабильность-API" href="#Стабильность-API">Стабильность API</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Можно описать степень стабильности **API** или отдельных конечных **url** при помощи установки флагов **prototype** / **development** / **production**.

Как только было объявлено что API готово к релизу и стабильно, не стоит совершать модификаций, которые нарушают обратную совместимость внутри этой версии. Для внесения таких изменений небходимо создать новою ветвь API с новым индексом версии.

<a id="Масштабирование-приложений" href="#Масштабирование-приложений">Масштабирование приложений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========================

## <a id="Доступность" href="#Доступность">Доступность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Надежность** - в общем случае означает качество системы. Способность системы выполнять требуемые действия, не допуская ошибок.

**Доступность** - в общем случае означает способность системы выполнять задачи, которые она способна выполнять. Готовность системы к работе при необходимости выполнить требуемые действия.

Пункты по улучшению доступности системы:
- **учет возможных отказов**:
    - **при проектировании** - это учет и перехват ошибок в глубине приложения, повторения запроса, прерыватели запросов при долгом ожидании, которые позволят перехватывать ошибки тогда, когда они еще существенно не повлияли на функциональность приложения;
    - **внешняя зависимость** - это ситуации при которых случается временный или невосстановимый (катастрофический) отказ зависимости;
    - **клиенты** - это ситуации при которых клиенты системы, начинают вести себя некорректно - увеличивают нагрузку, присылают мусорные или избыточные данные.
- **масштабирование**:
    - **расширение хранилищ** - закладывание в архитектуру возможность увиличения размера и емкости хранилищ;
    - **границы хранилищ** - это когда достигаются границы масштабирования данных приложения, что будет если они достигнуться и как их отодвинуть;
    - **горизонтальное масштабирование** - проектривание с легким добавлением серверов;
    - **статическо данные** - перенаправление запросов статичного содержимого внешним провайдерам, таким как сетям доставки контента (*Content Delivery Network*, *CDN*);
    - **статическо-динамические данные** - преобразование части динамического контента в статический, если возможно.
- **последствия рисков** - заключаются скорее в идентификации риска, принятии допустимого объема риска и мер по смягчению его последствий. Виды рисков:
    - **риск отказа сервера**;
    - **риск повреждения базы данных**;
    - **риск возврата некорректного ответа**;
    - **риск неисправности сетевого подключения**;
    - **риск отказа вновь развернутого программного модуля**.

    Суть **смягчения последствий рисков** состоит в том, что приложение должно работать настолько хорошо и настолько полно, насколько возможно, даже если сервисы и ресурсы испытывают проблемы. Смягчение последствий рисков подразумевает определение того, что может поити не так, и составление всеобъемлющего плана быстрого выхода из нештатной ситуации прежде, чем она возникнет.

- **мониторинг**:
    - **серверный мониторинг** - контроль рабочего состояния серверов и эффективности их работы;
    - **мониторинг изменений конфигурации** - наблюдение за конфигурацией системы, выявляющее изменения в инфраструктуре, повлиявшие на работу приложения;
    - **мониторинг производительности приложения** - внутренний контроль за должной эффективностью работы приложения и сервисов;
    - **синтетическое тестирование** - нагрузочное тестирование;
    - **оповещения** - при возникновении сбоя происходит оповещение об этом.

### <a id="Измерение-доступности" href="#Измерение-доступности">Измерение доступности</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<степень_доступности_сайта> = (<сумма_секунд_в_промежутке_времени> - <сумма_секунд_недоступности_системы>) / <сумма_секунд_в_промежутке_времени>`

Доступность часто указывается девятками. Это сокращенный способ обозначения степеней доступности.

Девятки   | Процент, % | Период неработоспособности за месяц (43 200 мин)
 -------- | ---------- | ------------------------------------------------
2 девятки | 99,00      | 432 мин
3 девятки | 99,9       | 43 мин
4 девятки | 99,99      | 4 мин
5 девяток | 99,999     | 26 с
6 девяток | 99,9999    | 2,6 с

Для большинства веб-приложений **приемлемой степенью доступности** считается 3 девятки.

Плановое и регулярное обслуживание, во время которого приложение недоступно, также учитывается при оценке степени доступности.

### <a id="Автоматизация-ручных-процессов" href="#Автоматизация-ручных-процессов">Автоматизация ручных процессов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для поддержки доступности на высоком уровне должны быть исключены любые неопределенности, а именно ручные операции в системе, находящейся в эксплуатации.

Все по автоматизации должны быть повторно применимы, так как ао многих случаях возможность повторения изменений значительно повлияет на стабильность системы и приложения.  
Эти задачи - изменения в конфигурации, регулировку и настройку производительности, перезапуск серверов, процессов и задач, изменение правил маршрутизации, а также обновление и развертывание пакетов программного обеспечения.

Управление конфигурацией должно осуществляться через процессы автоматического применения изменений (скрипты) так как они позволяют равномерно применять идентичные изменения во всей системе, а также для новых частей. Для этого ей нужно пользоваться **всегда** и для **всех** изменений в системе.  
Ни в коем случае нельзя обходить систему управления конфигурацией, чтобы внести какие-либо изменения. Никогда и ни при каких обстоятельствах. Так как это может создать неоднозначности.

## <a id="Управление-рисками" href="#Управление-рисками">Управление рисками</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Управление рисками включает в себя определение того, где именно в системе существуют риски, решение о том, какие риски непременно нужно удалить, а какие можно оставить, а затем принятие мер по смягчению последствий оставшихся рисков, призванное снизить вероятность их наступления и серьезность последствий.

### <a id="Принципы-управления-рисками" href="#Принципы-управления-рисками">Принципы управления рисками</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- **выявление рисков** - для этого строится **матрица рисков**, которая состоит из строк с рисками и колонками;
- **ликвидация самых опасных рисков** - на основании матрицы должны быть ликвидированны самые опасные риски, если возможно их ликвидировать;
- **смягчение последствий рисков** - для остальных рисков должен быть составлен план по снижению вероятности наступления и смягчению последствий опасных рисков;
- **регулярный пересмотр плана** - должен произволиться раз в квартал или после возникновения риска.

Риски оформляются в виде: `<тип_вероятности> / <тип_критичности>`, где `<тип_вероятности>` и `<тип_критичности>` будут в виде:
- `В` - высокий (3);
- `С` - средний (2);
- `Н` - низкий (1).
> `В / Н` (`3 / 1`) - высока вероятность, низкая критичность.

### <a id="Матрица-рисков" href="#Матрица-рисков">Матрица рисков</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из строк с рисками и колонками:
- **идентификатор** - уникальный номер риска;
- **система** - обозначение системы, подсистемы или модуля, в которых присутствует риск;
- **владелец** - имя лица или название команды, которые занимаются областью, где имеется риск;
- **описание риска** - краткое описание;
- **дата обнаружения** - когда был добавлен;
- **вероятность** - вероятность наступления риска (1, 2, 3);
- **критичность** - (тяжесть последствий риска) - стоимость последствий риска в случае его наступления (1, 2, 3);
- **план смягчения последствий риска** - это план того, какие изменения будут внесены сейчас или в ближайшем будущем, чтобы снизить критичность риска или вероятность его реализации (не предусматривает избавления от риска);
- **статус** - статус риска (**активный**, **смягчен**, **в процессе исправления**, **ликвидирован**);
- **оценка времени** - оценка времени необходимого для окончательного избавления от этого риска (если возможно);
- **мониторинг** - установлен ли мониторинг риска, если нет то почему не установлен;
- **план на случай реализации риска** - высокоуровневый план на уровне менеджмента, которые будут предприниматься при возникновении риска, а не план реагирования на проблему;
- **комментарий** - любая информация о риске и его история.

Должна быть отсортирована по приоритетам.

Общая матрица рисков должна разбиваться на меньшие для одной команды, группы или организации, которая самостоятельно принимает решения об объеме работы и приоритетах.

Для составления матрицы используются источники идей:
- **команда разработки**;
- **сотрудники технической поддержки**;
- **векторы атаки** и уязвимостях в безопасности;
- **бэклог функциональностей** в котором имеются еще не реализованные возможности, которые очень важны для здорового состояния системы;
- **производительность системы**;
- **владельцы бизнеса**;
- **остальная часть команды** - внутрение пользователи, команды, с которыми связана работа, служба внедрения и т. д.;
- **системы и процессы** - какие есть области, функционирование которых никак не отражено в документации;
- **технический долг** - области кода, которые трудно понять, переусложненные или имеющие больше подвижных частей, чем следует. Так как области, в которых имеется технический долг, почти гарантированно содержат риски.

Класификация рисков должна происходить отдельно от их составления.

### <a id="Смягчение-рисков" href="#Смягчение-рисков">Смягчение рисков</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Суть смягчения рисков** - в снижении негативного влияния риска путем либо снижения вероятности его реализации, либо критичности его последствий.

**План восстановления** - это составленный заранее список действий для устранения последствий риска и приведения системы в рабочее состояние после возникновения проблем, вызванных реализацией риска. Описывает, что необходимо предпринять, должен включать:
- детальное описание признаков необходимости начала действий по плану восстановления;
- перечень лиц, которые должны быть привлечены к реализации плана восстановления;
- пошаговые инструкции реализации плана восстановления с указанием роли каждого сотрудника;
- организацию уведомления о проблеме всех, кто должен быть оповещен;
- действия, предпринимаемые после того, как проблема решена.

**План аварийного восстановления** - это один из видов плана восстановления, в котором указано, что должна предпринять компания в случае возникновения серьезной проблемы конкретного вида.

### <a id="Избыточность" href="#Избыточность">Избыточность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Обеспечение избыточности - средство увеличения доступности и надежности приложения, которое снижает риски, но в то же время усложняет приложение, что увеличивает риски.

Безопасное улучшение избыточности на этапе проектирования:
- **одновременная работа на нескольких независимых компонентах оборудования** (работа на нескольких параллельных серверах);
- **возможность независимого запуска разных задач, сервисов** - это улучшит востановление после выхода из строя различных задач, сервисов;
- **возможность асинхронного запуска задач, сервисов** - тогда таким образом запросы на исполнение задач и их запуск могут быть поставлены в очередь, что не повлияет на основной процесс работы приложения;
- **локализация состояния только в определенных областях** - это снизит необходимость управления состоянием в других частях системы;
- **использование идемпотентных интерфейсов, где это только возможно** - это означает, что интерфейсы могут быть при необходимости вызваны несколько раз подряд для гарантии того, что запрошенное действие в конечном итоге выполнено, но выполнено фактически лишь один раз. Использование идемпотентных интерфейсов упрощает восстановление после ошибок с помощью простых механизмов повтора.

### <a id="Сложность" href="#Сложность">Сложность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Сложность - враг стабильности**. Чем сложнее становится система, тем менее она стабильна. Чем менее она стабильна, тем рискованнее она становится и тем ниже оказывается уровень ее доступности.

### <a id="Самовосстановление" href="#Самовосстановление">Самовосстановление</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это набор приемов по самовосстановлении систем без участия человека. Примеры:
- **балансировщик нагрузки серверов**, для того чтобы переадресовывать трафик новому серверу, если предыдущий не смог его обработать;
- **резервная база данных**, полностью дублирующая основную, для замены основной, если она перестанет быть доступной;
- **сервис, который повторяет запрос**, если тот завершился с ошибкой, предполагая, что изначальный запрос был неуспешен по какой-то случайной причине, а новая попытка будет благополучно отработана;
- **система обработки запросов**, отслеживающая отложенные задачи: если какой-либо запрос оказывается неуспешным, позднее он может быть запланирован для нового обработчика, что повышает вероятность успешного завершения этого запроса и снижает вероятность потери задач;
- **сервис, который вызывает несколько других сервисов**, индивидуально разработанных и управляемых, для проведения одной и той же операции, если результаты работы сервисов одинаковы, они используются иначе, тот который отдает отличный результат от них, отключается для проверки.

## <a id="Сервисы-и-микросервисы" href="#Сервисы-и-микросервисы">Сервисы и микросервисы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Сервис** - обособленная закрытая система, обеспечивающая функционирование отдельной бизнес-возможности и используемая при разработке одного или нескольких крупных продуктов.

**Сервисно-ориентированные архитектуры** предоставляют возможность разделить приложение на несколько отдельных доменов, каждым из которых управляет определенная группа лиц внутри организации. Их преимущества:
- **масштабирование**;
- **разделение обязанностей для эффективной концентрации**;
- **локализация сложности** - так как каждый сервис представляет собой черный ящик, то только те кто его разрабатывают знают его сложность и механизмы его работы, а для других он представляет лишь свои возможности и API;
- **тестирование**.

Сервисы должны предлагать **контракт**, который состоит из:
- **возможности сервиса** - его API, то что делает сервис и способ обращения к сервису и значение каждого вызова его API;
- **ответственность сервиса** - то как часто может быть использован его API, когда сервис может быть использован, насколько быстро реагирует API сервиса и может ли API адаптироваться.

**Сервис** - автономный компонент, который должен соответствовать следующим критериям:
- **основываться на собственной базе кода** которая обособленная от остальных баз кода;
- **управлять собственными данными** - должен хранить всю необходимую информацию в собственной базе данных. Единственный способ получить к ней доступ - через определенное сервисом API. Ни один сервис не может получить доступ к данным или информации о состоянии другого сервиса;
- **предоставлять возможности другим сервисам** - предоставлять API;
- **пользоваться возможностями других сервисов** - использовать API других сервисов;
- **иметь единственного владельца** - принадлежать только одной команде, которая отвечает за разработку, тестирование, развертывание, производительность и доступность данного сервиса.

Рекомендации по разделению на сервисы:
1. **Разделение по бизнес-требованиям** - это требования обеспечения безопасности, соблюдения законодательства, валидации, ограничение доступа и нормативно-правовые требования;
2. **Разделение по зонам ответственности**;
3. **Разделение по роду данных**;
4. **Разделение возможностей или информации**.

### <a id="Обработка-отказов-сервисов" href="#Обработка-отказов-сервисов">Обработка отказов сервисов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

<a id="Общие-паттерны" href="#Общие-паттерны">Общие паттерны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==============

## <a id="Кэширование" href="#Кэширование">Кэширование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Виды кэширования:
- **FIFO** - если искомый элемент не находится в кэше, он вставляется в хвост очереди. Если нужно освободить место, удаляются элементы из головы очереди. Таким образом вытесняется элемент, находящийся в кэше дольше всех.
- **LRU** - новый элемент вставляется в голову списка. При запроса из кэша элемент перемещается в голову списка. Если нужно освободить место, вытесняется элемент из хвоста списка.
- **MRU** - последний использованный вылетает из кэша.
- **LFU** - каждый элемент имеет счетчик обращений. Новый элемент вставляется в кэш со значением счетчика равным 1. При попадании в кэш счетчик найденного элемента увеличивается на 1. Если нужно освободить место, нужно найти элемент с самым маленьким значением счетчика.
- **SNLRU** (сегментированный LRU) - это N кэшей LRU. Новый элемент вставляется в нулевой LRU кэш. При попадании в кэш элемент перемещается в следующий LRU кэш, либо на MRU (Most Recently Used) позицию последнего LRU кэша, если выше уже идти некуда. При вытеснении элемента из k-го LRU кэша он перемещается в k-1 LRU кэш. По достижению нулевого LRU кэша элемент удаляется.
- **2Q** - кэш разделяется на три части:
    - **In** - FIFO кэш, в который попадают все новые элементы, запрошенные отсюда элементы никуда не перемещаются;
    - **Out** - FIFO кэш, в который попадают элементы, вытесненные из In. При этом этот кэш хранит ключ и не хранит значение, поэтому его можно сделать достаточно большим;
    - **Main** - главный LRU кэш, в который попадают новые элементы запрошенные из Out, в котором они удаляются. При вытеснении элемента из главного кэша он удаляется.
- **MQ** - сегментированный LRU в котором запоминается позиция с которой элемент вылетел - и при повторном запросе - возвращается туда, где был, если не вылетел из очереди запомненных позиций.

## <a id="Паттерн-RORO" href="#Паттерн-RORO">Паттерн RORO</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основной смысл этого принципа заключается во фразе *receive an object, return an object* (получил объект, вернул объект) и применяется для функций:  

`function <имя>(<входящий_объект>) {... return <исходящий_объект>;}`

Этот паттерн позволяет избежать передачи параметров в функцию в заданом порядке и позволяет делать именованные параметры, все это упрощается благодаря декомпозиции. Также это позволяет задать обязательные поля с помощью функции, которая выбрасывает исключения:  
> `function func({key, key2 = requiredParam('key2'), key3 = 4}) {...}`

```javascript
function requiredParam(param) {
    const requiredParamError = new Error(`Required parameter, "${param}" is missing.`);
    if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(
            requiredParamError,
            requiredParam
        );
    }
    throw requiredParamError;
}
```

Благодаря тому что всегда получается и возвращается объект можно реализовать удобную композицию функций:
```javascript
function pipe(...fns) {
    return param => fns.reduce((result, fn) => fn(result), param);
}
```

Эта функция принимает список функций и возвращает одну функцию, которая может выполнить эти функции слева направо, передав первой из этих функций аргументы, переданные в `pipe`, второй - то, что вернет первая функция, и так далее.

> `pipe(validate, normalize, persist)(userInfo)`

## <a id="Паттерн-Ice-Factory" href="#Паттерн-Ice-Factory">Паттерн Ice Factory</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Представляет собой функцию, которая возвращает "замороженный" (иммутабеленый) объект. Используется для построения фабрик по производству объектов, что позволяет скрывать их реализацию:
```javascript
function make<Имя>(<параметры>) { // <параметры> представляют собой объект
    // определение локальных переменных
    const <переменная>[ = <значение>];
    [...]
    //возврат иммутабельного объекта
    return Object.freeze({
        <переменная>[, ...],
        <метод>[, ...]
    });
    //определение методов
    function <метод>() {
        // код, который использует локальные переменные
    }
    [...]
}
```

В этом паттерне вместо наследования применяется композиция.

```javascript
const productList = makeProductList(<параметры>);
const cart = makeShoppingCart(productList);
```

## <a id="Паттерн-BIF" href="#Паттерн-BIF">Паттерн BIF</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Паттерн BIF (Backend In the Frontend) использует ту же логику, которая может применяться при использовании BFF (комбинирование нескольких API и очистка данных), но эта логика перемещается на сторону клиента.

```
    | Backend  |                        | Frontend                        |
    |          |                        |                                 |
    | +------+ | <-[ /auth          ]-> | +------+               +------+ |
    | | Data | | <-[ /profile       ]-> | | BIF  | <-[ /user ]-> | App  | |
    | +------+ | <-[ /notifications ]-> | +------+               +------+ |
```

Его использование не приводит к необходимости убирать какую-то логику из проекта. Он всего лишь отделяет логику одного типа (модификация структур данных) от логики другого типа (формирование пользовательского интерфейса).

Это приводит к комбинированию обращений к Backend через функции. То есть теперь все обращения к внешним данным будут проходить только через функции.

Эти функции также должны производить очистку и модификацию данных для приложения, то есть производить нормализацию данных.

## <a id="Паттерн-Модуль" href="#Паттерн-Модуль">Паттерн Модуль</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Заключается в использовании самовызывающийся функции (IIFE, Immediately-Invoked Function Expression, немедленно вызываемое функциональное выражение), которая возвращает модуль в переменную или объявляет какие-то данные глобально. Подобные функции удобно использовать для того, чтобы решить некую задачу, которую нужно решить лишь один раз, не оставляя при этом ничего лишнего в глобальной области видимости. Внутри этой функции создается приватная область видимости, недоступная извне.

```javascript
[var <Модуль> = ](function () {
    // приватные переменные и функции
    return {
        // публичные переменные
    };
})();
```

## <a id="Внедрение-зависимостей-Dependency-Injection" href="#Внедрение-зависимостей-Dependency-Injection">Внедрение зависимостей Dependency Injection</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Шаблон "**Внедрение зависимостей**" (**Dependency Injection** , **DI**) - основная идея шаблона внедрения зависимостей заключается в предоставлении компонента зависимости в качестве входных данных с помощью внешней сущности. Такой сущностью может быть клиентский компонент или глобальный контейнер, централизованно связывающий все модули системы. Основным преимуществом такого подхода является устранение тесных связей, особенно между модулями и экземплярами с состоянием. При использовании DI все зависимости не создаются внутри модуля, а передаются извне. Это означает, что модуль можно настроить на использование любых зависимостей и, следовательно, повторно использовать в различных контекстах.

Реорганизация модулей для использования DI заключается в следовании простому рецепту: заменить жесткие зависимости от экземпляров с состоянием фабрикой, получающей набор зависимостей в качестве аргументов.

Алгоритм использования:
1. Сначала загружаются фабрики служб; на данный момент они являются объектами без состояния;
2. Затем создается по экземпляру каждой из служб с передачей необходимых зависимостей. Это тот этап, где создаются и соединяются вместе все модули.

Дополнительные виды DI:
- **внедрение через параметры конструктора** - зависимости передаются в конструктор в момент создания объекта;
- **внедрение через свойства** - зависимости внедряются в объект после его создания.

## <a id="Локатор-служб" href="#Локатор-служб">Локатор служб</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Шаблон "**Локатор служб**" - основная идея заключается в наличии центрального реестра для управления компонентами системы, который выступает в качестве посредника при загрузке зависимости любым модулем. Суть в том, что вместо жесткого связывания зависимости запрашиваются у локатора служб.

Важно понимать, что при использовании локатора служб возникает зависимость от него самого, что определяет уровень сцепления модулей и, следовательно, возможность их повторного использования. В Node.js можно определять три вида локаторов служб, в зависимости от порядка подключения к компонентам системы:
- **жесткая зависимость от локатора служб** - подразумевает создание непосредственной ссылки на экземпляр локатора служб с помощью `require()`, это считается антишаблоном, так как приводит к образованию тесной связи с компонентом, предназначенным для ослабления связей;
- **внедрение локатора служб** - с использованием механизма DI;
- **глобальный локатор служб** - ссылка на локатор служб в глобальной области видимости. Имеет те же недостатки, что и жесткое связывание локатора служб, но, поскольку в этом случае локатор носит глобальный характер, то является настоящим объектом одиночкой и, следовательно, может совместно использоваться разными пакетами как общий экземпляр.

Пример локатора служб:
```javascript
module.exports = function () {
    const dependencies = {};
    const factories = {};
    const serviceLocator = {};
    serviceLocator.factory = (name, factory) => {
        factories[name] = factory;
    };
    serviceLocator.register = (name, instance) => {
        dependencies[name] = instance;
    };
    serviceLocator.get = (name) => {
            if(!dependencies[name]) {
                const factory = factories[name];
                dependencies[name] = factory && factory(serviceLocator);
                if(!dependencies[name]) {
                    throw new Error('Cannot find module: ' + name);
                }
            }
            return dependencies[name];
    };
    return serviceLocator;
};
```

Модуль `serviceLocator` является фабрикой, возвращающей объект с тремя методами:
- метод `factory()` используется для связывания имени компонента с фабрикой;
- метод `register()` используется для связывания имени компонента непосредственно с экземпляром;
- метод `get()` извлекает компонент по его имени. Если экземпляр уже доступен, метод просто возвращает его, в противном случае он пытается вызвать зарегистрированную фабрику для получения нового экземпляра.

Важно, что фабрики модулей вызываются путем внедрения текущего экземпляра локатора служб `serviceLocator`, который передается в каждый модуль в качестве параметра. Это основной механизм шаблона, который обеспечивает построение графа зависимостей автоматически или по требованию. Модули-фабрики должны быть вида:
```javascript
module.exports = function (serviceLocator) {
    const <модуль> = serviceLocator.get('<имя_зависимости>');
    ...
};
```

Локатор служб может использоваться для извлечения не только экземпляров компонентов, но и параметров конфигурации, определяющих поведение всего создаваемого графа зависимостей.

Использование в главном модуле:
```javascript
const <serviceLocator> = require('...serviceLocator')();
<serviceLocator>.register('<имя_зависимости>', <экземпляр>);
<serviceLocator>.factory('<имя_зависимости>', require('<путь_к_модулю>'));
```

Минусы:
- затрудняет определение взаимосвязей между компонентами, поскольку они разрешаются во время выполнения;
- компоненты, полагающиеся на локатор служб, хуже подходят для повторного использования, поскольку требуют доступности в системе локатора служб;
- усложняет понимание, какую именно зависимость конкретный компонент собирается затребовать.

## <a id="Контейнер-внедрения-зависимостей-DI-контейнер" href="#Контейнер-внедрения-зависимостей-DI-контейнер">Контейнер внедрения зависимостей, DI-контейнер</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

DI-контейнер, по сути, представляет собой локатор служб с одной дополнительной функцией, определяющей зависимости модуля до создания его экземпляра. Для этого модуль должен объявить свои зависимости одним из способов:
- внедрить набор зависимостей, опираясь на имена аргументов фабрики или конструктора:

    `module.exports = (<имя1>[, <имя2>[, ...]]) => {...}`, чтобы получить возможность прочитать имена аргументов функции необходимо сериализовать функцию и получить ее исходный код. Для этого достаточно вызвать метод `toString()` ссылки на функцию и получить список аргументов с помощью регулярных выражений, имя должно полностью соответствовать зависимости;

- в фабричную функцию можно добавить специальное свойство, например массив, явно перечисляющий все зависимости для внедрения:

    `module.exports = (<имя1>[, <имя2>[, ...]]) => {...};`  
    `module.exports._inject = ['<зависимость1>'[, '<зависимость2>' [, ...]]];`

- модуль можно описать как массив имен зависимостей, за которыми следует фабричная функция:

    `module.exports = ['<зависимость1>'[, '<зависимость2>'[, ...]], (<имя1> [, <имя2> [, ...]]) => {...}];`

- можно использовать аннотацию в виде комментария, добавляемую к каждому аргументу функции:

    `module.exports = (<имя1> /*<зависимость1>*/[, <имя2> /*<зависимость2>*/[, ...]]) => {...};`

Пример DI-контейнера:
```javascript
module.exports = function () {
    const dependencies = {};
    const factories = {};
    const serviceLocator = {};
    diContainer.factory = (name, factory) => {
        factories[name] = factory;
    };
    diContainer.register = (name, instance) => {
        dependencies[name] = instance;
    };
    diContainer.get = (name) => {
        if(!dependencies[name]) {
            const factory = factories[name];
            dependencies[name] = factory && diContainer.inject(factory);
            if(!dependencies[name]) {
                throw new Error('Cannot find module: ' + name);
            }
        }
        return dependencies[name];
    };
    diContainer.inject = (factory) => {
        const args = <функция_вычленения_зависимостей>(factory)
        .map(dependency => diContainer.get(dependency));
            return factory.apply(null, args);
        };
        return diContainer;
    };
```

Модуль `diContainer` является фабрикой, похожим по строению на `serviceLocator`, возвращающей объект с дополнительными методами:
- метод `inject()` используется для определения зависимостей модуля и использующий их для вызова фабрики.

Логика его работы:
1. С помощью функции `<функция_вычленения_зависимостей>` извлекается список аргументов указанной фабричной функции;
2. Затем имя каждого аргумента отображается в экземпляр зависимости, полученный с помощью метода `get()`;
3. В завершение полученный список зависимостей просто передается в вызов фабрики.

Использование в главном модуле:
```javascript
const <diContainer> = require('...diContainer')();
<diContainer>.register('<имя_зависимости>', <экземпляр>);
<diContainer>.factory('<имя_зависимости>', require('<путь_к_модулю>'));
```

## <a id="Плагины" href="#Плагины">Плагины</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Часто в Node.js плагины приложения устанавливаются как пакеты в каталог `node_modules` проекта. Этот способ имеет два преимущества:
- появляется возможность использовать npm для распространения плагинов и управления их зависимостями;
- пакет может иметь собственный граф зависимостей, что снижает вероятность конфликтов и несовместимостей между зависимостями, поскольку плагин не использует зависимости родительского проекта.

Вот как выглядит структура каталогов приложения с плагинами-пакетами:
```
application
'-- node_modules
 |-- plugin1
 |-- ...
 '-- pluginN
```

Расширение, управляемое плагинами и приложением:
- **расширение, управляемое плагином**, является более мощным и гибким, так как часто открывает доступ к внутренним компонентам приложения и дает больше свободы, как если бы плагин был частью самого приложения. Но иногда это может приводить к увеличению ответственности, не давая никаких преимуществ. В самом деле, любое изменение в приложении может влиять на плагин, что требует постоянного его обновления по мере развития основного приложения. В плагин передается само приложение;
- **расширение, управляемое приложением**, требует организации инфраструктуры управления плагинами в самом приложении. Когда расширение управляется плагинами, единственным требованием является поддержка определенного способа расширения компонентами приложения. Из плагина берутся методы и значения и подключаются в определенных местах приложения.

## <a id="Подключение-модулей-инициализируемых-асинхронно" href="#Подключение-модулей-инициализируемых-асинхронно">Подключение модулей, инициализируемых асинхронно</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для модулей у которых длительная инициализация.

Для этого используется шаблон "**Прокси**", в который оборачивается оригинальный модуль и в нем используется шаблон "**Состояние**", которое состоит из двух частей:
- для постановки в очередь всех операций, пока модуль не инициализирован, которые используют шаблон "**Команда**";
- для передачи операций оригинальному модулю после завершения его инициализации.

Вся работа с оригинальным модулем происходит через прокси объект. Прокси-объект изначально имеет состояние, которое помещает все все вызовы методов как команды в очередь, пока инициализация не завершится.

Вызов инициализуруешего метода запускает инициализацию оригинального модуля, передавая метод прокси-объекта как функцию обратного вызова. Это позволяет обертке узнать, когда завершится инициализация оригинального модуля, и выполнить следующие операции:
1. Присвоить переменной, которая отвечает за состояние объект следующего состояния, который работает напрямую с оригинальным модулем или есть сам оригинальный модуль;
2. Выполнить все команды, хранящиеся в очереди;
3. Вызвать оригинальную функцию обратного вызова.

## <a id="Группировка-асинхронных-операций" href="#Группировка-асинхронных-операций">Группировка асинхронных операций</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сама идея очень проста и заключается в том, чтобы при вызове асинхронной функции в момент, когда аналогичный вызов уже находится в режиме ожидания, присоединить обратный вызов к уже выполняемой операции, а не создавать новый запрос.

Преобразовать от:
```
    +----------+  +----------+  +----------------------+  +----------------------+
    | Клиент A |  | Клиент Б |  | Асинхронная операция |  | Асинхронная операция |
    +----------+  +----------+  +----------------------+  +----------------------+
          | запрос с данными                |                         |
          |================================>|                         |
          |             | запрос с теми же данными                    |
          |             |============================================>|
          | ответ       |                   |                         |
          |<--------------------------------|                         |
          |             | ответ             |                         |
          |             |<--------------------------------------------|
    +----------+  +----------+  +----------------------+  +----------------------+
    | Клиент A |  | Клиент Б |  | Асинхронная операция |  | Асинхронная операция |
    +----------+  +----------+  +----------------------+  +----------------------+
```

К:
```
    +----------+  +----------+         +----------------------+
    | Клиент A |  | Клиент Б |         | Асинхронная операция |
    +----------+  +----------+         +----------------------+
          | запрос с данными                       |
          |=======================================>|
          |             | запрос с теми же данными |
          |             |=========================>|
          |             |                #---------------------#
          |             |                # Присоединения к     #
          |             |                # запущенной операции #
          |             |                #---------------------#
          | ответ       |                          |
          |<---------------------------------------|
          |             | ответ                    |
          |             |<-------------------------|
    +----------+  +----------+         +----------------------+
    | Клиент A |  | Клиент Б |         | Асинхронная операция |
    +----------+  +----------+         +----------------------+
```

Для этого используется шаблон "Прокси", который реализует проксирование оригинального программного интерфейса для каждой функции и действует следующим образом:
1. Если очередь для заданной функции с конкретными параметрами уже существует, значит, в настоящее время обрабатывается запрос для заданной функции с конкретными параметрами. В таком случае достаточно добавить обратный вызов в существующую очередь и немедленно вернуть управление. Ничего больше не потребуется;
2. Если очередь для заданной функции с конкретными параметрами отсутствует, необходимо создать новый запрос. Для этого создается новая очередь для заданной функции с конкретными параметрами, куда помещается текущая функция обратного вызова. Затем вызывается оригинальный программный интерфейс, его функция;
3. После, когда оригинальная функция вернет управление, выполняются обход и вызов всех функций в очереди с передачей им результата операции.

Шаблон группировки запросов наиболее эффективен в высоконагруженных приложениях с медленным программным интерфейсом, поскольку именно в этих обстоятельствах имеется возможность группировать наибольшее число запросов.

Можно использовать объект `Promise`, так как к нему можно подключить несколько обработчиков `then()` и он уже кэширует вычисленное значение, что обеспечивает естественный механизм возврата кэшированного значения асинхронным образом. В него оборачивается заданая функция.

Одна из проблем шаблона группировки запросов заключается в том, что чем быстрее работает программный интерфейс, тем меньше запросов можно сгруппировать. То нет никакого смысла пытаться его оптимизировать, но он по-прежнему расходует ресурсы приложения, что в конечном итоге может иметь существенное значение.

## <a id="Кэширование-асинхронных-запросов" href="#Кэширование-асинхронных-запросов">Кэширование асинхронных запросов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Его идея проста и заключается в том, чтобы сохранить результат запроса в кэше, который может быть переменной, записью в базе данных или записью в специализированном сервере кэширования. Тогда при следующем обращении результат можно извлечь непосредственно из кэша, не инициируя нового запроса.

В асинхронном программировании этот шаблон отличается дополнительной поддержкой группировки запросов, что делает его более эффективным. Причина включения такой поддержки - в том, что одновременно может обрабатываться несколько запросов, пока кэш еще не создан, и по завершении этих запросов кэш будет сохранен несколько раз.

Два этапа работы алгоритма оптимального асинхронного кэширования:
- первый этап полностью идентичен шаблону группировки. Любые запросы, полученные в моменты времени, пока кэш еще не создан, объединяются в группу. После обработки запроса кэш сохраняется только один раз;
- если кэш уже создан, все последующие запросы будет обслуживаться непосредственно из него.

Кэш должен очищаться через время или при изменении данных на которые он ссылается.

Основные механизмы по использованию кэша:
- большое количество кэшированных значений может потреблять слишком много памяти. В этом случае избежать чрезмерных затрат памяти поможет применение алгоритма **вытеснения давно неиспользуемых**;
- когда приложение выполняется как группа процессов, использование обычных переменных для хранения кэша может привести к возврату разных результатов разными экземплярами сервера. Если это нежелательно, решить данную проблему можно, использовав для кэша общее хранилище;
- очистка кэша вручную, в отличие от использования механизма истечения срока действия, продлевает существование кэша и при этом позволяет возвращать более актуальные данные, но таким кэшем сложнее управлять.

**Мемоизация** - один из способов кэширования, когда в кэше сохраняются результаты выполнения функции.

Можно использовать объект `Promise`, также как и в группировке асинхронных операций, так как он кэширует результат.

## <a id="Использование-нескольких-процессов" href="#Использование-нескольких-процессов">Использование нескольких процессов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные шаги по реализации делегирования задач:
1. Создать новый модуль, создающий пул процессов. Запуск нового процесса является достаточно затратным в отношении ресурсов и времени, поэтому наличие пула работающих процессов, готовых к обработке запросов, позволит сэкономить время и ресурсы центрального процессора. Кроме того, пул поможет ограничить число одновременно выполняющихся процессов, что позволит исключить риск атак отказ в обслуживании (*denial-of-service*, *DoS*);
2. Создать модуль, отвечающий за абстрагирование задач, выполняемого в дочернем процессе. Его задача - взаимодействие с дочерним процессом и вывод результатов в той форме, как если бы они поступали из текущего приложения;
3. Создать рабочий (дочерний) процесс - программу Node.js, предназначенную только для выполнения алгоритма извлечения подмножеств с заданной суммой элементов и передачи результатов родительскому процессу.

Реализация пула процессов:
```javascript
const child_process = require('child_process');
class ProcessPool {
    constructor(file, poolMax) {
        this.file = file;
        this.poolMax = poolMax;
        this.pool = [];
        this.active = [];
        this.waiting = [];
    }
    acquire(callback) {
        let worker;
        if(this.pool.length > 0) {
            worker = this.pool.pop();
            this.active.push(worker);
            return process.nextTick(callback.bind(null, null, worker));
        }
        if(this.active.length >= this.poolMax) {
            return this.waiting.push(callback);
        }
        worker = child_process.fork(this.file);
        this.active.push(worker);
        process.nextTick(callback.bind(null, null, worker));
    }
    release(worker) {
        if(this.waiting.length > 0) {
            const waitingCallback = this.waiting.shift();
            waitingCallback(null, worker);
        }
        this.active = this.active.filter(w => worker !== w);
        this.pool.push(worker);
    }
}
```

Где:
- `file` - файл с программой для запуска;
- `poolMax` - максимальное количество запущенных экземпляров в пуле;
- `pool` - список готовых к использованию запущенных процессов;
- `active` - список используемых в настоящее время процессов;
- `waiting` - очередь функций обратного вызова для всех запросов, которые не могут быть выполнены немедленно из-за отсутствия доступных процессов;
- `acquire` - возвращающий готовый к использованию процесс, алгоритм его работы:
    - если в пуле имеется готовый к использованию процесс, он просто перемещается в список `active`, а затем возвращается вызовом функции `callback`;
    - если в пуле нет доступных процессов и достигнуто максимальное число запущенных процессов, нужно пождать, пока один из них освободится. Для этого текущий обратный вызов помещается в список `waiting`;
    - если еще не достигнуто максимальное число запущенных процессов, вызовом функции `child_process.fork()` создается новый процесс и добавляется в список `active` с последующим возвратом этого процесса с помощью функции `callback`;
- `release` - возвращает процесс обратно в пул, алгоритм его работы:
    - если в списке `waiting` имеется запрос, выполняется переназначение освободившегося рабочего процесса путем передачи ему обратного вызова из начала очереди `waiting`;
    - в противном случае рабочий процесс исключается из списка `active` и помещается обратно в пул.

Чтобы уменьшить объем памяти, не используемой долгое время, и повысить надежность пула, можно:
- уничтожать процессы, простаивающие определенное время, для высвобождения памяти;
- добавить механизм уничтожения зависших процессов или перезапуска тех из них, в работе которых возник сбой.

Взаимодействие с дочерним процессом:
```javascript
const ProcessPool = require('./processPool');
const workers = new ProcessPool(__dirname + '<файл_с_программой>', <макс_кол_экземпляров>);
workers.acquire((err, worker) => {
    worker.send(<объект_с_данными_для_задачи>);//отправка сообщения с исходными данными дочернему процессу
    const onMessage = msg => {//рабочий процесс генерирует сообщения в формате {event, data}
        if (msg.event === 'end') {//обработка завершения операции по событию end
            worker.removeListener('message', onMessage);
            workers.release(worker);
        }
        //дальнейшая обработка данных из процесса
    };
    worker.on('message', onMessage);//подключение функции для приема сообщений, возвращаемых рабочим процессом
});
```

Взаимодействие с родительским процессом:
```javascript
process.on('message', msg => {
    //обработка сообщения, поступающие от родительского процесса
    process.send({event: 'end', data: <данные>});//отправка родительскому процессу данных в формате {event, data}
});
```

> **DoS-атака** - это попытка сделать машину или сетевой ресурс недоступным для предполагаемых пользователей, чтобы временно или постоянно отключить или приостановить службу, действующую на подключенном к Интернету узле.

## <a id="Масштабирование-приложений" href="#Масштабирование-приложений">Масштабирование приложений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Распределение нагрузки** - технология распределения нагрузки приложения между несколькими процессами и машинами.

Модель **куб масштабирования** описывает масштабируемость с точки зрения трех размерностей:
- *ось x* - клонирование - заключается в клонировании одного и того же приложения n раз, что позволяет каждому экземпляру обрабатывать 1/n-часть рабочей нагрузки;
- *ось y* - разделение на службы/функциональные особенности - обозначает декомпозицию приложений по функциональным особенностям, службам или вариантам использования. Предполагает создание разных автономных приложений, каждое из которых обладает собственной базой кода, а иногда и выделенной базой данных и даже отдельным пользовательским интерфейсом, чаще всего ассоциируется с термином "**микрослужбы**";
- *ось z* - разбиение на разделы данных - определяет такое разбиение приложения, что каждый из его экземпляров отвечает только за часть всего массива данных. Этот метод используется в основном для баз данных и по-другому называется **горизонтальным разделением**, или **шардингом** (*sharding*). Каждый из разделов соотносится с конкретным экземпляром приложения. Использование разделов данных требует перед каждой операцией определять, какой именно экземпляр приложения отвечает за нужный раздел данных. Виды разбиения на разделы данных:
    - **списочное разделение**;
    - **диапазонное разделение**;
    - **хешевое разделение**.

Нижний левый угол куба представляет приложения, все функциональные возможности и службы которых сосредоточены в единой (монолитной) базе кода, выполняющейся в одном экземпляре.

### <a id="Клонирование-и-распределение-нагрузки" href="#Клонирование-и-распределение-нагрузки">Клонирование и распределение нагрузки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Приложению Node.js доступен один поток и ему по умолчанию доступен ограниченный объем памяти 1,7 ГБ на 64-битных машинах (этот предел можно увеличить с помощью специального параметра командной строки `--max_old_space_size=<размер_в_МБ>`).

Виды масштабирования:
- **вертикальное масштабирование** - наращивание ресурсов одной машины;
- **горизонтальное масштабирование** - добавление в инфраструктуру дополнительных машин.

С помощью модуля `cluster` можно обеспечить **отказоустойчивость и высокую доступность**. Главная точка входа оборачивается в модуль, который подключается с помощью: `cluster.fork(<путь_к_модулю>);` и проверяется в главном кластере событие и если подтверждается что процесс завершился из-за ошибки, запускается новый рабочий процесс:
```javascript
cluster.on('exit', (worker, code) => {
    if(code != 0 && !worker.suicide) {
        cluster.fork();
    }
});
```

**Перезапуск без простоя** можно организовать с помощью модуля `cluster`. Суть решения заключается в том, чтобы перезапускать рабочие процессы по одному. В этом случае остальные рабочие процессы продолжат выполняться и обслуживать приложение. Основной алгоритм работы:
1. Перезапуск рабочих процессов начинается после получения сигнала, указывающего на перезапуск;
2. Создается функция `restartWorker()`, которая реализует шаблон асинхронных последовательных итераций по элементам объекта `cluster.workers` и замыкается на нем;
3. Первая задача функции `restartWorker()` - безопасно остановить рабочий процесс вызовом метода `worker.disconnect()`;
4. После завершения процесса запускается новый рабочий процесс:
    ```javascript
    worker.on('exit', () => {
        if (!worker.suicide) return;
        const newWorker = cluster.fork();
        newWorker.on('listening', () => {
            restartWorker(i + 1);
        });
    });
    ```
5. Только когда новый рабочий процесс будет готов к приему новых соединений, по событию `'listening'`, можно перейти к следующей итерации и приступить к перезапуску очередного рабочего процесса.

**Взаимодействия с сохранением состояния** можно организовать с помощью:
- **совместного использования состояния всеми экземплярами** - для этого потребуется общее хранилище данных;
- **распределением нагрузки с привязкой** - когда балансировщик нагрузки получает запрос на создание нового сеанса, он связывает этот сеанс с одним конкретным экземпляром, выбранным алгоритмом распределения нагрузки. В следующий раз, получив запрос в рамках того же сеанса, балансировщик минует алгоритм распределения нагрузки и выберет тот экземпляр приложения, который был ранее связан с сеансом. Главная проблема заключается в том, что оно сводит на нет преимущества избыточной системы, где все экземпляры приложения равноценные и где любой из экземпляров может заменить тот, что перестал работать.

**Масштабирование с помощью обратного проксирования** является запуск нескольких автономных экземпляров одного и того же приложения, прослушивающих разные порты или выполняющихся на разных машинах, и использование **обратного прокси-сервера** (или шлюза) для доступа к этим экземплярам и распределения трафика между ними. В такой конфигурации отсутствует главный процесс, распределяющий запросы между рабочими процессами, вместо этого имеется множество автономных процессов, запущенных на одном компьютере (и прослушивающих разные порты) или разбросанных по нескольким компьютерам в сети. Роль единой точки доступа к приложению играет **обратный прокси-сервер** - специальное устройство или служба, - находящийся между клиентами и экземплярами приложения, который принимает все запросы, передает их конечному серверу и возвращает результат клиенту, как будто он сам его создал. В этом случае обратный прокси-сервер используется также в качестве балансировщика нагрузки, распределяя запросы между экземплярами приложения.

**Динамическое масштабирование** - если приложение снижает производительность из-за роста нагрузки, автоматически подключаются серверы, помогающие справиться с этой повышенной нагрузкой. Поддерживается также возможность остановки некоторых серверов в определенные часы, например ночью, когда трафик существенно меньше, и запуска их снова по утрам. Этот механизм требует распределения нагрузки в зависимости от актуальной топологии сети, чтобы знать, когда следует запускать серверы.

**Реестром служб** - хранит информацию о действующих серверах и предоставляемых ими услугах, т.е. используется как центральное хранилище актуальных данных о доступных в системе серверах и службах. Для работы в автоматическом режиме все экземпляры приложения должны регистрироваться в реестре после перехода в состояние готовности принимать запросы и отменять регистрацию перед завершением работы. Благодаря этому балансировщик нагрузки всегда обладает актуальными сведениями о доступных серверах и службах.

### <a id="Динамическое-распределение-нагрузки-с-помощью-http-proxy-и-Consul" href="#Динамическое-распределение-нагрузки-с-помощью-http-proxy-и-Consul">Динамическое распределение нагрузки с помощью http-proxy и Consul</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные пакеты:
- `http-proxy` - библиотека, упрощающая создание прокси-серверов и средства распределения нагрузки на платформе Node.js;
- `portfinder` - библиотека, помогающая обнаруживать свободные порты в системе;
- `consul` - библиотека, обеспечивающая регистрацию служб в реестре Consul.

Файл `app.js`:
```javascript
const http = require('http');
const pid = process.pid;
const consul = require('consul')();
const portfinder = require('portfinder');
const serviceType = process.argv[2];
portfinder.getPort((err, port) => {
    const serviceId = serviceType + port;
    consul.agent.service.register({
        id: serviceId,
        name: serviceType,
        address: 'localhost',
        port: port,
        tags: [serviceType]
    }, () => {
        const unregisterService = (err) => {
            consul.agent.service.deregister(serviceId, () => {
                process.exit(err ? 1 : 0);
            });
        };
        process.on('exit', unregisterService);
        process.on('SIGINT', unregisterService);
        process.on('uncaughtException', unregisterService);
        http.createServer((req, res) => {
            for (let i = 1e7; i> 0; i--) {}
            console.log(`Handling request from ${pid}`);
            res.end(`${serviceType} response from ${pid}\n`);
        }).listen(port, () => {
            console.log(`Started ${serviceType} (${pid}) on port ${port}`);
        });
    });
});
```

Отвечает за отдельный сервер, где:
- `portfinder.getPort` - вызывается чтобы получить свободный порт (по умолчанию `portfinder` начинает поиск с порта 8000);
- `consul.agent.service.register` - выполняется регистрация новой службы в реестре. Где:
    - `id` - уникальное имя службы;
    - `name` - общее имя, идентифицирующее службу;
    - `address` и `port` - адрес и порт для доступа к службе;
    - `tags` - необязательный массив тегов, используемый для фильтрации и группировки служб.
- `unregisterService` - функция, которая позволит удалить службу, зарегистрированную в реестре Consul, которая вызывается в момент завершения программы (намеренного или случайного), для отмены регистрации в реестре служб Consul;
- в конце выполняется запуск HTTP-сервера, прослушивающего порт, обнаруженный с помощью `portfinder`.

Файл `loadBalancer.js`:
```javascript
const routing = [
    {
        path: '/api',
        service: 'api-service',
        index: 0
    },
    {
        path: '/',
        service: 'webapp-service',
        index: 0
    }
];
const http = require('http');
const httpProxy = require('http-proxy');
const consul = require('consul')();
const proxy = httpProxy.createProxyServer({});
http.createServer((req, res) => {
    let route;
    routing.some(entry => { // [2]
        route = entry;
        return req.url.indexOf(route.path) === 0;
    });
    consul.agent.service.list((err, services) => { // [3]
        const servers = [];
        Object.keys(services).filter(id => { //
            if (services[id].Tags.indexOf(route.service) > -1) {
                servers.push(`http://${services[id].Address}:${services[id].Port}`)
            }
        });
        if (!servers.length) {
            res.writeHead(502);
            return res.end('Bad gateway');
        }
        route.index = (route.index + 1) % servers.length; // [4]
        proxy.web(req, res, {target: servers[route.index]});
    });
}).listen(8080, () => console.log('Load balancer started on port 8080'));
```

Отвечает за сервер отвечающий за распределение нагрузки, это главный сервер, который контролирует все службы, где:
- `routing` - содержит таблицу соответствия URL-путей и служб, где:
    - `path` - путь (адрес);
    - `service` - имя службы;
    - `index` - указывает на следующий сервер в списке, в соответствии с циклическим алгоритмом;
- `routing.some` - выполняется поиск URL-адреса в таблице маршрутизации. В результате извлекается дескриптор, содержащий имя службы;
- `consul.agent.service.list` - извлекается список серверов, реализующих требуемые службы. Если этот список пуст, клиенту возвращается ошибка. Атрибут Tag используется для фильтрации всех доступных служб и поиска адресов серверов, реализующих данный вид службы;
- `route.index` - изменяется так чтобы он указывал на следующий сервер в списке;
- `proxy.web` - обеспечивает отправку запроса выбранному серверу вместе с объектами запроса (`req`) и ответа (`res`).

Запуск:
```bash
# запуск реестра служб
consul agent -dev
# запуск балансировщика нагрузки
node loadBalancer
# запуск нескольких экземпляров служб
forever start app.js api-service
forever start app.js api-service
forever start app.js webapp-service
```

Таким образом можно масштабировать инфраструктуру динамически, по требованию или по расписанию, и балансировщик нагрузки будет автоматически корректировать свою работу в соответствии с новой конфигурацией.

### <a id="Одноранговое-распределение-нагрузки" href="#Одноранговое-распределение-нагрузки">Одноранговое распределение нагрузки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Оно состоит в том что распределять запросы будет клиент, который будет отвечать за распределение нагрузки между различными экземплярами служб. Тогда клиент будет знать подробности реализации серверов, предоставляющих службы, что во внутренней сети является обычной практикой. Обеспечивает следующие преимущества:
- снижение сложности инфраструктуры путем удаления сетевого узла;
- ускорение взаимодействий, поскольку маршрут передачи сообщений сокращается на один узел;
- улучшение масштабирования, так как производительность не ограничиваетсявозможностями балансировщика нагрузки.

Недостатки:
- исключение обратного прокси-сервера приводит к раскрытию всей сложной внутренней инфраструктуры;
- возлагается реализация алгоритма распределения нагрузки;
- возлагается хранение актуальных сведений об инфраструктуре.

Файл `balancedRequest.js`:
```javascript
const http = require('http');
const servers = [
    {host: 'localhost', port: '8081'},
    {host: 'localhost', port: '8082'}
];
let i = 0;
module.exports = (options, callback) => {
    i = (i + 1) % servers.length;
    options.hostname = servers[i].host;
    options.port = servers[i].port;
    return http.request(options, callback);
};
```

Обертывает оригинальный программный интерфейс `http.request` и подменяет значения `hostname` и `port` в запросе значениями, выбранными из списка доступных серверов `servers` с помощью циклического алгоритма.

Файл `client.js`:
```javascript
const request = require('./balancedRequest');
for (let i = 10; i>= 0; i--) {
    request({method: 'GET', path: '/'}, res => {
        let str = '';
        res.on('data', chunk => {
            str += chunk;
        }).on('end', () => {
            console.log(str);
        });
    }).end();
}
```

Использование однорангово распределения нагрузки.

Запуск:
```bash
# запуск нескольких экземпляров служб
node app 8081
node app 8082
# запуск клиента
node client
```

## <a id="Примитивная-одержимость" href="#Примитивная-одержимость">Примитивная одержимость</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это использование примитивных значений там где сложный тип будет более подходящим является анти-паттерном.