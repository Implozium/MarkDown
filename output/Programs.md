[Содержание](#Содержание)
==========

- [Docker](#Docker)
    - [Файл **Dockerfile**](#Файл-Dockerfile)
        - [Инструкции файла **Dockerfile**](#Инструкции-файла-Dockerfile)
    - [Сборка](#Сборка)
        - [Команды для управления образами](#Команды-для-управления-образами)
    - [Работа с контейнирами](#Работа-с-контейнирами)
        - [Команды для управления контейнерами](#Команды-для-управления-контейнерами)
    - [Тома Docker](#Тома-Docker)
        - [Команды для работы с томами](#Команды-для-работы-с-томами)
    - [Другие команды](#Другие-команды)
    - [`docker-compose`](#docker-compose)
- [Redis](#Redis)
- [`curl`](#curl)

<a id="Docker" href="#Docker">Docker</a>
======

`service docker start` - запуск службы docker.  
`service docker stop` - остановка службы docker.

**Образы** - это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит.

## <a id="Файл-Dockerfile" href="#Файл-Dockerfile">Файл **Dockerfile**</a>

Файл **Dockerfile** (именно так должен он именоваться) содержит набор инструкций, следуя которым Docker будет собирать образ контейнера.

**Контейнеры** - состоят из слоёв. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. **Dockerfile** сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.  
Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** (родительский) - это то, что является исходным слоем (или слоями) создаваемого образа.

### <a id="Инструкции-файла-Dockerfile" href="#Инструкции-файла-Dockerfile">Инструкции файла **Dockerfile**</a>

Состоит из инструкций, после которых идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать: открыть какой-то порт или выполнить какую-то команду.

Инструкции:
- `# <коментарий>` - коментарий;
- `FROM <имя_родительского_образа>[:<версия>] [AS <алиас>]` - (обязательная) задаёт базовый (родительский) образ [если версия не указана, то возьмется последняя] [с указаным алиасом] - начинает новый шаг сборки:
    > `FROM ubuntu:18.04`

    Рекомендуется использовать базовые образы, основанные на Alpine Linux.
- `LABEL <ключ>=<значение>` - описывает метаданные. Например - сведения о том, кто создал и поддерживает образ - содержат в себе полезную информацию об образе Docker:
    > `LABEL maintainer="jeffmshale@gmail.com"`
- `ENV <ключ>=<значение>[ ...]` - устанавливает постоянные переменные среды:
    > `ENV ADMIN="jeff"`
- `RUN <команда1>[ && ...]`  
  `RUN ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов или выполнения вспомогательный действий. После её выполнения в образ добавляется новый слой, его состояние фиксируется:
    > `RUN apk update && apk upgrade && apk add bash && apk add --update git`  
    > `RUN ["mkdir", "/a_directory"]`
    
    В конце установки пакетов рекомендуется удалять их кеш: `&& rm -rf /var/lib/apt/lists/*`
- `COPY [--from=<алиас_образа>] <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует в контейнер файлы и папки [с указаного образа]:
    > `COPY . ./app`
- `ADD <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или добавлять файлы из сети:
    > `ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory`
- `CMD <команда1>[ && ...]`  
  `CMD ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней. Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в **Dockerfile**:
    > `CMD ["python", "./my_script.py"]`
- `WORKDIR <директория>` - задаёт рабочую директорию для следующей инструкции, автоматически создаёт директорию в том случае, если она не существует:
    > `WORKDIR /usr/src/my_app_directory`
- `ARG <имя_переменной>=<значение_по_умолчанию>` - позволяет задать переменную, значение которой можно передать из командной строки в образ, во время его сборки их можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа или в качестве аргументов для команд `RUN`, `CMD`, `ENTRYPOINT` в виде `"<имя_переменной>"` или `${<имя_переменной>}`:
    > `ARG bd=oracle`
- `ENTRYPOINT ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - предоставляет команду с аргументами для вызова во время выполнения контейнера, параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки, а дополняются к команде запуска:
    > `ENTRYPOINT ["python", "./app/my_script.py", "my_var"]`
- `EXPOSE <порт>[ ...]` - указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run -p <порт>`. Если использовать ключ в виде `-P`, то открыты будут все порты, указанные в инструкции `EXPOSED`:
    > `EXPOSE 8000`
- `VOLUME <том>[ ...]` - позволяет указать место - том, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами:
    > `VOLUME /my_volume`

```Dockerfile
FROM node:8 AS build
# Папки
RUN mkdir /app && mkdir /src
WORKDIR /src
# Установка зависимостей
COPY package*.json ./
RUN npm install
# Для использования в продакшне
# RUN npm install --production
# Копирование файлов проекта и сборка проекта
COPY . .
RUN npm run build:production
# В результате получается образ, состоящий из одного слоя
FROM node:alpine
# Копируем собранные файлы из папки build в папку app
COPY --from=build ./build/* /app
ENTRYPOINT ["/app"]
# Уведомление о порте, который будет прослушивать работающее приложение
EXPOSE 3000
# Запуск проекта
CMD ["npm", "run"]
```

Файл `.dockerignore` позволяет игнорировать файлы и папки, в которых нет необходимости при сборке образа, размещается там же, где находится файл **Dockerfile**, поддерживает шаблоны имён файлов (похож на файл `.gitignore`).

## <a id="Сборка" href="#Сборка">Сборка</a>

### <a id="Команды-для-управления-образами" href="#Команды-для-управления-образами">Команды для управления образами</a>

- `docker image build [--build-arg [<имя_переменной>=<значение>[ ...]]] -t <имя>[:<тег>] <путь>`  
    `docker build ...` - собирает образ Docker [с установлением значений переменных] с именем `<имя>` [и тегом `<тег>`] из **Dockerfile** по контексту сборки - из набора файлов, расположенных по определённому пути или URL;
- `docker image ls` - выводит в консоль размеры образов;
- `docker image history <имя_образа>[:<версия>]` - выводит в консоль размеры промежуточных образов, из которых собран некий образ;
- `docker image inspect <имя_образа>[:<версия>]` - выводит в консоль подробные сведения об образе, в том числе - размер каждого его слоя;
- `docker image rm <образ>`  
    `docker rmi <образ>` - удаляет образ.

## <a id="Работа-с-контейнирами" href="#Работа-с-контейнирами">Работа с контейнирами</a>

### <a id="Команды-для-управления-контейнерами" href="#Команды-для-управления-контейнерами">Команды для управления контейнерами</a>

- `docker container create [-p <порт>:<expose_порт>] [--name <имя>] <образ>` - создание контейнера [с именем `<имя>`], на основе указанного образа [с проброшеными портами внутрь];
- `docker container start <контейнер>[ ...]` - запуск существующего контейнера[-ов];
- `docker container run [-p <порт>:<expose_порт>] [--name <имя>] [--rm] [-d] [--mount type=volume,source=<том>,destination=<путь_монтирования>] <образ> [-it <команда>]`  
    `docker run ...` - запускает контейнер [с проброшеными портами внутрь] [с именем `<имя>`] [и удаляет его после завершения работы контейнера] [в фоновом режиме] [с монтирование тома с именем `<том>` по пути `<путь_монтирования>`], на основе указанного образа [, а в нем указаную команду];
- `docker container ls [-s] [-a]` - вывод списка работающих контейнеров [с их примерным размером] [всех контейнеров];
- `docker container inspect [-s] <контейнер>[ ...]` - вывод подробной информации о контейнере [с их общим размером];
- `docker container logs [-f] [--tail=<количество>] <контейнер>`  
    `docker logs ...` - вывод логов контейнера [в реальном времени] [только указаное количество последних строк];
- `docker container stop <контейнер>[ ...]`  
    `docker stop ...` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время, `SIGKILL`;
- `docker container kill <контейнер>[ ...]`  
    `docker kill ...` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`;
- `docker container rm <контейнер>[ ...]`  
    `docker rm ...` - удаление остановленного контейнера.

## <a id="Тома-Docker" href="#Тома-Docker">Тома Docker</a>

**Том** - это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker.

### <a id="Команды-для-работы-с-томами" href="#Команды-для-работы-с-томами">Команды для работы с томами</a>

`docker volume create --name <имя_тома>` - создает том.  
`docker volume ls` - выводит список томов.  
`docker volume inspect <имя_тома>` - вывод подробной информации о томе.  
`docker volume rm <имя_тома>` - удаляет том.  
`docker volume prune` - удаляет не используемые контейнерами тома.  

## <a id="Другие-команды" href="#Другие-команды">Другие команды</a>

`docker stats $(docker ps -q)` - непрерывно выводит в консоль статуса работающих контейнеров.

`docker ps {--all | -a}` - выводит в консоль статус контейнеров.  
`docker ps {--quiet | -q}` - выводит в консоль только id контейнеров.

`docker exec -it <контейнер> sh` - подключается к докеру для выполнения команд. `exit` - выход из докера.

`docker system prune [-a] [--volumes]` - удаляет неиспользуемые контейнеры, которым не назначено имя и тег [все] , сети и образы, [тома].

`docker restart <контейнер>` - перезапускает указанный контейнер.  
`docker restart $(docker ps -a -q)`  - перезапускает все контейнеры.

## <a id="docker-compose" href="#docker-compose">`docker-compose`</a>

Файл `docker-compose.yml` - это файл Docker Compose, который будет содержать инструкции, необходимые для запуска и настройки сервисов.

```yml
version: "3"
# 1 сервис = 1 контейнер.
# Сервисом может быть клиент, сервер, сервер баз данных...
services:
    <имя_сервиса>:
        # Ключевое слово "build" позволяет задать путь к файлу Dockerfile, который нужно использовать для создания образа, который позволит запустить сервис.
        # Здесь <путь> соответствует пути к папке сервера, которая содержит соответствующий Dockerfile.
        build: <путь>
        # Команда, которую нужно запустить после создания образа.
        command: <команда>
        # Для перенаправления портов применяется следующая конструкция: [порт компьютера]:[порт контейнера]
        ports:
            - <порт_компьютера>:<порт_контейнера]>
        # Ключевое слово 'network_mode' используется для описания типа сети, указывается то, что контейнер может обращаться к 'localhost' компьютера.
        network_mode: host
        # Ключевое слово 'depends_on' позволяет указывать, должен ли сервис, прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы <имя_сервиса>.
    
        depends_on:
            - <имя_сервиса>
```

`docker-compose build` - выполняет команды `build` для всех сервисов.

`docker-compose down` - остановка всех контейнеров.  
`docker-compose up -d` - запуск всех остановленных контейнеров.  
`docker-compose restart`  - перезапускает все контейнеры.  
`docker-compose restart <контейнер>` - перезапускает указанный контейнер.

`docker-compose logs -f <контейнер>` - выводит журналы сервиса.

`docker-compose ps` - выводит список контейнеров.

`docker-compose exec <контейнер> <команда>` - выполняет команду в выполняющемся контейнере.

<a id="Redis" href="#Redis">Redis</a>
=====

`redis-cli <команда>[ <арг1>[ ...]]` - базовое выполнение команд.

`redis-cli DEL <ключ>` - удаляет ключ.

`redis-cli HGET <ключ> <поле>` - выводит в консоль значение поля указаного ключа (хеш-таблицы).  
`redis-cli HSET <ключ> <поле> "<значение>"` - устанавливает значение поля указаного ключа (хеш-таблицы).

`redis-cli --raw keys *<маска>*` - возвращает список ключей, которые соответствуют маске.  
`redis-cli --raw keys *<маска>* | xargs redis-cli DEL` - удаляет все ключи, которые соответствуют маске

<a id="curl" href="#curl">`curl`</a>
======

`curl [<опции>] <url>` - базовый вызов адреса `<url>`, по умолчанию GET.

Опции:

- `-i` - выводит заголовки ответа;
- `-F '<имя_поля>=@<путь_к_файлу>'` - добавляет содержимое файла в указаное поле;
- `-X POST` - изменяет тип запроса на POST;
- `-H "<имя_заголовка>: <значение_заголовка>"` - добавляет заголовок в запрос;

Примеры:

`curl -F '<имя_поля>=@<путь_к_файлу>'[ ...] <url>` - загружает файл на указанный адрес `<url>`.  
`curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <soap_метод_вызова>" --data-binary @<путь_к_файлу_xml> <url>` - отправляет soap запрос с указанным действием `<soap_метод_вызова>` на адрес `<url>` с телом запроса из файла.