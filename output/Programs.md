[Содержание](#Содержание)
==========

- [Docker](#user-content-Docker)
    - [Файл **Dockerfile**](#user-content-Файл-Dockerfile)
        - [Инструкции файла **Dockerfile**](#user-content-Инструкции-файла-Dockerfile)
    - [Сборка](#user-content-Сборка)
        - [Команды для управления образами](#user-content-Команды-для-управления-образами)
    - [Работа с контейнерами](#user-content-Работа-с-контейнерами)
        - [Команды для управления контейнерами](#user-content-Команды-для-управления-контейнерами)
    - [Тома Docker](#user-content-Тома-Docker)
        - [Команды для работы с томами](#user-content-Команды-для-работы-с-томами)
    - [Другие команды](#user-content-Другие-команды)
    - [`docker compose`](#user-content-docker-compose)
    - [Примеры](#user-content-Примеры)
        - [Файлы для сервера ноды](#user-content-Файлы-для-сервера-ноды)
- [Kubernetes](#user-content-Kubernetes)
    - [Манифест](#user-content-Манифест)
    - [Helm](#user-content-Helm)
        - [Шаблоны](#user-content-Шаблоны)
- [Terraform](#user-content-Terraform)
    - [Переменные](#user-content-Переменные)
    - [Ресурсы](#user-content-Ресурсы)
    - [Сохранение значений](#user-content-Сохранение-значений)
        - [Разворачивание инфраструктуры](#user-content-Разворачивание-инфраструктуры)
        - [Разное](#user-content-Разное)
- [Redis](#user-content-Redis)
- [`curl`](#user-content-curl)
- [`jq`](#user-content-jq)
- [`nmap`](#user-content-nmap)
- [`nginx`](#user-content-nginx)
    - [Подключение конфигурации](#user-content-Подключение-конфигурации)
    - [Переменные](#user-content-Переменные)
    - [Условия](#user-content-Условия)
    - [Глобвльные переменные](#user-content-Глобвльные-переменные)
    - [Директивы](#user-content-Директивы)
- [`vim`](#user-content-vim)
    - [Обычный режим](#user-content-Обычный-режим)
    - [Навигация и окна](#user-content-Навигация-и-окна)
    - [Режим вставки](#user-content-Режим-вставки)
    - [Визуальный режим](#user-content-Визуальный-режим)
    - [Командный режим](#user-content-Командный-режим)
    - [Особые команды](#user-content-Особые-команды)

<a id="Docker" href="#Docker">Docker</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`service docker start` - запуск службы docker.  
`service docker stop` - остановка службы docker.

**Образы** - это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит.

## <a id="Файл-Dockerfile" href="#Файл-Dockerfile">Файл **Dockerfile**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Файл **Dockerfile** (именно так должен он именоваться) содержит набор инструкций, следуя которым Docker будет собирать образ контейнера.

**Контейнеры** - состоят из слоев. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. **Dockerfile** сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.  
Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** (родительский) - это то, что является исходным слоем (или слоями) создаваемого образа.

Docker-образы создаются с помощью инструкций, таких как запуск команды, добавление файла или директории, создание переменной окружения. Инструкции хранятся в `Dockerfile` - это обычный текстовый файл.

Каждая инструкция создает новый слой образа, и эти слои накладываются друг на друга.

Процесс создания образа - это считывание и выполнение инструкций из `Dockerfile`.

### <a id="Инструкции-файла-Dockerfile" href="#Инструкции-файла-Dockerfile">Инструкции файла **Dockerfile**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из инструкций, после которых идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать: открыть какой-то порт или выполнить какую-то команду.

Инструкции:
- `# <коментарий>` - коментарий;
- `FROM <имя_родительского_образа>[:<версия>] [AS <алиас>]` - (обязательная) задает базовый (родительский) образ [если версия не указана, то возьмется последняя] [с указаным алиасом] - начинает новый шаг сборки:
    > `FROM ubuntu:18.04`

    Рекомендуется использовать базовые образы, основанные на Alpine Linux.

- `LABEL <ключ>=<значение>` - описывает метаданные. Например - сведения о том, кто создал и поддерживает образ - содержат в себе полезную информацию об образе Docker:
    > `LABEL maintainer="jeffmshale@gmail.com"`

- `ENV <ключ>=<значение>[ ...]` - устанавливает постоянные переменные среды:
    > `ENV ADMIN="jeff"`

- `RUN <команда1>[ && ...]`.

  `RUN ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - выполняет команду и создает слой образа. Используется для установки в контейнер пакетов или выполнения вспомогательный действий. После ее выполнения в образ добавляется новый слой, его состояние фиксируется:
    > `RUN apk update && apk upgrade && apk add bash && apk add --update git`  
    > `RUN ["mkdir", "/a_directory"]`

    В конце установки пакетов рекомендуется удалять их кэш: `&& rm -rf /var/lib/apt/lists/*`

- `COPY [--from=<алиас_образа>] <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует в контейнер файлы и папки [с указаного образа]:
    > `COPY . ./app`

- `ADD <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или добавлять файлы из сети:
    > `ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory`

- `CMD <команда1>[ && ...]`.

  `CMD ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней. Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в **Dockerfile**:
    > `CMD ["python", "./my_script.py"]`

- `WORKDIR <директория>` - задает рабочую директорию для следующей инструкции, автоматически создает директорию в том случае, если она не существует:
    > `WORKDIR /usr/src/my_app_directory`

- `ARG <имя_переменной>=<значение_по_умолчанию>` - позволяет задать переменную, значение которой можно передать из командной строки в образ, во время его сборки их можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа или в качестве аргументов для команд `RUN`, `CMD`, `ENTRYPOINT` в виде `"<имя_переменной>"` или `${<имя_переменной>}`:
    > `ARG bd=oracle`

- `ENTRYPOINT ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - предоставляет команду с аргументами для вызова во время выполнения контейнера, параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки, а дополняются к команде запуска:
    > `ENTRYPOINT ["python", "./app/my_script.py", "my_var"]`

- `EXPOSE <порт>[ ...]` - указывает на то, какие порты планируется открыть внутри контейнера для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run -p <порт>`. Если использовать ключ в виде `-P`, то открыты будут все порты, указанные в инструкции `EXPOSE`:
    > `EXPOSE 8000`

- `VOLUME <том>[ ...]` - позволяет указать место - том, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами:
    > `VOLUME /my_volume`

```Dockerfile
FROM node:8 AS build
# Папки
RUN mkdir /app && mkdir /src
WORKDIR /src
# Установка зависимостей
COPY package*.json ./
RUN npm install
# Для использования в продакшне
# RUN npm install --production
# Копирование файлов проекта и сборка проекта
COPY . .
RUN npm run build:production
# В результате получается образ, состоящий из одного слоя
FROM node:alpine
# Копируем собранные файлы из папки build в папку app
COPY --from=build ./build/* /app
ENTRYPOINT ["/app"]
# Уведомление о порте, который будет прослушивать работающее приложение
EXPOSE 3000
# Запуск проекта
CMD ["npm", "run"]
```

Файл `.dockerignore` позволяет игнорировать файлы и папки, в которых нет необходимости при сборке образа, размещается там же, где находится файл **Dockerfile**, поддерживает шаблоны имен файлов (похож на файл `.gitignore`).

## <a id="Сборка" href="#Сборка">Сборка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Команды-для-управления-образами" href="#Команды-для-управления-образами">Команды для управления образами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `docker image build [--build-arg [<имя_переменной>=<значение>[ ...]]] [-f <путь_к_Dockerfile>] [--no-cache] [--progress=plain] -t <имя_образа> <путь_к_каталогу_сборки>` - собирает образ Docker [с установлением значений переменных] из `Dockerfile` [который находится по `<путь_к_Dockerfile>`] с именем `<имя_образа>` [и тегом `<тег>`] из **Dockerfile** по контексту сборки - из набора файлов, расположенных по определенному пути или URL:
    > `docker image build -f my-dockerfile -t my-image .`
- `docker build [--build-arg [<имя_переменной>=<значение>[ ...]]] -t <имя_образа>[:<тег>] <путь_к_каталогу_сборки>` - аналогично предыдущей;
- `docker image ls` - выводит в консоль размеры образов;
- `docker image history <имя_образа>[:<версия>]` - выводит в консоль размеры промежуточных образов, из которых собран некий образ;
- `docker image inspect <имя_образа>[:<версия>]` - выводит в консоль подробные сведения об образе, в том числе - размер каждого его слоя;
- `docker image rm <образ>` - удаляет образ;
- `docker rmi <образ>` - аналогично предыдущей;
- `docker push <имя_образа>` - помещает образ в хранилище;
- `docker pull <имя_образа>` - загружает образ из хранилища.

## <a id="Работа-с-контейнерами" href="#Работа-с-контейнерами">Работа с контейнерами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Команды-для-управления-контейнерами" href="#Команды-для-управления-контейнерами">Команды для управления контейнерами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `docker container create [-p <порт>:<expose_порт>] [--name <имя>] <образ>` - создание контейнера [с именем `<имя>`], на основе указанного образа [с проброшеными портами внутрь];
- `docker container start <контейнер>[ ...]` - запуск существующего контейнера[-ов];
- `docker container run [-p <порт>:<expose_порт>] [--name <имя>] [--rm] [-d] [--mount type=volume,source=<том>,destination=<путь_монтирования>] <образ> [-it <команда>]` - запускает контейнер [с проброшеными портами внутрь] [с именем `<имя>`] [и удаляет его после завершения работы контейнера] [в фоновом режиме] [с монтирование тома с именем `<том>` по пути `<путь_монтирования>`], на основе указанного образа `<образ>`[, а в нем указаную команду];
- `docker run [-p <порт>:<expose_порт>] [--name <имя>] [--rm] [-d] [--mount type=volume,source=<том>,destination=<путь_монтирования>] <образ> [-it <команда>]` - аналогично предыдущей;
- `docker container ls [-s] [-a]` - вывод списка работающих контейнеров [с их примерным размером] [всех контейнеров];
- `docker container inspect [-s] <контейнер>[ ...]` - вывод подробной информации о контейнере [с их общим размером];
- `docker container logs [-f] [--tail=<количество>] <контейнер>` - вывод логов контейнера [в реальном времени] [только указаное количество последних строк];
- `docker logs ...` - аналогично предыдущей;
- `docker container stop <контейнер>[ ...]` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время, `SIGKILL`;
- `docker stop ...` - аналогично предыдущей;
- `docker container kill <контейнер>[ ...]` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`;
- `docker kill ...` - аналогично предыдущей;
- `docker container rm <контейнер>[ ...]` - удаляет остановленный контейнер.
- `docker rm ...` - аналогично предыдущей;

## <a id="Тома-Docker" href="#Тома-Docker">Тома Docker</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Том** - это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker.

### <a id="Команды-для-работы-с-томами" href="#Команды-для-работы-с-томами">Команды для работы с томами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`docker volume create --name <имя_тома>` - создает том.  
`docker volume ls` - выводит список томов.  
`docker volume inspect <имя_тома>` - вывод подробной информации о томе.  
`docker volume rm <имя_тома>` - удаляет том.  
`docker volume prune` - удаляет не используемые контейнерами тома.  

## <a id="Другие-команды" href="#Другие-команды">Другие команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`docker stats $(docker ps -q)` - непрерывно выводит в консоль статуса работающих контейнеров.

`docker ps {--all | -a}` - выводит в консоль статус контейнеров.  
`docker ps {--quiet | -q}` - выводит в консоль только id контейнеров.

`docker exec -it <контейнер> sh` - подключается к докеру для выполнения команд. `exit` - выход из докера.

`docker system prune [-a] [--volumes]` - удаляет неиспользуемые контейнеры, которым не назначено имя и тег [все] , сети и образы, [тома].

`docker restart <контейнер>` - перезапускает указанный контейнер.  
`docker restart $(docker ps -a -q)`  - перезапускает все контейнеры.

## <a id="docker-compose" href="#docker-compose">`docker compose`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Файл `compose.yml` - это файл Docker Compose, который будет содержать инструкции, необходимые для запуска и настройки сервисов.

```yml
# Сервисом может быть клиент, сервер, сервер баз данных...
services:
    <имя_сервиса>:
        # Позволяет задать путь к файлу Dockerfile, который нужно использовать для создания образа, который позволит запустить сервис.
        # Здесь <путь> соответствует пути к папке сервера, которая содержит соответствующий Dockerfile.
        build: <путь>
        # Устанавливает указанный образ в формате [<registry>/][<project>/]<image>[:<tag>|@<digest>]
        image: <образ>
        # Команда, которую нужно запустить после создания образа.
        command: <команда>
        # Для перенаправления портов применяется следующая конструкция: [<порт_компьютера>:]<порт_контейнера>[/<протокол>]
        ports:
            - <порт_компьютера>:<порт_контейнера>
        # Указывает какие порты необходимо пробросить из контейнера
        expose:
            - "<порт>"
        # Используется для описания типа сети, указывается то, что контейнер может обращаться к 'localhost' компьютера.
        network_mode: host
        # Указывает, должен ли сервис, прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы <имя_сервиса>.
        depends_on:
            - <имя_сервиса>
        # Имя контейнера
        container_name: <имя_контейнера>
        # Имя хоста
        hostname: <имя_хоста>
        # Загружает в контейнер файл `<имя_конфигурации>` с настройками
        configs:
            - <имя_конфигурации>
        # Загружает переменные окружения из файла для запускаемой команды
        env_file:
            - <путь>
        # Устанавливает переменные окружения для запускаемой команды
        environment:
            <имя_переменной_окружения>: <значение>
        # Указывает к каким сервисам можно подключиться в виде <имя_сервиса>[:<алиас>]
        links:
            - <имя_сервиса>
        # Укащывает имена профилей при которых сервис запустится
        profiles:
            - <имя_профиля>
        # Загружает в контейнер секрет по пути `/run/secrets/<имя_секрета>`
        secrets:
            - <имя_секрета>
        # Указывает какие тома и как подключать
        volumes:
            # Тип подключения, может быть: `volume`, `bind`, `tmpfs` или `npipe`
            - type: <тип>
              source: <путь_источника>
              target: <путь_назначения>
            - <путь_источника>:<путь_назначения>
        # Указывает к каким сетям принадлежит сервис
        networks:
            - <имя_сети>
configs:
    <имя_конфигурации>:
        file: <путь>
configs:
    <имя_секрета>:
        file: <путь>
networks:
    <имя_сети>:
        # Указывает типа сети `host` - есть сеть, а `none` - без сети
        driver: host
```

Порты контейнеров, назначенные в файлах Dockerfile, будут открыты в сети, организуемой Docker Compose.

`docker compose build` - выполняет команды `build` для всех сервисов.

`docker compose up` - запуск всех контейнеров.  
`docker compose up -d` - запуск всех остановленных контейнеров.
`docker compose -f <файл_конфигурации1>[ ...] up -d` - запуск всех контейнеров из файла с настройками, которые сливаются вместе при совпадении полей или дополняются.

`docker compose down` - остановка всех контейнеров.  
`docker compose restart`  - перезапускает все контейнеры.  
`docker compose restart <контейнер>` - перезапускает указанный контейнер.

`docker compose logs -f <контейнер>` - выводит журналы сервиса.

`docker compose ps` - выводит список контейнеров.

`docker compose exec <контейнер> <команда>` - выполняет команду в выполняющемся контейнере.

## <a id="Примеры" href="#Примеры">Примеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Файлы-для-сервера-ноды" href="#Файлы-для-сервера-ноды">Файлы для сервера ноды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Dockerfile для создания статики и запуска nginx сервера:
```Dockerfile
# использование образа с алиасом build для создания статики
FROM node:12-alpine as build
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# копирование исходного кода
COPY . /app
# запуск сборки
RUN npm run build
# использования образа nginx для запуска и отдачи статики
FROM nginx:1.16.0-alpine
# копирование из образа build из каталога /app/build в каталог /usr/share/nginx/html текущего образа
COPY --from=build /app/build /usr/share/nginx/html
# открытие порта 80 наружу
EXPOSE 80
# запуск команды на выполнение
CMD ["nginx", "-g", "daemon off;"]
```

Dockerfile для компиляции и запуска сервера ноды:
```Dockerfile
# использование образа с алиасом builder для комплиляции кода
FROM node:12-alpine as builder
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install
# копирование исходного кода
COPY . /app
# запуск компиляции
RUN npm run build
# использования образа ноды
FROM node:12-alpine
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование из образа builder из каталога /app/dist в каталог /app текущего образа
COPY --from=builder /app/dist /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# открытие порта 8080 наружу
EXPOSE 8080
# установка пользователя
USER node
# запуск команды на выполнение
CMD ["node", "index.js"]
```

Файл `docker-compose.yml` для запуска образов:
```yml
version: "3"
services:
  api:
    build: ./services/api
    ports:
      - "8080:8080"
    depends_on:
      - db
    container_name: blog-api
  client:
    build: ./services/client
    ports:
      - "80:80"
    container_name: blog-client
  db:
    image: mongo
    ports:
      - "27017:27017"
    container_name: blog-db
```

Для общения между контейнерами используется имя контейнера вместо ip адреса localhost.
> `mongodb://localhost:27017/blog` -> `mongodb://blog-db:27017/blog`

<a id="Kubernetes" href="#Kubernetes">Kubernetes</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========

Это программа для оркестрации образов.

В Kubernetes контейнеры или наборы контейнеров размещаются на **подах** (pod). **Под** - это логический хост. Один или несколько подов, а также сервисы для управления подами образуют **узел**, или ноду (node). **Узел** - это рабочая машина, виртуальная либо физическая. Однотипные узлы образуют **группу узлов**.

Узлы объединяются в **кластер**. У каждого кластера есть своя **панель управления** (control plane), именно она и обеспечивает оркестрацию. Один из узлов кластера становится главным - **мастером** (master). Он запускает управляющие процессы Kubernetes: сервер Kubernetes API, планировщик и контроллеры основных ресурсов.

В одном физическом кластере могут находиться несколько виртуальных. Виртуальный кластер называется **пространством имен** (namespace).

Что делает Kubernetes:
- **автоматическое развертывание** на основе файла конфигурации в котором описано состояние контейнеров, и Kubernetes автоматически обеспечит заданное состояние: будет развертывать и удалять контейнеры, перераспределять ресурсы;
- **мониторинг сервисов и балансировка**. Kubernetes распределяет сетевой трафик так, чтобы развертывание было стабильным;
- **оркестрация хранилища**. Kubernetes позволяет автоматически смонтировать систему хранения: локальное или облачное хранилище;
- **самоконтроль**. Kubernetes перезапускает отказавшие контейнеры, заменяет их и завершает работу контейнеров, которые не соответствуют заданному уровню работоспособности.

`kubectl <action> <resource>` - базовая структура для большинства команд, где `<action>` - какое либо действие над ресурсом `<resource>`.

Общие ключи:
- `--kubeconfig=<kubeconfig.conf>` - указывает конфигурационный файл для подключения;
- `--namespace=<namespace>` - указывает пространство имен.

Для автомасштабирования используется инструменты:
- **Horizontal Pod Autoscaler** - масштабирует поды: увеличивает и уменьшает их количество, когда изменяется нагрузка, он ориентируется на лимиты (`limits`) и запросы (`requests`);
- **Cluster Autoscaler** - управляет количеством узлов, на которых поды запущены, он оценивает запросы подов и автоматически изменяет количество узлов кластера Kubernetes.

`minikube start --driver=hyperkit` - запускает эмуляцию кластера kubernetes с гипервизором для локальной разработки.

`kubectl create namespace <namespace>` - создает namespace.

`kubectl cluster-info` - выводит информацию о кластерах.

`kubectl get nodes` - выводит информацию о нодах.

`kubectl create deployment <имя_деплоя> --image=<docker_образ>` - создает размещение docker образа `<docker_образ>` приложения под именем `<имя_деплоя>`.  
`kubectl get deployments` - выводит информацию о размещениях.  
`kubectl describe deployment` - выводит информацию о размещении.

`kubectl scale deployments/<имя_деплоя> --replicas=<количество>` - устанавливает количество реплик для размещения.

`kubectl set image deployments/<имя_деплоя> <имя_деплоя>=<docker_образ>` - обновляет образ размещения.

`kubectl rollout status deployments/<имя_деплоя>` - подтверждает обновления новым образом.  
`kubectl rollout undo deployments/<имя_деплоя>` - отклоняет обновления новым образом и возвращается на предыдущий.

**Узел** (node) - это отдельная физическая или виртуальная машина, на которой развернуты и выполняются контейнеры приложений. Каждый узел в кластере содержит сервисы для запуска приложений в контейнерах (например Docker), а также компоненты, предназначенные для централизованного управления узлом.

**Под** (pod) - базовая единица для запуска и управления приложениями: один или несколько контейнеров (Докер и подобные), которым гарантирован запуск на одном узле, обеспечивается разделение ресурсов и межпроцессное взаимодействие и предоставляется уникальный в пределах кластера IP-адрес, что позволяет приложениям, развернутым на поде, использовать фиксированные и предопределенные номера портов без риска конфликта. Поды могут напрямую управляться с использованием API Kubernetes или управление ими может быть передано контроллеру. Общие ресурсы: хранилище, сеть (один IP адрес и порт) и информация о запуске. Могут иметь метки. Поды находятся в приватной, изолированной сети и по умолчанию видны другим подам и сервисам в том же кластере. Сервер автоматически создает конечную точку для каждого пода основываясь на имени пода. Поды объединяются в `ReplicaSet`, который контролирует их количество и доступность и запускает новые, если старые умерли.

**Контроллер** (controller) - это процесс, который управляет состоянием кластера, пытаясь привести его от фактического состояния к желаемому; он делает это, оперируя набором подов, определяемых с помощью селекторов меток и являющихся частью определения контроллера.

`kubectl get rs` - выводит список подов в `ReplicaSet`.

`kubectl get pods [-l <метка>=<значение>] [-o wide]` - выводит список подов [отфильтрованых по метке и ее значению] [в расширенном формате].  
`kubectl describe pods` - выводит информацию о подах.  
`kubectl describe <имя_пода>` - выводит информацию о поде.

`kubectl logs [--previous] [--tail=<n>] <имя_пода>` - выводит логи пода [предыдущего], весь вывод в STDOUT.

`kubectl exec <имя_пода> -- <команда>` - выполняе команду на поде и возвращает весь ее вывод в STDOUT.  
`kubectl exec -ti <имя_пода> -- /bin/sh` - подключается к поду с терминалом.

`export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}{{.metadata.name}}{{"\n"}}{{end}}')` - получает имя текущего пода.  
`curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/` - возвращает информацию о поде.  
`curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/` - возвращает информацию о прокси пода.

`kubectl proxy` - создает прокси для соединения хостом и кластером.

**Сервис** - это совокупность логически связанных наборов подов и политик доступа к ним. Например, сервис может соответствовать одному из уровней программного обеспечения, разработанного в соответствии с принципами многоуровневой архитектуры программного обеспечения. Набор подов, соответствующий сервису, получается в результате выполнения селектора соответствующей метки. Сервисы позволяют приложениям получать внешний трафик с помощью меток - пары ключей и значений, и селекторов.

`kubectl get services [-l <метка>=<значение>]` - выводит список сервисов.  
`kubectl describe services/<имя_сервиса>` - выводит информацию о сервисе.  
`kubectl delete service -l <метка>=<значение>` - удаляет сервис с определенной меткой и ее значением.

`kubectl expose deployment/<имя_деплоя> --type="NodePort" --port <порт> service/<имя_сервиса> exposed` - создает сервис для открытия размещения по указанному порту.

`export NODE_PORT=$(kubectl get services/<имя_сервиса> -o go-template='{{(index .spec.ports 0).nodePort}}')` - получает порт сервиса.

`kubectl label pods <имя_пода> <метка>=<значение>` - устанавливает метку со значением поду.

## <a id="Манифест" href="#Манифест">Манифест</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это файл в формате `yaml` со структурой:
```yaml
apiVersion: apps/v1
kind: <механизм_использования>
metadata:
  name: <имя_приложения>
spec:
  replicas: <количество>
  selector:
    matchLabels:
      app: <метка>
  template:
    metadata:
      labels:
        app: <метка>
    spec:
      containers:
      - name: <имя>
        image: <имя_образа>
        resources:
          requests:
            memory: "256Mi"
            cpu: "500m"
          limits:
            memory: "500Mi"
            cpu: "1"
```

Где:
- `kind` - это механизм использования манифеста и может принимать значения: `Deployment`, `Namespace`, `Service`, `Pod`, `LoadBalancer` и т. д.;
- `metadata` - определяет метаданные приложения: имя, метки (labels), аннотации;
- `spec` - содержит описание объектов Kubernetes:
    - `replicas` - определяет масштабирование;
    - `selector` - определяет, какими подами будет управлять контейнер, которые отбираются с помощью метки (`label`);
    - `template` - определяет шаблон пода, метка в шаблоне `metadata` должна совпадать с меткой селектора:
        - `spec` - задает настройки контейнеров, которые будет развернуты на поде:
            - `resources` - описывает ресурсы для контейнера:
                - `requests` - содержит запросы контейнера;
                - `limits` - содержит ограничения контейнера;

С помощью **меток** можно идентифицировать, группировать объекты, выбирать их подмножества. Их можно добавлять, удалять и редактировать в любое время.

`kubectl apply -f <путь_к_файлу_манифеста.yaml>` - выполняет манифест.

Создание балансера:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: <имя_приложения>
spec:
  selector:
    app: <метка>
  ports:
    - port: 80
      targetPort: 80
  type: LoadBalancer
```

Создание балансера нагрузки Horizontal Pod Autoscaler:
```yaml
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: <имя_приложения>
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: <имя_приложения>
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 20
```

В одном манифесте можно описывать множество компонентов и они должны разделяться `---`.

## <a id="Helm" href="#Helm">Helm</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это пакетный менеджер Kubernetes, который позволяет запускать, обновлять и откатывать приложения. Основная сущность Helm - это чарты.

**Чарт** (Chart) - это коллекция связанных манифестов Kubernetes. При помощи чарта можно запускать приложения.

**Релиз** (Release) - это установленный чарт. В один кластер можно установить сколько угодно релизов одного чарта. У каждого релиза есть свое название, которое можно использовать для нейминга ресурсов Kubernetes.

`helm create <имя_чарта>` - создает Helm-Chart - это каталог с именем `<имя_чарта>` в котором есть:
- `charts/` - каталог, содержащий сторонние чарты, от которых зависит текущий;
- `Chart.yaml` - файл, содержащий основные сведения о чарте;
- `templates/` - каталог, содержащий шаблоны Kubernetes с возможностью форматирования и вставки значении Helm;
- `templates/*.tpl` - файлы, содержащие именнованые шаблоны. В файлах с расширением `tpl` размещаются шаблоны, которые можно использовать в манифестах;
- `values.yaml` - файл, содержащий переменные, используемые в шаблонах. Содержит стандартные значения, и при установке релиза можно указать собственные.

`helm install [--dry-run] <имя_релиза> <путь_к_чарту>` - производит установку [только отображение действий] релиза.

### <a id="Шаблоны" href="#Шаблоны">Шаблоны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Внутри tpl-шаблонов или `yaml` можно использовать шаблонные функции.

`{{ .<имя_переменной> }}` - производит подстановку в код текущего значения переменной с именем `<имя_переменной>`.
> `{{ .Release.Service }}`

`{{ .<имя_переменной> | <функция_1> [<арг_1>[ ...]] [| ...] }}` - производит подстановку в код текущего значения переменной с именем `<имя_переменной>`, которая была отформатирована с помощью функций.
> `{{ .Chart.AppVersion | quote }}`

`{{/* <комментарий> */}}` - содержит комментарий, который нее подставляется в код.

Условная конструкция:
```
{{- if .<имя_переменной> }}
содержит код при истинном условии
{{- else }}
содержит код при ложном условии
{{- end }}
```

<a id="Terraform" href="#Terraform">Terraform</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

Это программа, которая позволяет создавать облачную инфраструктуру (не только ВМ, но и балансировщики, сети, базы данных, хранилища и т. д.) по файлу спецификации на языке HCL в файлах формата `.tf`, из которой автоматически развернется готовая инфраструктура.

Terraform позволяет предварительно посмотреть план выполнения: что будет создано и удалено в процессе работы.

## <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Переменные Terraform хранятся в файлах с расширением `.tfvars`. Для подключения используется ключ `-var-file=<имя_файла_с_переменными>.tfvars`, который добавляется ко всем командам, если не указывать, то будет использоваться файл по умолчанию `terraform.tfvars`.
> `terraform apply -var-file=my-variables.tfvars`

Стркутура файла выглядит в виде строк формата:
- `<имя_переменной> = "<строка>"` - для строк;
- `<имя_переменной> = <число>` - для чисел;
- `<имя_переменной> = {true | false}` - для булевых значений;
- `<имя_переменной> = [<значение_1>[, ...]]` - для списка, где значение должно быть одним из типов и одинаковым;
- `<имя_переменной> = {<ключ_1> = <значение>[, ...]}` - для карты пар ключ-значение;

Для использования они должны быть объявлены в спецификации в блоке:
```hcl
variable "<имя_переменной>" {
    description = "<описание>"
    type = <тип>
    default = <значение_по_умолчанию>
}
```

Где:
- `type` - задает тип переменной и может быть:
    - `string`;
    - `number`;
    - `bool`;
    - `list(<тип>)` - список;
    - `map(<тип>)` - карта;
    - `object({ <имя_1>: <тип>[, ...] })` - карта;
- `description` - (не обязательное поле) задает описание переменной;
- `default` - (не обязательное поле) задает значение по умолчанию.

Переменные можно объявлять локально в файле спецификации в блоке:
```hcl
locals {
    <имя_переменной_1> = <значение>
}
```

Использование переменной: `var.<имя_переменной>`, а из локального файла тогда будет: `locals.<имя_переменной>`.

В строках можно указывать подстановку значений при использовании конструкции: `${var.<имя_переменной>}`.
> `"web-sg-${var.resource_tags["project"]}-${var.resource_tags["environment"]}"`

Для списков можно использовать `slice(var.<имя_переменной>, <начальный_индекс>, <конечный_не_включаемый_индекс>)` для получения подсписка.

Для карты можно использовать: `var.<имя_переменной>["<ключ>"]` для возвращения значения по ключу.

`merge(<карта_1>, <карта_2>)` - производит слияние карт и возвращает новую.

## <a id="Ресурсы" href="#Ресурсы">Ресурсы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для создания и изменения ресурсов. Описываются в файле спецификаций в формате блоков:
```hcl
resource "<имя_провайдера_ресурса>" "<имя_ресурса>" {
    count = <количество>
    for_each = <список>
    ## описание ресурса
}
```

Где:
- `count` - (не обязательное поле) количество описываемых ресурсов, может использоваться в описании потом как: `count.index`, который будет равен текущему индексу ресурса;
- `for_each` - (не обязательное поле) список или карта по которому будет производится итерирование для описываемых ресурсов, может использоваться в описании потом как: `each.value`, который будет содержать элемент из списка или карты, а `each.key` - индекс или ключ.

Для перечисления блока может использоваться `dynamic`:
```hcl
dynamic "<имя_блока>" {
    for_each = <список>
    content {
        <содержимое_блока>
        ## <имя_блока>.key - индекс или ключ
        ## <имя_блока>.value - элемент из списка или карты
    }
}
```

## <a id="Сохранение-значений" href="#Сохранение-значений">Сохранение значений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для сохранения информации о значении в переменную и его вывода. Описываются в файле спецификаций в формате блоков:
```hcl
output "<имя_переменной>" {
    description = "<описание>"
    value = <путь_к_значению>
    sensitive = true
}
```

Где:
- `value` - забирает значение переменной по указанному пути;
- `description` - (не обязательное поле) задает описание переменной;
- `sensitive` - (не обязательное поле) указывает, что вывод нужно скрыть.

### <a id="Разворачивание-инфраструктуры" href="#Разворачивание-инфраструктуры">Разворачивание инфраструктуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Инфраструктура разворачивается в три этапа:
1. Команда `terraform init` инициализирует провайдеров, указанных в файле спецификации.
2. Команда `terraform plan` запускает проверку спецификации. Если есть ошибки - появятся предупреждения. Если ошибок нет, отобразится список элементов, которые будут созданы или удалены.
3. Команда `terraform apply` запускает развертывание инфраструктуры.

Флаги:
- `-replace="<имя_ресурса>"` - указывает на то, что ресурс необходимо пересоздать - удалить старый и добавить новый.

Если инфраструктура больше не нужна, ее можно удалить командой `terraform destroy`.

Terraform не всегда создает заново все ресурсы, описанные в спецификации. Terraform ведет реестр - **State** (стейт-файл) в формате JSON, в котором фиксирует состояние инфраструктуры в облаке. State поддерживает связь между описанием ресурсов в спецификации и реальными ресурсами в облаке. При запуске команд `plan` и `apply` стейт-файл сравнивается с ресурсами, которые нужно создать из спецификации. По итогам сравнения недостающие ресурсы создаются, лишние - удаляются, а некоторые изменяются на ходу. Такой подход позволяет существенно улучшить производительность операций развертывания, особенно для масштабных инфраструктур. После выполнения команды `apply` стейт-файл обновляется.

Дополнительные команды:
- `terraform import` - импортировать описание конфигурации в стейт-файл;
- `terraform state list` - выводит список ресурсов из стейт-файла;
- `terraform state show <имя_ресурса>` - выводит информацию о ресурсе из стейт-файла;
- `terraform state rm <имя_ресурса>` - исключить ресурс из стейт-файла;
- `terraform state mv [-dry-run] <исходное_имя_ресурса> <новое_имя_ресурса>` - переименовывает ресурс [только отображает то, что сделает];
- `terraform output` и `terraform show` - выгрузить описание из стейт-файла.

### <a id="Разное" href="#Разное">Разное</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`TF_ENABLE_API_LOGGING=1 TF_LOG=debug` - перед командой включают отладку.

<a id="Redis" href="#Redis">Redis</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

`redis-cli <команда>[ <арг1>[ ...]]` - базовое выполнение команд.

`redis-cli DEL <ключ>` - удаляет ключ.

`redis-cli HGET <ключ> <поле>` - выводит в консоль значение поля указаного ключа (хеш-таблицы).  
`redis-cli HSET <ключ> <поле> "<значение>"` - устанавливает значение поля указаного ключа (хеш-таблицы).

`redis-cli --raw keys *<маска>*` - возвращает список ключей, которые соответствуют маске.  
`redis-cli --raw keys *<маска>* | xargs redis-cli DEL` - удаляет все ключи, которые соответствуют маске

<a id="curl" href="#curl">`curl`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`curl [<опции>] <url>` - базовый вызов адреса `<url>`, по умолчанию GET.

Опции:
- `-i` - выводит заголовки ответа;
- `-k` - обозначает что можно проводить небезопасный запрос, при невозможности подтверждения сертификата, при использовании протокола **https**;
- `-F '<имя_поля>=@<путь_к_файлу>'` - добавляет содержимое файла в указаное поле;
- `-X <тип_запроса>` - изменяет тип запроса на указанный (POST, GET, PUT, DELETE);
- `-H "<имя_заголовка>: <значение_заголовка>"` - добавляет заголовок в запрос;
- `-b "<имя_куки>=<значение_куки>"` - добавляет куку в запрос;
- `-d "<имя_поля>=<значение_поля>"` - добавляет значение ключа в POST-запрос;
- `--data "<тело>"` - добавляет тело в POST-запрос;
- `-o <путь_к_файлу>` - сохранит все в файл `<путь_к_файлу>`;
- `-6` - указывает использовать `ipv6`;
- `-4` - указывает использовать `ipv4`;
- `-g` - позволяет использовать символы `[`, `]`, `{`, `}` в URL;
- `-w "\n\n%{time_connect}:%{time_starttransfer}:%{time_total}\n"` - выведет информацию о времени выполнения запроса.

Для запросов типа POST по умолчанию используется заголовки: `Content-Type: application/x-www-form-urlencoded`. Для передачи JSON нужно дополнительно прописывать заголовок: `Content-Type: application/json`.

Примеры:
- `curl -F '<имя_поля>=@<путь_к_файлу>'[ ...] <url>` - загружает файл на указанный адрес `<url>`;
- `curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <soap_метод_вызова>" --data-binary @<путь_к_файлу_xml> <url>` - отправляет soap запрос с указанным действием `<soap_метод_вызова>` на адрес `<url>` с телом запроса из файла;
- `curl -OL <url>` - загружает файл с адреса `<url>` в файл с именем после последнего `/` в адресе `<url>`.

<a id="jq" href="#jq">`jq`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====

`jq '<операторы>' [<файл>]` - применяет селектор [к указанному файлу] и отображает результат.

Виды операторов:
- фильтры:
    - `.` - фильтр идентичности указывает, что все что на входе, должно быть и на выходе;
    - `.<ключ_1>[.<ключ_2>][. ...]` - фильтрует объект и забирает из него значения по указанным ключам, включая вложенность%
        > `jq '.fruit.color,.fruit.price' fruit.json`
    - `.[<ключ_или_индекс>]` - доступ по ключу в объекте или индексу в массиве;
    - `.[[<индекс_от>]:[<индекс_до>]]` - возвращает под массив.
- объединение:
    - `<оператор_1>,<соператор_2>[, ...]` - объединяет результат операторов:
        > `jq '.fruit.color,.fruit.price' fruit.json`
- итерации:
    - `.[]` - указывает, что оператор должен быть применен к каждому элементу массива:
        > `jq '.[].name' fruits.json`  
        >  `jq '.[]' fruits.json`
- каналы:
    - `<оператор_1>|<соператор_2>[| ...]` - указывает, что результат выхода оператора, должен быть входом для другого оператора:
        > `jq '.[] | .name' fruits.json`
- создание:
    - `{<ключ_1>: <оператор>[, ...]}` - создает новый объект;
    - `[<оператор>]` - создает новый массив в котором для каждого элемента применен оператор:
        > `jq '.query.pages | [.[] | map(.) | .[] | {page_title: .title, page_description: .extract}]' wikipedia.json`

Функции используются при помощи передачи параметров во внутрь или через использование каналов:
- `<функция>(<оператор>)`;
- `<оператор> | <функция>`.

Виды функций:
- `keys` - возвращает массив ключей;
- `length` - возвращает длину массива;
- `unique` - возвращает список уникальных элементов в массиве;
- `map(<оператор>)` - возвращает новый массив, в котором для каждого элемента применен оператор `<оператор>`;
- `select(<оператор>)` - возвращает новый массив, в котором оставлены только те элементы, которые попадают под условия:
    > `jq '.[] | select(.name | test("^a.")) | .price' fruits.json`
- `del(<оператор>)` - удаляет элемент&

<a id="nmap" href="#nmap">`nmap`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`nmap <ip>` - производит сканирование портов. По итогу сканирования выводит информацию со статусами о портах:
-  `open` - приложение активно принимает соединения TCP, дейтаграммы UDP или ассоциации SCTP на этом порту;
- `closed` - закрытый порт доступен (он принимает и отвечает на зондовые пакеты nmap), но его не прослушивает ни одно приложение;
- `filtered` - нет возможности определить, открыт ли порт, потому что фильтрация пакетов не позволяет его зондам достичь порта. Фильтрация может осуществляться с помощью выделенного брандмауэра, правил маршрутизатора или программного обеспечения брандмауэра на хосте;
- `unfiltered` - нефильтрованное состояние означает, что порт доступен, но нет возможности определить, открыт он или закрыт;
- `open|filtered` - это те порты, для которых нет возможности определить, открыты или отфильтроваын. Это происходит для типов сканирования, при которых открытые порты не дают ответа. Отсутствие ответа может также означать, что пакетный фильтр отклонил зонд.
`closed|filtered` - это состояние используется, когда нет возможности определить, закрыт порт или фильтруется.

Основные ключи:
- `-p <порт_от>-<порт_до>` - устанавливает интервал портов для сканирования;
- `-p <порт_1>[,...]` - устанавливает порты для сканирования.

<a id="nginx" href="#nginx">`nginx`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

`nginx -s <сигнал>` - посылает сигнал nginx, может быть:
- `stop` - быстрое завершение;
- `quit` - плавное завершение;
- `reload` - перезагрузка конфигурационного файла;
- `reopen` - переоткрытие лог-файлов.

Файл `nginx.conf` содержит конфигурацию, расположен по `/usr/local/nginx/conf`, `/etc/nginx`, `/usr/local/etc/nginx`.

`nginx -t` - проверяет конфигурацию на корректность.

Состоит из директив:
- **простая** - `<имя> <параметр_1>[ ...];`;
- **блочная** - `<имя> <параметр_1>[ ...] { ... }`.

`#` - обозначает коментарий.

Структура:
```nginx
http {
    server {
        listen <порт>; # порт прослушивания сервера
        server_name <имя_виртуального_сервера_1>[ ...]; # задает имя виртуального сервера
        root <путь_по_умолчанию_к_каталогу_с_файлами>; # будет использоваться, если в location не указана директива root
        # объявление секции потока
        upstream <upstream_name> {
            zone upstreams <количество>K; # указывает на количество общей памяти для рабочих процессов
            server <ip_адрес>:<порт> max_fails=<количество> fail_timeout=<количество_секунд>s; # указания одного сервера для перенаправления, могут повторяться с разными параметрами
            keepalive <количество>; # количество поддерживаемых соединений с вышестоящими серверами
        }
        location <префикс_пути_1> {
            root <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>/<префикс_пути_1>
        }
        location <префикс_пути_2> {
            proxy_pass <url>; # производит проксирование всех запросов по данному пути на указаный <url>
            # из исходного url вырезается все до <префикс_пути_2>, включая его и добавляется к <url>, поэтому нужно быть осторожным, чтобы не возникло два слеша //
            proxy_set_header Host $host; # для передачи имени хоста
        }
        location <префикс_пути_3> {
            alias <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>
        }
        location <префикс_пути_4> {
            proxy_set_header Host $host; # для передачи имени хоста
            proxy_http_version 1.1; # указывает использовать протокол версии 1.1
            proxy_set_header "Connection" ""; # указывает не завершать соединения
            proxy_pass http://<upstream_name>/; # перенаправляет все запросы на указанный upstream
            proxy_next_upstream error timeout http_500; # указывает передавать ошибки следующему серверу в вышестоящей группе
        }
        location = <путь> { # будет работать только для тех, которые точно равны указаному пути
            # ...
        }
        location ~ <регулярное_выражение> { # будет работать только для тех, которые совпадают с регулярным выражением, можно использовать выделения (), которые затем доступны в виде переменных $1..$9
            # ...
            # alias /usr/share/$1/$2
        }
        location ~* <регулярное_выражение> { # то же, только без учета регистра
            # ...
        }
        # ...
    }
    # ...
}
```

При этом выбирается самый больший префикс пути в директивах `location`.

Если не находится совпадение с директивами `location`, то возвращается заголовок **404**.

Если в регулярном выражении встречаются символы `}` или `;`, то все выражение следует заключить в одинарные или двойные кавычки.

При поиске виртуального сервера по имени, если имени соответствует несколько из указанных вариантов, например, одновременно подходят и имя с маской, и регулярное выражение, будет выбран первый подходящий вариант в следующем порядке приоритета:
- точное имя;
- самое длинное имя с маской в начале, например `*.example.com`;
- самое длинное имя с маской в конце, например `mail.*`;
- первое подходящее регулярное выражение (в порядке следования в конфигурационном файле).

## <a id="Подключение-конфигурации" href="#Подключение-конфигурации">Подключение конфигурации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого используется директива: `include <путь_к_файлу_конфигурации>;`, которая вставляет конфигурации из файла в указаное место, где путь `<путь_к_файлу_конфигурации>` может быть шаблоном.

## <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`set $<имя_переменной> <значение>;` - устанавливает значение переменной. Значение `<значение>` может быть заключено в кавычки: `"<значение>"`. Также может содержать внутри себя переменные, которые заменятся на значение переменных.
> `set $USER release;`  
> `set $USER_FOLDER "/user/$USER/www";`

## <a id="Условия" href="#Условия">Условия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```nginx
if (<условие>) {
    # ...
}
```

Где `<условие>` может быть вида:
- `<имя_переменной>` - при этом ложными значениями переменной являются пустая строка или `"0"`;
- `<имя_переменной> = <строка>`;
- `<имя_переменной> != <строка>`;
- `<имя_переменной> ~ <регулярное_выражение>` - можно использовать выделения `()`, которые затем доступны в виде переменных `$1`..`$9`;
- `<имя_переменной> !~ <регулярное_выражение>`;
- `<имя_переменной> ~* <регулярное_выражение>`;
- `<имя_переменной> !~* <регулярное_выражение>`.

## <a id="Глобвльные-переменные" href="#Глобвльные-переменные">Глобвльные переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$host` - содержит имя хоста из строки запроса, или имя хоста из поля `Host` заголовка запроса, или имя сервера, соответствующего запросу.

## <a id="Директивы" href="#Директивы">Директивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Директивы наследуются с предыдущего уровня конфигурации, или "сверху-вниз": дочерний контекст, будучи вложенным в другой контекст (родительский), наследует настройки директив, входящих в родительский уровень.

`add_header <заголовок> <значение>;` - добавляет заголовок со значением.

`return <код>[ "<содержимое>"];` - возвращает код ответа [и его содержимое].

`rewrite <регулярное_выражение> <строка> [permanent];` - переопределяет путь, который совпадает с регулярным выражением `<регулярное_выражение>`, на указаную строку `<строка>`, в которой можно использовать выделения `()` в виде переменных `$1`..`$9` из регулярного выражения.

`auth_basic "closed site";` - включает базовую HTTP-аутентификацию.  
`auth_basic_user_file <файл>;` - добавляет файл с логинами и паролями для прохождении аутентификации.

`allow {<ip_адрес> | <ip_подсеть>};` - разрешает доступ только из указанной ip подсети или ip адресов.  
`deny all;` - запрещает доступ отовюду, кроме разрешенных с помошью директив `allow`.

<a id="vim" href="#vim">`vim`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

`vim <файл_1>[ ...]` - открывает файлы на редактирование в командном режиме.

`~/.vimrc` - файл с командами настроек, которые запускаются автоматически при открытии редактора. Команды пишутся без `:`.

`vim scp://<user>@<myserver>[:<port>]//<path_to_file>` - открывает файл на редактирование на сервере.
> `vim scp://user@myserver[:port]//path/to/file.txt`

## <a id="Обычный-режим" href="#Обычный-режим">Обычный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для редактирования файла путем ввода команд.

`:q` - выход из редактора.  
`:q!` - принудительный выход из редактора без сохранения файла.

`:w` - запись в файл.  
`:w <файл>` - запись в указанный файл, но при этом редактироваться продолжит исходный.  
`:wq` - запись в файл и выход из редактора.

`ZZ` - запись в файл и выход из редактора.

`i` - переход в режим вставки.

`v` - переход в визуальный режим.

`:` - переход в командный режим.

`u` - отмена предыдущей команды.

`a` - переход в конец файла и переход в режим вставки.  
`A` - переход в конец текущей строки и переход в режим вставки.

Команды перемешения:
- `l` - вправо на один символ;
- `h` - влево на один символ;
- `j` - вниз на один символ;
- `k` - вверх на один символ;
- `0` - в начало текущей строки;
- `^` - к первому не пробельному символу в текущей строке;
- `$` - в конец текущей строки;
- `w` - в начало следующего слова или знаку препинания;
- `W` - в начало следующего слова минуя знаки препинания;
- `b` - в начало предыдущего слова или знаку препинания;
- `B` - в начало предыдущего слова минуя знаки препинания;
- `CTRL + F` - вниз на одну страницу;
- `CTRL + B` - вверх на одну страницу;
- `<число>G` - к заданной строке в файле.
- `G` - к последней строке в файле.

Перед командой может указываться число, которое обычно обозначает количество повторений команды.
> `5j`  
> `5dd`

Команды вставки:
- `o` - добавляет строку ниже текущей;
- `O` - добавляет строку выше текущей.

Команды удаления:
- `x` - удаляет текущий символ;
- `dd` - вырезает текущую строку;
- `dW` - вырезает от текущего символа до начала следующего слова;
- `d$` - вырезает от текущего символа до конца текущей строки;
- `d0` - вырезает от текущего символа до начала строки;
- `d^` - вырезает от текущего символа до первого непробельного символа в строке;
- `dG` - вырезает от текущей строки до конца файла;
- `d<число>G` - вырезает от текущей строки до указанной строки.

Команды копирование:
- `yy` - копирует текущую строку;
- `yW` - копирует от текущего символа до начала следующего слова;
- `y$` - копирует от текущего символа до конца текущей строки;
- `y0` - копирует от текущего символа до начала строки;
- `y^` - копирует от текущего символа до первого непробельного символа в строке;
- `yG` - копирует от текущей строки до конца файла;
- `y<число>G` - копирует от текущей строки до указанной строки.

Команды вставки из буфера:
- `p` - вставка правее текушей позиции курсора;
- `P` - вставка левее текушей позиции курсора.

`J` - удаляет у текущей строки символ конца строки (объединяет две строки).

Команды поиска:
- `f<символ>` - переместит курсор к следующему вхождению символа в текущей строке, для повторения поиска используется `;`;
- `/<строка> + ENTER` - переносит курсор к следующему вхождению строки в файле, для повторения поиска используется `n`.

`:%s/<строка_поиска>/<строка_замены>/g + ENTER` - заменяет все строки на новые во всем файле.

## <a id="Навигация-и-окна" href="#Навигация-и-окна">Навигация и окна</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`:e .` - выводит интерактивный текущий каталог с файлами и навигацией по ним.

Команды использования нескольких файлов:
- `:bn` - переключение на следующий файл;
- `:bp` - переключение на предыдущий файл;
- `:buffers [<номер_файла>]` - выводит список редактируемых файлов с возможностью выбора файла;
- `:e <файл>` - добавляет файл для редактирования.

`:r <файл>` - вставляет содержимое файла перед текущим курсором.

`CTRL + w n` - создание нового окна.

`CTRL + w s` - разбиение текущего окна по горизонтали.  
`:split` - аналогично.  
`CTRL + w v` - разбиение текущего окна по вертикали.  
`:vnew` - аналогично.

`CTRL + w {hjkl}` - перемещение по окнам (также можно использовать стрелочки).  
`CTRL + w {HJKL}` - перемещает окна.

`:q` - закрывает текущее окно.
`CTRL + w o` - закрывает все окна, кроме текущего.

`CTRL + w +` - увеличивает размер окна на 1.  
`CTRL + w -` - уменьшает размер окна на 1.  
`{<число>}CTRL + w _` - устанавливает размер окна равным `<число>`.

## <a id="Режим-вставки" href="#Режим-вставки">Режим вставки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для редактирования файла путем добавления текста.

`ESC` - переход в командный режим и окончание вставки текста.

## <a id="Визуальный-режим" href="#Визуальный-режим">Визуальный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для выделения текста в файле. В этом режиме клавиши перемещения будут выделять текст.

Выделенный текст можно скопировать `y` или удалить `d` с помощью команд обычного режима.

`ESC` - переход в командный режим.

## <a id="Командный-режим" href="#Командный-режим">Командный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для ввода команд.

`ESC` - переход в командный режим.

## <a id="Особые-команды" href="#Особые-команды">Особые команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`:syntax on` - включает подсветку синтаксиса.  
`:set syntax=<язык>` - устанавливает подсветку синтаксиса для определенного языка.
> `:set syntax=sh`

`:set hlsearch` - включает подсветку результатов поиска.

`:set tabstop=<количество>` - устанавливает длину символа tab.

`:set autoindent` - включает автоотступы для новых строк на основании предыдущей.

`:set clipboard=unnamed` - включает общийй буфер для macOS / Windows.  
`:set clipboard=unnamedplus` - включает общийй буфер для Linux.