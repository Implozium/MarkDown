[Содержание](#Содержание)
==========

- [Docker](#Docker)
    - [Файл **Dockerfile**](#Файл-Dockerfile)
        - [Инструкции файла **Dockerfile**](#Инструкции-файла-Dockerfile)
    - [Работа с образами](#Работа-с-образами)
    - [Работа с контейнирами](#Работа-с-контейнирами)
    - [`docker-compose`](#docker-compose)
- [Redis](#Redis)
- [`curl`](#curl)

<a id="Docker" href="#Docker">Docker</a>
======

`service docker start` - запуск службы docker.  
`service docker stop` - остановка службы docker.

`docker stats $(docker ps -q)` - непрерывно выводит в консоль статуса работающих контейнеров.

`docker ps {--all | -a}` - выводит в консоль статус контейнеров.  
`docker ps {--quiet | -q}` - выводит в консоль только id контейнеров.

**Образы** - это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит.

## <a id="Файл-Dockerfile" href="#Файл-Dockerfile">Файл **Dockerfile**</a>

Файл **Dockerfile** (именно так должен он именоваться) содержит набор инструкций, следуя которым Docker будет собирать образ контейнера.

**Контейнеры** - состоят из слоёв. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. **Dockerfile** сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.  
Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** (родительский) - это то, что является исходным слоем (или слоями) создаваемого образа.

`docker build -t <имя> <путь>` - собирает образ Docker с именем `<имя>` из **Dockerfile** по контексту сборки - из набора файлов, расположенных по определённому пути или URL.

### <a id="Инструкции-файла-Dockerfile" href="#Инструкции-файла-Dockerfile">Инструкции файла **Dockerfile**</a>

Состоит из инструкций, после которых идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать: открыть какой-то порт или выполнить какую-то команду.

Инструкции:
- `# <коментарий>` - коментарий;
- `FROM <имя_родительского_образа>[:<версия>]` - (обязательная) задаёт базовый (родительский) образ[ если версия не указана, то возьмется последняя]:
    > `FROM ubuntu:18.04`
- `LABEL <ключ>="<значение>"` - описывает метаданные. Например - сведения о том, кто создал и поддерживает образ - содержат в себе полезную информацию об образе Docker:
    > `LABEL maintainer="jeffmshale@gmail.com"`
- `ENV <ключ>="<значение>"` - устанавливает постоянные переменные среды:
    > `ENV ADMIN="jeff"`
- `RUN <команда1>[ && ...]` / `RUN ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов. После её выполнения в образ добавляется новый слой, его состояние фиксируется:
    > `RUN apk update && apk upgrade && apk add bash && apk add --update git`  
    > `RUN ["mkdir", "/a_directory"]`
- `COPY <путь_откуда> <путь_в_контейнере_куда>` - копирует в контейнер файлы и папки:
    > `COPY . ./app`
- `ADD <путь_откуда> <путь_в_контейнере_куда>` - копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или добавлять файлы из сети:
    > `ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory`
- `CMD <команда1>[ && ...]` / `CMD ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней. Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в **Dockerfile**:
    > `CMD ["python", "./my_script.py"]`
- `WORKDIR <директория>` - задаёт рабочую директорию для следующей инструкции, автоматически создаёт директорию в том случае, если она не существует:
    > `WORKDIR /usr/src/my_app_directory`
- `ARG <имя_переменной>=<значение>` - позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки их можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа или в качестве аргументов для команд `RUN`, `CMD`, `ENTRYPOINT` в виде `"<имя_переменной>"`:
    > `ARG bd=oracle`
- `ENTRYPOINT ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - предоставляет команду с аргументами для вызова во время выполнения контейнера, параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки, а дополняются к команде запуска:
    > `ENTRYPOINT ["python", "./app/my_script.py", "my_var"]`
- `EXPOSE <порт>` - указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run -p <порт>`. Если использовать ключ в виде `-P`, то открыты будут все порты, указанные в инструкции `EXPOSED`:
    > `EXPOSE 8000`
- `VOLUME <путь>` - позволяет указать место, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами:
    > `VOLUME /my_volume`

## <a id="Работа-с-образами" href="#Работа-с-образами">Работа с образами</a>

`docker run <образ>` - запускает контейнер, на основе указанного образа.  
`docker run <образ> -it <команда>` - запускает контейнер, на основе указанного образа, а в нем указаную команду.

`docker rmi <образ>` - удаляет образ.

## <a id="Работа-с-контейнирами" href="#Работа-с-контейнирами">Работа с контейнирами</a>

`docker rm <контейнер>` - удаляет контейнер.

`docker stop <контейнер>` - останавливает контейнер.

`docker kill <контейнер>` - убивает контейнер.

`docker logs -f [--tail=<количество>] <контейнер>` - непрерывно выводит в консоль лог контейнера докера [только указаное количество последних строк].

`docker exec -it <контейнер> sh` - подключается к докеру для выполнения команд. `exit` - выход из докера.

## <a id="docker-compose" href="#docker-compose">`docker-compose`</a>

`docker-compose down` - остановка всех контейнеров.  
`docker-compose up -d` - запуск всех остановленных контейнеров.  
`docker-compose restart`  - перезапускает все контейнеры.  
`docker-compose restart <контейнер>` - перезапускает указанный контейнер.

<a id="Redis" href="#Redis">Redis</a>
=====

`redis-cli <команда>[ <арг1>[ ...]]` - базовое выполнение команд.

`redis-cli DEL <ключ>` - удаляет ключ.

`redis-cli HGET <ключ> <поле>` - выводит в консоль значение поля указаного ключа (хеш-таблицы).  
`redis-cli HSET <ключ> <поле> "<значение>"` - устанавливает значение поля указаного ключа (хеш-таблицы).

`redis-cli --raw keys *<маска>*` - возвращает список ключей, которые соответствуют маске.  
`redis-cli --raw keys *<маска>* | xargs redis-cli DEL` - удаляет все ключи, которые соответствуют маске

<a id="curl" href="#curl">`curl`</a>
======

`curl -F '<имя_поля>=@<путь_к_файлу>'[ ...] <url>` - загружает файла на указанный адрес `<url>`.  
`curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <soap_метод_вызова>" --data-binary @<путь_к_файлу_xml> <url>` - отправляет soap запрос с указанным действием `<soap_метод_вызова>` на адрес `<url>` с телом запроса из файла.