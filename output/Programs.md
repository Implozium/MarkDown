[Содержание](#Содержание)
==========

- [Форматы](#Форматы)
    - [YAML](#YAML)
        - [Типы данных](#Типы-данных)
            - [Строки](#Строки)
            - [Числа](#Числа)
            - [Массивы](#Массивы)
    - [Синтаксис](#Синтаксис)
        - [Ссылки](#Ссылки)
    - [Расширенная форма Бэкуса - Наура](#Расширенная-форма-Бэкуса---Наура)
- [Docker](#Docker)
    - [Файл **Dockerfile**](#Файл-Dockerfile)
        - [Инструкции файла **Dockerfile**](#Инструкции-файла-Dockerfile)
    - [Сборка](#Сборка)
        - [Команды для управления образами](#Команды-для-управления-образами)
    - [Работа с контейнерами](#Работа-с-контейнерами)
        - [Команды для управления контейнерами](#Команды-для-управления-контейнерами)
    - [Тома Docker](#Тома-Docker)
        - [Команды для работы с томами](#Команды-для-работы-с-томами)
    - [Другие команды](#Другие-команды)
    - [`docker-compose`](#docker-compose)
    - [Примеры](#Примеры)
        - [Файлы для сервера ноды](#Файлы-для-сервера-ноды)
- [Redis](#Redis)
- [`curl`](#curl)
- [`nginx`](#nginx)
    - [Подключение конфигурации](#Подключение-конфигурации)
    - [Переменные](#Переменные)
    - [Условия](#Условия)
    - [Глобвльные переменные](#Глобвльные-переменные)
    - [Директивы](#Директивы)
- [`vim`](#vim)
    - [Командный режим](#Командный-режим)
    - [Режим вставки](#Режим-вставки)
    - [Визуальный режим](#Визуальный-режим)
    - [Особые команды](#Особые-команды)

<a id="Форматы" href="#Форматы">Форматы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

## <a id="YAML" href="#YAML">YAML</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Формат для описания данных. Имеет расширение `.yml`.

### <a id="Типы-данных" href="#Типы-данных">Типы данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`# <комментарий>` - комментарий, все что идет после `#` считается комментарием и не влияет ни на что. Может располагаться где угодно.
> `key one: value one # this is temporary`

#### <a id="Строки" href="#Строки">Строки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<строка>` - строка, если не содержит спец символов `@`, `_`.  
`'<строка>'` - строка.  
`"<строка>"` - строка.  
> `This is a string`  
> `"This is @ string"`



#### <a id="Числа" href="#Числа">Числа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Если число без точки - то оно имеет тип integer, иначе float.
> `200 # integer`  
> `20.1 # float`

#### <a id="Массивы" href="#Массивы">Массивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`[<значение1>[, ...]]` - описание списка (массива) в одной строке. В виде синтаксиса дефиса:
```yaml
  - <значение1>
  ...
```

> `['Anne', 'John', 'Max']`
```yaml
  - Anne
  - John
  - Max
```

## <a id="Синтаксис" href="#Синтаксис">Синтаксис</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Вложеность задается пробелами (2). 0 пробелов обозначает корень.

`<ключ>: <значение>` - описание ключа и его значения. Все что до `:` идет за ключ, а после за значение. Значением может быть число, строка или массив.
> `key: value`  
> `key one: value one`  
> `people: ['Anne', 'John', 'Max']`
```yaml
people:
  - Anne
  - John
  - Max
```

### <a id="Ссылки" href="#Ссылки">Ссылки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<ключ>: &<переменная>` - объявление переменной. Все что вложено в этот ключ будет в переменной.

`<<: *<переменная>` - вставляет все ключи из переменной в текущее место.

```yaml
base-config: &config
  os: ubuntu
  manager: yarn
  run:
    - NODE_ENV=${ENVIRONMENT} yarn build
development:
  <<: *config
  env:
    - ENVIRONMENT: development
production:
  <<: *config
  env:
    - ENVIRONMENT: production
```

## <a id="Расширенная-форма-Бэкуса---Наура" href="#Расширенная-форма-Бэкуса---Наура">Расширенная форма Бэкуса - Наура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это формальная система определения синтаксиса, в которой одни синтаксические категории последовательно определяются через другие. Используется для описания граматик.

**Терминальные символы** - это минимальные элементы грамматики, не имеющие собственной грамматической структуры - это предопределенные идентификаторы (имена, считающиеся заданными для данного описания грамматики), либо цепочки - последовательности символов в кавычках или апострофах.

**Нетерминальные символы** - это элементы грамматики, имеющие собственные имена и структуру. Каждый нетерминальный символ состоит из одного или более терминальных и / или нетерминальных символов, сочетание которых определяется правилами грамматики.

**Правила** - используются для определения нетерминальных символов:  
`<идентификатор> = <выражение>.` - правило, где `<идентификатор>` - это нетерминальный символ, а `<выражение>` - это комбинация терминальных и нетерминальных символов и специальных знаков, могут быть комбинацией конструкций:
- **конкатенация** - это перечисление терминальных и не терминальных символов через символ `,`, что обозначает что нетерминал состоит из последовательности символов. Правило вида `A = B,C.`, иногда символ `,` может опускаться:
    > `SELECT = 'select', COLUMN_LIST, 'from', TABLE.`
- **выбор** - это выбор одного из терминальных и не терминальных символов через символ `|`, что обозначает что нетерминал может состоять из одного из символов. Правило вида `A = B|C.`:
    > `COND = 'or' | 'and'.`
- **условное вхождение** - это необязательный элемент выражения, который может присутствовать, а может и отсутствовать и заключается между символами `[` и `]`. Правило вида `A = [B].`:
    > `COND = ['not'], COND.`
- **повторение** - это повторяющийся элемент выражения, который обозначают конкатенацию любого числа (включая нуль) записанных в ней элементов и заключается между символами `{` и `}`. Правило вида `A = {B}.`:
    > `LIST = ARG {',', ARG}.`
- **групировка** - это конструкция, которая применяется для группировки элементов при формировании сложных выражений и заключается между символами `(` и `)`. Правило вида `A = (B).`:
    > `COND = ARG, 'in', (ARG | LIST).`

<a id="Docker" href="#Docker">Docker</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`service docker start` - запуск службы docker.  
`service docker stop` - остановка службы docker.

**Образы** - это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит.

## <a id="Файл-Dockerfile" href="#Файл-Dockerfile">Файл **Dockerfile**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Файл **Dockerfile** (именно так должен он именоваться) содержит набор инструкций, следуя которым Docker будет собирать образ контейнера.

**Контейнеры** - состоят из слоев. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. **Dockerfile** сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.  
Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** (родительский) - это то, что является исходным слоем (или слоями) создаваемого образа.

### <a id="Инструкции-файла-Dockerfile" href="#Инструкции-файла-Dockerfile">Инструкции файла **Dockerfile**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из инструкций, после которых идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать: открыть какой-то порт или выполнить какую-то команду.

Инструкции:
- `# <коментарий>` - коментарий;
- `FROM <имя_родительского_образа>[:<версия>] [AS <алиас>]` - (обязательная) задает базовый (родительский) образ [если версия не указана, то возьмется последняя] [с указаным алиасом] - начинает новый шаг сборки:
    > `FROM ubuntu:18.04`

    Рекомендуется использовать базовые образы, основанные на Alpine Linux.

- `LABEL <ключ>=<значение>` - описывает метаданные. Например - сведения о том, кто создал и поддерживает образ - содержат в себе полезную информацию об образе Docker:
    > `LABEL maintainer="jeffmshale@gmail.com"`

- `ENV <ключ>=<значение>[ ...]` - устанавливает постоянные переменные среды:
    > `ENV ADMIN="jeff"`

- `RUN <команда1>[ && ...]`.

  `RUN ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - выполняет команду и создает слой образа. Используется для установки в контейнер пакетов или выполнения вспомогательный действий. После ее выполнения в образ добавляется новый слой, его состояние фиксируется:
    > `RUN apk update && apk upgrade && apk add bash && apk add --update git`  
    > `RUN ["mkdir", "/a_directory"]`

    В конце установки пакетов рекомендуется удалять их кэш: `&& rm -rf /var/lib/apt/lists/*`

- `COPY [--from=<алиас_образа>] <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует в контейнер файлы и папки [с указаного образа]:
    > `COPY . ./app`

- `ADD <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или добавлять файлы из сети:
    > `ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory`

- `CMD <команда1>[ && ...]`.

  `CMD ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней. Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в **Dockerfile**:
    > `CMD ["python", "./my_script.py"]`

- `WORKDIR <директория>` - задает рабочую директорию для следующей инструкции, автоматически создает директорию в том случае, если она не существует:
    > `WORKDIR /usr/src/my_app_directory`

- `ARG <имя_переменной>=<значение_по_умолчанию>` - позволяет задать переменную, значение которой можно передать из командной строки в образ, во время его сборки их можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа или в качестве аргументов для команд `RUN`, `CMD`, `ENTRYPOINT` в виде `"<имя_переменной>"` или `${<имя_переменной>}`:
    > `ARG bd=oracle`

- `ENTRYPOINT ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - предоставляет команду с аргументами для вызова во время выполнения контейнера, параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки, а дополняются к команде запуска:
    > `ENTRYPOINT ["python", "./app/my_script.py", "my_var"]`

- `EXPOSE <порт>[ ...]` - указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run -p <порт>`. Если использовать ключ в виде `-P`, то открыты будут все порты, указанные в инструкции `EXPOSED`:
    > `EXPOSE 8000`

- `VOLUME <том>[ ...]` - позволяет указать место - том, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами:
    > `VOLUME /my_volume`

```Dockerfile
FROM node:8 AS build
# Папки
RUN mkdir /app && mkdir /src
WORKDIR /src
# Установка зависимостей
COPY package*.json ./
RUN npm install
# Для использования в продакшне
# RUN npm install --production
# Копирование файлов проекта и сборка проекта
COPY . .
RUN npm run build:production
# В результате получается образ, состоящий из одного слоя
FROM node:alpine
# Копируем собранные файлы из папки build в папку app
COPY --from=build ./build/* /app
ENTRYPOINT ["/app"]
# Уведомление о порте, который будет прослушивать работающее приложение
EXPOSE 3000
# Запуск проекта
CMD ["npm", "run"]
```

Файл `.dockerignore` позволяет игнорировать файлы и папки, в которых нет необходимости при сборке образа, размещается там же, где находится файл **Dockerfile**, поддерживает шаблоны имен файлов (похож на файл `.gitignore`).

## <a id="Сборка" href="#Сборка">Сборка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Команды-для-управления-образами" href="#Команды-для-управления-образами">Команды для управления образами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `docker image build [--build-arg [<имя_переменной>=<значение>[ ...]]] -t <имя>[:<тег>] <путь>`.

    `docker build ...` - собирает образ Docker [с установлением значений переменных] с именем `<имя>` [и тегом `<тег>`] из **Dockerfile** по контексту сборки - из набора файлов, расположенных по определенному пути или URL;

- `docker image ls` - выводит в консоль размеры образов;
- `docker image history <имя_образа>[:<версия>]` - выводит в консоль размеры промежуточных образов, из которых собран некий образ;
- `docker image inspect <имя_образа>[:<версия>]` - выводит в консоль подробные сведения об образе, в том числе - размер каждого его слоя;
- `docker image rm <образ>`.

    `docker rmi <образ>` - удаляет образ.

## <a id="Работа-с-контейнерами" href="#Работа-с-контейнерами">Работа с контейнерами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Команды-для-управления-контейнерами" href="#Команды-для-управления-контейнерами">Команды для управления контейнерами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `docker container create [-p <порт>:<expose_порт>] [--name <имя>] <образ>` - создание контейнера [с именем `<имя>`], на основе указанного образа [с проброшеными портами внутрь];
- `docker container start <контейнер>[ ...]` - запуск существующего контейнера[-ов];
- `docker container run [-p <порт>:<expose_порт>] [--name <имя>] [--rm] [-d] [--mount type=volume,source=<том>,destination=<путь_монтирования>] <образ> [-it <команда>]`.

    `docker run ...` - запускает контейнер [с проброшеными портами внутрь] [с именем `<имя>`] [и удаляет его после завершения работы контейнера] [в фоновом режиме] [с монтирование тома с именем `<том>` по пути `<путь_монтирования>`], на основе указанного образа [, а в нем указаную команду];

- `docker container ls [-s] [-a]` - вывод списка работающих контейнеров [с их примерным размером] [всех контейнеров];
- `docker container inspect [-s] <контейнер>[ ...]` - вывод подробной информации о контейнере [с их общим размером];
- `docker container logs [-f] [--tail=<количество>] <контейнер>`.

    `docker logs ...` - вывод логов контейнера [в реальном времени] [только указаное количество последних строк];

- `docker container stop <контейнер>[ ...]`.

    `docker stop ...` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время, `SIGKILL`;

- `docker container kill <контейнер>[ ...]`.
    `docker kill ...` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`;

- `docker container rm <контейнер>[ ...]`.
    `docker rm ...` - удаление остановленного контейнера.

## <a id="Тома-Docker" href="#Тома-Docker">Тома Docker</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Том** - это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker.

### <a id="Команды-для-работы-с-томами" href="#Команды-для-работы-с-томами">Команды для работы с томами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`docker volume create --name <имя_тома>` - создает том.  
`docker volume ls` - выводит список томов.  
`docker volume inspect <имя_тома>` - вывод подробной информации о томе.  
`docker volume rm <имя_тома>` - удаляет том.  
`docker volume prune` - удаляет не используемые контейнерами тома.  

## <a id="Другие-команды" href="#Другие-команды">Другие команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`docker stats $(docker ps -q)` - непрерывно выводит в консоль статуса работающих контейнеров.

`docker ps {--all | -a}` - выводит в консоль статус контейнеров.  
`docker ps {--quiet | -q}` - выводит в консоль только id контейнеров.

`docker exec -it <контейнер> sh` - подключается к докеру для выполнения команд. `exit` - выход из докера.

`docker system prune [-a] [--volumes]` - удаляет неиспользуемые контейнеры, которым не назначено имя и тег [все] , сети и образы, [тома].

`docker restart <контейнер>` - перезапускает указанный контейнер.  
`docker restart $(docker ps -a -q)`  - перезапускает все контейнеры.

## <a id="docker-compose" href="#docker-compose">`docker-compose`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Файл `docker-compose.yml` - это файл Docker Compose, который будет содержать инструкции, необходимые для запуска и настройки сервисов.

```yml
version: "3"
# 1 сервис = 1 контейнер.
# Сервисом может быть клиент, сервер, сервер баз данных...
services:
    <имя_сервиса>:
        # Ключевое слово "build" позволяет задать путь к файлу Dockerfile, который нужно использовать для создания образа, который позволит запустить сервис.
        # Здесь <путь> соответствует пути к папке сервера, которая содержит соответствующий Dockerfile.
        build: <путь>
        # Команда, которую нужно запустить после создания образа.
        command: <команда>
        # Для перенаправления портов применяется следующая конструкция: [порт компьютера]:[порт контейнера]
        ports:
            - <порт_компьютера>:<порт_контейнера]>
        # Ключевое слово 'network_mode' используется для описания типа сети, указывается то, что контейнер может обращаться к 'localhost' компьютера.
        network_mode: host
        # Ключевое слово 'depends_on' позволяет указывать, должен ли сервис, прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы <имя_сервиса>.
        depends_on:
            - <имя_сервиса>
        # имя контенера
        container_name: <имя_контенера>
```

Порты контейнеров, назначенные в файлах Dockerfile, будут открыты в сети, организуемой Docker Compose.

`docker-compose build` - выполняет команды `build` для всех сервисов.

`docker-compose up` - запуск всех контейнеров.  
`docker-compose up -d` - запуск всех остановленных контейнеров.
`docker-compose -f <файл_конфигурации1>[ ...] up -d` - запуск всех контейнеров из файла с настройками, которые сливаются вместе при совпадении полей или дополняются.

`docker-compose down` - остановка всех контейнеров.  
`docker-compose restart`  - перезапускает все контейнеры.  
`docker-compose restart <контейнер>` - перезапускает указанный контейнер.

`docker-compose logs -f <контейнер>` - выводит журналы сервиса.

`docker-compose ps` - выводит список контейнеров.

`docker-compose exec <контейнер> <команда>` - выполняет команду в выполняющемся контейнере.

## <a id="Примеры" href="#Примеры">Примеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Файлы-для-сервера-ноды" href="#Файлы-для-сервера-ноды">Файлы для сервера ноды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Dockerfile для создания статики и запуска nginx сервера:
```Dockerfile
# использование образа с алиасом build для создания статики
FROM node:12-alpine as build
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# копирование исходного кода
COPY . /app
# запуск сборки
RUN npm run build
# использования образа nginx для запуска и отдачи статики
FROM nginx:1.16.0-alpine
# копирование из образа build из каталога /app/build в каталог /usr/share/nginx/html текущего образа
COPY --from=build /app/build /usr/share/nginx/html
# открытие порта 80 наружу
EXPOSE 80
# запуск команды на выполнение
CMD ["nginx", "-g", "daemon off;"]
```

Dockerfile для компиляции и запуска сервера ноды:
```Dockerfile
# использование образа с алиасом builder для комплиляции кода
FROM node:12-alpine as builder
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install
# копирование исходного кода
COPY . /app
# запуск компиляции
RUN npm run build
# использования образа ноды
FROM node:12-alpine
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование из образа builder из каталога /app/dist в каталог /app текущего образа
COPY --from=builder /app/dist /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# открытие порта 8080 наружу
EXPOSE 8080
# установка пользователя
USER node
# запуск команды на выполнение
CMD ["node", "index.js"]
```

Файл `docker-compose.yml` для запуска образов:
```yml
version: "3"
services:
  api:
    build: ./services/api
    ports:
      - "8080:8080"
    depends_on:
      - db
    container_name: blog-api
  client:
    build: ./services/client
    ports:
      - "80:80"
    container_name: blog-client
  db:
    image: mongo
    ports:
      - "27017:27017"
    container_name: blog-db
```

Для общения между контейнерами используется имя контейнера вместо ip адреса localhost.
> `mongodb://localhost:27017/blog` -> `mongodb://blog-db:27017/blog`

<a id="Redis" href="#Redis">Redis</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

`redis-cli <команда>[ <арг1>[ ...]]` - базовое выполнение команд.

`redis-cli DEL <ключ>` - удаляет ключ.

`redis-cli HGET <ключ> <поле>` - выводит в консоль значение поля указаного ключа (хеш-таблицы).  
`redis-cli HSET <ключ> <поле> "<значение>"` - устанавливает значение поля указаного ключа (хеш-таблицы).

`redis-cli --raw keys *<маска>*` - возвращает список ключей, которые соответствуют маске.  
`redis-cli --raw keys *<маска>* | xargs redis-cli DEL` - удаляет все ключи, которые соответствуют маске

<a id="curl" href="#curl">`curl`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`curl [<опции>] <url>` - базовый вызов адреса `<url>`, по умолчанию GET.

Опции:
- `-i` - выводит заголовки ответа;
- `-k` - обозначает что можно проводить небезопасный запрос, при невозможности подтверждения сертификата, при использовании протокола **https**;
- `-F '<имя_поля>=@<путь_к_файлу>'` - добавляет содержимое файла в указаное поле;
- `-X <тип_запроса>` - изменяет тип запроса на указанный (POST, GET, PUT, DELETE);
- `-H "<имя_заголовка>: <значение_заголовка>"` - добавляет заголовок в запрос;
- `-b "<имя_куки>=<значение_куки>"` - добавляет куку в запрос;
- `-d "<имя_поля>=<значение_поля>"` - добавляет значение ключа в POST-запрос;
- `--data "<тело>"` - добавляет тело в POST-запрос;
- `-o <путь_к_файлу>` - сохранит все в файл `<путь_к_файлу>`;
- `-w "\n\n%{time_connect}:%{time_starttransfer}:%{time_total}\n"` - выведет информацию о времени выполнения запроса.

Для запросов типа POST по умолчанию используется заголовки: `Content-Type: application/x-www-form-urlencoded`. Для передачи JSON нужно дополнительно пропичывать зоголовок: `Content-Type: application/json`.

Примеры:
- `curl -F '<имя_поля>=@<путь_к_файлу>'[ ...] <url>` - загружает файл на указанный адрес `<url>`;
- `curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <soap_метод_вызова>" --data-binary @<путь_к_файлу_xml> <url>` - отправляет soap запрос с указанным действием `<soap_метод_вызова>` на адрес `<url>` с телом запроса из файла;
- `curl -OL <url>` - загружает файл с адреса `<url>` в файл с именем после последнего `/` в адресе `<url>`.

<a id="nginx" href="#nginx">`nginx`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

`nginx -s <сигнал>` - посылает сигнал nginx, может быть:
- `stop` - быстрое завершение;
- `quit` - плавное завершение;
- `reload` - перезагрузка конфигурационного файла;
- `reopen` - переоткрытие лог-файлов.

Файл `nginx.conf` содержит конфигурацию, расположен по `/usr/local/nginx/conf`, `/etc/nginx`, `/usr/local/etc/nginx`.

Состоит из директив:
- **простая** - `<имя> <параметр_1>[ ...];`;
- **блочная** - `<имя> <параметр_1>[ ...] { ... }`.

`#` - обозначает коментарий.

Структура:
```nginx
http {
    server {
        listen <порт>; # порт прослушивания сервера
        server_name <имя_виртуального_сервера_1>[ ...]; # задает имя виртуального сервера
        root <путь_по_умолчанию_к_каталогу_с_файлами>; # будет использоваться, если в location не указана директива root
        # объявление секции потока
        upstream <upstream_name> {
            zone upstreams <количество>K; # указывает на количество общей памяти для рабочих процессов
            server <ip_адрес>:<порт> max_fails=<количество> fail_timeout=<количество_секунд>s; # указания одного сервера для перенаправления, могут повторяться с разными параметрами
            keepalive <количество>; # количество поддерживаемых соединений с вышестоящими серверами
        }
        location <префикс_пути_1> {
            root <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>/<префикс_пути_1>
        }
        location <префикс_пути_2> {
            proxy_pass <url>; # производит проксирование всех запросов по данному пути на указаный <url>
            # из исходного url вырезается все до <префикс_пути_2>, включая его и добавляется к <url>, поэтому нужно быть осторожным, чтобы не возникло два слеша //
            proxy_set_header Host $host; # для передачи имени хоста
        }
        location <префикс_пути_3> {
            alias <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>
        }
        location <префикс_пути_4> {
            proxy_set_header Host $host; # для передачи имени хоста
            proxy_http_version 1.1; # указывает использовать протокол версии 1.1
            proxy_set_header "Connection" ""; # указывает не завершать соединения
            proxy_pass http://<upstream_name>/; # перенаправляет все запросы на указанный upstream
            proxy_next_upstream error timeout http_500; # указывает передавать ошибки следующему серверу в вышестоящей группе
        }
        location = <путь> { # будет работать только для тех, которые точно равны указаному пути
            # ...
        }
        location ~ <регулярное_выражение> { # будет работать только для тех, которые совпадают с регулярным выражением, можно использовать выделения (), которые затем доступны в виде переменных $1..$9
            # ...
            # alias /usr/share/$1/$2
        }
        location ~* <регулярное_выражение> { # то же, только без учета регистра
            # ...
        }
        # ...
    }
    # ...
}
```

При этом выбирается самый больший префикс пути в директивах `location`.

Если не находится совпадение с директивами `location`, то возвращается заголовок **404**.

Если в регулярном выражении встречаются символы `}` или `;`, то все выражение следует заключить в одинарные или двойные кавычки.

При поиске виртуального сервера по имени, если имени соответствует несколько из указанных вариантов, например, одновременно подходят и имя с маской, и регулярное выражение, будет выбран первый подходящий вариант в следующем порядке приоритета:
- точное имя;
- самое длинное имя с маской в начале, например `*.example.com`;
- самое длинное имя с маской в конце, например `mail.*`;
- первое подходящее регулярное выражение (в порядке следования в конфигурационном файле).

## <a id="Подключение-конфигурации" href="#Подключение-конфигурации">Подключение конфигурации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого используется директива: `include <путь_к_файлу_конфигурации>;`, которая вставляет конфигурации из файла в указаное место, где путь `<путь_к_файлу_конфигурации>` может быть шаблоном.

## <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`set $<имя_переменной> <значение>;` - устанавливает значение переменной. Значение `<значение>` может быть заключено в кавычки: `"<значение>"`. Также может содержать внутри себя переменные, которые заменятся на значение переменных.
> `set $USER release;`  
> `set $USER_FOLDER "/user/$USER/www";`

## <a id="Условия" href="#Условия">Условия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```nginx
if (<условие>) {
    # ...
}
```

Где `<условие>` может быть вида:
- `<имя_переменной>` - при этом ложными значениями переменной являются пустая строка или `"0"`;
- `<имя_переменной> = <строка>`;
- `<имя_переменной> != <строка>`;
- `<имя_переменной> ~ <регулярное_выражение>` - можно использовать выделения `()`, которые затем доступны в виде переменных `$1`..`$9`;
- `<имя_переменной> !~ <регулярное_выражение>`;
- `<имя_переменной> ~* <регулярное_выражение>`;
- `<имя_переменной> !~* <регулярное_выражение>`.

## <a id="Глобвльные-переменные" href="#Глобвльные-переменные">Глобвльные переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$host` - содержит имя хоста из строки запроса, или имя хоста из поля `Host` заголовка запроса, или имя сервера, соответствующего запросу.

## <a id="Директивы" href="#Директивы">Директивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Директивы наследуются с предыдущего уровня конфигурации, или "сверху-вниз": дочерний контекст, будучи вложенным в другой контекст (родительский), наследует настройки директив, входящих в родительский уровень.

`add_header <заголовок> <значение>;` - добавляет заголовок со значением.

`return <код>[ "<содержимое>"];` - возвращает код ответа [и его содержимое].

`rewrite <регулярное_выражение> <строка> [permanent];` - переопределяет путь, который совпадает с регулярным выражением `<регулярное_выражение>`, на указаную строку `<строка>`, в которой можно использовать выделения `()` в виде переменных `$1`..`$9` из регулярного выражения.

`auth_basic "closed site";` - включает базовую HTTP-аутентификацию.  
`auth_basic_user_file <файл>;` - добавляет файл с логинами и паролями для прохождении аутентификации.

`allow {<ip_адрес> | <ip_подсеть>};` - разрешает доступ только из указанной ip подсети или ip адресов.  
`deny all;` - запрещает доступ отовюду, кроме разрешенных с помошью директив `allow`.

<a id="vim" href="#vim">`vim`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

`vim <файл_1>[ ...]` - открывает файлы на редактирование в командном режиме.

`~/.vimrc` - файл с командами настроек, которые запускаются автоматически при открытии редактора. Команды пишутся без `:`.

## <a id="Командный-режим" href="#Командный-режим">Командный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для редактирования файла путем ввода команд.

`:q` - выход из редактора.  
`:q!` - принудительный выход из редактора без сохранения файла.

`:w` - запись в файл.  
`:w <файл>` - запись в указанный файл, но при этом редактироваться продолжит исходный.  
`:wq` - запись в файл и выход из редактора.

`ZZ` - запись в файл и выход из редактора.

`i` - переход в режим вставки.

`v` - переход в визуальный режим.

`u` - отмена предыдущей команды.

`a` - переход в конец файла и переход в режим вставки.  
`A` - переход в конец текущей строки и переход в режим вставки.

Команды перемешения:
- `l` - вправо на один символ;
- `h` - влево на один символ;
- `j` - вниз на один символ;
- `k` - вверх на один символ;
- `0` - в начало текущей строки;
- `^` - к первому не пробельному символу в текущей строке;
- `$` - в конец текущей строки;
- `w` - в начало следующего слова или знаку препинания;
- `W` - в начало следующего слова минуя знаки препинания;
- `b` - в начало предыдущего слова или знаку препинания;
- `B` - в начало предыдущего слова минуя знаки препинания;
- `CTRL + F` - вниз на одну страницу;
- `CTRL + B` - вверх на одну страницу;
- `<число>G` - к заданной строке в файле.
- `G` - к последней строке в файле.

Перед командой может указываться число, которое обычно обозначает количество повторений команды.
> `5j`  
> `5dd`

Команды вставки:
- `o` - добавляет строку ниже текущей;
- `O` - добавляет строку выше текущей.

Команды удаления:
- `x` - удаляет текущий символ;
- `dd` - вырезает текущую строку;
- `dW` - вырезает от текущего символа до начала следующего слова;
- `d$` - вырезает от текущего символа до конца текущей строки;
- `d0` - вырезает от текущего символа до начала строки;
- `d^` - вырезает от текущего символа до первого непробельного символа в строке;
- `dG` - вырезает от текущей строки до конца файла;
- `d<число>G` - вырезает от текущей строки до указанной строки.

Команды копирование:
- `yy` - копирует текущую строку;
- `yW` - копирует от текущего символа до начала следующего слова;
- `y$` - копирует от текущего символа до конца текущей строки;
- `y0` - копирует от текущего символа до начала строки;
- `y^` - копирует от текущего символа до первого непробельного символа в строке;
- `yG` - копирует от текущей строки до конца файла;
- `y<число>G` - копирует от текущей строки до указанной строки.

Команды вставки из буфера:
- `p` - вставка правее текушей позиции курсора;
- `P` - вставка левее текушей позиции курсора.

`J` - удаляет у текущей строки символ конца строки (объединяет две строки).

Команды поиска:
- `f<символ>` - переместит курсор к следующему вхождению символа в текущей строке, для повторения поиска используется `;`;
- `/<строка> + ENTER` - переносит курсор к следующему вхождению строки в файле, для повторения поиска используется `n`.

`:%s/<строка_поиска>/<строка_замены>/g + ENTER` - заменяет все строки на новые во всем файле.

Команды использования нескольких файлов:
- `:bn` - переключение на следующий файл;
- `:bp` - переключение на предыдущий файл;
- `:buffers [<номер_файла>]` - выводит список редактируемых файлов с возможностью выбора файла;
- `:e <файл>` - добавляет файл для редактирования.

`:r <файл>` - вставляет содержимое файла перед текущим курсором.

## <a id="Режим-вставки" href="#Режим-вставки">Режим вставки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для редактирования файла путем добавления текста.

`ESC` - переход в командный режим и окончание вставки текста.

## <a id="Визуальный-режим" href="#Визуальный-режим">Визуальный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для выделения текста в файле.

`ESC` - переход в командный режим.

## <a id="Особые-команды" href="#Особые-команды">Особые команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`:syntax on` - включает подсветку синтаксиса.  
`:set syntax=<язык>` - устанавливает подсветку синтаксиса для определенного языка.
> `:set syntax=sh`

`:set hlsearch` - включает подсветку результатов поиска.

`:set tabstop=<количество>` - устанавливает длину символа tab.

`:set autoindent` - включает автоотступы для новых строк на основании предыдущей.