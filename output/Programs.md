[Содержание](#Содержание)
==========

- [Docker](#user-content-Docker)
    - [Файл **Dockerfile**](#user-content-Файл-Dockerfile)
        - [Инструкции файла **Dockerfile**](#user-content-Инструкции-файла-Dockerfile)
    - [Сборка](#user-content-Сборка)
        - [Команды для управления образами](#user-content-Команды-для-управления-образами)
    - [Работа с контейнерами](#user-content-Работа-с-контейнерами)
        - [Команды для управления контейнерами](#user-content-Команды-для-управления-контейнерами)
    - [Тома Docker](#user-content-Тома-Docker)
        - [Команды для работы с томами](#user-content-Команды-для-работы-с-томами)
        - [Команды для работы с сетью](#user-content-Команды-для-работы-с-сетью)
    - [Другие команды](#user-content-Другие-команды)
    - [`docker compose`](#user-content-docker-compose)
    - [Примеры](#user-content-Примеры)
        - [Файлы для сервера ноды](#user-content-Файлы-для-сервера-ноды)
- [Kubernetes](#user-content-Kubernetes)
    - [Под](#user-content-Под)
    - [ReplicaSet](#user-content-ReplicaSet)
    - [Deployment](#user-content-Deployment)
    - [HorizontalPodAutoscaler](#user-content-HorizontalPodAutoscaler)
    - [StatefulSet](#user-content-StatefulSet)
    - [Контроллер](#user-content-Контроллер)
    - [Сервис](#user-content-Сервис)
    - [Ingress](#user-content-Ingress)
    - [Job](#user-content-Job)
    - [minikube](#user-content-minikube)
    - [Helm](#user-content-Helm)
        - [Шаблоны](#user-content-Шаблоны)
        - [Структура чарта](#user-content-Структура-чарта)
            - [`Chart.yaml`](#user-content-Chartyaml)
            - [`values.yaml`](#user-content-valuesyaml)
- [Terraform](#user-content-Terraform)
    - [Состояние (State)](#user-content-Состояние-State)
    - [Провайдеры (Providers)](#user-content-Провайдеры-Providers)
    - [Ресурсы (Resources)](#user-content-Ресурсы-Resources)
    - [Провиженеры (Provisioners)](#user-content-Провиженеры-Provisioners)
    - [Блоки](#user-content-Блоки)
        - [Провайдеры](#user-content-Провайдеры)
        - [Переменные](#user-content-Переменные)
            - [Выходные значения](#user-content-Выходные-значения)
            - [Стандартные функции](#user-content-Стандартные-функции)
            - [Шаблоны](#user-content-Шаблоны)
            - [Предустановленные значения переменных](#user-content-Предустановленные-значения-переменных)
        - [Ресурсы](#user-content-Ресурсы)
                - [Провиженеры](#user-content-Провиженеры)
                    - [Провиженер `file`](#user-content-Провиженер-file)
                    - [Провиженер `local-exec`](#user-content-Провиженер-local-exec)
                    - [Провиженер `remote-exec`](#user-content-Провиженер-remote-exec)
            - [Существующий ресурс](#user-content-Существующий-ресурс)
            - [Локальный ресурс](#user-content-Локальный-ресурс)
            - [Провайдер `random`](#user-content-Провайдер-random)
            - [Провайдер `time`](#user-content-Провайдер-time)
            - [Условные выражения `?:`](#user-content-Условные-выражения-)
            - [Перебор `for..in`](#user-content-Перебор-forin)
        - [Модули](#user-content-Модули)
        - [Разворачивание инфраструктуры](#user-content-Разворачивание-инфраструктуры)
        - [Разное](#user-content-Разное)
            - [Структура каталогов](#user-content-Структура-каталогов)
- [Redis](#user-content-Redis)
- [`curl`](#user-content-curl)
- [`jq`](#user-content-jq)
- [`nmap`](#user-content-nmap)
- [`nginx`](#user-content-nginx)
    - [Подключение конфигурации](#user-content-Подключение-конфигурации)
    - [Переменные](#user-content-Переменные)
    - [Условия](#user-content-Условия)
    - [Глобвльные переменные](#user-content-Глобвльные-переменные)
    - [Директивы](#user-content-Директивы)
- [`vim`](#user-content-vim)
    - [Обычный режим](#user-content-Обычный-режим)
    - [Навигация и окна](#user-content-Навигация-и-окна)
    - [Режим вставки](#user-content-Режим-вставки)
    - [Визуальный режим](#user-content-Визуальный-режим)
    - [Командный режим](#user-content-Командный-режим)
    - [Команды](#user-content-Команды)

<a id="Docker" href="#Docker">Docker</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`service docker start` - запуск службы docker.  
`service docker stop` - остановка службы docker.

**Образы** - это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит.

## <a id="Файл-Dockerfile" href="#Файл-Dockerfile">Файл **Dockerfile**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Файл **Dockerfile** (именно так должен он именоваться) содержит набор инструкций, следуя которым Docker будет собирать образ контейнера.

**Контейнеры** - состоят из слоев. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. **Dockerfile** сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.  
Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** (родительский) - это то, что является исходным слоем (или слоями) создаваемого образа.

Docker-образы создаются с помощью инструкций, таких как запуск команды, добавление файла или директории, создание переменной окружения. Инструкции хранятся в `Dockerfile` - это обычный текстовый файл.

Каждая инструкция создает новый слой образа, и эти слои накладываются друг на друга.

Процесс создания образа - это считывание и выполнение инструкций из `Dockerfile`.

### <a id="Инструкции-файла-Dockerfile" href="#Инструкции-файла-Dockerfile">Инструкции файла **Dockerfile**</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Состоит из инструкций, после которых идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать: открыть какой-то порт или выполнить какую-то команду.

Инструкции:
- `# <коментарий>` - коментарий;

- `FROM <имя_родительского_образа>[:<версия>] [AS <алиас>]` - (обязательная) задает базовый (родительский) образ [если версия не указана, то возьмется последняя] [с указаным алиасом] - начинает новый шаг сборки:
    > `FROM ubuntu:18.04`

    Рекомендуется использовать базовые образы, основанные на Alpine Linux.

- `LABEL <ключ>=<значение>` - описывает метаданные. Например - сведения о том, кто создал и поддерживает образ - содержат в себе полезную информацию об образе Docker:
    > `LABEL maintainer="jeffmshale@gmail.com"`

- `ENV <ключ>=<значение>[ ...]` - устанавливает постоянные переменные окружения:
    > `ENV ADMIN="jeff"`

- `USER <пользователь>` - устанавливает пользователя, он должен быть ранее создан `addgroup --system <пользователь> && adduser --system --group <пользователь>` и для него должны выдаться права на директорию `chown -R <пользователь>:<пользователь> <путь_к_директории>`:
    > `USER postgres`

- `RUN <команда1>[ && ...]`.

  `RUN ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - выполняет команду и создает слой образа. Используется для установки в контейнер пакетов или выполнения вспомогательный действий. После ее выполнения в образ добавляется новый слой, его состояние фиксируется:
    > `RUN apk update && apk upgrade && apk add bash && apk add --update git`  
    > `RUN ["mkdir", "/a_directory"]`

    В конце установки пакетов рекомендуется удалять их кэш: `&& rm -rf /var/lib/apt/lists/*`

  `RUN --mount=<опции> <команда1>[ && ...]` - позволяет для дальнейшей команды примонтировать директорию, без копирования содержимого внутрь, где `<опции>` аналогичные `--mount` при выполнении команды `docker run`.

- `COPY [--from=<алиас_образа>] <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует в контейнер файлы и папки [с указаного образа]:
    > `COPY . ./app`

- `ADD <путь_откуда>[ ...] <путь_в_контейнере_куда>` - копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы или добавлять файлы из сети:
    > `ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 /my_app_directory`

- `CMD <команда1>[ && ...]`.

  `CMD ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен или аргументы, которые будут добавлены к команде `ENTRYPOINT`. В файле может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней. Вся команда `CMD` может быть переопределена при запуске контейнера, посредством передачи аргументов командной строки в команду `docker run`:
    > `CMD ["python", "./my_script.py"]`

- `WORKDIR <директория>` - задает рабочую директорию для последующих инструкций, автоматически создает директорию в том случае, если она не существует:
    > `WORKDIR /usr/src/my_app_directory`

- `ARG <имя_переменной[>=<значение_по_умолчанию>]` - позволяет задать переменную, значение которой можно передать из командной строки в образ, во время его сборки их можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа или в качестве аргументов для команд `RUN`, `CMD`, `ENTRYPOINT` в виде `"<имя_переменной>"` или `${<имя_переменной>}`:
    > `ARG bd=oracle`
    
    Для того чтобы переменная могла использоваться, ее нужно объявлять в каждом слоя образа (после `FROM`), переменные которые определены вне слоя образов будут доступны внутри только при их определении внутри слоя образа.

- `ENTRYPOINT ["<команда>"[, "<аргумент1_для_команды>"[, ...]]]` - предоставляет команду с аргументами для вызова во время выполнения контейнера (по умолчанию `/bin/sh -c`), параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки, а дополняются к команде запуска. `ENTRYPOINT` полезна для преобразования контейнера в отдельный исполняемый файл:
    > `ENTRYPOINT ["python", "./app/my_script.py", "my_var"]`

- `EXPOSE <порт>[ ...]` - указывает на то, какие порты будет слушать контейнер, после запуска. Эта инструкция не открывает порты, это лишь отметка о том, что контейнеру для работы нужны будут указанные порты. Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run -p <порт>`. Если использовать ключ в виде `-P`, то открыты будут все порты, указанные в инструкции `EXPOSE`:
    > `EXPOSE 8000`

- `VOLUME <том>[ ...]` - позволяет указать место - том, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами (по умолчанию хранятся в каталоге `/var/lib/docker/volumes/<том>`, который представляет из себя директорию с файлами):
    > `VOLUME /my_volume`

`RUN`, `CMD` и `ENTRYPOINT` могут быть:
- **shell form** - когда запись происходит в виде строки, в этом случае команда выполняется в подоболочке, обычно `/bin/sh -c`. Этот формат позволяет обрабатывать оболочку (например, расширять переменные, использовать подстановочные знаки и т. д.), таким образом делая ее более гибкой для определенных типов команд, но в этом случае процесс, выполняющий команду, не является PID `1` контейнера, что может привести к проблемам с обработкой сигналов посылаемые Docker PID `1`:
    > `RUN apt-get update && apt-get install -y nginx`
- **exec form** - когда запись происходит в виде массива, в этом случае не вызывается командная оболочка и процесс имеет PID `1`:
    > `ENTRYPOINT ["python", "/app/my_script.py"]`

```Dockerfile
FROM node:8 AS build
# Зависимости
RUN <<EOF
apt-get update;
apt-get install -y apache2-utils;
rm -rf /var/lib/apt/lists/*;
EOF
# Папки
RUN mkdir /app && mkdir /src
WORKDIR /src
# Установка зависимостей
COPY package*.json ./
RUN npm install
# Для использования в продакшне
# RUN npm install --production
# Копирование файлов проекта и сборка проекта
COPY . .
RUN npm run build:production
# В результате получается образ, состоящий из одного слоя
FROM node:alpine
# Копируем собранные файлы из папки build в папку app
COPY --from=build ./build/* /app
ENTRYPOINT ["/app"]
# Уведомление о порте, который будет прослушивать работающее приложение
EXPOSE 3000
# Запуск проекта
CMD ["npm", "run"]
```

Файл `.dockerignore` позволяет игнорировать файлы и папки, в которых нет необходимости при сборке образа, размещается там же, где находится файл **Dockerfile**, поддерживает шаблоны имен файлов (по синтаксису и работе напоминает файл `.gitignore`).

## <a id="Сборка" href="#Сборка">Сборка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Команды-для-управления-образами" href="#Команды-для-управления-образами">Команды для управления образами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `docker [image] build [<опции>] <путь_к_директории_сборки>` - собирает образ Docker из `Dockerfile` из набора файлов, расположенных по определенному пути `<путь_к_директории_сборки>` или URL, с указанными опциями `<опции>`:
    - `--build-arg [<имя_переменной>=<значение>[ ...]` - установливает значения переменных `ARG`;
    - `-f <путь_к_Dockerfile>` - указывает путь к файлу `Dockerfile` внутри директории `<путь_к_директории_сборки>`;
    - `--no-cache` - выключает кэширование слоев;
    - `--progress=plain` - включает вывод логов сборки;
    - `-t <имя_образа>[:<тег>]` - устанавливает имя образа [и тегом];

    > `docker image build -f my-dockerfile -t my-image .`

- `docker image ls` - выводит в консоль образов, которые доступны локально;
- `docker image history <имя_образа>[:<версия>]` - выводит в консоль размеры промежуточных образов, из которых собран некий образ;
- `docker image inspect <имя_образа>[:<версия>]` - выводит в консоль подробные сведения об образе, в том числе - размер каждого его слоя;
- `docker image rm <образ>` - удаляет образ;
- `docker rmi <образ>` - аналогично предыдущей;
- `docker push <имя_образа>` - помещает образ в хранилище;
- `docker pull <имя_образа>` - загружает образ из хранилища.

- `docker [image] tag <имя_образа> <имя>` - добавляет тег `<имя>` для образа;  
- `docker [image] tag <имя_образа> [<репозиторий>][/<реестр>]<имя_образа>:<тег>` - добавляет тег для образа для заливки его в репозиторий;
    > `docker image tag ubuntu registry-1.docker.io/library/ubuntu:22.04`

## <a id="Работа-с-контейнерами" href="#Работа-с-контейнерами">Работа с контейнерами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Команды-для-управления-контейнерами" href="#Команды-для-управления-контейнерами">Команды для управления контейнерами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `docker [container] run [<опции>] <образ> [[-it] <команда> [, <аргумент1_для_команды>[ ...]]]` - создает и запускает контейнер на основе указанного образа `<образ>`[, а в нем указаную команду] с указанными опциями `<опции>`:
    - `{-p | --publish} <порт>:<expose_порт>` - с указанием проброса порта `<expose_порт>` из контейнера на порт `<порт>` хоста;
    - `--name <имя>` - с именем `<имя>`;
    - `--rm` - с удалением его после завершения работы контейнера;
    - `-d` - в фоновом режиме;
    - `-i` - оставляет в контейнере `STDIN` открытым, что позволяет общаться через консоль;
    - `-t` - включает псевдоконсоль `TTY`;
    - `--mount [type=volume,]source=<том>,destination=<путь_монтирования>` - с монтирование тома с именем `<том>` по пути `<путь_монтирования>`;
    - `--mount type=tmpfs,destination=<путь_монтирования>` - с монтирование тома в оперативной памяти по пути `<путь_монтирования>`;
    - `--mount type=bind,source=<путь_к_директории>,target=<путь_монтирования>` - с монтирование директории по пути `<путь_к_директории>` (должен быть абсолютным путем) на хосте в контейнер по пути `<путь_монтирования>`;
    - `{-v | --volume} <том>:<путь_монтирования>` - аналогично `--mount type=volume`;
    - `{-v | --volume} <путь_к_директории>:<путь_монтирования>` - аналогично `--mount type=bind`;
    - `-e <env_переменная>=<env_значение>` - с установкой env-переменной `<env_переменная>` в значение `<env_значение>`;
    - `--env-file <env_файл>` - с установкой env-переменных их файла `<env_файл>`;
    - `--entrypoint <команда> [<аргумент1_для_команды>[ ...]]` - переопределяет `ENTRYPOINT` в контейнере при запуске;
    - `--entrypoint="<команда>"` - переопределяет `ENTRYPOINT` в контейнере при запуске;
    - `--command="<команда>"` - переопределяет `CMD` в контейнере при запуске;
    - `--network=<имя_сети>` - устанавливает сеть `<имя_сети>` для контейнера;
    - `--hostname=<имя_контейнера>` - устанавливает сетевое имя `<имя_контейнера>` для контейнера, чтобы другие контейнеры могли подключаться к нему по этому имени;

- `docker container create [<опции>] <образ>` - создает контейнера на основе указанного образа с указанными опциями `<опции>` аналогичными команде `run`;
- `docker container start <контейнер>[ ...]` - запускает существующий контейнер(-ы);
- `docker container ls [-s] [-a]` - вывод списка работающих контейнеров [с их примерным размером] [всех контейнеров];
- `docker container inspect [-s] <контейнер>[ ...]` - вывод подробной информации о контейнере [с их общим размером];
- `docker [container] logs [-f] [--tail=<количество>] <контейнер>` - вывод логов контейнера [в реальном времени] [только указаное количество последних строк];
- `docker [container] stop <контейнер>[ ...]` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время (10 секунд), `SIGKILL`;
- `docker [container] kill <контейнер>[ ...]` - остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`;
- `docker [container] rm <контейнер>[ ...]` - удаляет остановленный контейнер;
- `docker exec -it <контейнер> <команда>` - подключается к контейнеру и выполняет в нем команду `<команда>`;
    > `docker exec -it <контейнер> sh` - подключается к докеру для выполнения команд, где `exit` - выход из докера.

## <a id="Тома-Docker" href="#Тома-Docker">Тома Docker</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Том** - это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker.

### <a id="Команды-для-работы-с-томами" href="#Команды-для-работы-с-томами">Команды для работы с томами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`docker volume create --name <имя_тома>` - создает том.  
`docker volume ls` - выводит список томов.  
`docker volume inspect <имя_тома>` - вывод подробной информации о томе.  
`docker volume rm <имя_тома>` - удаляет том.  
`docker volume prune` - удаляет не используемые контейнерами тома.

### <a id="Команды-для-работы-с-сетью" href="#Команды-для-работы-с-сетью">Команды для работы с сетью</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Контейнеры в одной сети, могут общаться друг с другом по любому порту без необходимости их открытия.

`docker network create [--ingress] [-d <драйвер>] <имя_сети>` - создает [только внутреннюю] сеть с именем `<имя_сети>`, где `<драйвер>` может быть:
- `bridge` - по умолчанию, используется для связи контейнеров друг с другом;
- `host` - убирает сетевую изоляцию между контейнерами и хостом и используетхостовую сеть;
- `none` - изолирует контейнер от хоста и других контейнеров;
- `overlay` - используется для соединения множества docker-демонов;
- `ipvlan` - используется для назначения ip-адресов контейнерам;
- `macvlan` - используется для назначения mac-адресов контейнерам.

`docker network ls` - выводит список сетей.  
`docker network inspect <id_сети>` - выводит подробную информацию о сети.

## <a id="Другие-команды" href="#Другие-команды">Другие команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`docker stats $(docker ps -q)` - непрерывно выводит в консоль статуса работающих контейнеров.

`docker ps {--all | -a}` - выводит в консоль статус контейнеров.  
`docker ps {--quiet | -q}` - выводит в консоль только id контейнеров.

`docker system prune [-a] [--volumes]` - удаляет неиспользуемые контейнеры, которым не назначено имя и тег [все] , сети и образы, [тома].

`docker restart <контейнер>` - перезапускает указанный контейнер.  
`docker restart $(docker ps -a -q)`  - перезапускает все контейнеры.

`docker login [{-u | --username} <логин>] [{-p | --password} <пароль>] [--password-stdin] <сервер>` - производит авторизацию на сервере `<сервер>` [для пользователя `<логин>`] [с паролем `<пароль>`] [читая пароль из stdin].  
`docker logout <сервер>` - производит раздлгин на сервере `<сервер>`.

## <a id="docker-compose" href="#docker-compose">`docker compose`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Файл `compose.yml` - это файл Docker Compose, который будет содержать инструкции, необходимые для запуска и настройки сервисов.

Состоит из описания сущностей:
1. **Services** (Сервисы) - представляют собой отдельные контейнеры, которые нужно запускать, включает в себя инструкции по созданию и запуску контейнера. Сервисы могут зависеть друг от друга и взаимодействовать между собой;
2. **Networks** (Сети) - позволяют контейнерам взаимодействовать друг с другом (по умолчанию создается отдельная сеть для каждого проекта, но можно определить собственные сети и подключать контейнеры к ним);
3. **Volumes** (Тома) - используются для хранения данных, которые должны сохраняться между перезапусками контейнеров, могут быть подключены к контейнерам для обеспечения долговременного хранения данных.

```yml
version: <версия>
# имя проекта
name: <имя_проекта>
# сервисом может быть клиент, сервер, сервер баз данных...
services:
    <имя_сервиса>:
        # позволяет задать путь к файлу Dockerfile, который нужно использовать для создания образа, который позволит запустить сервис
        # где <путь> соответствует пути к папке сервера, которая содержит соответствующий Dockerfile
        build: <путь>
        # устанавливает указанный образ в формате [<registry>/][<project>/]<image>[:<tag>|@<digest>]
        image: <образ>
        # команда, которую нужно запустить после создания образа, как CMD в образе
        command: <команда>
        # указывает сколько инстансов нужно запустить
        scale: <количество>
        # указывает перенаправления портов в формате [<порт_компьютера>:]<порт_контейнера>[/<протокол>]
        # не влияет на взаимодействие контейнеров, так как они используют внутренние порты контейнеров внутри сети
        ports:
            - <порт_компьютера>:<порт_контейнера>
        # указывает какие порты необходимо пробросить из контейнера
        expose:
            - "<порт>"
        # используется для описания типа сети, указывается то, что контейнер может обращаться к 'localhost' компьютера
        network_mode: host
        # указывает, должен ли сервис, прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы <имя_сервиса>
        depends_on:
            - <имя_сервиса>
            <имя_сервиса>:
                condition: service_healthy # ожидание пока сервис не будет доступен
                condition: service_started # ожидание пока сервис не будет запущен
                restart: true # перезапуск после перехапуска зависимого сервиса
        # имя контейнера
        container_name: <имя_контейнера>
        # имя хоста
        hostname: <имя_хоста>
        # загружает в контейнер файл `<имя_конфигурации>` с настройками
        configs:
            - <имя_конфигурации>
        # загружает переменные окружения из файла для запускаемой команды
        env_file:
            - <путь>
        # устанавливает переменные окружения для запускаемой команды
        environment:
            <имя_переменной_окружения>: <значение>
        # указывает к каким сервисам можно подключиться в виде <имя_сервиса>[:<алиас>]
        links:
            - <имя_сервиса>
        # укащывает имена профилей при которых сервис запустится
        profiles:
            - <имя_профиля>
        # загружает в контейнер секрет по пути `/run/secrets/<имя_секрета>`
        secrets:
            - <имя_секрета>
        # указывает какие тома и как подключать
        volumes:
            # тип подключения, может быть: `volume`, `bind`, `tmpfs` или `npipe`
            - type: <тип>
              source: <относительный_путь_источника>
              target: <абсолютный_путь_назначения>
              read_only: true # только чтение
            - <относительный_путь_источника>:<абсолютный_путь_назначения>
        # указывает к каким сетям принадлежит сервис
        networks:
            - <имя_сети>
            <имя_сети>:
                ipv4_address: <ipv4>
        # указывает на проверку доступности сервиса
        healthcheck:
            test: ["CMD", "<команда>"[, "<аргумент1_для_команды>"[, ...] ]] # команда для проверки
            interval: <количество>s # интервал запуска проверок после первой удачной проверки
            timeout: <количество>s # максимальная длительность проверки
            retries: <количество> # количество неудачных проверок
            start_period: <количество>s # максимальное время старта когда не учитываются не удачные проверки
            start_interval: <количество>s # интервал запуска проверок после старта
configs:
    <имя_конфигурации>:
        file: <путь>
configs:
    <имя_секрета>:
        file: <путь>
networks:
    <имя_сети>:
        # указывает типа сети `host` - есть сеть, `bridge` - мост, а `none` - без сети
        driver: host
        internal: true # внутренняя сеть, без доступа вне контейрера
    <имя_сети>:
        driver: bridge
        ipam:
            driver: default
            config:
                # указывает подсеть через cdir
                - subnet: <cdir>
# указывает какие тома и как подключать
volumes:
    <том>:
```

Порты контейнеров, назначенные в файлах `Dockerfile`, будут открыты в сети, организуемой Docker Compose.

По умолчанию при запуске переменные окружения берутся из файла `.env`. Для использования их из файла используется подстановка в формате `${<имя_переменной_окружения>[:-<значение_по_умолчанию>]}`.
> `DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@db:5432/logistics`

`docker compose build` - выполняет команды `build` для всех сервисов.

`docker compose pull` - скачивает образы для всех сервисов.

`docker compose up [{-d | --detach}] [--no-deps] [--force-recreate] [--build]` - запуск всех сервисов [в фоне] [не запуская связанные сервисы] [всегда пересоздавая сервисы] [с выполнением команды `build` для всех сервисов].  
`docker compose -f <файл_конфигурации1>[ ...] up -d` - запуск всех сервисов из файла с настройками, которые сливаются вместе при совпадении полей или дополняются.

`docker compose config` - выводит итоговый манифест с подставленными значениями.

`docker compose down [{-v | --volumes}]` - остановка всех сервисов [с удалением всех хранилищ].  
`docker compose restart`  - перезапускает все сервисы.  
`docker compose restart <сервис>` - перезапускает указанный сервис.

`docker compose logs [-f] <сервис>` - выводит журналы сервиса [в реальном времени].  
`docker compose events <сервис>` - выводит журнал событий сервиса.

`docker compose ps` - выводит список сервисов.

`docker compose ls` - выводит список запущенных проектов на хосте.

`docker compose exec <сервис> <команда>` - выполняет команду в выполняющемся контейнере.

Для выполнения команды внутри контейнера используется такая конструкция:
```bash
docker compose exec -T <сервис> <команда> --port <порт> --quiet <<EOF
# <команды>
EOF
```

## <a id="Примеры" href="#Примеры">Примеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Файлы-для-сервера-ноды" href="#Файлы-для-сервера-ноды">Файлы для сервера ноды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Dockerfile для создания статики и запуска nginx сервера:
```Dockerfile
# использование образа с алиасом build для создания статики
FROM node:12-alpine as build
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# копирование исходного кода
COPY . /app
# запуск сборки
RUN npm run build
# использования образа nginx для запуска и отдачи статики
FROM nginx:1.16.0-alpine
# копирование из образа build из каталога /app/build в каталог /usr/share/nginx/html текущего образа
COPY --from=build /app/build /usr/share/nginx/html
# открытие порта 80 наружу
EXPOSE 80
# запуск команды на выполнение
CMD ["nginx", "-g", "daemon off;"]
```

Dockerfile для компиляции и запуска сервера ноды:
```Dockerfile
# использование образа с алиасом builder для комплиляции кода
FROM node:12-alpine as builder
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install
# копирование исходного кода
COPY . /app
# запуск компиляции
RUN npm run build
# использования образа ноды
FROM node:12-alpine
# создание директории и установка ее активной для следующих команд
WORKDIR /app
# копирование из образа builder из каталога /app/dist в каталог /app текущего образа
COPY --from=builder /app/dist /app
# копирование package.json внутрь контейнера
COPY package.json /app/package.json
# установка зависимостей
RUN npm install --only=prod
# открытие порта 8080 наружу
EXPOSE 8080
# установка пользователя
USER node
# запуск команды на выполнение
CMD ["node", "index.js"]
```

Файл `docker-compose.yml` для запуска образов:
```yml
version: "3"
services:
  api:
    build: ./services/api
    ports:
      - "8080:8080"
    depends_on:
      - db
    container_name: blog-api
  client:
    build: ./services/client
    ports:
      - "80:80"
    container_name: blog-client
  db:
    image: mongo
    ports:
      - "27017:27017"
    container_name: blog-db
```

Для общения между контейнерами используется имя контейнера вместо ip адреса localhost.
> `mongodb://localhost:27017/blog` -> `mongodb://blog-db:27017/blog`

<a id="Kubernetes" href="#Kubernetes">Kubernetes</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========

Это система для автоматизации развертывания, масштабирования контейнеризированных приложений и управления ими.

Основные компоненты:
- **кластер** - состоит из одного или нескольких мастер-узлов и рабочих узлов;
- **мастер-узлы** - управляют состоянием кластера, отвечают за планирование и координацию работы контейнеров;
- **рабочие узлы** (Nodes) - запускают контейнеры и управляют ими;
- **под** (Pod) - наименьшая единица, представляющая собой один или несколько контейнеров, которые работают вместе;
- **службы** (Services) - обеспечивают постоянный доступ к наборам подов, абстрагируя сетевые детали;
- **конфигурации** (ConfigMaps) и **секреты** (Secrets) - хранят конфигурационные данные и чувствительную информацию соответственно;
- **контроллеры** (Controllers) - управляют состоянием приложений, обеспечивают автоматическое восстановление и масштабирование.

В Kubernetes контейнеры или наборы контейнеров размещаются на **подах** (pod). **Под** - это логический хост. Один или несколько подов, а также сервисы для управления подами образуют **узел**, или ноду (node). **Узел** - это рабочая машина, виртуальная либо физическая. Однотипные узлы образуют **группу узлов**.

Узлы объединяются в **кластер**. У каждого кластера есть своя **панель управления** (control plane), именно она и обеспечивает оркестрацию. Один из узлов кластера становится главным - **мастером** (master). Он запускает управляющие процессы Kubernetes: сервер Kubernetes API, планировщик и контроллеры основных ресурсов.

В одном физическом кластере могут находиться несколько виртуальных. Виртуальный кластер называется **пространством имен** (namespace).

Что делает Kubernetes:
- **автоматическое развертывание** на основе файла конфигурации в котором описано состояние контейнеров, и Kubernetes автоматически обеспечит заданное состояние: будет развертывать и удалять контейнеры, перераспределять ресурсы;
- **мониторинг сервисов и балансировка**. Kubernetes распределяет сетевой трафик так, чтобы развертывание было стабильным;
- **оркестрация хранилища**. Kubernetes позволяет автоматически смонтировать систему хранения: локальное или облачное хранилище;
- **самоконтроль**. Kubernetes перезапускает отказавшие контейнеры, заменяет их и завершает работу контейнеров, которые не соответствуют заданному уровню работоспособности.

`kubectl <action> <resource>` - базовая структура для большинства команд, где `<action>` - какое либо действие над ресурсом `<resource>`.

**Ресурс** - это документ YAML/JSON.

Общие ключи:
- `--kubeconfig=<kubeconfig.conf>` - указывает конфигурационный файл для подключения;
- `--namespace=<namespace>` - указывает пространство имен;
- `-n <namespace>` - указывает пространство имен;
- `-o yaml` - указывает формат вывода yaml;
- `-o json` - указывает формат вывода json.

`kubectl describe <тип_ресурса> <имя_ресурса>` - выводит информацию о ресурсе `<имя_ресурса>` типа `<тип_ресурса>`.

`kubectl logs <тип_ресурса>/<имя_ресурса>` - выводит логи ресурса `<имя_ресурса>` типа `<тип_ресурса>`.

`kubectl get events --sort-by='.metadata.creationTimestamp' -A` - выводит все события в хронологическом порядке.

Для автомасштабирования используется инструменты:
- **Horizontal Pod Autoscaler** - масштабирует поды: увеличивает и уменьшает их количество, когда изменяется нагрузка, он ориентируется на лимиты (`limits`) и запросы (`requests`);
- **Cluster Autoscaler** - управляет количеством узлов, на которых поды запущены, он оценивает запросы подов и автоматически изменяет количество узлов кластера Kubernetes.

`kubectl create namespace <namespace>` - создает namespace.

Если ресурс созданный вне namespace по умолчанию, то он не будет виден без использования своего namespace, для этого нужно использовать `--namespace=<namespace>`.

`kubectl cluster-info` - выводит информацию о кластерах.

`kubectl api-resources` - выводит список доступных ресурсов.

`kubectl get nodes` - выводит информацию о нодах.

**Узел** (node) - это отдельная физическая или виртуальная машина, на которой развернуты и выполняются контейнеры приложений. Каждый узел в кластере содержит сервисы для запуска приложений в контейнерах (например Docker), а также компоненты, предназначенные для централизованного управления узлом.

`kubectl apply -f <путь_к_файлу_манифеста.yaml>` - выполняет манифест.

Для выполнения манифеста из файла используется:
```bash
kubectl apply -f - <<EOF
# манифест
EOF
```

В одном манифесте можно описывать множество компонентов и они должны разделяться `---`.

`kubectl patch <тип_ресурса> <имя_ресурса> --patch-file <путь_к_файлу_манифеста.yaml>` - выполняет патч к ресурсу `<имя_ресурса>` типа `<тип_ресурса>` с изменениями из файла `<путь_к_файлу_манифеста.yaml>`, сам файл должен содержать только ту часть, которую нужно изменить.

`kubectl edit <тип_ресурса> <имя_ресурса>` - редактирует манифест ресурса `<имя_ресурса>` типа `<тип_ресурса>` и применяет его.

`kubectl set env <тип_ресурса>/<имя_ресурса> <имя_переменной_окружения>=<значение_переменной_окружения>` - устанавливает переменную окружения для ресурса `<имя_ресурса>` типа `<тип_ресурса>`.

`kubectl create secret generic <имя_секрета> --from-file <путь_к_файлу_с_секретом>` - создает секрет `<имя_секрета>` из файла `<путь_к_файлу_с_секретом>`.

## <a id="Под" href="#Под">Под</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Под** (pod) - базовая единица для запуска и управления приложениями: один или несколько контейнеров (Докер и подобные), которым гарантирован запуск на одном узле, обеспечивается разделение ресурсов и межпроцессное взаимодействие и предоставляется уникальный в пределах кластера IP-адрес, что позволяет приложениям, развернутым на поде, использовать фиксированные и предопределенные номера портов без риска конфликта. Поды могут напрямую управляться с использованием API Kubernetes или управление ими может быть передано контроллеру. Общие ресурсы: хранилище, сеть (один IP адрес и порт) и информация о запуске. Могут иметь метки. Поды находятся в приватной, изолированной сети и по умолчанию видны другим подам и сервисам в том же кластере. Сервер автоматически создает конечную точку для каждого пода основываясь на имени пода. Поды объединяются в `ReplicaSet`, который контролирует их количество и доступность и запускает новые, если старые умерли.

`kubectl get pods [-l <метка>=<значение>] [-o wide]` - выводит список подов [отфильтрованых по метке и ее значению] [в расширенном формате].  
`kubectl describe pods` - выводит информацию о подах.  
`kubectl describe <имя_пода>` - выводит информацию о поде.

`kubectl logs [--previous] [--tail=<n>] <имя_пода>` - выводит логи пода [предыдущего], весь вывод в stdout.

`kubectl exec [-it] <имя_пода> -- <команда>` - запускает команду `<команда>` на поде `<имя_пода>` [не отключаясь от терминала].  
`kubectl exec -i <имя_пода> -- /bin/sh` - подключается к поду с терминалом.

`kubectl delete pod [--force] <pod>` - удаляет под [принудительно].

`export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}{{.metadata.name}}{{"\n"}}{{end}}')` - получает имя текущего пода.  
`curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/` - возвращает информацию о поде.  
`curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/` - возвращает информацию о прокси пода.

`kubectl proxy` - создает прокси для соединения хостом и кластером.

`kubectl port-forward pod/<имя_пода> <внешний_порт>:<порт_в_поде>` - устанавливает проброс портов с пода `<имя_пода>` на локальный хост, что позоволяет получить доступ по `localhost:<внешний_порт>`.

`kubectl label pods <имя_пода> <метка>=<значение>` - устанавливает метку со значением поду.

Манифест для Pod:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: <имя>
spec:
  containers:
    - name: <имя_контейнера_1>
      image: <образ_для_контейнера>
      imagePullPolicy: Never # политика для загрузки образов, указывается для того чтобы не загружать образ из интернета
      command: ["<команда_запуска>"]
      # пробрасываемые порты
      ports:
        - containerPort: <порт>
          name: <имя_порта>
      # описывает переменные окружения
      env:
        - name: <имя_переменной_окружения>
          value: <значение_переменной_окружения>
      # монтирумые хранилища
      volumeMounts:
        - mountPath: <путь_монтирования>
          name: <имя_хранилища>
          readOnly: true # только чтение
      # устанавливает ресурсы для контейнера
      resources:
        # гарантированные ресурсы
        requests:
          memory: "<количество>Mi" # оперативная память
          cpu: "<количество>m" # количество частей виртуальных ядер в <количество> * 0.001 от 1 ядра
        # максимальные ресурсы
        limits:
          memory: "<количество>Mi"
          cpu: "<количество>m"
      # определяет liveness-пробы
      livenessProbe:
        httpGet: # описывает http пробу методом get
          path: <путь>
          port: <порт>
          # дополнительные заголовки
          httpHeaders:
          - name: <имя_заголовка>
            value: <значение_заголовка>
        initialDelaySeconds: <отсрочка> # указывает через сколько времени начать пробы
        periodSeconds: <период> # частота взятия проб
        failureThreshold: <количество> # количество неудачных проб (ответ не 200 или таймаут) для перезапуска пода
  restartPolicy: {Never | OnFailure} # политика перезапуска контейнеров в случае ошибок, Never - никогда, только через пересоздание пода, OnFailure - возможен перезапуск
```

## <a id="ReplicaSet" href="#ReplicaSet">ReplicaSet</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**ReplicaSet** - это персистентный набор подов. Основное назначение создание и поддерживание нужного количества активных подов - рестарт подов при наличии ошибок, создание новых в случае удаления (например, в сценарии с падением ноды или удаление одного из подов руками).

`kubectl get rs` - выводит список подов в `ReplicaSet`.

Манифест для ReplicaSet:
```yaml
apiVersion: v1
kind: ReplicaSet
metadata:
  name: <имя>
spec:
  replicas: <количество_подов>
  # определяет шаблон для подов
  template:
    metadata:
      # это произвольные key-value пары, хранящие метаинформацию о поде
      labels:
        <ключ>: <значение>
        # используется для идентификации приложения
        app: <имя_приложения>
    spec:
      containers:
        # содержимое аналогично секции из манифеста Pod: spec.containers
  # это способ понять, какие поды из числа уже существующих в кластере относятся к нему
  selector:
    matchLabels:
      app: <имя_приложения>
```

## <a id="Deployment" href="#Deployment">Deployment</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Deployment** - поведение аналогично **ReplicaSet**, то с дополнительными возможностями по плавной выкатке подов. При создании создает **ReplicaSet**, который порождает нужное количество подов и берется следить, чтобы их количество не менялось. При необходимости перевыкатки возьмет на себя создание второго **ReplicaSet** и постепенное масштабирование их обоих до тех пор, пока в старом не останется подов.

`kubectl create deployment <имя_деплоя> --image=<docker_образ>` - создает размещение docker образа `<docker_образ>` приложения под именем `<имя_деплоя>`.  
`kubectl get deployments` - выводит информацию о размещениях.  
`kubectl describe deployment` - выводит информацию о размещении.

`kubectl scale deployments/<имя_деплоя> --replicas=<количество>` - устанавливает количество реплик для размещения.

`kubectl set image deployments/<имя_деплоя> <имя_деплоя>=<docker_образ>` - обновляет образ размещения.

`kubectl rollout restart deployments/<имя_деплоя>` - начинает обновление.  
`kubectl rollout status deployments/<имя_деплоя>` - подтверждает обновления новым образом.  
`kubectl rollout undo deployments/<имя_деплоя>` - отклоняет обновления новым образом и возвращается на предыдущий.

Манифест для Deployment:
```yaml
apiVersion: v1
kind: Deployment
metadata:
  name: <имя>
spec:
  replicas: <количество_подов>
  # определяет шаблон для подов
  template:
    metadata:
      # это произвольные key-value пары, хранящие метаинформацию о поде
      labels:
        <ключ>: <значение>
        # используется для идентификации приложения
        app: <имя_приложения>
    spec:
      containers:
        # содержимое аналогично секции из манифеста Pod: spec.containers
  # это способ понять, какие поды из числа уже существующих в кластере относятся к нему
  selector:
    matchLabels:
      app: <имя_приложения>
  # устанавливает стратегию обновления
  strategy:
    rollingUpdate:
      maxUnavailable: "{<процент>% | <количество>}" # максимальный {<процент>% | <количество>} подов в недоступном состоянии при обновлении
      maxSurge: "{<процент>% | <количество>}" # максимальный {<процент>% | <количество>} лишних подов в моменте обновления, сверх лимита
```

## <a id="HorizontalPodAutoscaler" href="#HorizontalPodAutoscaler">HorizontalPodAutoscaler</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**HorizontalPodAutoscaler** (HPA) - это ресурс по автоматическому горизональному масштабированию.

Манифест для HorizontalPodAutoscaler:
```yaml
apiVersion: v1
kind: HorizontalPodAutoscaler
metadata:
  name: <имя>
spec:
  # указывает, для какого Deployment добавить масштабирование
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: <имя_deployment>
  minReplicas: <количество> # минимальное количество реплик
  maxReplicas: <количество> # максимальное количество реплик для масштабирования
  # определяет метрики для масштабирования
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: <процент> # процент утилизации по всем репликам после которого нужно начать масштабировать
  - type: Resource
    resource:
      name: memory
      target:
        type: AverageValue
        averageValue: <количество>Mi # среднее количество памяти по всем репликам после которого нужно начать масштабировать
```

## <a id="StatefulSet" href="#StatefulSet">StatefulSet</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**StatefulSet** - это стабильный упорядоченный набор подов с фиксированными именами (и адресами, по которому можно обращаться к ним внутри кластера) и доступом к персистентным томам.

`kubectl get persistentvolumes` - выводит список хранилищ.

`kubectl delete pvc <имя_хранилища>` - удаляет хранилище.

Манифест для StatefulSet:
```yaml
apiVersion: v1
kind: StatefulSet
metadata:
  name: <имя>
spec:
  replicas: <количество_подов>
  # определяет шаблон для подов
  template:
    metadata:
      # это произвольные key-value пары, хранящие метаинформацию о поде
      labels:
        <ключ>: <значение>
        # используется для идентификации приложения
        app: <имя_приложения>
    spec:
      containers:
        # содержимое аналогично секции из манифеста Pod: spec.containers
  # это способ понять, какие поды из числа уже существующих в кластере относятся к нему
  selector:
    matchLabels:
      app: <имя_приложения>
  # описывает шаблоны хранилища
  volumeClaimTemplates:
    - metadata:
        name: <имя_хранилища>
      spec:
        # тип монтирования
        accessModes:
          - ReadWriteOnce # можно читать/писать только на одной ноде
        # описания хранилища
        resources:
          requests:
            storage: 100Mi # размер
  # описывает существующие хранилища
  volumes:
    - name: <имя_хранилища>
      # тип хранилища - секрет
      secret:
        secretName: <имя_секрета>
        optional: false
```

## <a id="Контроллер" href="#Контроллер">Контроллер</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Контроллер** (controller) - это процесс, который управляет состоянием кластера, пытаясь привести его от фактического состояния к желаемому; он делает это, оперируя набором подов, определяемых с помощью селекторов меток и являющихся частью определения контроллера.

## <a id="Сервис" href="#Сервис">Сервис</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Сервис** (service) - это совокупность логически связанных наборов подов и политик доступа к ним. Например, сервис может соответствовать одному из уровней программного обеспечения, разработанного в соответствии с принципами многоуровневой архитектуры программного обеспечения. Набор подов, соответствующий сервису, получается в результате выполнения селектора соответствующей метки. Сервисы позволяют приложениям получать внешний трафик с помощью меток - пары ключей и значений, и селекторов.

`kubectl get services [-l <метка>=<значение>]` - выводит список сервисов.  
`kubectl describe services/<имя_сервиса>` - выводит информацию о сервисе.  
`kubectl delete service -l <метка>=<значение>` - удаляет сервис с определенной меткой и ее значением.

`kubectl expose deployment/<имя_деплоя> --type="NodePort" --port <порт> service/<имя_сервиса> exposed` - создает сервис для открытия размещения по указанному порту.

`export NODE_PORT=$(kubectl get services/<имя_сервиса> -o go-template='{{(index .spec.ports 0).nodePort}}')` - получает порт сервиса.

Манифест для Service (ClusterIP):
```yaml
apiVersion: v1
kind: Service
metadata:
  name: <имя>
spec:
  # указывает тип сервиса
  type: ClusterIP # тип связи, который позволяет подам связываться друг с другом в рамках кластера, но абсолютно никак не виден снаружи
  clusterIP: None
  # это способ понять, какие поды из числа уже существующих в кластере относятся к нему
  selector:
    app: <имя_приложения>
```

Манифест для Service (NodePort):
```yaml
apiVersion: v1
kind: Service
metadata:
  name: <имя>
spec:
  # указывает тип сервиса
  type: NodePort # тип связи по порту к группе подов
  # это способ понять, какие поды из числа уже существующих в кластере относятся к нему
  selector:
    app: <имя_приложения>
  ports:
    - protocol: TCP
      port: <порт>
```

`<имя_сервиса>.<namespace>.svc.cluster.local` - используется для связи с сервисом `<имя_сервиса>` и попаданием на неопределенный под в пространстве имен `<namespace>`.

`<имя_пода>.<имя_сервиса>.<namespace>.svc.cluster.local` - используется для связи с подом `<имя_пода>` в сервисе `<имя_сервиса>` в пространстве имен `<namespace>`.

## <a id="Ingress" href="#Ingress">Ingress</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Ingress** - это ресурс, инкапсулирующий правило роутинга.

Манифест для Ingress:
```yaml
apiVersion: v1
kind: Ingress
metadata:
  name: <имя>
spec:
  # описывает правила роутинга
  rules:
      # описывает хосты
    - host: <хост>
      # протокол http
      http:
        paths:
          - path: <префикс_пути>
            pathType: Prefix
            backend:
              service:
                name: <имя_сервиса>
                port:
                  number: <порт_сервиса>
```

## <a id="Job" href="#Job">Job</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Job** - это ресурс для одноразового выполнения асинхронных задач.

Манифест для Job:
```yaml
apiVersion: v1
kind: Job
metadata:
  name: <имя>
spec:
  # определяет шаблон для подов
  template:
    spec:
      containers:
        # содержимое аналогично секции из манифеста Pod: spec.containers
  backoffLimit: <количество> # максимальное количество попыток
```

`kubectl create job --from="cronjob/<имя_job>" [<новое_имя_job>]` - создает джобу, на основе кронджобы `cronjob/<job-name>` [с новым именем `<новое_имя_job>`] и запускает ее.

## <a id="minikube" href="#minikube">minikube</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`minikube start --driver=hyperkit` - запускает эмуляцию кластера kubernetes с гипервизором для локальной разработки.

`(eval $(minikube docker-env) && <docker_команда>)` - позволяет использовать Docker daemon из minikube и выполнять в нем команды.
> `(eval $(minikube docker-env) && docker images)`

`minikube addons enable ingress` - включает поддержку ingress.

`minikube tunnel` - включает тунель для проброски портов 80 и 443 внутрь minikube.

`minikube delete` - удаляет кластер.

## <a id="Helm" href="#Helm">Helm</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это пакетный менеджер Kubernetes, который позволяет запускать, обновлять и откатывать приложения. Основная сущность Helm - это чарты.

**Чарт** (Chart) - это пакеты Helm, содержащие все необходимые описания Kubernetes-ресурсов для развертывания приложения. Они включают шаблоны YAML-файлов, которые определяют конфигурацию и ресурсы Kubernetes - Pods, Services, Deployments и другие. Чарты также могут включать зависимости и скрипты для предварительной и последующей настройки.

Чарты позволяют пакетировать все необходимые конфигурации и зависимости приложения в один пакет, что делает развертывание приложений и управление ими более удобным и повторяемым.

**Релиз** (Release) - это развернутые инстансы чартов в кластере Kubernetes. Каждый раз, когда чарт устанавливается в кластер, создается новый релиз, который можно обновлять, отменять и удалять - эффективно управлять жизненным циклом приложений.

Релизы позволяют управлять состоянием развернутых приложений, обеспечивают контроль версий и возможность отката, что особенно полезно для управления обновлениями и восстановлением в случае проблем.

**Репозитории** (Repositories) - это хранилища, где размещаются чарты, которые упрощают доступ к чартам и управление ими, помогают легко находить и использовать готовые решения для распространенных задач, позволяют делиться чартами с другими пользователями и командами.

`helm create <имя_чарта>` - создает Helm-Chart - это каталог с именем `<имя_чарта>` в котором есть:
- `charts/` - каталог, содержащий сторонние чарты, от которых зависит текущий;
- `Chart.yaml` - файл, содержащий основные сведения о чарте;
- `templates/` - каталог, содержащий шаблоны Kubernetes с возможностью форматирования и вставки значении Helm;
- `templates/*.tpl` - файлы, содержащие именнованые шаблоны. В файлах с расширением `tpl` размещаются шаблоны, которые можно использовать в манифестах;
- `requirements.yaml` - файл с зависимостями чарта;
- `values.yaml` - файл, содержащий переменные, используемые в шаблонах. Содержит стандартные значения, и при установке релиза можно указать собственные.

`helm install [--dry-run] <имя_релиза> <путь_к_чарту>` - производит установку [только отображение действий] релиза `<имя_релиза>` на основе чарта `<путь_к_чарту>`.

`helm list` - выводит список релизов.

`helm upgrade <имя_релиза> <путь_к_чарту>` - обновляет релиз `<имя_релиза>` на основе чарта `<путь_к_чарту>`.

`helm rollback <имя_релиза> <версия>` - откатывает релиз на версию `<версия>`.

`helm init` - устанавливает Helm в кластере Kubernetes.

`helm dependency update <путь_к_чарту>` - устанавливает или обновляет зависимости.

### <a id="Шаблоны" href="#Шаблоны">Шаблоны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Внутри tpl-шаблонов или `yaml` можно использовать шаблонные функции.

`{{ .<имя_переменной> }}` - производит подстановку в код текущего значения переменной с именем `<имя_переменной>`.
> `{{ .Release.Service }}`

`{{ .<имя_переменной> | <функция_1> [<арг_1>[ ...]] [| ...] }}` - производит подстановку в код текущего значения переменной с именем `<имя_переменной>`, которая была отформатирована с помощью функций.
> `{{ .Chart.AppVersion | quote }}`

`{{/* <комментарий> */}}` - содержит комментарий, который нее подставляется в код.

Условная конструкция:
```
{{- if .<имя_переменной> }}
содержит код при истинном условии
{{- else }}
содержит код при ложном условии
{{- end }}
```

Основные переменные:
- `.Release.Name` - содержит имя релиза;
- `.Chart.<путь>` - содержит значение из файла `Chart.yaml` по пути вложености `<путь>`;
- `.Values.<путь>` - содержит значение из файла `values.yaml` по пути вложености `<путь>`;

### <a id="Структура-чарта" href="#Структура-чарта">Структура чарта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="Chartyaml" href="#Chartyaml">`Chart.yaml`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основной файл, содержащий метаданные чарта.

Имеет структуру:
```yaml
apiVersion: v2
name: <имя_чарта>
description: <описание>
type: application
version: <версия_чарта>
appVersion: <версия_приложения>
```

#### <a id="valuesyaml" href="#valuesyaml">`values.yaml`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Файл конфигурации с параметрами по умолчанию. Содержит значения конфигурации, которые могут быть изменены при установке чарта для адаптации к различным средам.

Имеет произвольную структуру.

<a id="Terraform" href="#Terraform">Terraform</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

Это программа, которая позволяет создавать облачную инфраструктуру (не только ВМ, но и балансировщики, сети, базы данных, хранилища и т. д.) по файлу спецификации на языке HCL в файлах формата `.tf`, из которой автоматически развернется готовая инфраструктура.

Terraform позволяет предварительно посмотреть план выполнения: что будет создано и удалено в процессе работы.

## <a id="Состояние-State" href="#Состояние-State">Состояние (State)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Информация о созданной инфраструктуре сохраняется в файлах с расширением`.tfstate`.

Terraform сравнивает текущее состояние ресурсов с тем, что описано в конфигурационных файлах (`.tf` файлах), что позволяет ему понять, что уже существует, что изменилось и что нужно создать или удалить.

Файл состояния включает в себя:
- список всех созданных ресурсов, их идентификаторы и текущие конфигурации;
- метаданные, такие как атрибуты, зависимости, IP-адреса, размеры дисков и другие параметры.

Основные параметры ресурса в state:
- `mode` - тип ресурса в state: `data` или `managed`;
- `type` - тип блока ресурса;
- `name` - имя блока ресурса;
- `attributes` - выходные атрибуты, которые получил Terraform при применении и сохранил в state.

## <a id="Провайдеры-Providers" href="#Провайдеры-Providers">Провайдеры (Providers)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Провайдеры** - используются для взаимодействия с сервисами облачных или локальных ресурсов в Terraform, которые служат мостом между описанием инфраструктуры в виде конфигурационного кода и реальными ресурсами, которые должны быть созданы, изменены или удалены.

## <a id="Ресурсы-Resources" href="#Ресурсы-Resources">Ресурсы (Resources)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Ресурсы** - это инфраструктурные компоненты, которыми управляет Terraform (например виртуальные машины, сетевые интерфейсы, базы данных, балансировщики нагрузки и т. д.) Ресурсы описываются в конфигурационных файлах. У каждого ресурса есть собственный тип и набор атрибутов.

## <a id="Провиженеры-Provisioners" href="#Провиженеры-Provisioners">Провиженеры (Provisioners)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Провиженеры** - это инструменты, которые позволяют настроить созданные ресурсы: установить программное обеспечение, скопировать файлы или выполнить скрипты после их развертывания.

## <a id="Блоки" href="#Блоки">Блоки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Блок используется для описания конфигурации и состоит из определения и тела блока:
```hcl
<тип_блока> ["<тип_блока_ресурса>"] "<имя_блока>" {
    <тело_блока>
}
```

Где:
- `<тип_блока>` - тип блока, который может быть:
    - `data` - данные;
    - `resource` - ресурс - инфраструктурный объект;
    - `provider` - провайдер - плагин для работы с определенной облачной платформой или системой;
    - `variable` - переменная;
    - `module` - модуль - переиспользуемая конфигурация;
    - `output` - выходные атрибуты - данные, которые будут доступны после применения конфигурации;
- `<тип_блока_ресурса>` - тип блока ресурса, к которому относится блок;
- `<имя_блока>` - локальное имя блока, которое будет выступать в качестве ссылки во всем пространстве имен конфигурации;
- `<тело_блока>` - содержит атрибуты для определения параметров.

### <a id="Провайдеры" href="#Провайдеры">Провайдеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имеет вид:
```hcl
provider "<имя_провайдера>" {
    <атрибуты_провайдера>
}
```

### <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для использования они должны быть объявлены в спецификации в блоке:
```hcl
variable "<имя_переменной>" {
    description = "<описание>"
    type = <тип>
    default = <значение_по_умолчанию>
    validation {
        condition = <условие_валидации>
        error_message = <ошибка_валидации>
    }
    sensitive = true
    nullable = false
}
```

Где:
- `<имя_переменной>` - определяет имя переменной и не может быть одним из: `source`, `version`, `providers`, `count`, `for_each`, `lifecycle`, `depends_on`, `locals`;
- `<тип>` - задает тип переменной и может быть:
    - простым типом:
        - `string` - последовательность символов Unicode, представляющая текст;
        - `number` - числовое значение, которое может представлять целые числа и дробные значения;
        - `bool` - логическое значение (`true` / `false`), которое может использоваться в условной логике;
    - коллекцией:
        - `list(<тип>)` - список из значений типа `<тип>`, задается как: `[<значение_1>[, ...]]`:
            > `list(number)`
        - `map(<тип>)` - карта из значений типа `<тип>`, задается как: `{ <ключ_1>: <значение>[, ...] }`:
            > `map(string)`
        - `set(<тип>)` - уникальный список - набор, из значений типа `<тип>`, задается как: `[<значение_1>[, ...]]`:
            > `set(string)`
    - структурой:
        - `object({ <ключ_1>: <тип>[, ...] })` - структура для группировки нескольких значений различных типов данных в одно, задается как: `{ <ключ_1>: <значение>[, ...] }`;
            > `object({ name = string, description = string, labels = map(string) })`
        - `tuple(<тип_1>[, ...])` - кортеж для группировки нескольких значений различных типов данных в одну последовательность, задается как: `[<значение_1>[, ...]]`:
            > `tuple(string, number, bool)`
    - `optional(<тип>, <значение_по_умолчанию>)` - опциональныи типом, где значение по умолчанию будет использоваться если не передано значение атрибута или передано `null`, по умолчанию = `null`:
        > `optional(bool, null)`
    - `any` - любым типом;
- `<описание>` - (не обязательное поле) задает описание переменной;
- `<значение_по_умолчанию>` - (не обязательное поле) задает проверку значения переменной;
- `<условие_валидации>` - (не обязательное поле) задает условие валидации, которое должно быть условием и возвращать `true` для валидного значения, внутри можно ссылаться на значение переменной `var.<имя_переменной>`:
    > `length(var.image_id) > 4 && substr(var.image_id, 0, 4) == "ami-"`
- `<ошибка_валидации>` - (не обязательное поле) задает текст ошибки валидации;
- `sensitive = true` - (не обязательное поле) ограничивает вывод интерфейса Terraform при использовании переменной в конфигурации;
- `nullable = false` - (не обязательное поле) убирает возможность присваивать `null` переменной.

Установка значений:
- `<имя_переменной> = "<строка>"` - для строк;
- `<имя_переменной> = <<EOF<многострочная_строка>EOF` - для многострочных строк;
- `<имя_переменной> = <число>` - для чисел;
- `<имя_переменной> = {true | false}` - для булевых значений;
- `<имя_переменной> = [<значение_1>[, ...]]` - для списка, набора, где значение должно быть одного типа;
    > `[4, 8, 15, 16, 23, 42]`  
    > `["apple", "cherry", "banana"]`
- `<имя_переменной> = [<значение_1>[, ...]]` - для кортежей;
    > `["example", 42, true]`
- `<имя_переменной> = {<ключ_1> = <значение>[, ...]}` - для карты пар ключ-значение, где значение должно быть одного типа:
    > `{owner = "DevOps", project = "infra"}`
- `<имя_переменной> = {<ключ_1> = <значение>[, ...]}` - для структур:
    > `{name = "infra", description = "Infrastracture", labels = {environment = "production", owner = "DevOps"}}`

Переменные можно объявлять локально в файлах в блоке:
```hcl
locals {
    <имя_переменной_1> = <значение>
}
```

Использование переменной: `var.<имя_переменной>`, а из локального файла тогда будет: `local.<имя_переменной>`.

В строках можно указывать подстановку значений при использовании конструкции: `${var.<имя_переменной>}`.
> `"web-sg-${var.resource_tags["project"]}-${var.resource_tags["environment"]}"`

Для карты можно использовать: `var.<имя_переменной>["<ключ>"]` для возвращения значения по ключу.

Для структур можно использовать: `var.<имя_переменной>.<ключ>` для возвращения значения по ключу.

#### <a id="Выходные-значения" href="#Выходные-значения">Выходные значения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Выходные значения** предоставляют информацию об инфраструктуре в командной строке и могут предоставлять информацию для использования другими конфигурациями Terraform.

Выходные значения - это способ предоставить пользователям модуля экспортируемые атрибуты.

Выходные значения отображаются только при применении плана Terraform.

Описываются в файле спецификаций в формате блоков:
```hcl
output "<имя_выходного_значения>" {
    description = "<описание>"
    value = <путь_к_значению>
    sensitive = true
}
```

Где:
- `<путь_к_значению>` - забирает значение переменной по указанному пути;
- `<описание>` - (не обязательное поле) задает описание выходного значения;
- `sensitive = true` - (не обязательное поле) указывает, что вывод нужно скрыть.

`terraform output <имя_выходного_значения>` - выводит значение выходного значения, даже если оно `sensitive`.

#### <a id="Стандартные-функции" href="#Стандартные-функции">Стандартные функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Функции для строк:
- `concat(<строка_1>, <строка_2>)` - возвращает объединенные строки;
- `replace(<строка>, <строка_поиска>, <строка_замены>)` - возвращает строку в которой будет заменено `<строка_поиска>` на `<строка_замены>`;
- `substr(<строка>, <начальный_индекс>, <конечный_не_включаемый_индекс>)` - возвращает подстроку от `<начальный_индекс>` и до `<конечный_не_включаемый_индекс>`, если `<начальный_индекс>` < 0, то отсчет идет с конца строки;
- `upper(<строка>)` - возвращает строку в верхнем регистре.

Функции для чисел:
- `max(<число_1>, <число_2>)` - возвращает максимальное число;
- `min(<число_1>, <число_2>)` - возвращает минимальное число;
- `ceil(<число>)` - возвращает округленное вверх число;
- `floor(<число>)` - возвращает округленное вниз число.

Функции для коллекций:
- `slice(<список>, <начальный_индекс>, <конечный_не_включаемый_индекс>)` - возвращает подсписок списка `<список>` от индекса `<начальный_индекс>` и до индекса `<конечный_не_включаемый_индекс>`;
- `contains(<список>, <значение>)` - возвращает `true` если список `<список>` содержит значение `<значение>` иначе `false`;
- `keys(<карта>)` - возвращает список ключей из карты `<карта>`;
- `values(<карта>)` - возвращает список значений из карты `<карта>`;
- `flatten(<список>)` - возвращает список значений из списка списков `<список>`;
- `merge(<карта_1>, <карта_2>)` - возвращает слитые карты;
- `length(<список>)` - возвращает количество элементов в списке, наборе, карте;
- `split(<разделитель>, <строка>)` - возвращает список значений из строки, который разделен разделителем `<разделитель>`.

Функции для даты и времени:
- `timestamp()` - возвращает текущую отметку времени - таймштамп;
- `formatdate("<формат>", <таймштамп>)` - фозвращает отформатированный таймштамп:
    > `formatdate("YYYY-MM-DD.hh-mm-ss", timestamp())`

Функции для кодирования и декодирования:
- `base64encode(<строка>)` - возвращает строку закодированную в формате base64;
- `base64decode(<base64_строка>)` - возвращает раскодированную строку из формата base64.

Функции проверки:
- `try(<значение_1>[, ...])` - возвращает первое валидное значение.

Функции для файлов:
- `file(<путь_к_файлу>)` - возвращает содержимой файла в виде строки по пути `<путь_к_файлу>`.

#### <a id="Шаблоны" href="#Шаблоны">Шаблоны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Представляют из себя файлы с расширением `.tftpl`. Который можно отрендерить с помощью функции: `templatefile("<файл>.tftpl", <параметры>)`, где:
- `<файл>` - это файл с шаблоном;
- `<параметры>` - объект с параметрами для шаблона.

Отрендеренный шаблон можно сохранять в переменную или выходное значение:
```hcl
output "<имя_выходного_значения>" {
    value = templatefile("<файл>.tftpl", <параметры>)
}
```

Внутри шаблона можно использовать:
- `${<имя_параметра>}` - для вывода значения;
- `%{ for [<index>, ]<value> in <список> ~}<тело>%{ endfor ~}` - для повторения блока `<тело>` для элементов списка;
- `%{ for <key>, <value> in <карта> ~}<тело>%{ endfor ~}` - для повторения блока `<тело>` для элементов карты.

```hcl
%{ for addr in ip_addrs ~}
backend ${addr}:${port}
%{ endfor ~}
```

#### <a id="Предустановленные-значения-переменных" href="#Предустановленные-значения-переменных">Предустановленные значения переменных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Предустановленные значения переменных Terraform хранятся в файлах с расширением `.tfvars`. Для подключения используется ключ `-var-file=<имя_файла_с_переменными>.tfvars`, который добавляется к командам вызова.
> `terraform apply -var-file=my-variables.tfvars`

Terraform автоматически загружает файлы: `terraform.tfvars`, `terraform.tfvars.json`, `*.auto.tfvars`, `*.auto.tfvars.json`.

Стркутура файла выглядит в виде строк формата: `<имя_переменной> = <значение>`.

С помощью ключа: `-var="<имя_переменной>=<значение>"` при использовании команд. Может повторяться для указания больше чем одной переменной.
> `terraform apply -var='image_id_list=["fd8ne6e3etbrr2ve9nlc","fd8fsjddp35jvb4e4jo7"]' -var="cores=4"`

С помощью переменных окружения, которые задаются в формате: `TF_VAR_<имя_переменной>=<значение>`.
> `TF_VAR_image_id=fd8ne6e3etbrr2ve9nlc terraform plan`

### <a id="Ресурсы" href="#Ресурсы">Ресурсы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для создания и изменения ресурсов. Описываются в файле спецификаций в формате блоков:
```hcl
resource "<имя_провайдера_ресурса>" "<имя_ресурса>" {
    count = <количество>
    for_each = <перечисление>
    depends_on = <перечисление_зависимостей>
    # атрибуты ресурса
    # провиженеры
}
```

Где:
- `<количество>` - (не обязательное поле) количество описываемых ресурсов, может использоваться в описании потом как: `count.index`, который будет равен текущему индексу ресурса;
- `<перечисление>` - (не обязательное поле) набор или карта по которому будет производится итерирование для описываемых ресурсов, может использоваться в описании потом как: `each.value`, который будет содержать элемент из набора или карты, а `each.key` - ключ этого элемента;
- `<перечисление_зависимостей>` - (не обязательное поле) набор зависимостей, который состоит из ссылок на ресурсы от которых зависист текущий ресурс.

Если используется `count`, то для обращения к ресурсу используется: `<имя_провайдера_ресурса>.<имя_ресурса>[<индекс>]`.

Если используется `for_each`, то для обращения к ресурсу используется: `<имя_провайдера_ресурса>.<имя_ресурса>[<ключ>]`.

Для перечисления блока может использоваться `dynamic`:
```hcl
dynamic "<имя_блока>" {
    for_each = <перечисление>
    content {
        <содержимое_блока>
        # <имя_блока>.key - ключ
        # <имя_блока>.value - элемент из набора или карты
    }
}
```

##### <a id="Провиженеры" href="#Провиженеры">Провиженеры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Провиженеры** позволяют копировать файлы на удаленные машины и выполнять скрипты локально или удаленно для настройки развернутой инфраструктуры.

Внутри ресурса могут повторяться множество раз.

Для подключения к удаленной машине используется блок `connection`, который располагается либо в `resource`, либо в `provisioner`:
```hcl
connection {
    type        = "ssh"
    user        = "<имя_пользователя>"
    private_key = <приватный_ключ>
    host        = <хост>
}
```

Где:
- `<имя_пользователя>` - имя пользователя;
- `<приватный_ключ>` - приватный ключ пользователя;
- `<хост>` - хост удаленной машины.

```hcl
connection {
    type        = "ssh"
    user        = "ubuntu"
    private_key = var.private_key
    host        = self.network_interface.0.nat_ip_address
}
```

Внутри провиженера или блока подключения можно ссылаться на текущий ресурс через специальный объект: `self.<атрибут>`, также можно ссылаться на переменные.

Провижининг можно использовать без конкретного ресурса, а использоваться специальный тип ресурс `terraform_data` или `null_resource`.

Подходящие случаи использования `remote-exec`:
- **настройка сервера после развертывания** для установки и настройки программного обеспечения;
- **выполнение скриптов настройки** на самом инстансе;
- **инициализация** - запуск сервисов, настройка файрвола, регистрация в системах управления конфигурациями или в панелях мониторинга и т.д.;
- **тестирование развертываемых узлов** - автоматическое выполнение тестов для проверки конфигурации или работоспособности системы после развертывания.

Подходящие случаи использования `local-exec`:
- **инициирование внешних скриптов или процессов** - например, запуск скрипта для регистрации нового устройства в системе мониторинга или бэкапа, если эти задачи нельзя выполнить с помощью кастомных провайдеров;
- **взаимодействие с API внешних сервисов** с которыми Terraform не может работать напрямую либо с помощью кастомных провайдеров;
- **логирование и уведомления** в локальных системах по завершении действий Terraform;
- **интеграция с другими инструментами** - вызов внешних инструментов или систем, которые должны запускаться после или во время выполнения Terraform, если для них нет подходящих провайдеров.

###### <a id="Провиженер-file" href="#Провиженер-file">Провиженер `file`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Провиженер `file` копирует файлы или директории с машины, на которой запущен Terraform, на удаленную машину. Подключение может быть выполнено через SSH и WinRM:
```hcl
provisioner "file" {
    source      = "<локальный_путь>"
    content     = "<содержимое>"
    destination = "<путь_назначения>"
}
```

Где:
- `<локальный_путь>` - путь к файлу или директории (если указан в конце `/`, то будет скопировано содержимое директории, иначе будет скопирована она вся) для копирования (не может использоваться с `<содержимое>`);
- `<содержимое>` - содержимое для копирования (не может использоваться с `<локальный_путь>`);
- `<путь_назначения>` - место назначения на удаленной машине.

```hcl
provisioner "file" {
    content     = "instance_id: ${self.id}"
    destination = "/tmp/file.log"
}
```

###### <a id="Провиженер-local-exec" href="#Провиженер-local-exec">Провиженер `local-exec`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Провиженер `local-exec` выполняет скрипт на машине, на которой запускается Terraform:
```hcl
provisioner "local-exec" {
    command      = "<команда>"
    working_dir  = "<путь_к_директории>"
    interpreter  = <интерпретатор>
    environment  = <карта_переменных_окружения>
    when         = <условие_выполнения>
    quiet        = true
}
```

Где:
- `<команда>` - команда для выполнения;
- `<путь_к_директории>` - (не обязательное поле) путь к директории выполнения команды;
- `<интерпретатор>` - (не обязательное поле) список аргументов интерпретатора для выполнения команды:
    > `["/bin/bash", "-c"]`
- `<карта_переменных_окружения>` - (не обязательное поле) карта для задания переменных окружения для команды;
- `<условие_выполнения>` - (не обязательное поле) условие выполнения:
    - `destroy` - при удалении ресурса;
- `quiet = true` - (не обязательное поле) подавляет вывод в stdout.

```hcl
provisioner "local-exec" {
    command = "yc compute instance stop ${self.id}"
}
```

###### <a id="Провиженер-remote-exec" href="#Провиженер-remote-exec">Провиженер `remote-exec`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Провиженер `remote-exec` вызывает скрипт на удаленной машине. Подключение может быть выполнено через SSH и WinRM:
```hcl
provisioner "remote-exec" {
    inline      = <список_команд>
    script      = "<путь_к_файлу_скрипта>"
    scripts     = <список_файлов>
}
```

Где:
- `<список_команд>` - список команд для выполнения на удаленной машине (конфликтует с `<путь_к_файлу_скрипта>` и `<список_файлов>`);
- `<путь_к_файлу_скрипта>` - путь до скрипта на локальной машине, который будет скопирован и запущен на удаленной машине (конфликтует с `<список_команд>` и `<список_файлов>`);
- `<список_файлов>` - список путей до скриптов на локальной машине, которые будут скопированы и запущены на удаленной машине в порядке их указания (конфликтует с `<путь_к_файлу_скрипта>` и `<списписок_командсок_файлов>`).

Внутри провиженера можно ссылаться на текущий ресурс через специальный объект: `self.<атрибут>`

```hcl
provisioner "remote-exec" {
    inline = [
        "chmod +x /tmp/script.sh",
        "/tmp/script.sh args",
    ]
}
```

#### <a id="Существующий-ресурс" href="#Существующий-ресурс">Существующий ресурс</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для связи с уже существующим ресурсом:
```hcl
import {
    to = <имя_провайдера_ресурса>.<имя_ресурса>
    id = "<идентификатор_ресурса>"
}
resource "<имя_провайдера_ресурса>" "<имя_ресурса>" {
    # ...
    # атрибуты ресурса
}
```

В этом случае, все изменения вносимые в ресурс `<имя_ресурса>`, будут применяться к ресурсу с идентификатором `<идентификатор_ресурса>`.

#### <a id="Локальный-ресурс" href="#Локальный-ресурс">Локальный ресурс</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для создания файлов:
```hcl
resource "local_file" "<имя_ресурса>" {
    content = <содержимое_файла>
    filename = "<имя_файла>"
}
```

#### <a id="Провайдер-random" href="#Провайдер-random">Провайдер `random`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для генерации случайных значений.

Подключается:
```hcl
terraform {
  required_providers {
    random = {
      source = "hashicorp/random"
    }
  }
}
provider "random" {
}
```

Имеет вид:
```hcl
resource "<тип>" "<имя>" {
    # атрибуты ресурса
}
```

Где `<тип>`:
- `random_id` - случайные цифры и их hex-значение, трансформированное в base64, для создания уникальных идентификаторов ресурсов;
- `random_bytes` - случайные байты, для секретов и ключей;
- `random_integer` - случайное цифровое значение, определенное с помощью атрибутов `min` и `max`, для задания значения приоритета для listener;
- `random_password` - случайная последовательность букв, цифр и специальных символов, для создания паролей;
- `random_pet`- случайные имена животных, для создания уникальных идентификаторов ресурсов;
- `random_shuffle` - случайная выборка списка строк из строк, заданных атрибутом `input`, для списка случайных зон доступности и подсетей;
- `random_string` - случайная последовательность букв, цифр и специальных символов, для случайных строковых значений;
- `random_uuid` - случайная строка в UUID-формате, для сервисов, требующих уникальный строковый идентификатор.

Значение можно получить с помощью: `<тип>.<имя>.result`.

Для перегенерации нужно пересоздать ресурс с помощью: `terraform apply -replace="<тип>.<имя>"`.

#### <a id="Провайдер-time" href="#Провайдер-time">Провайдер `time`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для ожидания.

Подключается:
```hcl
terraform {
  required_providers {
    random = {
      source = "hashicorp/time"
    }
  }
}
provider "time" {
}
```

Имеет вид:
```hcl
resource "time_sleep" "<имя>" {
    create_duration = "<количество>s"
}
```

Где `<количество>` - это сколько секунд будет ресурс создаваться.

#### <a id="Условные-выражения-" href="#Условные-выражения-">Условные выражения `?:`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для динамического настраивания конфигураций в зависимости от различных условий.

`<условие> ? <значение_истиности> : <значение_ложности>` - проверяется условие, затем если оно верно - возвращается `<значение_истиности>`, если неверно - `<значение_ложности>`.

Условные операторы:
- **больше/меньше**: `a > b`, `a < b`;
- **больше/меньше или равно**: `a >= b`, `a <= b`;
- **равно**: `a == b`;
- **не равно**: `a != b`;
- **или**: `a || b`;
- **и**: `a && b`;
- **не**: `!a`.

#### <a id="Перебор-forin" href="#Перебор-forin">Перебор `for..in`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для перебора значения и создания на основе этих значений карт и списков:
- `for [<index>, ]<value> in <список> : <выражение> [if <фильтрация>]` - используется для перебора списка, где `<value>` - это значение элемента в списке на текущей итерации [`<index>` - его индекс];
- `for <key>, <value> in <карта> : <выражение> [if <фильтрация>]` - используется для перебора элементов карты, где `<value>` - это значение элемента в списке на текущей итерации, `<key>` - его ключ;

Для формирования новой структуры используется `<выражение>`:
- при использовании `[for..in]` структурой будет кортеж и `<выражение>` должно быть значением:
    > `[for i, v in var.list : "${i} is ${v}"]`
- при использовании `{for..in}` структурой будет карта и `<выражение>` должно быть: `<ключ> => <значение>` или `<ключ> => <значение>...` для группировки значений в списки при одинаковых ключах:
    > `{for name, user in var.users : name => user.role}`  
    > `{for name, user in var.users : user.role => name...}`

В блоке `if <фильтрация>` указывается фильтрация элементов списка или карты:
```hcl
admin_users = {
    for name, user in var.users : name => user
    if user.is_admin
}
```

### <a id="Модули" href="#Модули">Модули</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Модуль** - это контейнер для нескольких ресурсов, которые используются совместно и позволяют структурировать код Terraform. Модуль состоит из набора файлов `.tf` или `.tf.json` в одной директории и позволяет компоновать и переиспользовать код Terraform, скрывая его внутреннюю реализацию.

Корневой модуль - **root**, который содержит файлы в текущей директории. Корневой модуль может вызывать другие модули для добавления их в конфигурацию — **child**, или дочерние. При этом дочерние модули также могут вызывать другие модули.

Дочерний модуль предоставляет интерфейс для взаимодействия с ним посредством входных и выходных значений. В качестве входных значений передаются параметры для создаваемой инфраструктуры. В качестве выходных значений можно получить, например, идентификаторы созданных ресурсов для использования в корневом модуле.

Описываются в файле спецификаций в формате блоков:
```hcl
module "<имя_модуля>" {
    source = "<источник_модуля>"
    count = <количество>
    for_each = <перечисление>
    depends_on = <перечисление_зависимостей>
    # атрибуты модуля
}
```

Где:
- `<источник_модуля>` - это путь к файлам модуля, может быть:
    - локальным путем:
        > `"../"`
    - Git-репозиторием;
        > `git::https://github.com/terraform-yc-modules/terraform-yc-vpc`
    - Terraform Registry вида `<nsmespace>/<имя_модуля>/<провайдер>`;
        > `terraform-aws-modules/vpc/aws`
    - HTTP URLs.

Если у модуля есть выходные значения `output`, то их можно получить: `module.<имя_модуля>.<имя_выходного_значения>`.

Файловая структура модуля:
- `main.tf` - содержит вызов модулей, источников данных для создания ресурсов, блоки ресурсов;
- `variables.tf` - содержит описание переменных, которые используются в `main.tf`.
- `outputs.tf` - содержит описание выходных данных ресурсов, которые создаются в `main.tf`.
- `versions.tf` - содержит требования к версиям Terraform и провайдеров.
- `terraform.tfvars` - содержит значения переменных;
- дополнительные файлы для более простого восприятия, которые аналогичны `main.tf`.

### <a id="Разворачивание-инфраструктуры" href="#Разворачивание-инфраструктуры">Разворачивание инфраструктуры</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Инфраструктура разворачивается в три этапа:
1. Команда `terraform init [-reconfigure [-upgrade]` инициализирует backend [с переинициализацией его, если в нем что-то поменялось] для хранения **state**, загружает провайдеров, указанных в файле спецификации, загружает модули [и обновляет];
2. Команда `terraform plan [-out=<файл_плана>]` запускает проверку спецификации - сравнение конфигурации Terraform с реальной инфраструктурой, проверка на ошибки и отображение плана выполнения [и сохранением плана в файл `<файл_плана>`];
3. Команда `terraform apply [-auto-approve] [<файл_плана>]` запускает развертывание инфраструктуры [без подтверждения] - создание, обновление, удаление ресурсов в соответствии с конфигурацией и обновление **state** [из файла плана `<файл_плана>`].

Флаги:
- `-replace="<имя_ресурса>"` - указывает на то, что ресурс необходимо пересоздать - удалить старый и добавить новый;
- `-target="<имя_ресурса>"` - указывает на то, какой ресурс будет задействован для команды.

В зависимости от характера изменений они могут быть выполнены:
- без пересоздания ресурсов (in-place) - помечаются префиксом `~`;
- с пересозданием ресурса - помечаются префиксом `-/+`.

Комментарий `# forces replacement` показывает, какое изменение приводит к пересозданию ресурса.

`terraform destroy` - удаляет ресурсы, указанные в конфигурации и обновляет **state**.

Terraform не всегда создает заново все ресурсы, описанные в спецификации. Terraform ведет реестр - **State** (стейт-файл) в формате JSON, в котором фиксирует состояние инфраструктуры в облаке. State поддерживает связь между описанием ресурсов в спецификации и реальными ресурсами в облаке. При запуске команд `plan` и `apply` стейт-файл сравнивается с ресурсами, которые нужно создать из спецификации. По итогам сравнения недостающие ресурсы создаются, лишние - удаляются, а некоторые изменяются на ходу. Такой подход позволяет существенно улучшить производительность операций развертывания, особенно для масштабных инфраструктур. После выполнения команды `apply` стейт-файл обновляется.

Дополнительные команды:
- `terraform import` - импортировать описание конфигурации в стейт-файл;
- `terraform state list` - выводит список ресурсов из стейт-файла;
- `terraform state show <тип_ресурса>.<тип_блока_ресурса>.<имя_ресурса>` - выводит информацию о ресурсе из стейт-файла;
    > `terraform state show data.yandex_compute_image.dev`
- `terraform state rm <имя_ресурса>` - исключить ресурс из стейт-файла;
- `terraform state mv [-dry-run] <исходное_имя_ресурса> <новое_имя_ресурса>` - переименовывает ресурс [только отображает то, что сделает];
- `terraform output` и `terraform show` - выгрузить описание из стейт-файла;
- `terraform refresh` - обновляет только стейт, без применения изменений, аналогично: `terraform apply -refresh-only -auto-approve`;
- `terraform console` - считывает конфигурацию Terraform из текущего рабочего каталога и файла state - состояния конфигурации, а затем запускае консоль в которой можно проверять функции.

### <a id="Разное" href="#Разное">Разное</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`TF_ENABLE_API_LOGGING=1 TF_LOG=debug` - перед командой включают отладку.

#### <a id="Структура-каталогов" href="#Структура-каталогов">Структура каталогов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
|-- modules // содержит модули
    |-- <модуль_1>
        ├── main.tf // основная конфигурация инфраструктуры
        ├── variables.tf // переменные для определения входных параметров
        ├── versions.tf // указание версии провайдеров
        ├── outputs.tf // выходные переменные для определения значений, которые следует отобразить после развертывания инфраструктуры
        ├── README.md // документация
        └── ...
    └── ...
|-- environments // содержит различные окружения
    |-- <окружение_1>
        ├── main.tf
        ├── variables.tf
        └── ...
    └── ...
├── scripts // файлы скриптов
├── files // файлы
└── templates // шаблоны
```

<a id="Redis" href="#Redis">Redis</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

`redis-cli <команда>[ <арг1>[ ...]]` - базовое выполнение команд.

`redis-cli DEL <ключ>` - удаляет ключ.

`redis-cli HGET <ключ> <поле>` - выводит в консоль значение поля указаного ключа (хеш-таблицы).  
`redis-cli HSET <ключ> <поле> "<значение>"` - устанавливает значение поля указаного ключа (хеш-таблицы).

`redis-cli --raw keys *<маска>*` - возвращает список ключей, которые соответствуют маске.  
`redis-cli --raw keys *<маска>* | xargs redis-cli DEL` - удаляет все ключи, которые соответствуют маске

<a id="curl" href="#curl">`curl`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`curl [<опции>] <url>` - базовый вызов адреса `<url>`, по умолчанию GET.

Опции:
- `-i` - выводит заголовки ответа;
- `-k` - обозначает что можно проводить небезопасный запрос, при невозможности подтверждения сертификата, при использовании протокола **https**;
- `-F '<имя_поля>=@<путь_к_файлу>'` - добавляет содержимое файла в указаное поле;
- `-X <тип_запроса>` - изменяет тип запроса на указанный (POST, GET, PUT, DELETE);
- `-H "<имя_заголовка>: <значение_заголовка>"` - добавляет заголовок в запрос;
- `-b "<имя_куки>=<значение_куки>"` - добавляет куку в запрос;
- `-d "<имя_поля>=<значение_поля>"` - добавляет значение ключа в POST-запрос;
- `--data "<тело>"` - добавляет тело в POST-запрос;
- `-o <путь_к_файлу>` - сохранит все в файл `<путь_к_файлу>`;
- `-6` - указывает использовать `ipv6`;
- `-4` - указывает использовать `ipv4`;
- `-g` - позволяет использовать символы `[`, `]`, `{`, `}` в URL;
- `-w "\n\n%{time_connect}:%{time_starttransfer}:%{time_total}\n"` - выведет информацию о времени выполнения запроса.

Для запросов типа POST по умолчанию используется заголовки: `Content-Type: application/x-www-form-urlencoded`. Для передачи JSON нужно дополнительно прописывать заголовок: `Content-Type: application/json`.

Примеры:
- `curl -F '<имя_поля>=@<путь_к_файлу>'[ ...] <url>` - загружает файл на указанный адрес `<url>`;
- `curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <soap_метод_вызова>" --data-binary @<путь_к_файлу_xml> <url>` - отправляет soap запрос с указанным действием `<soap_метод_вызова>` на адрес `<url>` с телом запроса из файла;
- `curl -OL <url>` - загружает файл с адреса `<url>` в файл с именем после последнего `/` в адресе `<url>`.

<a id="jq" href="#jq">`jq`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====

`jq '<операторы>' [<файл>]` - применяет селектор [к указанному файлу] и отображает результат.

Виды операторов:
- фильтры:
    - `.` - фильтр идентичности указывает, что все что на входе, должно быть и на выходе;
    - `.<ключ_1>[.<ключ_2>][. ...]` - фильтрует объект и забирает из него значения по указанным ключам, включая вложенность%
        > `jq '.fruit.color,.fruit.price' fruit.json`
    - `.[<ключ_или_индекс>]` - доступ по ключу в объекте или индексу в массиве;
    - `.[[<индекс_от>]:[<индекс_до>]]` - возвращает под массив.
- объединение:
    - `<оператор_1>,<соператор_2>[, ...]` - объединяет результат операторов:
        > `jq '.fruit.color,.fruit.price' fruit.json`
- итерации:
    - `.[]` - указывает, что оператор должен быть применен к каждому элементу массива:
        > `jq '.[].name' fruits.json`  
        >  `jq '.[]' fruits.json`
- каналы:
    - `<оператор_1>|<соператор_2>[| ...]` - указывает, что результат выхода оператора, должен быть входом для другого оператора:
        > `jq '.[] | .name' fruits.json`
- создание:
    - `{<ключ_1>: <оператор>[, ...]}` - создает новый объект;
    - `[<оператор>]` - создает новый массив в котором для каждого элемента применен оператор:
        > `jq '.query.pages | [.[] | map(.) | .[] | {page_title: .title, page_description: .extract}]' wikipedia.json`

Функции используются при помощи передачи параметров во внутрь или через использование каналов:
- `<функция>(<оператор>)`;
- `<оператор> | <функция>`.

Виды функций:
- `keys` - возвращает массив ключей;
- `length` - возвращает длину массива;
- `unique` - возвращает список уникальных элементов в массиве;
- `map(<оператор>)` - возвращает новый массив, в котором для каждого элемента применен оператор `<оператор>`;
- `select(<оператор>)` - возвращает новый массив, в котором оставлены только те элементы, которые попадают под условия:
    > `jq '.[] | select(.name | test("^a.")) | .price' fruits.json`
- `del(<оператор>)` - удаляет элемент&

<a id="nmap" href="#nmap">`nmap`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

`nmap <ip>` - производит сканирование портов. По итогу сканирования выводит информацию со статусами о портах:
-  `open` - приложение активно принимает соединения TCP, дейтаграммы UDP или ассоциации SCTP на этом порту;
- `closed` - закрытый порт доступен (он принимает и отвечает на зондовые пакеты nmap), но его не прослушивает ни одно приложение;
- `filtered` - нет возможности определить, открыт ли порт, потому что фильтрация пакетов не позволяет его зондам достичь порта. Фильтрация может осуществляться с помощью выделенного брандмауэра, правил маршрутизатора или программного обеспечения брандмауэра на хосте;
- `unfiltered` - нефильтрованное состояние означает, что порт доступен, но нет возможности определить, открыт он или закрыт;
- `open|filtered` - это те порты, для которых нет возможности определить, открыты или отфильтроваын. Это происходит для типов сканирования, при которых открытые порты не дают ответа. Отсутствие ответа может также означать, что пакетный фильтр отклонил зонд.
`closed|filtered` - это состояние используется, когда нет возможности определить, закрыт порт или фильтруется.

Основные ключи:
- `-p <порт_от>-<порт_до>` - устанавливает интервал портов для сканирования;
- `-p <порт_1>[,...]` - устанавливает порты для сканирования.

<a id="nginx" href="#nginx">`nginx`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

`nginx -s <сигнал>` - посылает сигнал nginx, может быть:
- `stop` - быстрое завершение;
- `quit` - плавное завершение;
- `reload` - перезагрузка конфигурационного файла;
- `reopen` - переоткрытие лог-файлов.

Файл `nginx.conf` содержит конфигурацию, расположен по `/usr/local/nginx/conf`, `/etc/nginx`, `/usr/local/etc/nginx`.

`nginx -t` - проверяет конфигурацию на корректность.

Состоит из директив:
- **простая** - `<имя> <параметр_1>[ ...];`;
- **блочная** - `<имя> <параметр_1>[ ...] { ... }`.

`#` - обозначает коментарий.

Структура:
```nginx
http {
    server {
        listen <порт>; # порт прослушивания сервера
        server_name <имя_виртуального_сервера_1>[ ...]; # задает имя виртуального сервера
        root <путь_по_умолчанию_к_каталогу_с_файлами>; # будет использоваться, если в location не указана директива root
        # объявление секции потока
        upstream <upstream_name> {
            zone upstreams <количество>K; # указывает на количество общей памяти для рабочих процессов
            server <ip_адрес>:<порт> max_fails=<количество> fail_timeout=<количество_секунд>s; # указания одного сервера для перенаправления, могут повторяться с разными параметрами
            keepalive <количество>; # количество поддерживаемых соединений с вышестоящими серверами
        }
        location <префикс_пути_1> {
            root <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>/<префикс_пути_1>
        }
        location <префикс_пути_2> {
            proxy_pass <url>; # производит проксирование всех запросов по данному пути на указаный <url>
            # из исходного url вырезается все до <префикс_пути_2>, включая его и добавляется к <url>, поэтому нужно быть осторожным, чтобы не возникло два слеша //
            proxy_set_header Host $host; # для передачи имени хоста
        }
        location <префикс_пути_3> {
            alias <путь_к_каталогу_с_файлами>; # при этом поиск будет происходить по пути <путь_к_каталогу_с_файлами>
        }
        location <префикс_пути_4> {
            proxy_set_header Host $host; # для передачи имени хоста
            proxy_http_version 1.1; # указывает использовать протокол версии 1.1
            proxy_set_header "Connection" ""; # указывает не завершать соединения
            proxy_pass http://<upstream_name>/; # перенаправляет все запросы на указанный upstream
            proxy_next_upstream error timeout http_500; # указывает передавать ошибки следующему серверу в вышестоящей группе
        }
        location = <путь> { # будет работать только для тех, которые точно равны указаному пути
            # ...
        }
        location ~ <регулярное_выражение> { # будет работать только для тех, которые совпадают с регулярным выражением, можно использовать выделения (), которые затем доступны в виде переменных $1..$9
            # ...
            # alias /usr/share/$1/$2
        }
        location ~* <регулярное_выражение> { # то же, только без учета регистра
            # ...
        }
        # ...
    }
    # ...
}
```

При этом выбирается самый больший префикс пути в директивах `location`.

Если не находится совпадение с директивами `location`, то возвращается заголовок **404**.

Если в регулярном выражении встречаются символы `}` или `;`, то все выражение следует заключить в одинарные или двойные кавычки.

При поиске виртуального сервера по имени, если имени соответствует несколько из указанных вариантов, например, одновременно подходят и имя с маской, и регулярное выражение, будет выбран первый подходящий вариант в следующем порядке приоритета:
- точное имя;
- самое длинное имя с маской в начале, например `*.example.com`;
- самое длинное имя с маской в конце, например `mail.*`;
- первое подходящее регулярное выражение (в порядке следования в конфигурационном файле).

## <a id="Подключение-конфигурации" href="#Подключение-конфигурации">Подключение конфигурации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого используется директива: `include <путь_к_файлу_конфигурации>;`, которая вставляет конфигурации из файла в указаное место, где путь `<путь_к_файлу_конфигурации>` может быть шаблоном.

## <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`set $<имя_переменной> <значение>;` - устанавливает значение переменной. Значение `<значение>` может быть заключено в кавычки: `"<значение>"`. Также может содержать внутри себя переменные, которые заменятся на значение переменных.
> `set $USER release;`  
> `set $USER_FOLDER "/user/$USER/www";`

## <a id="Условия" href="#Условия">Условия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```nginx
if (<условие>) {
    # ...
}
```

Где `<условие>` может быть вида:
- `<имя_переменной>` - при этом ложными значениями переменной являются пустая строка или `"0"`;
- `<имя_переменной> = <строка>`;
- `<имя_переменной> != <строка>`;
- `<имя_переменной> ~ <регулярное_выражение>` - можно использовать выделения `()`, которые затем доступны в виде переменных `$1`..`$9`;
- `<имя_переменной> !~ <регулярное_выражение>`;
- `<имя_переменной> ~* <регулярное_выражение>`;
- `<имя_переменной> !~* <регулярное_выражение>`.

## <a id="Глобвльные-переменные" href="#Глобвльные-переменные">Глобвльные переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$host` - содержит имя хоста из строки запроса, или имя хоста из поля `Host` заголовка запроса, или имя сервера, соответствующего запросу.

## <a id="Директивы" href="#Директивы">Директивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Директивы наследуются с предыдущего уровня конфигурации, или "сверху-вниз": дочерний контекст, будучи вложенным в другой контекст (родительский), наследует настройки директив, входящих в родительский уровень.

`add_header <заголовок> <значение>;` - добавляет заголовок со значением.

`return <код>[ "<содержимое>"];` - возвращает код ответа [и его содержимое].

`rewrite <регулярное_выражение> <строка> [{last | break | redirect | permanent}];` - переопределяет путь, который совпадает с регулярным выражением `<регулярное_выражение>` на указанную строку `<строка>`, в которой можно использовать выделения `()` в виде переменных `$1..$9` из регулярного выражения. Где:
- `last` - указывает, что нужно прервать обработку директив `rewrite` и начать поиск нового совпадения с переопределенным путем;
- `break` - указывает, что нужно прервать обработку директив `rewrite` в секции `location` и начать в ней обработку с переопределенным путем;
- `redirect` - устанавливает код ответа `302` и возвращает новую `location`;
- `permanent` - устанавливает код ответа `301` и возвращает новую `location`.

> `rewrite ^/users/(.*)$ /show?user=$1? last;`

`auth_basic "closed site";` - включает базовую HTTP-аутентификацию.  
`auth_basic_user_file <файл>;` - добавляет файл с логинами и паролями для прохождении аутентификации.

`allow {<ip_адрес> | <ip_подсеть>};` - разрешает доступ только из указанной ip подсети или ip адресов.  
`deny all;` - запрещает доступ отовюду, кроме разрешенных с помошью директив `allow`.

<a id="vim" href="#vim">`vim`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

`vim ["+<команда_1>[ ...]"] <файл_1>[ ...]` - открывает файлы на редактирование в командном режиме [но перед этим выполняет команды `<команда_1> ...`].

`~/.vimrc` - файл с командами настроек, которые запускаются автоматически при открытии редактора. Команды пишутся без `:`.

`vim scp://<user>@<myserver>[:<port>]//<path_to_file>` - открывает файл на редактирование на сервере.
> `vim scp://user@myserver[:port]//path/to/file.txt`

## <a id="Обычный-режим" href="#Обычный-режим">Обычный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для редактирования файла путем ввода команд.

`:q` - выход из редактора.  
`:q!` - принудительный выход из редактора без сохранения файла.

`:w` - запись в файл.  
`:w <файл>` - запись в указанный файл, но при этом редактироваться продолжит исходный.  
`:wq` - запись в файл и выход из редактора.

`ZZ` - запись в файл и выход из редактора.

`i` - переход в режим вставки.

`v` - переход в визуальный режим.

`:` - переход в командный режим.

`u` - отмена предыдущей команды.

`a` - переход в конец файла и переход в режим вставки.  
`A` - переход в конец текущей строки и переход в режим вставки.

Команды перемешения:
- `l` - вправо на один символ;
- `h` - влево на один символ;
- `j` - вниз на один символ;
- `k` - вверх на один символ;
- `0` - в начало текущей строки;
- `^` - к первому не пробельному символу в текущей строке;
- `$` - в конец текущей строки;
- `w` - в начало следующего слова или знаку препинания;
- `W` - в начало следующего слова минуя знаки препинания;
- `b` - в начало предыдущего слова или знаку препинания;
- `B` - в начало предыдущего слова минуя знаки препинания;
- `CTRL + F` - вниз на одну страницу;
- `CTRL + B` - вверх на одну страницу;
- `<число>G` - к заданной строке в файле.
- `G` - к последней строке в файле.

Перед командой может указываться число, которое обычно обозначает количество повторений команды.
> `5j`  
> `5dd`

Команды вставки:
- `o` - добавляет строку ниже текущей;
- `O` - добавляет строку выше текущей.

Команды удаления:
- `x` - удаляет текущий символ;
- `dd` - вырезает текущую строку;
- `dW` - вырезает от текущего символа до начала следующего слова;
- `d$` - вырезает от текущего символа до конца текущей строки;
- `d0` - вырезает от текущего символа до начала строки;
- `d^` - вырезает от текущего символа до первого непробельного символа в строке;
- `dG` - вырезает от текущей строки до конца файла;
- `d<число>G` - вырезает от текущей строки до указанной строки.

Команды копирование:
- `yy` - копирует текущую строку;
- `yW` - копирует от текущего символа до начала следующего слова;
- `y$` - копирует от текущего символа до конца текущей строки;
- `y0` - копирует от текущего символа до начала строки;
- `y^` - копирует от текущего символа до первого непробельного символа в строке;
- `yG` - копирует от текущей строки до конца файла;
- `y<число>G` - копирует от текущей строки до указанной строки.

Команды вставки из буфера:
- `p` - вставка правее текушей позиции курсора;
- `P` - вставка левее текушей позиции курсора.

`J` - удаляет у текущей строки символ конца строки (объединяет две строки).

Команды поиска:
- `f<символ>` - переместит курсор к следующему вхождению символа в текущей строке, для повторения поиска используется `;`;
- `/<строка> + ENTER` - переносит курсор к следующему вхождению строки в файле, для повторения поиска используется `n`.

`:%s/<строка_поиска>/<строка_замены>/g + ENTER` - заменяет все строки на новые во всем файле.

## <a id="Навигация-и-окна" href="#Навигация-и-окна">Навигация и окна</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`:e .` - выводит интерактивный текущий каталог с файлами и навигацией по ним.

Команды использования нескольких файлов:
- `:bn` - переключение на следующий файл;
- `:bp` - переключение на предыдущий файл;
- `:buffers [<номер_файла>]` - выводит список редактируемых файлов с возможностью выбора файла;
- `:e <файл>` - добавляет файл для редактирования.

`:r <файл>` - вставляет содержимое файла перед текущим курсором.

`CTRL + w n` - создание нового окна.

`CTRL + w s` - разбиение текущего окна по горизонтали.  
`:split` - аналогично.  
`CTRL + w v` - разбиение текущего окна по вертикали.  
`:vnew` - аналогично.

`CTRL + w {hjkl}` - перемещение по окнам (также можно использовать стрелочки).  
`CTRL + w {HJKL}` - перемещает окна.

`:q` - закрывает текущее окно.
`CTRL + w o` - закрывает все окна, кроме текущего.

`CTRL + w +` - увеличивает размер окна на 1.  
`CTRL + w -` - уменьшает размер окна на 1.  
`{<число>}CTRL + w _` - устанавливает размер окна равным `<число>`.

## <a id="Режим-вставки" href="#Режим-вставки">Режим вставки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для редактирования файла путем добавления текста.

`ESC` - переход в командный режим и окончание вставки текста.

## <a id="Визуальный-режим" href="#Визуальный-режим">Визуальный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для выделения текста в файле. В этом режиме клавиши перемещения будут выделять текст.

Выделенный текст можно скопировать `y` или удалить `d` с помощью команд обычного режима.

`ESC` - переход в командный режим.

## <a id="Командный-режим" href="#Командный-режим">Командный режим</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для ввода команд.

`ESC` - переход в командный режим.

## <a id="Команды" href="#Команды">Команды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`set <команда>&` - устанавливает значение команды по умолчанию.

`:syntax on` - включает подсветку синтаксиса.  
`:set syntax=<язык>` - устанавливает подсветку синтаксиса для определенного языка.
> `:set syntax=sh`

`:set hlsearch` - включает подсветку результатов поиска.

`:set nu` - включает отображение строк.  
`:set number` - аналогично.

`:set tabstop=<количество>` - устанавливает длину символа tab.

`:set autoindent` - включает автоотступы для новых строк на основании предыдущей.

`:set clipboard=unnamed` - включает общий буфер для macOS / Windows.  
`:set clipboard=unnamedplus` - включает общий буфер для Linux.

`:set laststatus=2` - включает информационную строку.  
`:set statusline=%t[%{strlen(&fenc)?&fenc:'none'},%{&ff}]%h%m%r%y%=%c,%l/%L\ %P` - включает информационную строку в которой будет отображено множество информации об открытом файле.