[Содержание](#Содержание)
==========

- [Основы](#Основы)
    - [Комментарии](#Комментарии)
    - [Переменные](#Переменные)
        - [Стандартные типы данных](#Стандартные-типы-данных)
            - [Логические значения `boolean`](#Логические-значения-boolean)
            - [Строка](#Строка)
            - [Число](#Число)
            - [`None`](#None)
        - [Приведение типа](#Приведение-типа)
        - [Список](#Список)
        - [Словарь](#Словарь)
    - [Операции](#Операции)
        - [Вложеность](#Вложеность)
        - [Условие `if`](#Условие-if)
            - [Операции сравнения](#Операции-сравнения)
        - [Цикл `for`](#Цикл-for)
        - [Цикл `while`](#Цикл-while)
        - [Команда `break`](#Команда-break)
        - [Команда `continue`](#Команда-continue)
    - [Ввод данных](#Ввод-данных)
    - [Функции](#Функции)
    - [Классы](#Классы)
    - [Модули и импортирование](#Модули-и-импортирование)
    - [Файлы](#Файлы)
    - [Исключения](#Исключения)
- [Модули](#Модули)
    - [Модуль `json`](#Модуль-json)
- [Тестирование модуль `unittest`](#Тестирование-модуль-unittest)
- [Установка и настройка](#Установка-и-настройка)
    - [Интерпретатор](#Интерпретатор)
    - [Запуск программы](#Запуск-программы)
    - [Установка пакетов - модулей](#Установка-пакетов---модулей)
- [Философия Python](#Философия-Python)

<a id="Основы" href="#Основы">Основы</a>
======

В именах файлов и папок лучше использовать буквы нижнего регистра и символы подчеркивания, потому что это соответствует соглашениям об именах Python.

`print(<значение>)` - производит вывод значения в консоль.

## <a id="Комментарии" href="#Комментарии">Комментарии</a>

Начинается с символа `#` и следует до конца строки.

## <a id="Переменные" href="#Переменные">Переменные</a>

Имена переменных могут состоять только из букв, цифр и символов подчеркивания. Они могут начинаться с буквы или символа подчеркивания, но не с цифры.

`<переменная> = <значение>`

### <a id="Стандартные-типы-данных" href="#Стандартные-типы-данных">Стандартные типы данных</a>

#### <a id="Логические-значения-boolean" href="#Логические-значения-boolean">Логические значения `boolean`</a>

Обладает двумя значениями - `True` и `False`, которые представляют традиционные логические (или булевы) значения.

#### <a id="Строка" href="#Строка">Строка</a>

**Строка** представляет собой простую последовательность символов. Любая последовательность символов, заключенная в `'` или `"` считается строкой. Для хранения многострочных строк используется заключение строк в `'''` или `"""`.

Конкатенация строк происходит с помощью оператора `+`.

`len(<сторока>)` - возвращает размер строки.

`<сторока>.title()` - возвращает новую строку в которой каждый первый символ каждого слова в строке преобразован к верхнему регистру, тогда как все остальные символы преобразованы к нижнему регистру.  
`<сторока>.upper()` - возвращает новую строку в которой каждый символ в верхнем регистре.  
`<сторока>.lower()` - возвращает новую строку в которой каждый символ в нижнем регистре.  
`<сторока>.rstrip()` - возвращает новую строку в которой удалены все пробелы справа и пустые строки.  
`<сторока>.lstrip()` - возвращает новую строку в которой удалены все пробелы слева и пустые строки.  
`<сторока>.strip()` - возвращает новую строку в которой удалены все пробелы и пустые строки как справа так и слева.  
`<сторока>.replace("<заменяемая_строка>", "<строка_замены>")` - возвращает новую строку в которой заменены все подстроки `<заменяемая_строка>` на подстроки `<строка_замены>`.  
`<сторока>.split()` - разделяет строку на части по всем позициям, в которых обнаружит пробел и возвращает список из этих строк.  
`<сторока>.count("<подстрока>")` - возвращает количество подстрок `<подстрока>` в строке.  

#### <a id="Число" href="#Число">Число</a>

Делятся на целые и вещественные.

Стандартные арифметические операции:
- бинарные: `+` (сложение), `-` (вычитание), `*` (умножение), `/` (деление), `**` (возведение в степень), `%` (остаток от деления);
- унарные: `-` (отрицание).

Если производить операции только с целыми числами, то результат будет целое число, иначе вещественное число.

#### <a id="None" href="#None">`None`</a>

Представляет собой отсутствие значения.

### <a id="Приведение-типа" href="#Приведение-типа">Приведение типа</a>

`str(<значение>)` возвращает значение преобразованное к строке.  
`int("<строка>")` возвращает значение преобразованное к целому числу из строки.  
`float("<строка>")` возвращает значение преобразованное к вещественному числу из строки.

### <a id="Список" href="#Список">Список</a>

**Список** - это набор элементов, следующих в определенном порядке - массив.

`<список> = []` - создает пустой список.  
`<список> = [<значение1>[, ...]]` - создает инициализированный значениями список.

`<список>[<индекс>]` - возвращает значение заданое на указаной позиции `<индекс>` списка (начинается с 0). Отрицательные индексы возвращают элементы с конца списка (-1 - последний элемент, -2 - второй элемент от конца списка и т.д.).  
`<список>[<индекс>] = <значение>` - присваивает значение указаной позиции `<индекс>` списка.

`del <список>[<индекс>[:<индекс_до>[:<шаг>]]]` - удаляет элемент из списка по указаной позиции, при этом сдвигая все элементы влево [и до `<индекс_до>` (но не включая его) с шагом равным 1 [равным `<шаг>`]].

`len(<список>)` - возвращает размер списка.

`<список>[<индекс_от>:<индекс_до>[:<шаг>]]` - создает срез (список) - копию из указаного списка который состоит из элементов списка от `<индекс_от>` и до `<индекс_до>` (но не включая его) с шагом равным 1 [равным `<шаг>`].  
`<список>[<индекс_от>:]` - аналогично `<список>[<индекс_от>:len(<список>)]`.  
`<список>[:<индекс_до>]` - аналогично `<список>[0:<индекс_до>]`.  
`<список>[:]` - аналогично `<список>[0:len(<список>)]`.

`<список1> + <список2>` - возвращает новый список из списков `<список1>` и `<список2>`.

`<список>.index(<значение>[, <индекс_от>[, <индекс_до>]])` - возвращает позицию значения `<значение>` в списке `<список>`[, после позиции `<индекс_от>`[, и перед `<индекс_до>`]]. Если значения нет в списке, то будет исключение типа `ValueError`.

`<список>.append(<значение>)` - добавляет в конец списка значение.  
`<список>.insert(<индекс>, <значение>)` - вставляет в указаную позицию списка значение, при этом сдвигая все элементы вправо.

`<список>.pop([<индекс>])` - удаляет последний элемент в списке [в указаной позиции `<индекс>`] и возвращает его.  
`<список>.remove(<значение>)` - удаляет только первое вхождение заданного значения в списке.

`<список>.sort([reverse=True])` - производит сортировку [в обратном порядке] списка.

`sorted(<список>[, reverse=True])` - возвращает новый отсортированный список [в обратном порядке] из переданого списка.  
`set(<список>)` - возвращает новый список с уникальными значениями из списка.

`<список>.reverse()` - меняет порядок элементов в списке на обратный на месте.

`list(range(<начальное_значение>, <конечное_значение>[, <шаг>]))` - создает новый список из числовых значение с элементами от `<начальное_значение>` и до `<конечное_значение>` (но не включая его) с шагом равным 1 [равным `<шаг>`].

`min(<список>)` - возвращает минимальное число из списка.  
`max(<список>)` - возвращает максимальное число из списка.  
`sum(<список>)` - возвращает сумму чисел из списка.

**Генератор списка** (list comprehension) позволяет сгенерировать список:  
`<новый_список> = [<выражение_для_значений> for <переменная> in <список>]`
> `squares = [value**2 for value in range(1,11)]`

**Кортеж** - неизменяемый список - выглядит как список, не считая того, что вместо квадратных скобок используются круглые скобки. Поддерживает все операции со списком, кроме изменения его или его элементов.

`<кортеж> = ()` - создает пустой кортеж.  
`<кортеж> = (<значение1>[, ...])` - создает инициализированный значениями кортеж.

### <a id="Словарь" href="#Словарь">Словарь</a>

**Словарь** представляет собой совокупность пар "ключ-значение" в котором порядок элементов не важен.

`<словарь> = {}` - создает пустой словарь.  
`<словарь> = {'<ключ1>': <значение1>[, ...]}` - создает инициализированный значениями словарь.

`<словарь>['<ключ>']` - возвращает значение заданое по ключу `<ключ>` словаря.  
`<словарь>['<ключ>'] = <значение>` - присваивает значение заданое по ключу `<ключ>` словаря (так добавляются новые).  
`<словарь>.get('<ключ>'[, <значение_по_ум>])` - возвращает значение заданое по ключу `<ключ>` словаря[, или значение `<значение_по_ум>` если такого ключа нет].  

`del <словарь>['<ключ>']` - удаляет элемент из словаря по указаному ключу и указанный ключ.

`<словарь>.items()` - возвращает итератор для перебора словаря (ключ-значение).  
`<словарь>.keys()` - возвращает итератор для перебора всех ключей словаря.  
`<словарь>.values()` - возвращает итератор для перебора всех значений словаря.

```python
for <переменная_ключа>, <переменная_значения> in <словарь>.items():
    <код>
```

Класс `OrderedDict` из модуля `collections` - работает также как и словарь, только хранит пары ключ-значение в порядке добавления пар ключ-значение.

## <a id="Операции" href="#Операции">Операции</a>

### <a id="Вложеность" href="#Вложеность">Вложеность</a>

В Python связь одной строки кода с предшествующей строкой обозначается отступами.  
Каждая строка с начальным отступом после верхней строки считается вложенной в верхнюю строку.

Если будет отступ в строке, в которой он не нужен, Python сообщит об этом в виде ошибки. А также если не будет отступа там где он нужен.

### <a id="Условие-if" href="#Условие-if">Условие `if`</a>

```python
if <условие1>:
    <код>
[elif <условие2>:
    <код>]
[...]
[else:
    <код>]
```

#### <a id="Операции-сравнения" href="#Операции-сравнения">Операции сравнения</a>

`<значение1> <операция> <значение2>` - всегда производят булево значение.

`<`, `>`, `<=`, `>=` - только для чисел и строк.

`==` проверяет на равенство, если значения обладают разными типами, то они не равны, в противном случае сравниваются значения в соответствии с их типами, в частности, `nil` равно только самому себе.

`!=` проверяет на неравенство, для всех типов.

Операция `and` - логческое **и**.  
Операция `or` - логическое **или**.  
Обе операции, `and` и `or`, используют сокращенное вычисление, то есть они вычисляют свой второй операнд только при необходимости. У `and` более высокий приоритет, чем у `or`.

Операция `not` всегда возвращает булево значение.

`<значение> [not] in <список>` - возвращает `True` если значение `<значение>` есть [его нет] в списке `<список>` иначе `False`.  
`<подстрока> [not] in <строка>` - возвращает `True` если подстрока `<подстрока>` есть [его нет] в строке `<строка>` иначе `False`.  
`<ключ> [not] in <словарь>` - возвращает `True` если ключ `<ключ>` есть [его нет] в словаре `<словарь>` иначе `False`.

Пустой список - это ложное значение - `False`.  
Пустая строка - это ложное значение - `False`.  
`None` - это ложное значение - `False`

### <a id="Цикл-for" href="#Цикл-for">Цикл `for`</a>

Используется для перебора и помещает на каждой итерации в переменную `<переменная>` элементы из списка для списока и ключи для словаря.

```python
for <переменная> in <перебираемое_значение>:
    <код>
```

### <a id="Цикл-while" href="#Цикл-while">Цикл `while`</a>

```python
while <условие>:
    <код>
```

### <a id="Команда-break" href="#Команда-break">Команда `break`</a>

Команда `break` управляет ходом выполнения программы - позволяет прерывать цикл.

### <a id="Команда-continue" href="#Команда-continue">Команда `continue`</a>

Команда `continue` управляет ходом выполнения программы - позволяет прерывать итерацию цикла.

## <a id="Ввод-данных" href="#Ввод-данных">Ввод данных</a>

`<переменная> = input("<текст>")` - приостанавливает выполнение программы, выводит текст `<текст>` и ожидает ввода текста от пользователя (пользователь вводит данные в той же строке вывода текста), который помещает в переменную `<переменная>` в виде строки.

## <a id="Функции" href="#Функции">Функции</a>

Функции должны иметь содержательные имена, состоящие из букв нижнего регистра и символов подчеркивания.

```python
def <функция>([<параметр1>[ = <значение_по_умолчанию>][, ...]][, *<общий_параметр>][, **<общий_именованный_параметр>]):
    ["""<строка_документации>"""]
    <код>
    [return [<значение>]]
```

`*<общий_параметр>` - приказывает создать пустой кортеж с именем `<общий_параметр>` и упаковать в него все дальнейшие полученные значения функции.  
`*<общий_именованный_параметр>` - приказывает создать пустой словарь с именем `<общий_именованный_параметр>` и упаковать в него все дальнейшие полученные значения функции в виде: "ключ - значение".

`<функция>([<арг1>[, ...]])` - вызов функции.  
`<функция>([<параметр1>=<арг1>[, ...]])` - вызов функции с помощью именованных аргументов.

## <a id="Классы" href="#Классы">Классы</a>

По общепринятым соглашениям имена, начинающиеся с символа верхнего регистра - обозначают классы.

```python
class <Класс>([<КлассРодитель>]):
    ["""<строка_документации>"""]
    def __init__(self[, <параметр1>, [...]]):
        ["""<строка_документации>"""]
        [super().__init__([<арг1>[, ...]])]
        [self.<атрибут> = <значение>]
        <код>
    def <метод>(self[, <параметр1>, [...]]):
        ["""<строка_документации>"""]
        <код>
        [return [<значение>]]
```

Параметр `self` обязателен в определении метода, он должен предшествовать всем остальным параметрам. `self` - ссылка на экземпляр, она предоставляет конкретному экземпляру доступ к атрибутам и методам класса.

Функция `super()` - специальная функция, которая помогает связать потомка с родителем. Через нее можно получить доступ ко всем атрибутам и методам родителя.

Метод `__init__` - специальный метод, который автоматически выполняется при создании каждого нового экземпляра на базе класса `<Класс>`.

`<экземпляр> = <Класс>([<арг1>[, ...]])` - создание экземпляра класса. Каждый аргумент передается в метод `__init__` как параметр.  
`<экземпляр>.<атрибут>` - доступ к атрибуту экземпляра.  
`<экземпляр>.<метод>(...)` - вызов метода экземпляра.

## <a id="Модули-и-импортирование" href="#Модули-и-импортирование">Модули и импортирование</a>

Первой строкой в модуле может быть строка документации: `"""<строка_документации>"""`.

`import <имя_файла>[ as <псевдоним_модуля>]` - приказывает открыть файл `<имя_файла>` и скопировать все функции и классы из него в программу.

`<имя_файла>.<функция>()` - вызов функции из модуля.

`from <имя_файла> import {<функция> | <класс>}[ as <псевдоним>][, ...]` - приказывает открыть файл `<имя_файла>` и скопировать указанные функции или классы из него в программу.  
`from <имя_файла> import *` - приказывает открыть файл `<имя_файла>` и скопировать все функции и классы из него в программу.

`<функция>()` - вызов функции из модуля.

## <a id="Файлы" href="#Файлы">Файлы</a>

`<файл> = open('<имя_файла>'[, "{w | r | a | r+}"])` - производит открытие файла и возвращает объект, представляющий файл [`w` - в режиме записи, `r` - в режиме чтения, `a` - в режиме присоединения, `r+` - в режиме допускающем как чтение, так и запись]. Если файл нельзя открыть, то будет исключение типа `FileNotFoundError`.  
`close(<файл>)` - производит закрытие файла.  
`<файл>.read()` - возвращает все содержимое файла в виде строки.  
`<файл>.readlines()` - возвращает все строки из файла в виде списка строк.  
`<файл>.write('<строка>')` - производит запись в файл строки.

`with open('<имя_файла>'[, "{w | r | a | r+}"]) as <файл>:` - конструкция которая производит открытие файла и возвращает объект в переменную `<файл>`, которая доступна в блоке с последующим вызовом `close(<файл>)` после выхода из блока.

Все строки файла можно перебрать используя конструкцию: `for <строка> in <файл>:`, тогда в переменную `<строка>` будут записываться строки из файла.

## <a id="Исключения" href="#Исключения">Исключения</a>

```python
try:
    <код>
except <ТипИсключения>:
    <код>
[...]
[else:
    <код>]
```

Если в блоке `try` возникнет исключение, то оно попадет в указанный обработчик указаного типа исключения и выполнится код этого обработчика, иначе всплывет выше, если исключения не будет то выполнится код блока `else`.

Команда `pass` в блоке `except` приказывает ничего не делать.

<a id="Модули" href="#Модули">Модули</a>
======

## <a id="Модуль-json" href="#Модуль-json">Модуль `json`</a>

`json.dump(<данные>, <файл>)` - записывает в файл данные в формате JSON.  
`json.load(<файл>)` - возвращает данные из файла в формате JSON.

<a id="Тестирование-модуль-unittest" href="#Тестирование-модуль-unittest">Тестирование модуль `unittest`</a>
==============================

Класс `unittest.TestCase` используется для тестирования.

```python
import unittest
class <КлассТест>(unittest.TestCase):
    ["""<строка_документации>"""]
    [def setUp(self):
        <код>
    ]
    def <test_метод_тестирования_1>(self[, <параметр1>, [...]]):
        ["""<строка_документации>"""]
        <код>
        <функции_проверки>
unittest.main()
```

Функции проверки:
- `self.assertEqual(<значение1>, <значение2>)` - проверяет, что `<значение1>` == `<значение2>`;
- `self.assertNotEqual(<значение1>, <значение2>)` - проверяет, что `<значение1>` != `<значение2>`;
- `self.assertTrue(<значение>)` - проверяет, что значение `<значение>` истинно;
- `self.assertFalse(<значение>)` - проверяет, что значение `<значение>` ложно;
- `self.assertIn(<значение>, <список>)` - проверяет, что элемент входит в список;
- `self.assertNotIn(<значение>, <список>)` - проверяет, что элемент не входит в список.

Любой метод, имя которого начинается с `test_`, будет выполняться автоматически при запуске `unittest.main()`. В нем необходимо вызывать функции проверки.

Метод `setUp()` выполняет перед запуском каждого метода, имя которого начинается с `test_`.

Во время работы тестового сценария Python выводит один символ для каждого модульного теста после его завершения. Для прошедшего теста выводится точка `.`; если при выполнении произошла ошибка, выводится символ `E`, а если не прошла проверка условия `assert`, выводится символ `F`.

<a id="Установка-и-настройка" href="#Установка-и-настройка">Установка и настройка</a>
=====================

## <a id="Интерпретатор" href="#Интерпретатор">Интерпретатор</a>

`python` - запускает интерпретатора питона версии 2.  
`python3` - запускает интерпретатора питона версии 3, можно использовать везде, где используется `python`.

Закрывается комбинацией клавиш `Ctrl+D` / `Ctrl+Z` или командой `exit()`.

## <a id="Запуск-программы" href="#Запуск-программы">Запуск программы</a>

`python <имя_файла>` - запускает скрипт на выполнение.

## <a id="Установка-пакетов---модулей" href="#Установка-пакетов---модулей">Установка пакетов - модулей</a>

`pip` (`pip3`) - программа, управляющая загрузкой и установкой пакетов Python.

<a id="Философия-Python" href="#Философия-Python">Философия Python</a>
================

- Красивое лучше, чем уродливое;
- Простое лучше, чем сложное;
- Сложное лучше, чем запутанное;
- Удобочитаемость имеет значение;
- Должен существовать один - и желательно только один - очевидный способ сделать это;
- Сейчас лучше, чем никогда.