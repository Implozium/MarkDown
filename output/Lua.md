[Содержание](#Содержание)
==========

- [Основы](#Основы)
    - [Комментарии](#Комментарии)
    - [Переменные](#Переменные)
        - [Типы и значения](#Типы-и-значения)
            - [Отсутствие значения `nil`](#Отсутствие-значения-nil)
            - [Логические значения `boolean`](#Логические-значения-boolean)
            - [Числа `number`](#Числа-number)
                - [Арифметические операции](#Арифметические-операции)
            - [Строки `string`](#Строки-string)
            - [Таблицы `table`](#Таблицы-table)
            - [Функции `function`](#Функции-function)
            - [Пользовательские данные `userdata`](#Пользовательские-данные-userdata)
            - [Сопрограммы - нити `thread`](#Сопрограммы---нити-thread)
            - [Приведения типов](#Приведения-типов)
        - [Операции](#Операции)
            - [Операции сравнения](#Операции-сравнения)
            - [Логические операции](#Логические-операции)
        - [Управляющие конструкции](#Управляющие-конструкции)
            - [`if then else`](#if-then-else)
            - [`while`](#while)
            - [`repeat`](#repeat)
            - [Числовой `for`](#Числовой-for)
            - [Общий `for`](#Общий-for)
            - [`goto`](#goto)
    - [Функции](#Функции)
    - [Итераторы](#Итераторы)
        - [Подлинный итератор](#Подлинный-итератор)
    - [Ошибки](#Ошибки)
    - [Подключение файлов](#Подключение-файлов)
    - [Сопрограммы](#Сопрограммы)
    - [Запуск](#Запуск)
        - [Командная строка](#Командная-строка)

<a id="Основы" href="#Основы">Основы</a>
======

## <a id="Комментарии" href="#Комментарии">Комментарии</a>

Начинаются с `--` и до конца строки или от `--[[` и до `--]]`.

## <a id="Переменные" href="#Переменные">Переменные</a>

Идентификаторы (или имена) в Lua могут быть любой последовательностью из букв `A-Z` и `a-z`, цифр `0-9` и символов подчеркивания `_`, не начинающейся с цифры. Следует избегать символов подчеркивания `_` в начале идентификатора, так как они зарезервированы в Lua для особых целей.

Необъявленные переменные равны `nil` по умолчанию.

`<глобальная_переменная>[ = <значение>]` - присваивание значения глобальной переменной.  
`<переменная1>[, ...] = <значение1>[, ...]` - множественное присваивание.

`local <переменная>[ = <значение>]` - присваивание значения локальной переменной, область видимости локальной переменной ограничена блоком, где она была объявлена, где **блок** - это тело управляющей структуры, тело функции или кусок кода (файл или строка, где переменная была объявлена).

`local <переменная> = <глобальная_переменная>` - создание локальной переменной и инициализирует ее значением глобальной переменной. Используется для одного и того же имени переменных.

### <a id="Типы-и-значения" href="#Типы-и-значения">Типы и значения</a>

В Lua существует восемь базовых типов: `nil`, `boolean`, `number`, `string`, `table`, `function`, `userdata` и `thread`.

`type(<значение>)` - вернет тип значения.

У переменных нет предопределенных типов; любая переменная может содержать значения любого типа.

#### <a id="Отсутствие-значения-nil" href="#Отсутствие-значения-nil">Отсутствие значения `nil`</a>

Это тип с единственным значением, `nil`, основная задача которого состоит в том, чтобы отличаться от всех остальных значений.

#### <a id="Логические-значения-boolean" href="#Логические-значения-boolean">Логические значения `boolean`</a>

Обладает двумя значениями - `true` и `false`, которые представляют традиционные логические (или булевы) значения. Проверки условий (например, условий в управляющих структурах) считают `nil` и булево `false` ложными, а все прочие значения истинными.

#### <a id="Числа-number" href="#Числа-number">Числа `number`</a>

Представляет вещественные числа, т.е. числа двойной точности с плавающей точкой, `0x` - префикс для 16-го вида числа.

##### <a id="Арифметические-операции" href="#Арифметические-операции">Арифметические операции</a>

Стандартные арифметические операции:
- бинарные: `+` (сложение), `-` (вычитание), `*` (умножение), `/` (деление), `^` (возведение в степень), `%` (остаток от деления);
- унарные: `-` (отрицание).

#### <a id="Строки-string" href="#Строки-string">Строки `string`</a>

Это последовательность символов в кавычках `'`, `"` или от `[<набор_символов>[` и до `]<набор_символов>]`, поддерживает все 8-битовые символы, и строки могут содержать символы с любыми числовыми кодами, включая нульсимволы.

`#<переменная>` / `#<строка>` - возвращает длину строки.

Символы могут быть еще представлены в виде: `\ddd` - где `d` - десятичное число, `\xhh` - `h` - где `h` - шестнадцатеричное число.  

Специальный символ `\z` - пропускает все последующие символы в строке вплоть до первого не пробельного символа.

Операция `..` - служит для конкатенации строк. Строки являются неизменяемыми значениями. Операция конкатенации всегда создает новую строку, не изменяя свои операнды.

#### <a id="Таблицы-table" href="#Таблицы-table">Таблицы `table`</a>

Представляет ассоциативные массивы - это массив, который может быть индексирован любым другим значением языка, кроме `nil`. Являются главным (единственным) механизмом структурирования данных. Используется для представления обычных массивов, множеств, записей и других структур.

Это **объект** который всегда доступен по ссылке.

`<таблица> = {}` - создание таблицы.  
`<таблица> = {[{<строк_ключ1> | ["<строк_ключ1>"] | [<чис_ключ1>]} = ]<значение1>[{, | ;} ...]}` - создание таблицы через конструктор. Где первый элемент конструктора без ключа имеет индекс 1. Запятые после последней записи допустимы.
> `{x = 0, y = 0; "console"}`  
> `{["+"] = "add", ["-"] = "sub", }`

`<таблица>[<ключ>]` - получение записи по указанному ключу, если ее нет, то возвращается `nil`.  
`<таблица>[<ключ>] = <значение>` - установка записи по указанному ключу.  
`<таблица>[<ключ>] = nil` - удаление записи по указанному ключу.

`pairs(<таблица>)` - возвращает итератор с ключами и значениями.

`<таблица>["<ключ>"]` = `<таблица>.<ключ>` - равноценная запись, если `"<ключ>"` - строка без пробелов из букв `A-Z` и `a-z`, цифр `0-9` и символов подчеркивания `_`.

Чтобы представить традиционный массив или список используется таблица с целочисленными ключами, начиная с 1 (по соглашению). Длина хранится в ключе `n`, если это необходимо.

**Последовательность** - это список определенной длины без `nil` от 1, так как ключ со значением `nil` будет обозначать конец последовательности.

`#<последовательность>` - возвращает длину последовательности - максимальное значение ключа.

`<последовательность>[#<последовательность>]` - возвращает последнее значение последовательности.  
`<последовательность>[#<последовательность>] = nil` - удаляет последний элемент последовательности.  
`<последовательность>[#<последовательность> + 1] = <значение>` - добавляет значение к последовательности.

`table.unpack(<последовательность>[, <начальная_позиция>[, <конечная_позиция>]])` - возвращает все значения из массива `<последовательность>` в виде множественных значений.

#### <a id="Функции-function" href="#Функции-function">Функции `function`</a>

Являются значениями первого класса.

#### <a id="Пользовательские-данные-userdata" href="#Пользовательские-данные-userdata">Пользовательские данные `userdata`</a>

Пользовательские данные используются для представления новых типов, созданных прикладной программой или библиотекой, написанной на С.

#### <a id="Сопрограммы---нити-thread" href="#Сопрограммы---нити-thread">Сопрограммы - нити `thread`</a>

Это поток выполнения со своим стеком, своими локальными переменными и своим указателем команд; но он разделяет глобальные переменные и почти все остальное с другими сопрограммами.

#### <a id="Приведения-типов" href="#Приведения-типов">Приведения типов</a>

Lua обеспечивает автоматическое преобразование между числами и строками во время выполнения программ. Любая **числовая операция**, примененная к **строке**, пытается преобразовать эту строку в **число**. Каждый раз, когда Lua находит число там, где **ожидает строку**, он преобразует это **число** в **строку**.

`tonumber(<строка>)` - пытается преобразовать строку в число и возвращает его, возвращает `nil`, если строка не является правильным числом.

### <a id="Операции" href="#Операции">Операции</a>

#### <a id="Операции-сравнения" href="#Операции-сравнения">Операции сравнения</a>

`<значение1> <операция> <значение2>` - всегда производят булево значение

`<`, `>`, `<=`, `>=` - только для чисел и строк.

`==` проверяет на равенство, если значения обладают разными типами, то они не равны, в противном случае сравниваются значения в соответствии с их типами, в частности, `nil` равно только самому себе.

`~=` проверяет на неравенство, для всех типов.

#### <a id="Логические-операции" href="#Логические-операции">Логические операции</a>

Все логические операции трактуют `false` и `nil` как ложные, а все остальные - как истинные значения.

Операция `and` - логческое **и**, возвращает свой первый аргумент, если он ложный, иначе она возвращает свой второй аргумент.  
Операция `or` - логическое **или**, возвращает свой первый аргумент, если он не ложный; иначе она возвращает свой второй аргумент.  
Обе операции, `and` и `or`, используют сокращенное вычисление, то есть они вычисляют свой второй операнд только при необходимости. У `and` более высокий приоритет, чем у `or`.

Операция `not` всегда возвращает булево значение.

### <a id="Управляющие-конструкции" href="#Управляющие-конструкции">Управляющие конструкции</a>

Явное объявление блока:
```lua
do
    <код>
end
```

#### <a id="if-then-else" href="#if-then-else">`if then else`</a>

Оператор `if` проверяет свое условие и в зависимости от результата выполняет одну из своих частей.
```lua
if <условие1> then
    <код>
[elseif <условие2> then
    <код>
]
[...]
[else
    <код>
]
end
```

#### <a id="while" href="#while">`while`</a>

`while` повторяет свое тело до тех пор, пока условие истинно.
```lua
while <условие> do
    <код_тела>
end
```

`break` - в теле прерывает выполнение цикла.

#### <a id="repeat" href="#repeat">`repeat`</a>

Оператор `repeat`-`until` повторяет свое тело до тех пор, пока условие не станет истинным. Данный оператор производит проверку условия после выполнения тела, поэтому тело цикла будет выполнено хотя бы один раз.
```lua
repeat
    <код_тела>
until <условие> 
```

`break` - в теле прерывает выполнение цикла.

#### <a id="Числовой-for" href="#Числовой-for">Числовой `for`</a>

Перебирает значения от и до и записывает их в переменную с определенным шагом. Все три выражения вычисляются только один раз, перед началом цикла.

```lua
for <переменная> = <значение_от>, <значение_до>[, <значение_шага>] do
    <код_тела>
end
```

`break` - в теле прерывает выполнение цикла.  
`<значение_шага>` по умолчанию = 1.

#### <a id="Общий-for" href="#Общий-for">Общий `for`</a>

Перебирает все значения, возвращаемые итерирующей функцией.

```lua
for <переменная1>[, ...] in <список_выражений> do
    <код_тела>
end
```

Где `<список_выражений>` - это список из одного или нескольких выражений разделенных запятыми. Первая переменная - **управляющая переменная**, при значении ее равным `nil` выполнение цикла завершается.

Вначале `for` вычисляет выражения после `in` - эти выражения должны дать три значения, которые хранит `for`: итерирующая функция, инвариантное состояние (для удобства и гибкости может быть таблицей) и начальное значение управляющей переменной. При этом при каждом вызове в итерирующую функцию передается инвариантное состояние и значение управляющей переменной.

`break` - в теле прерывает выполнение цикла.

#### <a id="goto" href="#goto">`goto`</a>

`::<метка>::`  
`goto <метка>`

## <a id="Функции" href="#Функции">Функции</a>

```lua
[local ]function <функция>([<параметр1>[, ...]][, ...])
    <код>
    [return [<значение1>[, ...]]] -- можно использовать только в конце блоков
end
```

```lua
[local ]<переменная> = function ([<параметр1>[, ...]][, ...]) -- анонимная функция
    <код>
    [return [<значение1>[, ...]]] -- можно использовать только в конце блоков
end
```

Имя `<функция>` - может выглядеть как ключ вложенный в таблицу `<таблица>.<ключ>`.

`<функция>([<арг1>[, ...]])` - вызов.  
`<переменная1>[, ...] = <функция>([<арг1>[, ...]])` - множественное присваивание результатом вызова функции.

`<объект>:<функция>([<арг1>[, ...]])` = `<объект>.<функция>(<объект>[, <арг1>[, ...]])`

`<функция>{[{<ключ1> | ["<ключ1>"]} = ]<значение1>[{, | ;} ...]}` - вызов функции с единственным конструктором таблицы в качестве аргумента.

Параметры в точности как локальные переменные, если значение параметра не задано, то оно равно `nil`.

При этом лишние аргументы отбрасываются, лишние параметры получают `nil`.

`<параметр> = <параметр> or <значение_по_умолчанию>` - значение по умолчанию.

Три точки `...` в списке параметров указывают на то, что функция является **вариадической**. `...` - выражение с переменным числом аргументов.  
`{...}` - преобразует в последовательность.  
`<переменная1>[, ...] = ...` - присваивание переменным значениями из выражения с переменным числом аргументов.

Функции можно возвращать из функций и эти функции замыкаются на переменных, которые нужны ей для работы.

Функции поддерживают корректную хвостовую рекурсию. **Хвостовой вызов** происходит, когда одна функция вызывает другую в качестве своего последнего действия, и потому ей больше нечего делать. Хвостовым вызовом считается лишь вызов вида: `return <функция>(<аргументы>)`.

## <a id="Итераторы" href="#Итераторы">Итераторы</a>

Итератор (iterator) - это любая конструкция, которая позволяет перебирать элементы коллекции.

```lua
function <функция_фабрика>([<параметр1>[, ...]][, ...])
    <код>
    return function ()
        <код>
        return [<значение1>[, ...]]
    end
end
```

`<функция_фабрика>` - при вызове возвращает функцию итератор, которая при каждом вызове должна возвращать значение, а если значений нет, то `nil`. Итераторы лучше делать без состояния, чтобы они полагались лишь на инвариантное состояние и значение управляющей переменной.

Перебирается через общий `for`, который хранит внутри итерирующую функцию, вызывает итератор для каждой новой итерации и он останавливает цикл, когда итератор возвращает `nil`.
```lua
for <переменная1>[, ...] in <функция_фабрика>([<арг1>[, ...]]) do
    <код>
end
```

Пример итератора без замыкания:
```lua
local function iter(a, i)
    i = i + 1
    local v = a[i]
    if v then
        return i, v
    end
end
function ipairs(a)
    return iter, a, 0 -- возвращает итерирующую функция, инвариантное состояние и начальное значение управляющей переменной
end
a = {"one", "two", "three"}
for i, v in ipairs(a) do
    print(i, v)
end
-- или 
for i, v in iter, a do
    print(i, v)
end
```

### <a id="Подлинный-итератор" href="#Подлинный-итератор">Подлинный итератор</a>

Отличается от простого итератора, тем что принимает функцию в качестве параметра и применяет ее для каждого элемента.

```lua
function <подлинный_итератор>([<параметр1>[, ...], ]<функция>)
    <код>
    <функция>([<арг1>[, ...]])
end
```

## <a id="Ошибки" href="#Ошибки">Ошибки</a>

`error([<значение_ошибки>])` - выбрасывает ошибку[ со значением `<значение_ошибки>`], если значение строка или `nil`, то будет это значение со стеком трассировки.  
`assert(<значение>[, <значение_ошибки>])` - проверяет что значение не ложно и возвращает его, иначе выбрасывает ошибку `error`[ со значением `<значение_ошибки>`].

Для перехвата `error` используется защищенный режим:
`err, msg = pcall(<функция>)` - если возникла ошибка при вызове `<функция>`, то `err` будет равно `false`, а `msg` значением ошибки.

Если функция должна возвращать ошибку, то она должна возвращать ошибку вторым аргументом, а первым должен быть `nil`.

## <a id="Подключение-файлов" href="#Подключение-файлов">Подключение файлов</a>

`dofile("<имя_файла>")` - подключает и выполняет указанный файл.  
`<функция>, <ошибка> = loadfile("<имя_файла>")` - подключает указанный файл и возвращает функцию для его выполнения или `nil` если есть ошибка.  
`<функция> = load("<код>")` - компилирует строку и возвращает функцию для ее выполнения без учета лексической области действия или `nil` если есть ошибка компиляции.  
`<функция> = load(<итератор>)` - последовательно компилирует все строки возвращаемые функцией до значения `nil` и возвращает функцию для ее выполнения без учета лексической области действия или `nil` если есть ошибка компиляции.

`<функция>, <ошибка> = package.loadlib("<путь_к_файлу>", "<имя_функции>")` - подключает указанный файл-библиотеку и из него указанную `<имя_функции>` и возвращает функцию для его выполнения или `nil` если есть ошибка.

## <a id="Сопрограммы" href="#Сопрограммы">Сопрограммы</a>

`<co> = coroutine.create(<функция>)` - создает новую сопрограмму, с функцией `<функция>`, которую сопрограмма будет выполнять, в приостановленном состоянии.

Состояния сопрограммы:
- `suspended` - приостановленное (по умолчанию);
- `running` - выполняемое;
- `dead` - завершенное;
- `normal` - обычное.

`coroutine.status(<co>)` - возвращает состояние сопрограммы в виде строки.

`<статус>[, <переменная1>[, ...]] = coroutine.resume(<co>[, <арг1>[, ...]])` - (пере)запускает выполнение сопрограммы передавая ей дополнительные данные, меняя ее состояние из приостановленного в выполняемое и затем записывает возвращенные данные через `yield` или `return` в переменные и `true` в переменную `<статус>`. После выполнения функции, переводит сопрограмму в завершенное состояние.  
Выполняется в защищенном режиме, поэтому, если внутри сопрограммы есть какие-либо ошибки, Lua не будет показывать сообщение об ошибке, а просто вернет управление вызову `resume` и в этом случает возвратит `false` в переменную `<статус>` и сообщение об ошибке в следующую.

`[<переменная1>[, ...] = ]coroutine.yield([<арг1>[, ...]])` - позволяет выполняемой сопрограмме приостановить свое выполнение (уступить управление) и вернуть дополнительные данные, чтобы она могла быть возобновлена позже, переводит в приостановленное состояние и затем записывает переданные данные из `resume` в переменные. Используется внутри функции `<функция>`.

Первая `resume`, у которой нет соответственной ожидающей ее `yield`, передает свои дополнительные аргументы главной функции сопрограммы. Когда сопрограмма завершается, любые значения, возвращенные `return` ее главной функцией, передаются соответственной `resume`.

```lua
co = coroutine.create(function (a, b)
    print(a, b) -- 4 5
    c, d = coroutine.yield(a + b, a - b) -- 20, 10
    return c + d
    end)
status, c, d = coroutine.resume(co, 4, 5) -- true, 9, -1
status, f = coroutine.resume(co, 20, 10) -- true, 30
status, msg = coroutine.resume(co, 100) -- false, "cannot resume dead coroutine"
```

`<функция_возобновления> = coroutine.wrap(<функция>)` - возвращает функцию, которая при вызове возобновляет сопрограмму с функцией `<функция>`. Каждый вызов `<функция_возобновления>([<арг1>[, ...]])` будет возвращать данные возвращенные через `yield` или `return` из сопрограммы, если их нет, то `nil`. Подходит для создания итераторов.

## <a id="Запуск" href="#Запуск">Запуск</a>

`lua <имя_файла>.lua` - выполняет скриптовый файл `<имя_файла>.lua`.  
`luac -o <имя_скомпилируемого_файла>.lc <имя_файла>.lua` - компилирует файл `<имя_файла>.lua` в `<имя_скомпилируемого_файла>.lc`.  
`lua <имя_скомпилируемого_файла>.lc` - выполняет скомпилированный файл.  

### <a id="Командная-строка" href="#Командная-строка">Командная строка</a>

В переменной `arg` содержатся аргументы командной строки.