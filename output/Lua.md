[Содержание](#Содержание)
==========

- [Основы](#Основы)
    - [Комментарии](#Комментарии)
    - [Переменные](#Переменные)
        - [Типы и значения](#Типы-и-значения)
            - [Отсутствие значения `nil`](#Отсутствие-значения-nil)
            - [Логические значения `boolean`](#Логические-значения-boolean)
            - [Числа `number`](#Числа-number)
                - [Арифметические операции](#Арифметические-операции)
                - [Библиотечные методы](#Библиотечные-методы)
                - [Побитовая библиотека](#Побитовая-библиотека)
            - [Строки `string`](#Строки-string)
                - [Библиотечные методы](#Библиотечные-методы)
                - [Функции сопоставления с образцом](#Функции-сопоставления-с-образцом)
                    - [Образцы](#Образцы)
            - [Таблицы `table`](#Таблицы-table)
                - [Библиотечные методы](#Библиотечные-методы)
            - [Функции `function`](#Функции-function)
            - [Пользовательские данные `userdata`](#Пользовательские-данные-userdata)
            - [Сопрограммы - нити `thread`](#Сопрограммы---нити-thread)
            - [Приведения типов](#Приведения-типов)
        - [Операции](#Операции)
            - [Операции сравнения](#Операции-сравнения)
            - [Логические операции](#Логические-операции)
        - [Управляющие конструкции](#Управляющие-конструкции)
            - [`if then else`](#if-then-else)
            - [`while`](#while)
            - [`repeat`](#repeat)
            - [Числовой `for`](#Числовой-for)
            - [Общий `for`](#Общий-for)
            - [`goto`](#goto)
    - [Функции](#Функции)
    - [Итераторы](#Итераторы)
        - [Подлинный итератор](#Подлинный-итератор)
    - [Ошибки](#Ошибки)
    - [Подключение файлов](#Подключение-файлов)
        - [Модули и пакеты](#Модули-и-пакеты)
            - [Создание модуля](#Создание-модуля)
    - [Сопрограммы](#Сопрограммы)
    - [Метатаблицы](#Метатаблицы)
        - [Метаметоды](#Метаметоды)
            - [Арифметические метаметоды](#Арифметические-метаметоды)
            - [Метаметоды сравнения](#Метаметоды-сравнения)
            - [Библиотечные метаметоды](#Библиотечные-метаметоды)
            - [Метаметоды доступа к таблице](#Метаметоды-доступа-к-таблице)
            - [Слабые таблицы](#Слабые-таблицы)
            - [Финализаторы](#Финализаторы)
    - [Окружение](#Окружение)
    - [Объектно-ориентированное программирование](#Объектно-ориентированное-программирование)
        - [Классы](#Классы)
            - [Наследование](#Наследование)
            - [Множественное наследование](#Множественное-наследование)
            - [Конфиденциальность](#Конфиденциальность)
                - [Подход с единственным методом](#Подход-с-единственным-методом)
    - [Библиотека ввода-вывода](#Библиотека-ввода-вывода)
        - [Простая модель ввода-вывода](#Простая-модель-ввода-вывода)
        - [Полная модель ввода-вывода](#Полная-модель-ввода-вывода)
    - [Библиотека операционной системы](#Библиотека-операционной-системы)
    - [Запуск](#Запуск)
        - [Командная строка](#Командная-строка)
    - [Сборщик мусора](#Сборщик-мусора)

<a id="Основы" href="#Основы">Основы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

## <a id="Комментарии" href="#Комментарии">Комментарии</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Начинаются с `--` и до конца строки или от `--[[` и до `--]]`.

## <a id="Переменные" href="#Переменные">Переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Идентификаторы (или имена) в Lua могут быть любой последовательностью из букв `A-Z` и `a-z`, цифр `0-9` и символов подчеркивания `_`, не начинающейся с цифры. Следует избегать символов подчеркивания `_` в начале идентификатора, так как они зарезервированы в Lua для особых целей.

Необъявленные переменные равны `nil` по умолчанию.

`<глобальная_переменная>[ = <значение>]` - присваивание значения глобальной переменной.  
`<переменная1>[, ...] = <значение1>[, ...]` - множественное присваивание.

`local <переменная>[ = <значение>]` - присваивание значения локальной переменной, область видимости локальной переменной ограничена блоком, где она была объявлена, где **блок** - это тело управляющей структуры, тело функции или кусок кода (файл или строка, где переменная была объявлена).

`local <переменная> = <глобальная_переменная>` - создание локальной переменной и инициализирует ее значением глобальной переменной. Используется для одного и того же имени переменных.

### <a id="Типы-и-значения" href="#Типы-и-значения">Типы и значения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В Lua существует восемь базовых типов: `nil`, `boolean`, `number`, `string`, `table`, `function`, `userdata` и `thread`.

`type(<значение>)` - вернет тип значения.

У переменных нет предопределенных типов; любая переменная может содержать значения любого типа.

#### <a id="Отсутствие-значения-nil" href="#Отсутствие-значения-nil">Отсутствие значения `nil`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это тип с единственным значением, `nil`, основная задача которого состоит в том, чтобы отличаться от всех остальных значений.

#### <a id="Логические-значения-boolean" href="#Логические-значения-boolean">Логические значения `boolean`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Обладает двумя значениями - `true` и `false`, которые представляют традиционные логические (или булевы) значения. Проверки условий (например, условий в управляющих структурах) считают `nil` и булево `false` ложными, а все прочие значения истинными.

#### <a id="Числа-number" href="#Числа-number">Числа `number`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Представляет вещественные числа, т.е. числа двойной точности с плавающей точкой, `0x` - префикс для 16-го вида числа.

##### <a id="Арифметические-операции" href="#Арифметические-операции">Арифметические операции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Стандартные арифметические операции:
- бинарные: `+` (сложение), `-` (вычитание), `*` (умножение), `/` (деление), `^` (возведение в степень), `%` (остаток от деления);
- унарные: `-` (отрицание).

##### <a id="Библиотечные-методы" href="#Библиотечные-методы">Библиотечные методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Константы:
- `math.pi`.

Тригонометрические (принимают радианы):
- `math.sin(<число>)`;
- `math.cos(<число>)`;
- `math.tan(<число>)`;
- `math.asin(<число>)`;
- `math.acos(<число>)`.

Конвертеры:
- `math.deg(<число>)` - переводит градусы `<число>` в радианы и возвращает их;
- `math.rad(<число>)` - переводит радианы `<число>` в градусы и возвращает их.

Округление:
- `math.floor(<число>)` - округляет вниз и возвращает число;
- `math.ceil(<число>)` - округляет вверх и возвращает число.

Функции общего назначения:
- `math.log(<число>)` - возвращает натуральный (по основанию e) логарифм `<число>`;
- `math.log10(<число>)` - возвращает десятичный логарифм `<число>`;
- `math.exp(<число>)` - возвращает `e^<число>`, где `e` - основание натуральных логарифмов;
- `math.max(a, b, c[, ...])` - возвращает наибольший из списка аргументов;
- `math.min(a, b, c[, ...])` - возвращает наименьший из списка аргументов;
- `math.random([<до>])` - возвращает псевдо-случайное число в интервале `[0,1)`[`[0,<до>)`] - то есть между 0 (включительно) и 1 [`<до>`] (не включая);
- `math.random(<от>, <до>)` - возвращает псевдо-случайное число в интервале `[<от>,<до>)` - то есть между `<от>` (включительно) и `<до>` (не включая);
- `math.randomseed(<посев>)` - инициализирует псевдогенератор заданным посевом `<посев>`.

##### <a id="Побитовая-библиотека" href="#Побитовая-библиотека">Побитовая библиотека</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сравнение:
- `bit32.band(<число1>, <число2>)` - возвращает **побитовое И** (**AND**) для `<число1>` и `<число2>`;
- `bit32.btest(<число1>, <число2>)` - возвращает **побитовое И** (**AND**) для `<число1>` и `<число2>` и побитовое сравнение с 0 - `true` или `false`;
- `bit32.bor(<число1>, <число2>)` - возвращает **побитовое ИЛИ** (**OR**) для `<число1>` и `<число2>`;
- `bit32.bxor(<число1>, <число2>)` - возвращает побитовое **исключающее ИЛИ** (**XOR**) для `<число1>` и `<число2>`;
- `bit32.bnot(<число>)` - возвращает побитовое **НЕ** (**NOT**) для `<число>`.

Сдвиги:
- `bit32.rshift(<число>, <количество_знаков>)` - возвращает побитово сдвинутое число `<число>` направо на указаное количество знаков `<количество_знаков>` заполняются новые биты 0;
- `bit32.lshift(<число>, <количество_знаков>)` - возвращает побитово сдвинутое число `<число>` налево на указаное количество знаков `<количество_знаков>` заполняются новые биты 0;
- `bit32.arshift(<число>, <количество_знаков>)` - возвращает побитово сдвинутое число `<число>` налево на указаное количество знаков `<количество_знаков>` заполняются новые биты копиями послего бита;
- `bit32.lrotate(<число>, <количество_знаков>)` - возвращает побитово сдвинутое число `<число>` налево на указаное количество знаков `<количество_знаков>` и дополненное справа сдвинутыми битами;
- `bit32.rrotate(<число>, <количество_знаков>)` - возвращает побитово сдвинутое число `<число>` направо на указаное количество знаков `<количество_знаков>` и дополненное слева сдвинутыми битами.

Другие:
- `bit32.extract(<число>, <от>[, <количество>])` - возвращает 1 [указаное `<количество>`] бит из `<число>`, начиная с битовой позиции (знака) `<от>`;
- `bit32.replace(<число>, <число_замены>, <от>[, <количество>])` - возвращает новое число, в котором из `<число>` 1 [указаное `<количество>`] бит заменены на `<число_замены>`, начиная с битовой позиции (знака) `<от>`.

#### <a id="Строки-string" href="#Строки-string">Строки `string`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это последовательность символов в кавычках `'`, `"` или от `[<набор_символов>[` и до `]<набор_символов>]`, поддерживает все 8-битовые символы, и строки могут содержать символы с любыми числовыми кодами, включая нульсимволы.
> `local str = [[string]]`

`#<переменная>` / `#<строка>` - возвращает длину строки.

Символы могут быть еще представлены в виде: `\ddd` - где `d` - десятичное число, `\xhh` - `h` - где `h` - шестнадцатеричное число.  

Специальный символ `\z` - пропускает все последующие символы в строке вплоть до первого не пробельного символа.

Операция `..` - служит для конкатенации строк. Строки являются неизменяемыми значениями. Операция конкатенации всегда создает новую строку, не изменяя свои операнды.

##### <a id="Библиотечные-методы" href="#Библиотечные-методы">Библиотечные методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Индекс первого символа строки равен 1. При этом отрицательные индексы отсчитываются с конца строки (-1 - последний символ).

`string.len(<строка>)` - возвращает длину строки, аналогично `#<строка>`.  
`string.rep(<строка>, <количество>)` - возвращает новую строку повторенную `<количество>` раз.  
`string.lower(<строка>)` - возвращает новую строку в которой все символы из строки в нижнем регистре.  
`string.upper(<строка>)` - возвращает новую строку в которой все символы из строки в верхнем регистре.  
`string.sub(<строка>, <индекс_от>, <индекс_до>)` - возвращает часть строки `<строка>` от символа с индексом `<индекс_от>` по символ с индексом `<индекс_до>` включительно.

`string.char(<число1>[, ...])` - преобразует каждое чисел в символ и возвращает строку, в которой все эти символы соединены.  
`string.byte(<строка>, <индекс_от>[, <индекс_до>])` - возвращает внутреннее числовое представление символа с индексом `<индекс_от>` [и до `<индекс_до>`] в строке `<строка>`.

`string.format(<строка>[, <аргумент1>[, ...]])` - возвращает отформатированную версию всех своих аргументов, следуя описанию, заданному своим первым аргументом, так называемой форматирующей строкой (format string) (`printf`). Состоит из директив, которые имеют структуру:  
`%[0][<минимальное_количество_знаков>][.<количество_десятичных_знаков>]{d|x|o|f|s}` - где:
- `0` - обозначает дополнение нулями;
- `<минимальное_количество_знаков>` - обозначает минимальное количество знаков;
- `<количество_десятичных_знаков>` - обозначает количество десятичных знаков после запятой;
- `d` - обозначает десятичное число;
- `x` - обозначает шестнадцатеричное число;
- `o` - обозначает восьмеричное число;
- `f` - обозначает число с плавающей точкой;
- `s` - обозначает строку.

##### <a id="Функции-сопоставления-с-образцом" href="#Функции-сопоставления-с-образцом">Функции сопоставления с образцом</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`string.find(<строка>, <строка_образец>[, <индекс_от>])` - возвращает два значения: индекс, с которого начинается совпадение, и индекс, на котором совпадение заканчивается, строки `<строка_образец>` в строке `<строка>` [начиная с указаного индекса `<индекс_от>`]. Если совпадение не найдено, возвращается `nil`.

`string.match(<строка>, <строка_образец>[, <индекс_от>])` - возвращает часть обрабатываемой строки `<строка>`, удовлетворяющую образцу `<строка_образец>` (при наличии захватов возвращаются значения захватов, где каждый захват как отдельный результат) [начиная с указаного индекса `<индекс_от>`]. Если совпадение не найдено, возвращается `nil`.

`string.gsub(<строка>, <строка_образец>, <строка_замены>[, <количество>])` - возвращает новую строку в которой все подстроки удовлетворяющие образцу `<строка_образец>` будут заменены на `<строка_замены>` [максимальное количество `<количество>` раз] и число произведенных замен.  
`string.gsub(<строка>, <строка_образец>, <таблица>[, <количество>])` - возвращает новую строку в которой все подстроки удовлетворяющую **первому захвату** образца `<строка_образец>` будут заменены на связанные значения ключей из таблицы `<таблица>` по образцу, если значение равно `nil`, то замены не будет [максимальное количество `<количество>` раз] и число произведенных замен.  
`string.gsub(<строка>, <строка_образец>, function (<захват1>[, ...]) ... return '<замена>' end[, <количество>])` - возвращает новую строку в которой все подстроки удовлетворяющие образцу `<строка_образец>` будут заменены на возвращенное значение функции, которая принимает в качестве аргументов захваты [максимальное количество `<количество>` раз] и число произведенных замен.

`string.gmatch(<строка>, <строка_образец>)` - возвращает функцию, которая перебирает все вхождения образца `<строка_образец>` в строку `<строка>` (при наличии захватов функция возвращает значения захватов, где каждый захват как отдельный результат).

###### <a id="Образцы" href="#Образцы">Образцы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Класс символов:
- `.` - все символы;
- `%a` - буквы;
- `%c` - управляющие символы;
- `%d` - цифры;
- `%g` - печатные символы кроме пробельных;
- `%l` - строчные буквы;
- `%p` - символы пунктуации;
- `%s` - пробельные символы;
- `%u` - заглавные буквы;
- `%w` - буквенно-цифровые символы;
- `%x` - шестнадцатеричные цифры.

Символ `%` работает для магических символов (`(`, `)`, `.`, `%`, `+`, `-`, `*`, `?`, `[`, `]`, `^`, `$`) как экранирование.

`[[^]<символ1>[<символ2>[...]]]` - это набор, который означает один любой символ из указанных [при `^` не указанных]. Квадратные скобки могут также содержать диапазоны символов:  
`[<символ_начала>-<символ_конца>[...]]`

Модификаторы повторений могут быть применены только к классу символов, группировать образцы под одним модификатором нельзя:
- `+` - 1 или более повторений;
- `*` - 0 или более повторений;
- `-` - 0 или более коротких повторений;
- `?` - 0 или 1 вхождение (необязательный образец).

Если образец начинается с символа `^`, то он будет сопоставляться только с началом обрабатываемой строки.  
Если образец заканчивается символом `$`, то он будет сопоставляться только с концом обрабатываемой строки.  
Символы `^` и `$` являются магическими лишь тогда, когда применяются в начале или конце образца.

`%b<символ_открытия><символ_закрытия>` - соответствует сбалансированным строкам у которых `<символ_открытия>` - выступает как открывающий символ, а `<символ_закрытия>` - как закрывающий.

`%f[<множество_символов>]` - является **пограничным образцом** (frontier pattern). Он соответствует пустой строке, только если следующий символ входит во множество символов `<множество_символов>`, а предыдущий - нет. Позиции перед первым и после последнего символов в обрабатываемой строке трактуются как содержащие нуль-символ (символ с ASCII кодом 0).

`(<под_образец>)` - обозначает **захват** - позволяет образцу выдергивать из обрабатываемой строки те части, которые удовлетворяют частям образца `<под_образец>`, в целях дальнейшего использования. При этом для дальнейшего использования в образцах можно использовать ссылку на подобразец: `%1` - на значение первого подобразца и т.д.  
Используются также для функции `string.gsub` для строки замены, при этом `%0` - будет соответствовать всей строке.  
`()` - пустой захват - захватывает свою позицию в обрабатываемой строке как число.

#### <a id="Таблицы-table" href="#Таблицы-table">Таблицы `table`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Представляет ассоциативные массивы - это массив, который может быть индексирован любым другим значением языка, кроме `nil`. Являются главным (единственным) механизмом структурирования данных. Используется для представления обычных массивов, множеств, записей и других структур.

Это **объект** который всегда доступен по ссылке.

`<таблица> = {}` - создание таблицы.  
`<таблица> = {[{<строк_ключ1> | ["<строк_ключ1>"] | [<чис_ключ1>] | [<выражение1>]} = ]<значение1>[{, | ;} ...]}` - создание таблицы через конструктор. Где первый элемент конструктора без ключа имеет индекс 1. Запятые после последней записи допустимы.
> `{x = 0, y = 0; "console"}`  
> `{["+"] = "add", ["-"] = "sub", }`  
> `i = 20; s = "-"; a = {[i + 0] = s, [i + 1] = s .. s, [i + 2] = s .. s .. s}`

`<таблица>[<ключ>]` - получение записи по указанному ключу, если ее нет, то возвращается `nil`.  
`<таблица>[<ключ>] = <значение>` - установка записи по указанному ключу.  
`<таблица>[<ключ>] = nil` - удаление записи по указанному ключу.

`pairs(<таблица>)` - возвращает итератор с ключами и значениями.  
`ipairs(<таблица>)` - возвращает итератор по порядку следования ключей в массиве с ключами и значениями.

`<таблица>["<ключ>"]` = `<таблица>.<ключ>` - равноценная запись, если `"<ключ>"` - строка без пробелов из букв `A-Z` и `a-z`, цифр `0-9` и символов подчеркивания `_`.

Чтобы представить традиционный массив или список используется таблица с целочисленными ключами, начиная с 1 (по соглашению). Длина хранится в ключе `n`, если это необходимо.

**Последовательность** - это список определенной длины без `nil` от 1, так как ключ со значением `nil` будет обозначать конец последовательности.

`#<последовательность>` - возвращает длину последовательности - максимальное значение ключа.

`<последовательность>[#<последовательность>]` - возвращает последнее значение последовательности.  
`<последовательность>[#<последовательность>] = nil` - удаляет последний элемент последовательности.  
`<последовательность>[#<последовательность> + 1] = <значение>` - добавляет значение к последовательности.

##### <a id="Библиотечные-методы" href="#Библиотечные-методы">Библиотечные методы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`table.unpack(<последовательность>[, <начальная_позиция>[, <конечная_позиция>]])` - возвращает все значения из массива `<последовательность>` в виде множественных значений.

`table.concat(<последовательность>[, "<соединитель>"])` - возвращает строку в которой соединены элементы последовательности [указанным соединителем `<соединитель>`].

`table.insert(<последовательность>[, <позиция>], <значение>)` - вставляет значение `<значение>` в массив `<последовательность>` в конец [в указанную позицию `<позиция>` при этом сдвигая оставшиеся элементы].  
`table.remove(<последовательность>[, <позиция>])` - удаляет и возвращает элемент из массива `<последовательность>` с конца [с указанной позиции `<позиция>` при этом сдвигая оставшиеся элементы].

`table.sort(<последовательность>[, function (a, b) ... [return true] end])` - сортирует массив сравнивая два элемента с помощью `<` [с помощью указаной функции, которая должна вернуть `true`, когда ее первый аргумент должен идти перед вторым в отсортированном массиве].

#### <a id="Функции-function" href="#Функции-function">Функции `function`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Являются значениями первого класса.

#### <a id="Пользовательские-данные-userdata" href="#Пользовательские-данные-userdata">Пользовательские данные `userdata`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Пользовательские данные используются для представления новых типов, созданных прикладной программой или библиотекой, написанной на С.

#### <a id="Сопрограммы---нити-thread" href="#Сопрограммы---нити-thread">Сопрограммы - нити `thread`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это поток выполнения со своим стеком, своими локальными переменными и своим указателем команд; но он разделяет глобальные переменные и почти все остальное с другими сопрограммами.

#### <a id="Приведения-типов" href="#Приведения-типов">Приведения типов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Lua обеспечивает автоматическое преобразование между числами и строками во время выполнения программ. Любая **числовая операция**, примененная к **строке**, пытается преобразовать эту строку в **число**. Каждый раз, когда Lua находит число там, где **ожидает строку**, он преобразует это **число** в **строку**.

`tonumber(<строка>[, <система>])` - пытается преобразовать строку в число [в указаной системе исчисления `<система>`] и возвращает его, возвращает `nil`, если строка не является правильным числом.  
`tostring(<значение>)` - преобразует значение `<значение>` в строку и возвращает его.

### <a id="Операции" href="#Операции">Операции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="Операции-сравнения" href="#Операции-сравнения">Операции сравнения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<значение1> <операция> <значение2>` - всегда производят булево значение.

`<`, `>`, `<=`, `>=` - только для чисел и строк.

`==` проверяет на равенство, если значения обладают разными типами, то они не равны, в противном случае сравниваются значения в соответствии с их типами, в частности, `nil` равно только самому себе.

`~=` проверяет на неравенство, для всех типов.

#### <a id="Логические-операции" href="#Логические-операции">Логические операции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Все логические операции трактуют `false` и `nil` как ложные, а все остальные - как истинные значения.

Операция `and` - логческое **и**, возвращает свой первый аргумент, если он ложный, иначе она возвращает свой второй аргумент.  
Операция `or` - логическое **или**, возвращает свой первый аргумент, если он не ложный; иначе она возвращает свой второй аргумент.  
Обе операции, `and` и `or`, используют сокращенное вычисление, то есть они вычисляют свой второй операнд только при необходимости. У `and` более высокий приоритет, чем у `or`.

Операция `not` всегда возвращает булево значение.

### <a id="Управляющие-конструкции" href="#Управляющие-конструкции">Управляющие конструкции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Явное объявление блока:
```lua
do
    <код>
end
```

#### <a id="if-then-else" href="#if-then-else">`if then else`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Оператор `if` проверяет свое условие и в зависимости от результата выполняет одну из своих частей.
```lua
if <условие1> then
    <код>
[elseif <условие2> then
    <код>
]
[...]
[else
    <код>
]
end
```

#### <a id="while" href="#while">`while`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`while` повторяет свое тело до тех пор, пока условие истинно.
```lua
while <условие> do
    <код_тела>
end
```

`break` - в теле прерывает выполнение цикла.

#### <a id="repeat" href="#repeat">`repeat`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Оператор `repeat`-`until` повторяет свое тело до тех пор, пока условие не станет истинным. Данный оператор производит проверку условия после выполнения тела, поэтому тело цикла будет выполнено хотя бы один раз.
```lua
repeat
    <код_тела>
until <условие>
```

`break` - в теле прерывает выполнение цикла.

#### <a id="Числовой-for" href="#Числовой-for">Числовой `for`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Перебирает значения от и до и записывает их в переменную с определенным шагом. Все три выражения вычисляются только один раз, перед началом цикла.

```lua
for <переменная> = <значение_от>, <значение_до>[, <значение_шага>] do
    <код_тела>
end
```

`break` - в теле прерывает выполнение цикла.  
`<значение_шага>` по умолчанию = 1.

#### <a id="Общий-for" href="#Общий-for">Общий `for`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Перебирает все значения, возвращаемые итерирующей функцией.

```lua
for <переменная1>[, ...] in <список_выражений> do
    <код_тела>
end
```

Где `<список_выражений>` - это список из одного или нескольких выражений разделенных запятыми. Первая переменная - **управляющая переменная**, при значении ее равным `nil` выполнение цикла завершается.

Вначале `for` вычисляет выражения после `in` - эти выражения должны дать три значения, которые хранит `for`: итерирующая функция, инвариантное состояние (для удобства и гибкости может быть таблицей) и начальное значение управляющей переменной. При этом при каждом вызове в итерирующую функцию передается инвариантное состояние и значение управляющей переменной.

`break` - в теле прерывает выполнение цикла.

#### <a id="goto" href="#goto">`goto`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`::<метка>::`  
`goto <метка>`

## <a id="Функции" href="#Функции">Функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```lua
[local ]function <функция>([<параметр1>[, ...]][, ...])
    <код>
    [return [<значение1>[, ...]]] -- можно использовать только в конце блоков
end
```

```lua
[local ]<переменная> = function ([<параметр1>[, ...]][, ...]) -- анонимная функция
    <код>
    [return [<значение1>[, ...]]] -- можно использовать только в конце блоков
end
```

Имя `<функция>` - может выглядеть как ключ вложенный в таблицу `<таблица>.<ключ>`.
> List = {}; function List.new() return {first = 0, last = -1} end

`<функция>([<арг1>[, ...]])` - вызов.  
`<переменная1>[, ...] = <функция>([<арг1>[, ...]])` - множественное присваивание результатом вызова функции.

`<объект>:<функция>([<арг1>[, ...]])` = `<объект>.<функция>(<объект>[, <арг1>[, ...]])`

`<функция>{[{<ключ1> | ["<ключ1>"]} = ]<значение1>[{, | ;} ...]}` - вызов функции с единственным конструктором таблицы в качестве аргумента.
```lua
function Entry(data)
    data.count = data.count + 1
end
Entry{count = 10}
Entry({count = 10})
```

Параметры в точности как локальные переменные, если значение параметра не задано, то оно равно `nil`.

При этом лишние аргументы отбрасываются, лишние параметры получают `nil`.

`<параметр> = <параметр> or <значение_по_умолчанию>` - значение по умолчанию.

Три точки `...` в списке параметров указывают на то, что функция является **вариадической**. `...` - выражение с переменным числом аргументов.  
`{...}` - преобразует в последовательность.  
`<переменная1>[, ...] = ...` - присваивание переменным значениями из выражения с переменным числом аргументов.

Функции можно возвращать из функций и эти функции замыкаются на переменных, которые нужны ей для работы.

Функции поддерживают корректную хвостовую рекурсию. **Хвостовой вызов** происходит, когда одна функция вызывает другую в качестве своего последнего действия, и потому ей больше нечего делать. Хвостовым вызовом считается лишь вызов вида: `return <функция>(<аргументы>)`.

## <a id="Итераторы" href="#Итераторы">Итераторы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Итератор (iterator) - это любая конструкция, которая позволяет перебирать элементы коллекции.

```lua
function <функция_фабрика>([<параметр1>[, ...]][, ...])
    <код>
    return function ()
        <код>
        return [<значение1>[, ...]]
    end
end
```

`<функция_фабрика>` - при вызове возвращает функцию итератор, которая при каждом вызове должна возвращать значение, а если значений нет, то `nil`. Итераторы лучше делать без состояния, чтобы они полагались лишь на инвариантное состояние и значение управляющей переменной.

Перебирается через общий `for`, который хранит внутри итерирующую функцию, вызывает итератор для каждой новой итерации и он останавливает цикл, когда итератор возвращает `nil`.
```lua
for <переменная1>[, ...] in <функция_фабрика>([<арг1>[, ...]]) do
    <код>
end
```

Пример итератора без замыкания:
```lua
local function iter(a, i)
    i = i + 1
    local v = a[i]
    if v then
        return i, v
    end
end
function ipairs(a)
    return iter, a, 0 -- возвращает итерирующую функция, инвариантное состояние и начальное значение управляющей переменной
end
a = {"one", "two", "three"}
for i, v in ipairs(a) do
    print(i, v)
end
-- или
for i, v in iter, a do
    print(i, v)
end
```

### <a id="Подлинный-итератор" href="#Подлинный-итератор">Подлинный итератор</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Отличается от простого итератора, тем что принимает функцию в качестве параметра и применяет ее для каждого элемента.

```lua
function <подлинный_итератор>([<параметр1>[, ...], ]<функция>)
    <код>
    <функция>([<арг1>[, ...]])
end
```

## <a id="Ошибки" href="#Ошибки">Ошибки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`error([<значение_ошибки>])` - выбрасывает ошибку [со значением `<значение_ошибки>`], если значение строка или `nil`, то будет это значение со стеком трассировки.  
`assert(<значение>[, <значение_ошибки>])` - проверяет что значение не ложно и возвращает его, иначе выбрасывает ошибку `error` [со значением `<значение_ошибки>`].

Для перехвата `error` используется защищенный режим:
`err, msg = pcall(<функция>)` - если возникла ошибка при вызове `<функция>`, то `err` будет равно `false`, а `msg` значением ошибки.

Если функция должна возвращать ошибку, то она должна возвращать ошибку вторым аргументом, а первым должен быть `nil`.

## <a id="Подключение-файлов" href="#Подключение-файлов">Подключение файлов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`dofile("<имя_файла>")` - подключает и выполняет указанный файл.  
`<функция>, <ошибка> = loadfile("<имя_файла>")` - подключает указанный файл и возвращает функцию для его выполнения или `nil` если есть ошибка.  
`<функция> = load("<код>")` - компилирует строку и возвращает функцию для ее выполнения без учета лексической области действия или `nil` если есть ошибка компиляции.  
`<функция> = load(<итератор>)` - последовательно компилирует все строки возвращаемые функцией до значения `nil` и возвращает функцию для ее выполнения без учета лексической области действия или `nil` если есть ошибка компиляции.

`<функция>, <ошибка> = package.loadlib("<путь_к_файлу>", "<имя_функции>")` - подключает указанный файл-библиотеку и из него указанную `<имя_функции>` и возвращает функцию для его выполнения или `nil` если есть ошибка.

**Формат самоописываемых данных** - это когда в файле подключается с помощью `dofile("<имя_файла>")` и в нем используется конструкции:
```lua
<Функция>{
    <ключ> = <значение1>[, ...]
}
```

### <a id="Модули-и-пакеты" href="#Модули-и-пакеты">Модули и пакеты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Пакет** является набором модулей.

**Модуль** - это некоторый код (на Lua или С), который может быть загружен посредством require и который создает и возвращает таблицу. Все, что модуль экспортирует, будь то функции или таблицы, он определяет внутри этой таблицы, которая выступает в качестве пространства имен.

`local <модуль> = require "<путь_к_модулю>"` - подключения модуля из файла `<путь_к_модулю>` (если есть внутри `.`, то они преобразуются в `/` или `\`) в переменную `<модуль>` и в таблицу `package.loaded` для кеширования. Если модуль уже был загружен когда-то то возвращается уже загруженный модуль. Если не может найти файл с именем модуля, то она ищет библиотеку С с этим именем модуля.

Путь поиска по шаблонам: `?`, `?.lua`, `c:\windows\?`, `/usr/local/lua/?/?.lua`.

#### <a id="Создание-модуля" href="#Создание-модуля">Создание модуля</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

1. Экспорт:
    - создание таблицы: `local <модуль> = {}`;
    - объявление экспортируемых данных в таблице: `<модуль>.<ключ> = <значение>`;
    - возвращение таблицы из файла: `return <модуль>`.
2. Экспорт возвращаемой таблицы:
    - возвращение таблицы из файла: `return {<ключ> = <значение>[, ...]}`.
3. Присваивание:
    - создание таблицы: `local <модуль> = {}`;
    - объявление экспортируемых данных в таблице: `<модуль>.<ключ> = <значение>`;
    - присваивание таблицы из файла: `package.loaded[...] = <модуль>`.
4. Использование окружения для избежания засорения глобального пространства:
    - создание таблицы: `local <модуль> = {}`;
    - предоставления доступа к глобальным переменным: `setmetatable(<модуль>, {__index = _G})`;
    - задание окружения: `_ENV = <модуль>`;
    - объявление экспортируемых данных: `<переменная> = <значение>`;
    - возвращение таблицы из файла: `return <модуль>`.

## <a id="Сопрограммы" href="#Сопрограммы">Сопрограммы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<co> = coroutine.create(<функция>)` - создает новую сопрограмму, с функцией `<функция>`, которую сопрограмма будет выполнять, в приостановленном состоянии.

Состояния сопрограммы:
- `suspended` - приостановленное (по умолчанию);
- `running` - выполняемое;
- `dead` - завершенное;
- `normal` - обычное.

`coroutine.status(<co>)` - возвращает состояние сопрограммы в виде строки.

`<статус>[, <переменная1>[, ...]] = coroutine.resume(<co>[, <арг1>[, ...]])` - (пере)запускает выполнение сопрограммы передавая ей дополнительные данные, меняя ее состояние из приостановленного в выполняемое и затем записывает возвращенные данные через `yield` или `return` в переменные и `true` в переменную `<статус>`. После выполнения функции, переводит сопрограмму в завершенное состояние.  
Выполняется в защищенном режиме, поэтому, если внутри сопрограммы есть какие-либо ошибки, Lua не будет показывать сообщение об ошибке, а просто вернет управление вызову `resume` и в этом случает возвратит `false` в переменную `<статус>` и сообщение об ошибке в следующую.

`[<переменная1>[, ...] = ]coroutine.yield([<арг1>[, ...]])` - позволяет выполняемой сопрограмме приостановить свое выполнение (уступить управление) и вернуть дополнительные данные, чтобы она могла быть возобновлена позже, переводит в приостановленное состояние и затем записывает переданные данные из `resume` в переменные. Используется внутри функции `<функция>`.

Первая `resume`, у которой нет соответственной ожидающей ее `yield`, передает свои дополнительные аргументы главной функции сопрограммы. Когда сопрограмма завершается, любые значения, возвращенные `return` ее главной функцией, передаются соответственной `resume`.

```lua
co = coroutine.create(function (a, b)
    print(a, b) -- 4 5
    c, d = coroutine.yield(a + b, a - b) -- 20, 10
    return c + d
    end)
status, c, d = coroutine.resume(co, 4, 5) -- true, 9, -1
status, f = coroutine.resume(co, 20, 10) -- true, 30
status, msg = coroutine.resume(co, 100) -- false, "cannot resume dead coroutine"
```

`<функция_возобновления> = coroutine.wrap(<функция>)` - возвращает функцию, которая при вызове возобновляет сопрограмму с функцией `<функция>`. Каждый вызов `<функция_возобновления>([<арг1>[, ...]])` будет возвращать данные возвращенные через `yield` или `return` из сопрограммы, если их нет, то `nil`. Подходит для создания итераторов.

## <a id="Метатаблицы" href="#Метатаблицы">Метатаблицы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Метатаблица** - это таблица в которой определены **метаметоды**.  
`<метатаблица> = {}`

Любая таблица может быть метатаблицей для любого значения; группа связанных между собой таблиц может совместно использовать общую метатаблицу, которая описывает их общее поведение; таблица может быть метатаблицей для самой себя, таким образом описывая свое собственное индивидуальное поведение. Допустимо использовать любую схему.

`getmetatable(<таблица>)` - возвращает таблицу - метатаблицу таблицы `<таблица>`, если ее нет, то `nil`.  
`setmetatable(<таблица>, <метатаблица>)` - устанавливает метатаблицу `<метатаблица>` для таблицы `<таблица>`.

### <a id="Метаметоды" href="#Метаметоды">Метаметоды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При поиске метаметода Lua выполняет следующие шаги:
- если у первого значения есть метатаблица с указанным полем, то Lua использует это поле в качестве метаметода независимо от второго значения;
- если у второго значения есть метатаблица с указанным полем, Lua использует его поле в качестве метаметода;
- в противном случае Lua вызовет ошибку.

Метаметоды должны возвращать результат действия метода.

Виды:
- `<метатаблица>.<бинарный_метаметод> = function (a, b) <код>; return <значение> end`;
- `<метатаблица>.<унарный_метаметод> = function (a) <код>; return <значение> end`.

#### <a id="Арифметические-метаметоды" href="#Арифметические-метаметоды">Арифметические метаметоды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `__add` - бинарный метаметод для сложения;
- `__mul` - бинарный метаметод для умножения;
- `__sub` - бинарный метаметод для вычитания;
- `__div` - бинарный метаметод для деления;
- `__unm` - унарный метаметод для отрицания;
- `__mod` - бинарный метаметод для взятия остатка от деления;
- `__pow` - бинарный метаметод для возведения в степень;
- `__concat` - бинарный метаметод для описания поведения операции конкатенации.

#### <a id="Метаметоды-сравнения" href="#Метаметоды-сравнения">Метаметоды сравнения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `__eq` - бинарный метаметод для сравнения на равно;
- `__lt` - бинарный метаметод для сравнения на меньше, чем;
- `__lе` - бинарный метаметод для сравнения на меньше или равно, чем.

Для трех оставшихся операций сравнения нет отдельных метаметодов: Lua переводит:
- `а ~= b` в `not(а == b)`;
- `а > b` в `b < а`;
- `а >= b` в `b <= а`.

Для типов с полным порядком моно не определять метаметод `__lе`. При его отсутствии Lua использует поле `__lt`.

Если у двух объектов разные базовые типы или метаметоды, то операция сравнения на равенство вернет `false`, даже не вызывая метаметоды.

#### <a id="Библиотечные-метаметоды" href="#Библиотечные-метаметоды">Библиотечные метаметоды</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `__tostring` - унарный метаметод для перевода в строку;
- `__metatable` - при задании значения используется для защиты метатаблиц от изменения, то `getmetatable` вернет значение этого поля, в то время как `setmetatable` вызовет ошибку.

#### <a id="Метаметоды-доступа-к-таблице" href="#Метаметоды-доступа-к-таблице">Метаметоды доступа к таблице</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- `__index` - метаметод для получения поля, которое отсутствует в таблице, вызывается этот метаметод с аргументами таблицей и отсутствующим ключом, должен возвращать значение или `nil`.  
Может быть таблицей, тогда поиск будет проходить в этой таблице;
- `__newindex` - метаметод для установки поля, которое отсутствует в таблице, вызывается этот метаметод с аргументами таблицей и отсутствующим ключом.  
Может быть таблицей, тогда установка будет проходить в этой таблице.

`rawget(<таблица>, "<ключ>")` - возвращает значение ключа непосредственно у таблицы `<таблица>`, без обращения к метаметодам.  
`rawset(<таблица>, "<ключ>", <значение>)` - устанавливает значение ключа непосредственно у таблицы `<таблица>`, без обращения к метаметодам.

#### <a id="Слабые-таблицы" href="#Слабые-таблицы">Слабые таблицы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Слабая таблица** (*weak table*) - это такая таблица, все ссылки которой являются **слабыми** - это такая ссылка на объект, которая не учитывается сборщиком мусора. Задаются полем полем `__mode` ее метатаблицы. Бывают:
- `k` - таблицы со слабыми ключами;
- `v` - таблицы со слабыми значениями;
- `kv` - полностью слабые таблицы, где и ключи, и значения являются слабыми.

Из слабой таблицы могут быть утилизированы лишь объекты. Сборщик мусора очищает значения в слабой таблице перед восстановлением, в то время как ключи очищаются после восстановления.

#### <a id="Финализаторы" href="#Финализаторы">Финализаторы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Финализатор** (*finalizer*) - это функция, связанная с объектом, которая вызывается перед тем, как объект будет удален сборщиком мусора. Задаются полем полем `__gc` ее метатаблицы:  
`{__gc = function (o) ... end}` - где `o` - это объект у которого вызвался финализатор.

Объект для финализации помечается только тогда, когда для него задается метатаблица с ненулевым метаметодом `__gc` через `setmetatable`.

Когда сборщик мусора утилизирует несколько объектов в одном и том же цикле, он вызывает их финализаторы в порядке, обратном тому, в котором объекты были помечены для финализации.

## <a id="Окружение" href="#Окружение">Окружение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Lua хранит все свои глобальные переменные в обычной таблице, называемой **глобальным окружением** (global environment) в глобальной переменной `_G` (`_G._G` равно `_G`). Ей можно назначить метатаблицу.

`_ENV` - переменная ссылающая на глобальную таблицу с переменными, в которую присваиваются все переменные со **свободным именем** - это имя, которое не привязано к явному объявлению, то есть не встречается внутри области видимости локальной переменной (или переменной цикла `for`, или параметра) с этим именем.  
Позволяет получить доступ к глобальным переменным при переопределении имен переменных.  
Поскольку `_ENV` является обычной переменной, она подчиняется обычным правилам видимости. В частности, функции, определенные внутри куска, обращаются к `_ENV` так же, как и к любой другой внешней переменной. Если определить новую локальную переменную с именем `_ENV`, то ссылки на свободные имена будут привязаны к ней.

Присваивание `_ENV=nil` сведет на нет любой прямой доступ к глобальным переменным в оставшейся части кода.

## <a id="Объектно-ориентированное-программирование" href="#Объектно-ориентированное-программирование">Объектно-ориентированное программирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Операция двоеточия `<таблица>:<метод>` позволяет связать первый аргумент функции с переменной `self`. Двоеточие добавляет дополнительный скрытый параметр в определение метода и добавляет дополнительный аргумент в вызов метода:
```lua
local <таблица> = {[...]}
function <таблица>:<метод>([<параметр1>[, ...]])
    self -- равен <таблица>
end
<таблица>:<метод>([<аргумент1>[, ...]])
<таблица>.<метод>(<таблица>, [<аргумент1>[, ...]]) -- аналогично
```

```lua
local Account = {balance: 4}
function Account:withdraw(v)
    self.balance = self.balance - v
end
Account:withdraw(1)
Account.withdraw(Account, 1) -- аналогично
```

### <a id="Классы" href="#Классы">Классы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Класс работает как шаблон для создания объектов. У каждого объекта может быть прототип, который является обычным объектом, в котором первый объект ищет неизвестные ему действия. Для представления классов в таких языках мы просто создаем объект, который будет использован только в качестве прототипа для других объектов (его экземпляров). И классы, и прототипы работают в качестве мест хранения поведения, общего для различных объектов.

Для объявления класса используются метатаблицы:
```lua
local <Класс> = {[<ключ1> = <значение1>[, ...]]} -- объявление метатаблицы и значений по умолчанию
function <Класс>:new(o)
    o = o or {} -- создает таблицу, если пользователь ее не предоставил
    self.__index = self -- предоставляет поиск значений по умолчанию и методов в <Класс> для реализации наследования
    setmetatable(o, self) -- установка метатаблицы <Класс>
    return o
end
local <экземпляр> = <Класс>:new{[<ключ1> = <значение1>[, ...]]} -- создание экземпляра "класса" <Класс> с переопределением таблицы по умолчанию
```

```lua
local Account = {balance: 4}
function Account:new(o)
    o = o or {}
    self.__index = self
    setmetatable(o, self)
    return o
end
function Account:deposit(v)
    self.balance = self.balance + v
end
local anAccount = Account:new{balance: 100}
anAccount:deposit(200)
```

#### <a id="Наследование" href="#Наследование">Наследование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Поскольку классы являются объектами, они также могут получать методы от других классов.
```lua
local <ПодКласс> = <Класс>:new() -- наследование всех операций по умолчанию от класса <Класс>
local <экземпляр> = <ПодКласс>:new{[<ключ1> = <значение1>[, ...]]} -- создание экземпляра "класса" <ПодКласс> с переопределением таблицы по умолчанию
```

`<ПодКласс>` наследует `new` от `<Класс>`, как и любые другие методы. Однако при выполнении `new` его параметр `self` уже будет ссылаться на `<ПодКласс>`. Поэтому метатаблицей `<экземпляр>` будет `<ПодКласс>`, чье значение в поле `__index` тоже равно `<ПодКласс>`. Поэтому `<экземпляр>` наследует от `<ПодКласс>`, который, в свою очередь, наследует от `<Класс>`.

Можно переопределить любой метод, унаследованный от его суперкласса для этого нужно просто записать новый метод:  
`function <ПодКласс>:<метод>([<параметр1>[, ...]]) ... end`

#### <a id="Множественное-наследование" href="#Множественное-наследование">Множественное наследование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Реализуется с помощью переопределения поля `__index` в метатаблице для поиска в классах от которых происходило наследование.

#### <a id="Конфиденциальность" href="#Конфиденциальность">Конфиденциальность</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основная идея этой альтернативной схемы - представлять каждый объект при помощи двух таблиц: одна - для его состояния, а другая - для его действий (его интерфейс). Обращение к самому объекту происходит через вторую таблицу, то есть посредством действий, образующих его интерфейс. Во избежание несанкционированного доступа, таблица, представляющая состояние объекта, не хранится в поле другой таблицы; вместо этого она хранится лишь в замыкании методов.

##### <a id="Подход-с-единственным-методом" href="#Подход-с-единственным-методом">Подход с единственным методом</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Частным случаем для объектноориентированного программирования является случай, когда у объекта есть лишь один метод. Этот метод выполняет все действия и хранит свои данные в замыкании:
```lua
function newObject(value)
    return function (action, v)
        if action == "get" then return value
        elseif action == "set" then value = v
        else error("invalid action")
        end
    end
end
```

## <a id="Библиотека-ввода-вывода" href="#Библиотека-ввода-вывода">Библиотека ввода-вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Простая-модель-ввода-вывода" href="#Простая-модель-ввода-вывода">Простая модель ввода-вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Работает с одним файлом ввода и одним файлом вывода.

`io.input("<имя_файла>")` - открывает заданный файл в режиме чтения и устанавливает его как текущий входной файл.  
`io.input()` - возвращает дескриптор текущего входного файла.  
`io.output("<имя_файла>")` - открывает заданный файл в режиме записи и устанавливает его как текущий выходной файл.  
`io.output()` - возвращает дескриптор текущего выходного файла.  

`io.stdin` - стандартный ввод.  
`io.stdout` - стандартный вывод.  
`io.stderr` - стандартный вывод для ошибок.  
`tmpfile` - дескриптор временного файла, открытого в режиме чтения-записи, будет автоматически удален по завершении программы.

`print(<аргумент1>[, ...])` - записывает произвольное число строковых аргументов в стандартный вывод и добавляет между каждым аргументом табуляцию и после всего вывода перевод строки и автоматически применяет `tostring` к своим аргументам.

`io.write(<аргумент1>[, ...])` - записывает произвольное число строковых аргументов в текущий выходной файл.

`io.read(<формат1>[, ...])` - читает строки из текущего входного файла и возвращает их в переменные, если значений больше нет, то возвращает `nil`. При этом формат задается:
- `"*а"` - читает весь файл начиная с текущей позиции;
- `"*l"` - читает следующую строку (без символа перевода строки);
- `"*L"` - читает следующую строку (с символом перевода строки, если он есть);
- `"*n"` - читает число и возвращает его, при этом пропуская все пробелы перед числом;
- `<число>` - ограничивает количество читаемых символов.

`io.read(0)` - работает как проверка конца файла: она возвращает либо пустую строку, если еще есть, что читать, либо `nil`, если читать нечего.

`io.flush()` - применяет к файлу все отложенные операции записи, для сброса текущего выходного файла на диск.

`io.lines()` - возвращает итератор для перебора всех строк файла.  
`io.lines("<имя_файла>")` - возвращает итератор для перебора всех строк файла `<имя_файла>`, при этом откроет файл в режиме для чтения и закроет файл после достижения конца файла.  
`io.lines(<file>)` - возвращает итератор для перебора всех строк дескриптора файла, при этом не будет закрыт файл по достижению его конца.

### <a id="Полная-модель-ввода-вывода" href="#Полная-модель-ввода-вывода">Полная модель ввода-вывода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основана на понятии **дескриптора файла** (*file handle*), который аналогичен потокам (`FILE*` в С) он представляет собой открытый файл с текущей позицией.

`<file>, <error> = io.open("<имя_файла>", "{w|r|a}[b]")` - возвращает новый дескриптор файла и ошибку в случае ее наличия. Где:
- `r` - для чтения;
- `w` - для записи (которая при этом стирает любое предыдущее содержимое файла);
- `a` - для добавления к файлу;
- `b` - для открытия двоичных файлов.

`<file>:close()` - закрывает текущий дескриптор.  
`<file>:write(<аргумент1>[, ...])` - аналогично `io.write(<аргумент1>[, ...])` только для файла.  
`<file>:read(<формат1>[, ...])` - аналогично `io.read(<формат1>[, ...])` только для файла.  
`<file>:flush()` - аналогично `io.flush()` только для файла.  
`<file>:seek("{set|cur|end}"[, <смещение>])` - возвращает новую текущую позицию, измеренную в байтах от начала этого файла и устанавливает текущую позицию 0 [заданую `<смещение>`] внутри файла. Где:
- `set` - смещение трактуется от начала файла;
- `cur` - смещение трактуется от текущей позиции внутри файла;
- `end` - смещение трактуется с конца файла.

Для быстродействия можно считывать файл частями:  
`local lines, rest = f:read(<размер_буфера>, "*l")` - при этом переменная `rest` получит остаток любой строки, разбитой при чтении куска.

## <a id="Библиотека-операционной-системы" href="#Библиотека-операционной-системы">Библиотека операционной системы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`os.time([{year = <полный_год>, month = <01-12>, day = <01-31>[, hour = <00-23>][, min = <00-59>][, sec = <00-59>][, isdst = true}])` - возвращает текущую дату и время [указаную в таблице] как число прошедших с определенного начала отсчета.

`os.date("<формат>", <число>)` - преобразует число, обозначающее дату и время, в высокоуровневое представление и возвращает его:
- `*t` - в виде дата-таблицы + еще поля `wday` - день недели (1 - воскресенье) и `yday` - день года (1 - 1 января);
- `<строка_со_спецсимволами>` - возвращает строку на основе форматирующей строки со спецсимволами:
    - `%a` - сокращенное название дня недели (например, Wed);
    - `%A` - полное название дня недели (например, Wednesday);
    - `%b` - сокращенное название месяца (например, Sep);
    - `%B` - полное название месяца (например, September);
    - `%c` - дата и время (например, 09/16/98 23:48:10);
    - `%d` - день месяца (16) [01-31];
    - `%H` - час, используя 24-часовое время 23) [00-23];
    - `%I` - час, используя 12-часовое время (11) [01-12];
    - `%j` - день года (259) [001-366];
    - `%M` - минута (48) [00-59];
    - `%m` - месяц (09) [01-12];
    - `%p` - либо "am", либо "pm";
    - `%S` - секунда (10) [00-60];
    - `%w` - день недели (3) [0-6 = Sunday-Saturday];
    - `%x` - дата (например, 09/16/98);
    - `%X` - время (например, 23:48:10);
    - `%y` - сокращенный год из двух цифр (98) [00-99];
    - `%Y` - полный год (1998);
    - `%%` - символ '%'.

`os.date()` - возвращает строку, отформатированную как `%c` для текущего дата-времени.

`os.clock()` - возвращает число затраченных программой секунд процессорного времени.

`os.exit()` - завершает выполнение программы.

`os.getenv("<переменная_окружения>")` - возвращает значение переменной окружения, либо `nil` - если ее нет.

`os.execute("<команда>")` - выполняет команду операционной системы и возвращает значения:
- первое равно `true` если окончание программы произошло без ошибок, иначе `false`;
- второе равно `"exit"`, если программа завершилась нормально, и `"signal"`, если она была прервана сигналом;
- третье - статус возврата, если программа завершилась нормально, или номер сигнала, если она завершилась по сигналу.

## <a id="Запуск" href="#Запуск">Запуск</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`lua <имя_файла>.lua` - выполняет скриптовый файл `<имя_файла>.lua`.  
`luac -o <имя_скомпилируемого_файла>.lc <имя_файла>.lua` - компилирует файл `<имя_файла>.lua` в `<имя_скомпилируемого_файла>.lc`.  
`lua <имя_скомпилируемого_файла>.lc` - выполняет скомпилированный файл.

### <a id="Командная-строка" href="#Командная-строка">Командная строка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В переменной `arg` содержатся аргументы командной строки.

## <a id="Сборщик-мусора" href="#Сборщик-мусора">Сборщик мусора</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`collectgarbage()` - вызывает принудительный сборщик мусора.