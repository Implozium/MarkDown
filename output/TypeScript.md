[Содержание](#Содержание)
==========

- [Основы](#Основы)
    - [@types](#types)
    - [Структура](#Структура)
    - [Настройки компиляции](#Настройки-компиляции)
        - [Файл конфигурации tsconfig.json](#Файл-конфигурации-tsconfigjson)
- [Типы данных](#Типы-данных)
    - [Вариативности типов](#Вариативности-типов)
    - [Псевдонимы типов](#Псевдонимы-типов)
        - [Тип строкового литерала](#Тип-строкового-литерала)
            - [Шаблонные строковые литералы](#Шаблонные-строковые-литералы)
                - [Встроенные шаблонные типы](#Встроенные-шаблонные-типы)
        - [Объединения](#Объединения)
        - [Пересечение](#Пересечение)
    - [Type assertion](#Type-assertion)
    - [Const assertion (Неизменяемые структуры)](#Const-assertion-Неизменяемые-структуры)
- [Функции](#Функции)
    - [Определение функции](#Определение-функции)
        - [Оператор утверждения `!`](#Оператор-утверждения-)
        - [Параметр `this`](#Параметр-this)
        - [Перегрузка функций](#Перегрузка-функций)
        - [Тип функции](#Тип-функции)
- [Классы](#Классы)
    - [Абстрактные классы](#Абстрактные-классы)
- [Интерфейсы](#Интерфейсы)
    - [Интерфейсы классов](#Интерфейсы-классов)
    - [Интерфейсы функций](#Интерфейсы-функций)
    - [Интерфейсы объектов](#Интерфейсы-объектов)
    - [Гибридные интерфейсы](#Гибридные-интерфейсы)
    - [Оператор `instanceof`](#Оператор-instanceof)
    - [Оператор `typeof`](#Оператор-typeof)
    - [Структурная типизация](#Структурная-типизация)
- [Обобщения](#Обобщения)
    - [Ограничения обобщений](#Ограничения-обобщений)
        - [Условное ограничение](#Условное-ограничение)
    - [Вывод типа](#Вывод-типа)
    - [Ключевое слово `new`](#Ключевое-слово-new)
    - [Защитники типа](#Защитники-типа)
        - [Пользовательский защитник `is`](#Пользовательский-защитник-is)
        - [Утверждение типа `assert`](#Утверждение-типа-assert)
        - [Защитники типа `typeof`](#Защитники-типа-typeof)
        - [Защитники типа `instanceof`](#Защитники-типа-instanceof)
        - [Тип-сумма](#Тип-сумма)
        - [Бренд-типы](#Бренд-типы)
    - [`keyof`](#keyof)
    - [Отображенные типы](#Отображенные-типы)
    - [Исключающие типы](#Исключающие-типы)
    - [Рекурсивные типы](#Рекурсивные-типы)
    - [Утилитарные типы](#Утилитарные-типы)
    - [Обобщение функций с ответом `any`](#Обобщение-функций-с-ответом-any)
- [Типы и Интерфейсы](#Типы-и-Интерфейсы)
    - [Сходства](#Сходства)
    - [Отличия](#Отличия)
    - [Выбор](#Выбор)
- [Пространства имен](#Пространства-имен)
    - [Псевдонимы](#Псевдонимы)
- [Модули](#Модули)
- [Заголовочные файлы](#Заголовочные-файлы)
- [Декораторы](#Декораторы)
    - [Декораторы классов](#Декораторы-классов)
    - [Декоратор метода](#Декоратор-метода)
    - [Декораторы параметров методов](#Декораторы-параметров-методов)
    - [Декораторы свойств](#Декораторы-свойств)
    - [Декоратор метода доступа](#Декоратор-метода-доступа)
    - [Фабрики декораторов](#Фабрики-декораторов)
- [TSDoc](#TSDoc)
    - [Интерфейсы и классы](#Интерфейсы-и-классы)
- [Рекомендации](#Рекомендации)
    - [Смещение нулевых значения на периферию типов](#Смещение-нулевых-значения-на-периферию-типов)

<a id="Основы" href="#Основы">Основы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

TypeScript представляет язык программирования на основе JavaScript. TypeScript - это строго типизированный и компилируемый язык. TypeScript реализует многие концепции, которые свойственны объектно-ориентированным языкам, как, например, наследование, полиморфизм, инкапсуляция и модификаторы доступа и так далее. TypeScript является надмножеством JavaScript, а это значит, что любая программа на JS является программой на TypeScript. В TS можно использовать все те конструкции, которые применяются в JS - те же операторы, условные, циклические конструкции. Более того код на TS компилируется в javascript.

`npm install -g typescript` - глобальная установка через NPM.

`npm install --save-dev typescript` - локальная установка через NPM. Предпочтительнее глобальной. Запуск всех команд будет вместо: `tsc` - `npx tsc`.

`tsc -v` - вывод версии.

Все файлы для TypeScript именуются с суффиксом `ts`.

`tsc <файл>.ts` - производит компиляцию файла `<файл>.ts` в `<файл>.js`.

## <a id="types" href="#types">@types</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Содержат только типы для библиотек, но не их реализации. Устанавливаются:  
`npm install <библитека>`  
`npm install --save-dev @types/<библитека>`

Необходимо стараться придерживаться одинаковых версий библиотек и их типов.

## <a id="Структура" href="#Структура">Структура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Проект по умолчанию имеет следующие файлы:
- `app.ts` - файл с кодом на TypeScript;
- `package.json` - файл с определением пакетов и прочей конфигурации для Node.js;
- `tsconfig.json` - файл конфигурации TypeScript.

## <a id="Настройки-компиляции" href="#Настройки-компиляции">Настройки компиляции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Осуществляются в качестве ключей для `tsc`:
- `-w` - автоматически перекомпилирует файлы typescript, если в них были внесены какие-либо изменения;
- `-t <версия>` - позволяет указать версию стандарта, может принимать следующие значения: "ES3" (по умолчанию), "ES5", "ES6", "ES2015", "ES2016", "ES2017" или "ESNext";
- `--removeComments` - удаляет комментарии при компиляции;
- `--outDir <каталог>` - указывает папку для хранения скомпилированных файлов js;
- `--outFile <файл>[ ...]` - позволяет объединить файлы в один файл;
- `-m` - позволяет указать тип модуля, который будет использоваться для компиляции. Эта опция может принимать следующие значения: "none", "commonjs", "amd", "system" - универсальный, "umd", "es6", "es2015" и "esnext".

### <a id="Файл-конфигурации-tsconfigjson" href="#Файл-конфигурации-tsconfigjson">Файл конфигурации tsconfig.json</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью файла `tsconfig.json` можно настроить проект TypeScript. В частности, этот файл выполняет следующие задачи:
- устанавливает корневой каталог проекта TypeScript;
- выполняет настройку параметров компиляции;
- устанавливает файлы проекта.

Строение файла:
```json
{
    "compileOnSave": true,
    "compilerOptions": {
        "target": "es5",
        "removeComments": true,
        "outDir": "js",
        "sourceMap": true, // включает карты кода
        "outFile": "main.js",
        "module": "system",
        "noImplicitAny": true, // запрещает неявное использование типа any
        "strictNullChecks": "on", // типы null и undefined для переменных необходимо указывать явно
        "strict": true, // включает все проверки
    },
    ["files": [
        "<файл>"[, ...]
    ],]
    ["exclude": [
        "<каталог>"[, ...]
    ],]
}
```

Файл `tsconfig.json` используется при компиляции в том случае, если компилятору не передаются названия файлов, которые надо скомпилировать. В этом случае компилятор TypeScript просматривает текущий каталог, ищет в нем файл `tsconfig.json` и затем при компиляции использует те параметры, которые определены в этом файле.

<a id="Типы-данных" href="#Типы-данных">Типы данных</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===========

TypeScript является строго типизированным языком, и каждая переменная и константа в нем имеет определенный тип. При этом в отличие от javascript нельзя динамически изменить ранее указанный тип переменной.

Для установки типа применяется знак двоеточия `:`:  
`{let | const} <переменная>: <тип>[ = <значение>];`

При использовании модификатора `const` переменная получит **суженный тип** так как значение в дальнейшем нельзя переназначить.
> `let a = 'x'; // тип string`  
> `const a = 'x'; // тип 'x'`

В TypeScript имеются следующие базовые типы:
- `boolean` - логическое значение `true` или `false`;
- `number` - представляет числа, причем все числа в TypeScript, как и в JavaScript, являются числами с плавающей точкой. TS поддерживает двоичную (`0b`), восьмеричную (`0o`), десятичную и шестнадцатиричную (`0x`) записи чисел;
- `string` - строки.

    Тип `string` имеет проблемы, присущие `any`. Он допускает неверные значения и скрывает связи между типами. Поэтому если есть возможность, то лучше использовать объединения вместо типа `string`:
    > `'home' | 'about' | 'contact'`

- `array` - массивы - определяются с помощью выражения [] и также являются строго типизированными:
    - `let <переменная>: <тип_элементов_массива>[];`;
    - `let <переменная>: Array<<тип_элементов_массива>>;`;
    > `let names: Array<string> = ["Tom", "Bob", "Alice"];`

    Есть тип `ReadonlyArray<T>`, который, по сути, является типом `Array<T>`, из которого удалены все изменяющие его методы, так что такие массивы не будут изменяться после создания.

    Есть тип `ArrayLike<T>`, который, по сути, является псевдомасивом, у которого есть только индексы и свойство `length` для определения размера (длины) псевдомассива.

- `tuple` - кортежи - как и массивы, представляют набор элементов, для которых уже заранее известен тип:
    - `let <переменная>: [<тип_элемента>[, ...]];`:
        > `let userInfo: [string, number] = ["Tom", 28];`
    - `type <тип>: [[<имя_элемента>[?]: ]<тип_элемента>[?][, ...]];` - объявляет тип, где `<имя_элемента>` представляет собой просто метку, для удобного использования, `?` - указывает на его опциональность:
        > `type Params: [title: string, artist: string]`

- `enum` - перечисления - предназначен для описания набора числовых данных с помощью строковых констант (если элемент не имеет инициализатора, ему присваивается значение 0):
    - `enum <ИмяПеречисления> {<ИмяЭлемента>[ = {<значение> | <начальное_значение>}][, ...]};`;
    > `enum Season { Winter = 5, Spring, Summer, Autumn }; // 5, 6, 7, 8`  
    > `let a = Season.Winter`

    Типу `enum` с числовым значением можно присвоить любое число, поэтому он небезопасен (такая конструкция разработана, чтобы допускать структуры битовых флагов).  
    Тип `enum` со строковым значением безопасен. Он обеспечивает более прозрачные значения во время выполнения. Однако он не является структурно типизированным в отличие от остальных типов в TypeScript.

    Вместо `enum` лучше использовать объединение типов литералов (тип строкового литерала): `type <тип> = '<значение1>' | '<значение2>' [| ...]`, такой подход позволит не импортировать тип `enum`:
    > `type Flavor = 'vanilla' | 'chocolate' | 'strawberry';`

- `any` - произвольный тип - описывает данные, тип которых может быть неизвестен на момент написания приложения. Обладает указаными свойствами:
    - Типу `any` может быть присвоен любой тип;
    - Тип `any` может быть присвоен любому типу, кроме типа `never`.

- `null`, `undefined` - соответствуют значениям `null` и `undefined` в javascript, фактически можно присваивать значения `undefined` и `null` переменным других типов. В этом плане `null` и `undefined` выступают как подтипы других типов и полезны преимущественно в каких-то операциях, где неизвестен результат - то ли это будет число или строка, то ли это будет `null`;
- `void` - отсутствие конкретного значения, используется в основном в качестве возвращаемого типа функций. Является собирательным типом и может содержать тип `undefined` (и тип `null` при выключенном флаге строгости);
- `never` - также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку;
- `unknown` - универсальное множество - любое значение, перед использованием необходимо привести к определенному типу через `as` или использовать защитников типа. Любой тип является подтипом `unknown`, поэтому утверждения с ним всегда срабатывают;
- `{}` содержит все значения, кроме `null` и `undefined`;
- `object` содержит все непримитивные типы, это касается объектов и массивов;
- `symbol` соответствует символам.

Большинство из этих типов соотносятся с примитивными типами из JavaScript.

Для определения типа объекта используется структура, при этом необязательные параметры должны быть помечены вопросительным знаком `?`:  
`let <переменная>: {<ключ>: <тип_значения>[, ...]};`
> `let obj: {a: string, b?: number};`

Если тип не указан то компилятор выдаст ей тип присвоеного значения.  
Если же переменная определяется без значения, и только впоследствии при работе программы ей присваивается значение, тогда считается, что она имеет тип `any`.

При назначении объектного литерала к переменной с объявленным типом: `let <переменная>: <тип> = <значение>;` или при передачи его в качестве параметра в функцию, TypeScript дополнительно убеждается, что она обладает исключительно свойствами этого типа и **никакими другими**. Но при назначении существующего объекта из переменной, будет использоваться **структурная типизация**: `let <переменная>: <тип> = <переменная>;`.

Для слабых типов, это те у которых нет обязательных свойств, TypeScript добавляет другую проверку, которая следит, чтобы тип значения и объявленный тип имели хотя бы одно общее свойство, и находит опечатки.

Объявление типов для всех переменных подрывает продуктивность и считается плохим стилем так как TypeScript может сам вывести типы, что позволяет легче рефакторить код в дальнейшем.

Обычно типы параметров могут быть выведены, если функция использована в качестве обратного вызова библиотеки с декларациями типов. Но для функций, если они не являются функциями обратного вызова, лучше указывать возврвщаемый тип чтобы избежать ошибок реализации в использовании функции.

## <a id="Вариативности-типов" href="#Вариативности-типов">Вариативности типов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Совместимость присваивания** (assignment compatibility) - это возможность присвоить значение более частного типа совместимой переменной более общего типа.

**Вариантность** - это сохранение совместимости присваивания исходных типов у производных типов.

**Ковариантность** - это сохранение иерархии наследования исходных типов в производных типах - контейнеры, обобщенные типы, делегаты и т. п. в том же порядке.

**Контравариантность** - это обращение иерархии исходных типов на противоположную в производных типах - контейнеры, обобщенные типы, делегаты и т. п..

**Инвариантность** - это отсутствие наследования между производными типами.

Для функций:
- операции передачи аргументов в функции по умолчанию являются **контрвариантны**, со стороны вызова функции;
- операции присвоения результата вызова функции по умолчанию является **ковариантны**, со стороны вызова функции.

```ts
abstract class Animal {}
abstract class Pet extends Animal {}
class Cat extends Pet {}
class Dog extends Pet {}
class Fox extends Animal {}
class AnimalCage { content?: Animal }
class PetCage extends AnimalCage { content?: Pet }
class CatCage extends PetCage { content?: Cat }
class DogCage extends PetCage { content?: Dog }
class FoxCage extends AnimalCage { content?: Fox }
// ковариантность
function touchPet(cage: PetCage): void {
    console.log(`touch ${cage.content}`);
}
touchPet(new AnimalCage()); // forbid
touchPet(new PetCage()); // allow
touchPet(new CatCage()); // allow
touchPet(new DogCage()); // allow
touchPet(new FoxCage()); // forbid
// контрвариантность
function pushPet(cage: PetCage): void {
    const Pet = Math.random() > .5 ? Cat : Dog;
    cage.content = new Pet();
}
pushPet(new AnimalCage()); // allow
pushPet(new PetCage()); // allow
pushPet(new CatCage()); // forbid
pushPet(new DogCage()); // forbid
pushPet(new FoxCage()); // forbid
```

## <a id="Псевдонимы-типов" href="#Псевдонимы-типов">Псевдонимы типов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

TypeScript позволяет определять псевдонимы типов с помощью ключевого слова `type`:  
`type <имяПсевдонима> = <тип1>[ | <тип2>[ | ...]];`

Теперь можно применять псевдоним аналогично типу данных.

> `type stringOrNumberType = number | string;`  
> `let sum: stringOrNumberType = 36.6;`

От псевдонима типа невозможно расшириться или реализоваться.

### <a id="Тип-строкового-литерала" href="#Тип-строкового-литерала">Тип строкового литерала</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Тип строкового литерала позволяет указывать точное значение строки, которое она должна иметь: `type <Type> = '<строка1>' | '<строка1>'[ | ...]`

> `type Page = 'home' | 'about' | 'contact';`

#### <a id="Шаблонные-строковые-литералы" href="#Шаблонные-строковые-литералы">Шаблонные строковые литералы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для того чтобы модифицировать строковые литералы: ```type <MappedType> = `<perfix>${keyof }<suffix>`;```

```typescript
type Page = 'home' | 'about' | 'contact';
type PageWithId = `${Page}_id`;
// type PageWithId = 'home_id' | 'about_id' | 'contact_id';
```

Их можно использовать напрямую в виде типа переменных.

Можно использовать стандартные типы внутри:
> `type NumberString = ${number};` - тип, который представляет из себя число в виде строки

В случае шаблонных типов объединения в заменителях распределяются по шаблону:
```
`[${A|B|C}]` => `[${A}]` | `[${B}]` | `[${C}]`
```

##### <a id="Встроенные-шаблонные-типы" href="#Встроенные-шаблонные-типы">Встроенные шаблонные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`Uppercase<<строковый_литерал>>` - конвертирует каждый символ в символ верхнего регистра.

`Lowercase<<строковый_литерал>>` - конвертирует каждый символ в символ нижнего регистра.

`Capitalize<<строковый_литерал>>` - конвертирует первый символ в символ верхнего регистра.

`Uncapitalize<<строковый_литерал>>` - конвертирует первый символ в символ нижнего регистра.

### <a id="Объединения" href="#Объединения">Объединения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объединения (*union*) не являются собственно типом данных, но они позволяют определить переменную, которая может хранить значение двух или более типов, но при этом значение должно быть одним из этих типов:  
`type <тип> = <тип1> | <тип2>[ | ...];`  
`{let | const} <переменная>: <тип1> | <тип2>[ | ...][ = <значение>];`

> `let id: number | string;`  
> `type ExUser = { name: string } | { description: string };`

### <a id="Пересечение" href="#Пересечение">Пересечение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Пересечение (*intersection*), согласно теории множеств множество, содержит элементы, принадлежащие как множеству `<тип1>`, так и множеству `<тип2>`, являются новым типом данных, который содержит в себе новый тип из значение двух или более типов:  
`type <тип> = <тип1> & <тип2>[ & ...];`  
`{let | const} <переменная>: <тип1> & <тип2>[ & ...][ = <значение>];`

> `type ExUser = { name: string } & { description: string }; // = { name: string; description: string }`

Используется для интерфейсов, а не примитивных типов, так как пересечение примитивных типов дает тип `never`.

Обладает:
- **идентичностью**: `A & A` эквивалентно `A`;
- **коммутативностью**: `A & B` эквивалентно `B & A` за исключением конструкторов;
- **ассоциативностью**: `(A & B & C` эквивалентно `A & (B & C)`;
- **коллапсированием супертипа**: `A & B` эквивалентно `A`, если `A` является супертипом `B`.

Пересечение функциональных типов дает перегрузку функций.

Если имена свойств одинаковые, то будет выполняться пересечение их значений.

## <a id="Type-assertion" href="#Type-assertion">Type assertion</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Type assertion представляет модель утверждения, а не преобразования, значения переменной к определенному типу. Утверждение типов позволяет преобразовывать только к подтипам типа - сужать его.

`<<тип>><переменная>`  
`<переменная> as <тип>`

> `let someAnyValue: any = "hello world!";`  
> `let strLength: number = (<string>someAnyValue).length;`  
> `const button = e.currentTarget as HTMLButtonElement;`

Для утвержедения типа, который является не подтипом одного типа используется конструкция:  
`<переменная> as unknown as <тип>;`
> `const el = document.body as unknown as Person;`

Объявление типа гарантирует дополнительную проверку безопасности кода и является предпочтительным чем утверждение.

## <a id="Const-assertion-Неизменяемые-структуры" href="#Const-assertion-Неизменяемые-структуры">Const assertion (Неизменяемые структуры)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Const assertion представляет модель преобразования объектов и масивов к константным неизменяемым значениям. Также происходит сужение типов всех свойств, если это объект.

`<переменная> as const`

> `[ 1, 3, 5 ] as const;`  
> `{ value: 4 } as const;`

<a id="Функции" href="#Функции">Функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

## <a id="Определение-функции" href="#Определение-функции">Определение функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`function <имя>(<аргумент>: [readonly] <тип>[ = <значение>][, ...]): <тип_результата> {...}`

Если функция ничего не возвращает, то указывается тип результата `void`.

`[readonly]` - обозначает что агрумент используется только для чтения.

Чтобы иметь возможность передавать различное число значений в функцию, в TS некоторые параметры можно объявить как необязательные. Необязательные параметры должны быть помечены вопросительным знаком `?`. Причем необязательные параметры должны идти после обязательных.

`<аргумент>?: <тип>`

Если же необходимо, чтобы функция принимала набор однотипных параметров, то используется знак многоточия, после которого идет массив. Причем этот параметр идет после обязательных.

`...<аргумент>: <тип>[]`

### <a id="Оператор-утверждения-" href="#Оператор-утверждения-">Оператор утверждения `!`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`!` - после выражения утверждает компилятору, что значение не может быть `null` или `undefined`.

> `part.match(new RegExp(importRegExp))!.slice(1)`  
> `const el = document.getElementById('foo')!;`

`let <переменная>!: <тип>` - указывает что значение не может быть `null` или `undefined`, и присвоится до использования.

### <a id="Параметр-this" href="#Параметр-this">Параметр `this`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Так как `this` берется из функционального выражения внутри объектного литерала, то чтобы исправить это, можно явно указать `this` в качестве параметра. Параметр `this` - это "фальшивый" параметр, который идет первым в списке параметров функции:  
`function <имя>(this: <тип>, <аргумент>: <тип>[ = <значение>][, ...]): <тип_результата> {...}`

> `function (this: Deck) {...}`

### <a id="Перегрузка-функций" href="#Перегрузка-функций">Перегрузка функций</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

TypeScript поддерживает возможность перегрузки функций, то есть можно определить несколько версий функции, которые будут иметь одно и то же имя, но разные типы параметров или разное количество параметров или разные возвращаемые типы результатов.

Для перегрузки вначале определяются все версии функции, которые не будут иметь никакой логики - это будут **сигнатуры перегрузки**, которые только можно будет использовать. А потом определяется версия функции с общей сигнатурой - **сигнатура реализации**, которая подходит под все ранее определенные варианты, но она не будет использоваться вне определения. И в этой общей версии уже определяют конкретную логику функции.

То есть вначале аргументы идут с определенными типами, а потом в общей функции с общем типом (или `any`).

```typescript
function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: string | number, y: string | number): string | number {
    return x + y;
}
```

Если у функции возвращается один и тот же ответ, то можно сделать перегрузку ее параметров, с помощью тип-суммы:
```typescript
type Name =
    | [first: string, last: string]
    | [first: string, middle: string, last: string];
function formatName(...name: Name): string {
    if (name.length === 3) {
        return `User has name ${name[0]}, ${name[1]}, and ${name[2]}`;
    }
    return `User has name ${name[0]} and ${name[1]}`;
}
```

Если необходимо сделать так чтобы функция принимала разнообразыне параметы и количество, то можно воспользоваться примером:
```typescript
type UndefinedKeys<Obj> = {
    [K in keyof Obj]: Obj[K] extends undefined ? K : never;
}[keyof Obj];
class EventEmitter<E> {
    emit<K extends UndefinedKeys<E>>(name: K): void;
    emit<K extends keyof E>(name: K, data: E[K]): void;
    emit<K extends keyof E>(name: K, data?: E[K]): void {
        return;
    }
}
```

### <a id="Тип-функции" href="#Тип-функции">Тип функции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Каждая функция имеет тип, как и обычные переменные. Тип функции фактически представляет комбинацию типов параметров и типа возвращаемого значения. Имеет вид:  
`(<аргумент>: <тип>[, ...]) => <тип_результата>`

> `let operationFunc: (x: number, y: number) => number;`

Тип функции используется также как и простые типы.

Если у множества функций одинаковая сигнатура, то лучше вынести общий тип функции и использовать его в качестве единичного типа функций и тогда не нужно будет описывать подробно функции. Или воспользоваться конструкцией: `typeof <function>` если вынести общий тип нет возможности.

```typescript
type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
const sub: BinaryFn = (a, b) => a - b;
const mul: typeof add = (a, b) => a * b;
```

<a id="Классы" href="#Классы">Классы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

TypeScript реализует объектно-ориентированный подход, в нем есть полноценная поддержка классов. Класс представляет шаблон для создания объектов и инкапсулирует функциональность, которую должен иметь объект. Класс определяет состояние и поведение, которыми обладает объект.

```typescript
class <Класс>[ extends <Родитель>][ implements <Интерфейс1>[, ...]] {
    [static] [{private | public | protected}] [readonly] <свойство1>: <тип>[ = <начальное_значение>]; // Объявление свойства
    constructor([{private | public | protected}] [readonly] <аргумент>: <тип>[, ...]): <тип> {
        [super(...);]
        ...
    }
    [static] [{private | public | protected}] [readonly] [override] <метод1>(<аргумент>: <тип>[, ...]): <тип> {...}
    static {
        // ...
    }
}
```

Если к свойствам и функциям классов не применяется модификатор, то такие свойства и функции расцениваются как будто они определены с модификатором `public`. То есть доступ к переменным есть из вне.

Если же к свойствам и методам применяется модификатор `private`, то к ним нельзя будет обратиться извне при создании объекта данного класса.

Модификатор `protected` во многом аналогичен `private` - свойства и методы с данным модификатором не видны из вне, но к ним можно обратиться из классов-наследников.

Ключевое слово `readonly` позволяет определить свойства, которые доступны только для чтения. Его значение можно установить только в конструкторе класса или при объявлении.

Ключевое слово `override` перед методом указывает, что метод переопределен при наследовании или реализации интерфейса и если это метод пропадет из интерфейса или класса, то будет ошибка компиляции.

Также в описании класса можно описывать свойства с двумя методами `get`/`set`.

Имя класса используется также как и простые типы.

Если класс реализует интерфейс, то он обязан определить все те же свойства и функции, которые есть в интерфейсе. При этом объект класса является как объектом типа `<Класс>`, так и объектом `<Интерфейс>`.

`typeof <Класс>` - возвращает тип идентификатора, который является типом функции-конструктора. Этот тип будет содержать все статические члены `<Класс>`, вместе с конструктором, который создает экземпляры класса `<Класс>`.

В пространстве типов полиморфный тип `this` представляет тип, являющийся подтипом содержащегося класса или интерфейса.

**Свойство параметра** - в конструкторе с модификаторами `private`, `public`, `protected` - добавляют указаные свойства в класс со значением равным переданому значению в конструктор.  
Лучше не использовать так как запутывают код.

`static` блок выполняется один раз и может использоваться для инизиализации статических переменных.

## <a id="Абстрактные-классы" href="#Абстрактные-классы">Абстрактные классы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Абстрактные классы представляют классы, определенные с ключевым словом `abstract`. Они во многом похожи на обычные классы за тем исключением, что мы не можем создать напрямую объект абстрактного класса, используя его конструктор.

```typescript
abstract class <Класс>[ extends <Родитель>] {
    [static] [{private | public | protected}] [readonly] <свойство1>: <тип>;
    [static] [{private | public | protected}] [readonly] <метод1>(<аргумент>: <тип>[, ...]): <тип> {...}
    [{public | protected}] abstract <метод1>(<аргумент>: <тип>[, ...]): <тип>; // абстрактный метод, который необходимо переопределить в наследнике
}
```

Ключевое слово `abstract` указывает что метод или свойство является не определенным в текущий момент и должно быть определено в наследниках в дальнейшем.

Абстрактная сигнатура конструктора используется для присвоения абстрактного конструктора:

```typescript
type AbstractConstructor = abstract new (...args: any[]) => any;
abstract class Shape {
    abstract getArea(): number;
}
const Ctor: AbstractConstructor = Shape;
```

<a id="Интерфейсы" href="#Интерфейсы">Интерфейсы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========

## <a id="Интерфейсы-классов" href="#Интерфейсы-классов">Интерфейсы классов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Интерфейс определяет свойства и методы, которые объект должен реализовать. Другими словами, интерфейс - это определение кастомного типа данных, но без реализации. Интерфейсы определяются с помощью ключевого слова `interface`.

```typescript
interface <Интерфейс>[ extends {<Интерфейс> | <Класс>}[, ...]] {
    [readonly] <свойство1>: <тип>; // Обязательное свойство
    [readonly] <свойство1>?: <тип>; // Необязательное свойство
    [propName: <тип_ключа>]: <тип_значения>; // Описание всех остальных свойств, которые не перечислены в описании интерфейса
    <метод1>(<аргумент>: <тип>[, ...]): <тип>;
    new(<аргумент>: <тип>[, ...]): <тип>; // Определение типа конструктора для класса
}
```

Также интерфейс может содержать свойства только для чтения, значение которых нельзя изменять. Такие свойства определяются с помощью ключевого слова `readonly`.

Имя интерфейса используется также как и простые типы.

Если объект, удовлетворяет перечисленным требованиям интерфейса для аргумента функции, то он считается подходящим для функции. Проверка типов не требует, чтобы свойства шли в определенном порядке: важно лишь, что необходимые свойства присутствуют и имеют подходящий тип.

```typescript
interface User {
    id: number;
    name: string;
}
let employee: User = {
    id: 1,
    name: "Alice"
};
```

В описании интерфейсов нельзя описывать свойства с двумя методами `get`/`set`, вместо этого описывается просто свойство, а если необходима реализация `get`/`set`, то она реализуется в реализаторе этого интерфейса.

```typescript
interface Collection {
    length: number;
}
class NullCollection implements Collection {
    get length(): number {
        return 0;
    }
}
```

## <a id="Интерфейсы-функций" href="#Интерфейсы-функций">Интерфейсы функций</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Интерфейсы функций содержат определение типа функции. Затем они должны быть реализованы объектом, который представляет функцию данного типа.

```typescript
interface <Интерфейс> {
    (<аргумент>: <тип>[, ...]): <тип>;
}
```

```typescript
interface FullNameBuilder {
    (name: string, surname: string): string;
}
let simpleBuilder: FullNameBuilder = function (name:string, surname: string): string {
    return "Mr. " + name + " " + surname;
}
```

## <a id="Интерфейсы-объектов" href="#Интерфейсы-объектов">Интерфейсы объектов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Интерфейсы объектов содержат описание структуры ключа и структуры его значения. Затем они должны быть реализованы, тем кто представляет данный тип.

```typescript
interface <Интерфейс> {
    [readonly] [index: <тип_ключа>]: <тип_значения>;
}
```

Слово `index` может быть любым, так как оно используется только для документации. А `<тип_ключа>` может быть одним из `number`, `string`, `symbol` и только ими, а не объединениями литеральных типов или шаблонами.

```typescript
interface Dictionary {
    [index: string]: string;
}
var colors: Dictionary = {};
colors["red"] = "#ff0000";
colors["green"] = "#00ff00";
colors["blue"] = "#0000ff";
```

Сигнатуру индекса можно сделать доступной только для чтения, чтобы запретить присваивание индексам после объявления.

## <a id="Гибридные-интерфейсы" href="#Гибридные-интерфейсы">Гибридные интерфейсы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Интерфейсы могут сочетать различные стили, могут применяться сразу как к определению объекта, так и к определению функции.

Преобразование к интерфейсам происходит по правилу утиной типизации или с помощью конструкций стандартного преобразования.

## <a id="Оператор-instanceof" href="#Оператор-instanceof">Оператор `instanceof`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

С помощью оператора `instanceof` можно проверить, принадлежит ли объект определенному классу.

## <a id="Оператор-typeof" href="#Оператор-typeof">Оператор `typeof`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В контексте типа `typeof` принимает значение и возвращает его тип TypeScript.
> `type T = typeof Cylinder; // тип typeof Cylinder`

```typescript
const INIT_OPTIONS = {
    width: 640,
    height: 480,
    color: '#00FF00',
    label: 'VGA',
};
type Options = typeof INIT_OPTIONS;
/*
Будет выведен тип:
interface Options {
    width: number;
    height: number;
    color: string;
    label: string;
}
*/
```

## <a id="Структурная-типизация" href="#Структурная-типизация">Структурная типизация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Система типов TypeScript моделирует поведение JavaScript при выполнении.

В TypeScript используется **структурная типизация** и поэтому если у одного интерфейса набор своих свойств полстью соответсвует набору всех свойств другого интерфейса, то экземпляры с этим интерфейсом могут использоваться как реализующие другой интерфейс. В связи с этим значения, присваиваемые интерфейсам, могут иметь свойства, не указанные в объявленных типах.

Поэтому конструкции, которые работают с объектами: `Object.keys(<экземпляр>)` всегда будут возвращать все свойства экземпляра, а не интерфейса.

В TypeScript все типы открыты для расширения.

```typescript
interface User {
    id: number;
    name: string;
}
interface Employer {
    id: number;
    name: string;
    age: number;
}
function printInfo(user: User): void {
    console.log(`User ${user.name} has id = ${user.id}`);
}
```

В текущем примере экзкмпляры реализующие интерфейс `Employer` могут использоваться в функции `printInfo`.

<a id="Обобщения" href="#Обобщения">Обобщения</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

Для функций:  
`function <имя><T[, ...]>(<аргумент>: T[, ...]): T {...}`

С помощью выражения `<T>` указывают, что функция типизирована определенным типом `T`. При выполнении функции вместо `Т` будет подставляться конкретный тип. Причем на этапе компиляции конкретный тип не известен. И возвращать функция будет объект этого типа. Таким образом, можно передать в функцию объекты различных типов, но при этом сохраняется строгая типизация, каждый вариант обобщенной функции может принимать объекты только определенного типа.

```typescript
function getId<T>(id: T): T {
    return id;
}
let result1 = getId<number>(5);
let result2 = getId<string>("abc");
```

Для остальных:  
- `class <Класс><T> {...}`;
- `interface <Интерфейс><T> {...}`;
- `type <тип><T> = ...`.

Только нужно учитывать, что если типизировали объект определенным типом, то сменить данный тип уже не получится. То есть в следующем случае второе создание объекта не будет работать, так как объект уже типизирован типом изначальным типом.

```typescript
let tom = new User<number>(3);
console.log(tom.getId());
tom = new User<string>("vsf"); // ошибка
```

> `type Constructor<T> = new (...args: any[]) => T;`

Если не указывать тип обобщения, то будет выведен минимальный возможный тип.

## <a id="Ограничения-обобщений" href="#Ограничения-обобщений">Ограничения обобщений</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<T extends {<Интерфейс> | <тип>}>` - устанавливает что только можно передавать объекты, которые расширяют `{<Интерфейс> | <тип>}`, то есть ограничивается всеми "наследниками" этого типа.

```typescript
class UserInfo<T extends User> {
    getUserInfo(user: T): void {
        user.getInfo();
    }
}
```

### <a id="Условное-ограничение" href="#Условное-ограничение">Условное ограничение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<T extends <тип> ? <тип1> : <тип2>>` - устанавливает что если `T` является подмножеством `<тип>`, тогда вычесленный тип будет `<тип1>`, в противном случае `<тип2>`.

```typescript
function double<T extends number | string>(x: T): T extends string ? string : number;
function double(x: any) {
    return x + x;
}
```

В случае с распределенными условными типами, когда проверяемый тип является объединением, оно разбивается на несколько веток в процессе выполнения операции: `T extends U ? X : Y`

```
T => A | B | C
A | B | C extends U ? X : Y => (A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)
```

С помощью этого подхода можно сужать типы:
```ts
type A =
    | {
        type: 'one';
    }
    | {
        type: 'two';
        value: number;
    }
    | {
        type: 'three';
        value: string;
    };
type Filter<T> = T extends { value: unknown } ? T : never;
type Types<T> = T extends { type: unknown } ? T['type'] : never;
type FilterByType<T, K extends Types<T>> = T extends { type: K } ? T : never;
type O = Filter<A>; // { type: 'two'; value: number; } | { type: 'three'; value: string; }
type OT = FilterByType<A, 'two' | 'one'>; // { type: 'two'; value: number; } | { type: 'one'; }
```

## <a id="Вывод-типа" href="#Вывод-типа">Вывод типа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для вывода типа внутри объявления без передачи типа через обобщение.

`infer` используется для определения переменной типа для хранения типа, захваченного (captured) в процессе поиска совпадений.

`infer U` - это инструкция расширения, представляющая новую переменную типа `U` для хранения предполагаемого или выводимого типа.

`infer` может использоваться только в инструкции расширения условного типа. Переменная типа, объявленная посредством `infer`, доступна только в истинной ветке условного типа.

При наличии нескольких кандидатов для одной и той же переменной типа в ковариантной позиции (когда используется более одного `infer` с одинаковой переменной), предполагается, что результирующий тип является объединением (`|`). В  контрвариативной позиции, предполагается, что результирующий тип является пересечением (`&`)

`infer R ? R : <тип>` - `infer` смотрит на структуру данных и выводит ее тип, иначе тип будет `<тип>`.

```typescript
export type ArrayElement<A> = A extends (infer T)[] ? T : never;
type Item = ArrayElement<(number | string)[]>; // Item === (number | string)
```

```typescript
export type Swap<T extends [any, any]> = T extends [infer X, infer Y] ? [Y, X] : never;
type Swapped = Swap<[string, number]> // Swapped === [number, string]
```

## <a id="Ключевое-слово-new" href="#Ключевое-слово-new">Ключевое слово `new`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<T>(type: { new (): T; }): T`

Чтобы создать новый объект в коде обобщений, нужно указать, что обобщенный тип `T` имеет конструктор. Это означает, что вместо параметра `type: T` нужно указать `type: {new (): T;}`.

```typescript
function userFactory<T>(type: { new (): T; }): T {
    return new type();
}
class User {
    constructor() {console.log("создан объект User");}
}
let user: User = userFactory(User);
```

## <a id="Защитники-типа" href="#Защитники-типа">Защитники типа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Защитник типа** - это некоторое выражение, выполняющее проверку во время выполнения, гарантирующий тип в некоторой области - то ечть **сужает тип** до указаного.

### <a id="Пользовательский-защитник-is" href="#Пользовательский-защитник-is">Пользовательский защитник `is`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Чтобы определить защитник типа, нужно определить функцию, чей тип возврата является **предикатом типа**, которая должна возвращать `true` - если `<аргумент>` является типом `<нужный_тип>`, иначе `false`:
```typescript
function is<Имя>(<аргумент>: <тип1> | <тип2> [| ...]): <аргумент> is <нужный_тип> {
    return <boolean>;
}
```

Всякий раз, когда с некоторой переменной вызывается указаная функция, TypeScript ограничивает эту переменную в специфический тип, при условии, что оригинальный тип совместим.

```typescript
function isFish(pet: Fish | Bird): pet is Fish {
    return (<fish>pet).swim !== undefined;
}
if (isFish(pet)) {
    pet.swim();
}
```

### <a id="Утверждение-типа-assert" href="#Утверждение-типа-assert">Утверждение типа `assert`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`function assert<Имя>(<аргумент>: <тип1> | <тип2> [| ...]): assert <аргумент> is <нужный_тип> { ... }` - если функция не выбрасывает исключение, то утверждается, что в дальнейшем `<аргумент>` будет указанным типом `<нужный_тип>`.

```typescript
function assertNonNullish<TValue>(
    value: TValue,
    message: string
): asserts value is NonNullable<TValue> {
    if (value === null || value === undefined) {
        throw Error(message);
    }
}
```

С помощью утвержения можно расширять значения, новыми значениями:
```typescript
function extend<T extends object, U extends object>(
    value: T,
    extension: U
): asserts value is T & U {
    Object.assign(value, extension);
}
```

### <a id="Защитники-типа-typeof" href="#Защитники-типа-typeof">Защитники типа `typeof`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`typeof <переменная> === <тип>` - определяет защитник типа только для типов `"number"`, `"string"`, `"boolean"`, или `"symbol"`.

```typescript
if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
}
```

### <a id="Защитники-типа-instanceof" href="#Защитники-типа-instanceof">Защитники типа `instanceof`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<переменная> instanceof <тип>` - определяет защитник типа используя их функцию-конструктор.

```typescript
function contains(text: string, search: string|RegExp) {
    if (search instanceof RegExp) {
        return !!search.exec(text);
    }
    return text.includes(search);
}
```

### <a id="Тип-сумма" href="#Тип-сумма">Тип-сумма</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Тип-сумма** (размеченное объединение) - это шаблон при котором всем типам добавляется явный тег для определения его типа.

```typescript
interface UploadEvent {
    type: 'upload';
    filename: string;
    contents: string;
}
interface DownloadEvent {
    type: 'download';
    filename: string;
}
type AppEvent = UploadEvent | DownloadEvent;
function handleEvent(e: AppEvent) {
    switch (e.type) {
        case 'download':
            e // тип DownloadEvent
            break;
        case 'upload':
            e; // тип UploadEvent
            break;
    }
}
```

### <a id="Бренд-типы" href="#Бренд-типы">Бренд-типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Работают по аналогии с **тип-сумма**, только сильнее ужесточают тип.

`type Brand<T, B extends string> = T & { readonly _brand: B }`

Может использоваться с примитивными типами и тогда для того чтобы преобразовать примитивный тип в брендированый тип нужно использовать защитников типа: `<аргумент> is <нужный_тип>` или приведение типа. При этом примитив так и остается примитивом. Только при операциями с примитивами **бренд-тип** теряется.

```typescript
type AbsolutePath = string & {_brand: 'abs'};
function listAbsolutePath(path: AbsolutePath) {
    // ...
}
function isAbsolutePath(path: string): path is AbsolutePath {
    return path.startsWith('/');
}
```

Подходят для моделирования свойств, которые не могут быть выражены внутри системы типов.

```typescript
// Упорядоченый тип
type SortedList<T> = T[] & {_brand: 'sorted'};
function isSorted<T>(xs: T[]): xs is SortedList<T> {
    for (let i = 1; i < xs.length; i++) {
        if (xs[i] > xs[i - 1]) {
            return false;
        }
    }
    return true;
}
```

Можно сделать тип, который будет выводить бренд-типы на основе символов:  
`type Brand<T, Name extends string> = T & { [Symbol.species]: Name }`
> `type AbsolutePath = Brand<string, "AbsolutePath">`

## <a id="keyof" href="#keyof">`keyof`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Оператор индексовского типа.

Кострукция `keyof <Интерфейс>` возвращает тип в котором присутствуют все свойства этого интерфейса в качестве объединения.

```typescript
interface User {
    name: string;
    description: string;
    age: number;
}
type UKeys = keyof User; // будет равно объединенному типу 'name' | 'description' | 'age'
```

Его можно использовать в обобщениях: `K extends keyof <Интерфейс>` - это значит что `K` должно являться подмножеством типа `keyof <Интерфейс>`.

`keyof (A & B)` = `(keyof A) | (keyof B)` - будет тип в котором будут все свойства (ключи) из типа `A`, которые есть в типе `B`.
`keyof (A | B)` = `(keyof A) & (keyof B)` - будет тип в котором будут все свойства (ключи) из типа `A` и типа `B`.

Если применять его для интерфейсов объектов, то вернет тип индекса.

## <a id="Отображенные-типы" href="#Отображенные-типы">Отображенные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```ts
type Mapped = {
    [P in <K>]: <T>;
};
```

Где `<K>` должен быть под подтипом `string | number | symbol`, а `<T>` любым типом.

Если у типа или интерфеса есть свойства, то можно получить тип этого свойства:  
`<Интерфейс>[<свойство>]`

```typescript
interface State {
    userId: string;
    recentFiles: string[];
    pageContents: string;
}
type TopNavState = {
    [K in 'userId' | 'recentFiles']: State[K]
};
type RecordedState = {
    [K in keyof State]: Record<string, State[K]>
};
```

Полностью отображенный тип на новые значения свойств получается:
```typescript
type NewType = {
    [k in keyof <Интерфейс>]: <значения_свойств>;
};
```

Для того чтобы исключить какие-то ключи по определенному типу используется структура:
```typescript
type Keys<Obj, T> = {
  [K in keyof Obj]: Obj[K] extends T ? K : never;
}[keyof Obj];
type Mapped<Obj, T> = {
  [P in Keys<Obj, T>]: Obj[P];
};
```

```typescript
interface A {
  a: number;
  b: string;
  c: boolean;
}
type V = Mapped<A, boolean | number>; // { a: number; c: boolean }
```

Для того чтобы свойство именовалось по другому, можно использовать шаблонные строковые литералы в конструкции: `[k in keyof <Интерфейс> as <шаблонный_строковый_литерал>]`.

```typescript
type Getters<Type> = {
    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
};
interface Person {
    name: string;
    age: number;
    location: string;
}
type LazyPerson = Getters<Person>;
//   ^ = type LazyPerson = {
//       getName: () => string;
//       getAge: () => number;
//       getLocation: () => string;
//   }
```

Для фильтрования ключей может использоваться конструкция `as Exclude<Property, <тип>>`:
> `[Property in keyof Type as Exclude<Property, "kind">]: Type[Property]`

Для того чтобы узнать тип значений массива используется: `<array>[number]`.

Для того чтобы узнать тип значений структуры используется индексированный доступ: `<Интерфейс>[<тип_ключа>]`:
```ts
type Keys = 'key_1' | 'key_2';
type InnerType = number | string;
type Rec = Record<Keys, InnerType>;
type SubType = Rec[Keys]; // = InnerType
```

Для добавления или удаления модификаторов используются префиксы `-` / `+` перед их названиями для отображенных типов:
```typescript
type CreateMutable<Type> = {
    -readonly [Property in keyof Type]: Type[Property];
};
type Concrete<Type> = {
  [Property in keyof Type]-?: Type[Property];
};
```

## <a id="Исключающие-типы" href="#Исключающие-типы">Исключающие типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Тип `never` можно использовать для того, чтобы исключить определенные свойства:
```typescript
type Arg = {one?: never, two: boolean} | {one: boolean, two?: never};
//   ^ = {two: boolean}
//     = {one: boolean}
//     != {two: boolean, one: boolean}
```

## <a id="Рекурсивные-типы" href="#Рекурсивные-типы">Рекурсивные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сам тип внутри объявления может ссылаться на самого себя.

> `type Json = string | number | boolean | null | { [property: string]: Json } | Json[];`

## <a id="Утилитарные-типы" href="#Утилитарные-типы">Утилитарные типы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`Partial<<Интерфейс>>` - возвращает новый тип в котором все свойства `<Интерфейс>` определены как опциональные.
```typescript
type Partial<T> = {
    [P in keyof T]?: T[P];
};
```

```typescript
interface User {
    name: string;
    description: string;
}
type OptionalUser = Partial<User>;
const user: OptionalUser = { name: 'first' };
```

`Required<<Интерфейс>>` - возвращает новый тип в котором все свойства `<Интерфейс>` определены как обязательные.
```ts
type Required<T> = {
    [P in keyof T]-?: T[P];
};
```

`Readonly<<Интерфейс>>` - возвращает новый тип в котором все свойства `<Интерфейс>` определены как доступные только для чтения.
```ts
type Readonly<T> = {
    readonly [k in keyof T]: T[k]
};
```

`Record<<ИнтерфейсСвойств>, <ИнтерфейсЗначений>>` - возвращает новый тип - запись, в котором свойства могут быть только типа `<ИнтерфейсСвойств>`, а его значения только `<ИнтерфейсЗначений>`.
```ts
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
```

```ts
type Keys = 'name' | 'description' | 'age';
interface Value {
    value: string;
    created?: Date;
}
type UserRecord = Record<Keys, Value>;
const userRecord: UserRecord = {
    name: {
        value: 'second',
        created: new Date(12),
    },
    description: {
        value: 'description'
    },
    age: {
        value: 'second',
        created: new Date(123212),
    },
};
```

`Pick<<Интерфейс>, <ИнтерфейсВыбораЗначенийСвойств>>` - возвращает новый тип из типа `<Интерфейс>`, в котором оставляет только те свойства, которые могут быть только типа `<ИнтерфейсВыбораЗначенийСвойств>`.
```ts
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};
```

```typescript
type Keys = 'name' | 'description' | 'age';
interface User {
    name: string;
    description: string;
    age: number;
    created: Date;
}
type UserInfo = Pick<User, Keys>;
const userInfo: UserInfo = {
    name: 'second',
    description: 'description',
    age: 27,
};
```

`Omit<<Интерфейс>, <ИнтерфейсВыбораЗначенийСвойств>>` - возвращает новый тип из типа `<Интерфейс>`, из которого исключает только те свойства, которые могут быть только типа `<ИнтерфейсВыбораЗначенийСвойств>`.
```typescript
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```

```typescript
interface User {
    name: string;
    description: string;
    age: number;
    created: Date;
}
type UserInfo = Omit<User, 'created' | 'age'>;
const userInfo: UserInfo = {
    name: 'second',
    description: 'description',
};
```

`ReturnType<<функция>>` - возвращает тип, который возвращает функция.
```ts
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer P ? P : never;
```

`Parameters<<функция>>` - возвращает массив типов, который принимает функция.
```ts
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;
```

```typescript
export function getGift(name: SecretName, gift: string): SecretSanta {
    /* ... */
}
type MySanta = ReturnType<typeof getGift>; // SecretSanta
type MyName = Parameters<typeof getGift>[0]; // SecretName
```

`Exclude<<Тип1>, <Тип2>>` - возвращает новый тип на основе типа `<Тип1>`, у которго исключены типы из типа `<Тип2>`.
```ts
type Exclude<T, U> = T extends U ? never : T;
```
> `type Excluded = Exclude<string | number | (() => void), Function>; // string | number`

`Extract<<Тип1>, <Тип2>>` - возвращает новый тип на основе типа `<Тип1>`, у которго остаются только типы, которые есть в типе `<Тип2>`.
```ts
type Extract<T, U> = T extends U ? T : never;
```
> `type Extracted = Extract<string | number | (() => void), Function>; // () => void`

`NonNullable<<Тип>>` - возвращает новый тип на основе типа `<Тип>`, у которго исключены типы `null` и `undefined`.
```ts
type NonNullable<T> = T extends null | undefined ? never : T;
```

## <a id="Обобщение-функций-с-ответом-any" href="#Обобщение-функций-с-ответом-any">Обобщение функций с ответом `any`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для функций которые возвращают результат `any` лучше не использовать конструкцию вида:

```typescript
function <обощающая_функция><T>(/* ... */): T {
    return <функция_с_результатом_any>(/* ... */);
}
```

Это считается плохим стилем. Лучше вернуть тип `unknown`, чтобы в дальнейшем применить утверждение или сузить тип.

<a id="Типы-и-Интерфейсы" href="#Типы-и-Интерфейсы">Типы и Интерфейсы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=================

Имена интерфейсов и типов **не должны содержать** префиксы `I` (interface) или `T` (type) так как этот вариант считается плохим стилем, так как не применяется на постоянной основе в стандартных библиотеках.

## <a id="Сходства" href="#Сходства">Сходства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```typescript
interface <Интерфейс> extends <Тип> {
    // новые свойства
}
```

```typescript
type <Тип> = <Интерфейс> & {
    // новые свойства
};
```

Класс может реализовывать как интерфейс, так и простой тип.

## <a id="Отличия" href="#Отличия">Отличия</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Интерфейс не может расширять сложные типы вроде типов объединений.
> `type NamedVariable = (Input | Output) & { name: string };`

Существуют типы объединения, но но не существует интерфейсов объединения.

Тип может выражать кортежи и типы массивов.
> `type Pair = [number, number];`  
> `type StringList = string[];`  
> `type NamedNums = [string, ...number[]];`

Интерфейсы могут быть дополнены в отличие от типо, так как типы всегда фиксированы. Это называется **объединением деклараций**.

```typescript
interface <Интерфейс> {
    // свойства 1
}
interface <Интерфейс> {
    // свойства 2
}
```

Таким образом интерфейс `<Интерфейс>` будет содержать все свойства из всех объявлений интерфейсов. Так как слияние поддерживается в обычном коде так же, как декларации.

## <a id="Выбор" href="#Выбор">Выбор</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для сложных типов - типы.

Для возможности дополнения - интерфейсы.

В остальном все зависит от стиля в проекте.

<a id="Пространства-имен" href="#Пространства-имен">Пространства имен</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=================

Пространства имен предназначены для организации больших программ. Пространства имен содержат группу классов, интерфейсов, функций, других пространств имен, которые могут использоваться в некотором общем контексте. Чтобы типы и объекты, определенные в пространстве имен, были видны извне, они определяются с ключевым словом `export`.

При этом пространства имен могут содержать и интерфейсы, и объекты, и функции.

```typescript
namespace <имя_пространства_имен> {
    // тело пространства имен, которое содержит группу классов, интерфейсов, функций, других пространств имен
    export <экспортируемый_тип>;
}
```

С помощью директивы `/// <reference path="<файл>.ts" />` подключается файл `<файл>.ts`, в котором содержатся данные.

`<имя_пространства_имен>.<экспортируемый_тип>` - доступ к элементам пространства имен.

Пространства имен могут быть вложенными. Причем вложенные пространства имен определяются со словом `export`. Соответственно при обращении к типам надо использовать все пространства имен.

## <a id="Псевдонимы" href="#Псевдонимы">Псевдонимы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Псевдонимы задаются с помощью ключевого слова `import`.

`import <псевдоним> = <имя_пространства_имен>.<экспортируемый_тип>;`

> `import employee = Data.Personnel.Employee;`

Лучше не использовать так как были разработаны до появления стандартного механизма модулей.

<a id="Модули" href="#Модули">Модули</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

TypeScript поддерживает работу с модулями. Модули являются концепцией, привнесенной стандартом ES2015.

Модули в некотором смысле похожи на пространства имен: они могут заключать различные классы, интерфейсы, функции, объекты. Модули выделяются в отдельные файлы. При этом модули подключаются в приложение не посредством тега `<script>`, а с помощью загрузчика модулей.

Работают аналогично модулям ES2015.

<a id="Заголовочные-файлы" href="#Заголовочные-файлы">Заголовочные файлы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==================

Для установки связи с внешними файлами скриптов javascript в TS служат декларативные или заголовочные файлы. Это файлы с расширением `.d.ts`, они описывают синтаксис и структуру функций и свойств, которые могут использоваться в программе, не предоставляя при этом конкретной реализации. Их действие во многом похоже на работу файлов с расширением `.h` в языках C/C++. Они выполняют своего рода роль оберток над библиотеками JavaScript.

С помощью ключевого слова `declare` в программу на TS подключается определение глобальной переменной.

```typescript
declare var globalVar: string;
declare function display(): void;
```

Подключение с помощью: `/// <reference path="globals.d.ts" />`.

<a id="Декораторы" href="#Декораторы">Декораторы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========

Декораторы являются инструментом декларативного программирования, они позволяют добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода.

Декораторы представляют функции, которые могут применяться к классам, методам, методам доступа (геттерам и сеттерам), свойствам, параметрам.

Включаются с помощью `"experimentalDecorators": true`.

## <a id="Декораторы-классов" href="#Декораторы-классов">Декораторы классов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Декоратор класса представляет функцию, которая принимает один параметр:  
`function <декоратор>(constructor: Function) {...}`

В качестве параметра выступает конструктор класса.

Для применения декоратора используется знак `@`. Сам декоратор ставится перед названием класса: `@<декоратор>`.

Также декораторы могут изменять результат работы конструктора. В этом случае определение функции декоратора немного меняется, но она также в качестве параметра принимает конструктор класса:  
`function <декоратор><TFunction extends Function>(target: TFunction): TFunction {...}`

В самом декораторе передаваемый конструктор target никак не используется. Но создается новый конструктор который и возвращается `return <TFunction><новый_конструктор>;`.

```typescript
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}
@sealed
class User {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    print(): void {
        console.log(this.name);
    }
}
```

## <a id="Декоратор-метода" href="#Декоратор-метода">Декоратор метода</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Декоратор метода также представляет функцию, которая принимает три параметра:  
`function <декоратор>(target: any, propertyName: string, descriptor: PropertyDescriptor) {...}`

Декоратор принимает следующие параметры:
- `target` - функция конструктора класса для статического метода, либо прототип класса для обычного метода;
- `propertyName` - название метода;
- `descriptor` - объект интерфейса `PropertyDescriptor`.

```typescript
interface PropertyDescriptor {
    configurable?: boolean;
    enumerable?: boolean;
    value?: any;
    writable?: boolean;
    get? (): any;
    set? (v: any): void;
}
```

Этот объект описывает изменение декорируемого метода. Его свойство `value` содержит определение функции. Свойство `writable` указывает, является ли функция модифицируемой (если значение `true`, то является).

Указывается перед описанием метода.

## <a id="Декораторы-параметров-методов" href="#Декораторы-параметров-методов">Декораторы параметров методов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Декоратор параметра метода представляет функцию, которая принимает три параметра:  
`function <декоратор>(target: Object, propertyKey: string, parameterIndex: number) {...}`

Где `target` - представляет конструктор класса, если метод статический, либо прототип класса, если метод нестатический, `propertyKey` - представляет имя параметра, `parameterIndex` - представляет порядковый индекс параметра в списке параметров.

## <a id="Декораторы-свойств" href="#Декораторы-свойств">Декораторы свойств</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Декоратор свойства представляет функцию, которая принимает два параметра:  
`function <декоратор>(target: Object, propertyKey: string) {...}`

Где `target` - представляет конструктор класса, если свойство статическое, либо прототип класса, если свойство нестатическое, `propertyKey` - представляет имя свойства.

В функциях декораторов методов, свойств `this` - указывает на текущий экземпляр класса.

```typescript
class User {
    @format
    name: string;
    @logMethod
    setName(@logParameter name: string) {
        this.name = name;
    }
}
```

## <a id="Декоратор-метода-доступа" href="#Декоратор-метода-доступа">Декоратор метода доступа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Декоратор метода доступа принимает три параметра:  
`function <декоратор>(target: Object, propertyName: string, descriptor: PropertyDescriptor) {...}`

Декоратор принимает следующие параметры:
- `target` - функция конструктора класса для статического метода, либо прототип класса для обычного метода;
- `propertyName` - название метода;
- `descriptor` - объект интерфейса `PropertyDescriptor`.

## <a id="Фабрики-декораторов" href="#Фабрики-декораторов">Фабрики декораторов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Фабрика декоратора представляет функцию, которая в свою очерель возвращает функцию декоратора.

```typescript
function <фабрика_декораторов>(<параметры>) {
    ...
    return function <декоратор>(...) {}
}
```

```typescript
function regex(pattern: string) {
    const expression = new RegExp(pattern);
    return function regex(target: Object, propertyName: string) {
        let propertyValue = this[propertyName];
        const getter = function () {
            return propertyValue;
        };
        const setter = function (newVal) {
            let isValid: boolean = expression.test(newVal);
            if (isValid === false) {
                throw new Error(`Value ${newVal} does not match ${pattern}`);
            } else {
                console.log(`${newVal} is valid`);
            }
        };
        if (delete this[propertyName]) {
            Object.defineProperty(target, propertyName, {
                get: getter,
                set: setter
            });
        }
    }
}
class Account {
    @regex("^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$")
    email: string;
    @regex("^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$")
    phone: string;
    constructor(email: string, phone: string) {
        this.email = email;
        this.phone = phone;
    }
}
```

<a id="TSDoc" href="#TSDoc">TSDoc</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

Аналогично **JSDoc** только не указываются типы.

## <a id="Интерфейсы-и-классы" href="#Интерфейсы-и-классы">Интерфейсы и классы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для описания свойств интерфейсов и классов используется такой подход:

```typescript
/** описание итнерфейса */
interface <Интрефейс> {
    /** описание свойства */
    <свойство1>
}
```

<a id="Рекомендации" href="#Рекомендации">Рекомендации</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

## <a id="Смещение-нулевых-значения-на-периферию-типов" href="#Смещение-нулевых-значения-на-периферию-типов">Смещение нулевых значения на периферию типов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это обозначает что не нужно смешивать нулевые и ненулевые значения и избегать конструкций, где одно нулевое / ненулевое значение неявно связано с другим нулевым / ненулевым значением.

Нужно стараться смещать значения `null` на периферию API, создавая более крупные однозначно нулевые либо ненулевые объекты.

Для класов, если в них присутствуют нулевые поля, которые асинхронно инициализируются, то лучше использовать создание полностью ненулевого класса и его конструирование в момент доступности всех значений через статический метод этого класа.

```typescript
class UserPosts {
    user: UserInfo;
    posts: Post[];
    constructor(user: UserInfo, posts: Post[]) {
        this.user = user;
        this.posts = posts;
    }
    static async init(userId: string): Promise<UserPosts> {
        const [user, posts] = await Promise.all([
            fetchUser(userId),
            fetchPostsForUser(userId)
        ]);
        return new UserPosts(user, posts);
    }
}
```