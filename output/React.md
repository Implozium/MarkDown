[Содержание](#Содержание)
==========

- [Описание](#Описание)
- [Установка](#Установка)
    - [Create React App](#Create-React-App)
    - [Установка как пакетов](#Установка-как-пакетов)
- [JSX](#JSX)
    - [Создание компонента](#Создание-компонента)
        - [Комментарии внутри JSX](#Комментарии-внутри-JSX)
        - [Отрисовка (отображение) компонента](#Отрисовка-отображение-компонента)
    - [Отрисовка группы (массива) компонентов](#Отрисовка-группы-массива-компонентов)
- [Свойства](#Свойства)
    - [Хранение элементов в переменной](#Хранение-элементов-в-переменной)
    - [Использование компонентов через переменные](#Использование-компонентов-через-переменные)
    - [If - else внутри JSX](#If---else-внутри-JSX)
    - [HTML-код](#HTML-код)
- [Локальное состояние](#Локальное-состояние)
- [Цикл жизни компонента](#Цикл-жизни-компонента)
- [Обработка событий](#Обработка-событий)
- [Контролируемые компоненты](#Контролируемые-компоненты)
    - [Атрибут обратного вызова `ref`](#Атрибут-обратного-вызова-ref)
        - [Создание ссылок (>= 16.3)](#Создание-ссылок--163)
    - [Контекст](#Контекст)
    - [Порталы](#Порталы)
    - [Фрагменты `React.Fragment`](#Фрагменты-ReactFragment)
    - [`React.Children`](#ReactChildren)
    - [`React.cloneElement`](#ReactcloneElement)
    - [Компоненты высшего порядка](#Компоненты-высшего-порядка)
    - [Шаблон "render props"](#Шаблон-render-props)
- [React Router](#React-Router)
    - [Сопоставление маршрутов](#Сопоставление-маршрутов)
    - [Ссылки на роуты](#Ссылки-на-роуты)
- [Redux](#Redux)
    - [Actions](#Actions)
    - [Reducer](#Reducer)
    - [Точка входа](#Точка-входа)
        - [Store](#Store)
        - [Комбинирование редюсеров](#Комбинирование-редюсеров)
    - [Контейнеры и компоненты](#Контейнеры-и-компоненты)
        - [Селектор](#Селектор)
        - [Создание actions](#Создание-actions)
        - [Усилители](#Усилители)
        - [Асинхронные actions](#Асинхронные-actions)
            - [Усилитель: redux-thunk](#Усилитель-redux-thunk)
            - [Усилитель: redux-saga](#Усилитель-redux-saga)
                - [Эффекты](#Эффекты)

<a id="Описание" href="#Описание">Описание</a>
========

**React** - одна из библиотек, которая придерживаются строгих соглашений о том, как структурировать код и управлять данными вашего приложения. **JSX** является результатом одного из таких соглашений. **React** воплощает идею, что разметка и код, который генерирует ее по своей природе связаны друг с другом. В **React** компонентах это реализуется генерацией разметки прямо из **JavaScript**, используя всю мощь языка.

<a id="Установка" href="#Установка">Установка</a>
=========

## <a id="Create-React-App" href="#Create-React-App">Create React App</a>

```bash
npm install -g create-react-app
create-react-app my-app
cd my-app
npm start
```
Производит установку с помощью `create-react-app`.

```bash
npm run build
```
Это создаст production-сборку приложения в сборке / папке вашего проекта.

## <a id="Установка-как-пакетов" href="#Установка-как-пакетов">Установка как пакетов</a>

```bash
npm init
npm install --save react react-dom
```

<a id="JSX" href="#JSX">JSX</a>
===

Является синтаксическим расширением JavaScript. JSX производит React-элементы.

**JSX** нужен для JavaScript XML - разметки в стиле XML внутри компонентов React. React может работать и без JSX, но именно JSX делает компоненты более читаемыми.
- **JSX** это синтаксическая трансформация - каждая JSX ветвь соответствует JavaScript функции;
- не требует никаких библиотек для выполнения;
- **JSX** ничего не добавляет и не изменяет в JavaScript - он просто вызывает функции.

JSX трансформирует JavaScript код в семантическую осмысленную разметку.

React определяет все возможные HTML элементы в пространстве имен `React.dom`. Это к тому же позволяет использовать полностью произвольные компоненты внутри разметки.

Для того чтобы файл с JSX стал доступен для React, в начало файла нужно вставить такой заголовок: `/** @jsx React.DOM */`

Без этого JSX не поймет что файл нужно обработать для React.

React предопределяет все HTML теги которые только есть в пространстве имен `React.DOM`. JSX трансформирует их в глобальные переменные, которые позволят использовать просто `<div>...</div>` вместо того, чтобы каждый раз указывать `var div = React.dom.div` в каждом JSX файле.

После компиляции JSX-выражения становятся регулярными JavaScript-объектами. Что значит внутри можно использовать все преимущества при создании структуры компонента в HTML подобном синтаксис, который трансформируется в простые JavaScript функции.

## <a id="Создание-компонента" href="#Создание-компонента">Создание компонента</a>

Концептуально, компоненты подобны JavaScript-функциям. Они принимают произвольные данные (называемые props) и возвращают React-элементы, описывающие что должно появиться на экране.

```JSX
class <Компонент> extends React.Component {
    render() {
        return (
            <html_код_компонента>
        );
    }
};
```

```JSX
const <Компонент> = (
    <html_код_компонента>
);
```

```JSX
function <Компонент>(props) {
    return <html_код_компонента>;
}
```
Это создаст компонент. Внутри `return` всегда должен возвращаться DOM-узел (то есть, что угодно, обернутое в один, единый, родительский тэг) или `null` для того чтобы не отображать компонент. **Компонент всегда должен называться с большой буквы**.

Компоненты могут ссылаться на другие компоненты в своём выводе (результате отрисовки). Это позволяет использовать абстракцию компонента для любого уровня детализации. Внутри компонентов можно также использовать другие компоненты в `<html_код_компонента>`:  
`<<Компонент>> <контент> </<Компонент>>`

Запись `<<Компонент>/>` эквивалентна: `<<Компонент>></<Компонент>>`.

React DOM использует соглашение об именовании свойств в camelCase нотации, вместо имен HTML-атрибутов. Т.е. для того чтобы указать CSS-классы тега необходимо использовать атрибут `className` вместо стандартного `class`.
Также можно напрямую использовать js-код, для этого его необходимо заключить в:
`{<код>}`

### <a id="Комментарии-внутри-JSX" href="#Комментарии-внутри-JSX">Комментарии внутри JSX</a>

`{/* <комментарий> */}`

### <a id="Отрисовка-отображение-компонента" href="#Отрисовка-отображение-компонента">Отрисовка (отображение) компонента</a>

```JSX
ReactDOM.render(
    <<Компонент>> <контент> </<Компонент>>,
    document.getElementById('<id>')
);
```
Это вставляет компонент внутрь указанного элемента в html.

## <a id="Отрисовка-группы-массива-компонентов" href="#Отрисовка-группы-массива-компонентов">Отрисовка группы (массива) компонентов</a>

Каждый элемент в массиве должен обладать свойством `key`, для того чтобы идентифицировать, какой элемент был изменен, добавлен или удален. Ключи должны быть предоставлены элементам внутри массива, чтобы дать элементам стабильную идентифицируемость. Ключи имеют смысл только в контексте окружающего массива, т.е. **элементы внутри вызова `map()` требуют ключей**.

```JSX
const items = <массив>.map((<элемент>) => {
    return <<Компонент> key={<ключ>}>...</<Компонент>>;
});
```

Отрисовка массива будет: `<div>{items}</div>`.

<a id="Свойства" href="#Свойства">Свойства</a>
========

В свойство компонента можно передать любой javascript примитив, объект, переменную и даже выражение. Они передаются в компонент как html атрибуты:

`<<Компонент> <свойство>={<значение>}[ ...]> <контент> </<Компонент>>`

Значения свойств доступны внутри компонента как: `this.props.<свойство>`.

Если свойству значение не присвоено, но свойство написано, то оно равно по умолчанию `true`.

Для записи свойства HTML, которое использует `-` в своем название, используется camelCase именование.

В `{this.props.children}` – хранится `<контент>`, который был передан в компонент, который может быть любым значением понятным для реакта, а именно объект, строка или функция, а значения `false`, `null`, `undefined`, и `true` игнорируются.
> `<UserList users={users}>{(user) => <li key={user.id}>Пользователь: {user.name}</li>}</UserList>`

`this.props` – иммутабельная структура, используется только для чтения.

Для вывода (отображения) значения переменной внутри JSX, нужно использовать указанный синтаксис, при этом все преобразуется в строку, перед тем как будет отрисовано:  
`{<переменная>}`

`<<Компонент> {...<объект_свойств>}> <контент> </<Компонент>>` - передача всех свойств компоненту, через объект, с помощью оператора расширения.

## <a id="Хранение-элементов-в-переменной" href="#Хранение-элементов-в-переменной">Хранение элементов в переменной</a>

`const <переменная> = <Компонент>;`  
Отрисовка компонента из переменной: `{<переменная>}`.

## <a id="Использование-компонентов-через-переменные" href="#Использование-компонентов-через-переменные">Использование компонентов через переменные</a>

`const <Компонент> = <компонент>;` - всегда должен быть с большой буквы.  
`<<Компонент> .../>`

Таким способом можно передавать компоненты через свойства.

## <a id="If---else-внутри-JSX" href="#If---else-внутри-JSX">If - else внутри JSX</a>

Оно доступно внутри JSX как `{<условие> ? <код_истины> : <код_лжи>}`.  
Только if без else `{<условие> && <код_истины>}`

```JSX
<div className="solid" tabIndex="0" customProperty="value">
    {valid && <div className="valid">Profile is valided</div>}
</div>
```

## <a id="HTML-код" href="#HTML-код">HTML-код</a>

`<<тег> dangerouslySetInnerHTML={{__html: '<html_код>'}}/>` - производит прямую вставку HTML-кода в элемент.

<a id="Локальное-состояние" href="#Локальное-состояние">Локальное состояние</a>
===================

Это состояние подобно свойствам `props`, но является приватным и полностью контролируется компонентом. Локальное состояние является возможностью, доступной только для классов. Используется для динамических свойств, оно хранится в `this.state`.

Для его использования необходимо:

```JSX
class <Компонент> extends React.Component {
    constructor(props) {// props - свойства переданные при создании
        super(props);
        this.state = {};// инициализация начального состояния, можно делать только в конструкторе
    }
    // срабатывает после того, как компонент был отрисован в DOM
    // тут есть возможность использовать refs (к примеру для установки фокуса или задействования других компонентов), таймауты, ajax-запросы и взаимодействие с другими библиотеками
    componentDidMount() {}
    // вызывается сразу перед тем, как компонент будет удален из DOM
    componentWillUnmount() {}
    // компонент будет примонтирован. В данный момент нет возможности посмотреть DOM элементы
    // [DEPRECATED]
    componentWillMount() {}
    // компонент получает новые props
    // этот метод не вызывается в момент первого render'a. В этот момент, старые props доступны как this.props, а новые props доступны в виде nextProps. Если вызывать setState внутри этого метода - не будет вызван дополнительный render
    // [DEPRECATED]
    componentWillReceiveProps(nextProps) {}
    // вызывается прямо перед render, когда новые props и state получены
    // в этом методе нельзя вызывать setState
    // [DEPRECATED]
    componentWillUpdate() {}
    // вызывается перед вызовом render
    // должен возвращать объект для обновления state или null для, чтобы показать что обновлять нечего
    static getDerivedStateFromProps(props, state) {}
    // вызывается сразу после render, когда изменение еще не принято в DOM, позволяет захватить некоторую информацию из DOM
    // то что будет возвращено передается в componentDidUpdate
    getSnapshotBeforeUpdate(prevProps, prevState) {}
    // вызывается сразу после render. Не вызывается в момент первого render'а компонента
    // где prevProps - предыдущее props, текущие - this.props, prevState - предыдущий state, snapshot - результат функции getSnapshotBeforeUpdate
    componentDidUpdate(prevProps, prevState, snapshot) {}
    // вызывается до начала процесса повторной отрисовки, где nextProps - новые props, nextState - новые state, если вернет true, то React выполнит обновление (перерисовку) компонента, при false не будет
    shouldComponentUpdate(nextProps, nextState) {}
    render() {
        return (<html_код_компонента>);
    }
};
<Компонент>.defaultProps = <объект_свойств_по_умолчанию>;
```

Чтобы получить значение свойства из состояния в JSX используется: `{this.state.<свойство>}`.

`this.state` нельзя модифицировать вручную, для этого необходимо использовать функции готового компонента:

`this.setState({<свойство>:<значение>[, ...]}[, () => {...}])` - изменяет (обновляет) состояние компонента, при этом объединяя новое состояние с предыдущим, и перерисовывает его, каждый раз должно передаваться новый экземпляр состояния с теми свойствами, которые поменялись (а не всеми) [и вызовет callback функцию после того, как новое состояние "установится"].

`this.setState((prevState, props) => {...}[, () => {...}])` - аналогично предыдущему варианту, где функция должна возвращать новое состояние, а `prevState` - предыдущее состояние, `props` - свойства в момент отображения [и вызовет callback функцию после того, как новое состояние "установится"].

`this.setState()` - не изменяет `this.state` немедленно, а создает очередь изменений состояния. Доступ к `this.state` после вызова метода, потенциально может вернуть имеющееся (бывшее) значение.

Нельзя вызывать `setState` в `render`: так как реакт, видит изменилось состояние - начинает перерисовывать компонент - видит что изменилось состояние - начинает перерисовывать компонент и т.д.

Вызов `setState` родителя - перерисует дочерние компоненты.

<a id="Цикл-жизни-компонента" href="#Цикл-жизни-компонента">Цикл жизни компонента</a>
=====================

```
    Монтирование          :               Обновление             :        Демонтирование
        |                 :                                      :              |
        v                 :                                      :              |
    ---------------       :                                      :              |
    | constructor |       :  New props set­State() force­Update()  :              |
    ---------------       :     |          |            |        :              |
        |                 :     |          |            |        :              |
        v                 :     v          v            v        :              |
    ------------------------------------------------------------ :              |
    |                getDerivedStateFromProps                  | :              |
    ------------------------------------------------------------ :              |
        |                 :     |          |            |        :              |
        |                 :     v          v            |        :              |
        |                 : -------------------------   |        :              |
        |                 : | shouldComponentUpdate |   |        :              |
        |                 : -------------------------   |        :              |
        |                 :     |          |            |        :              |
        v                 :     v          x            v        :              |
    ------------------------------------------------------------ :              |
    |                           render                         | :              |     1
    ------------------------------------------------------------ :              |
        |                 :                |                     :              |
    +++ | +++++++++++++++ : ++++++++++++++ v +++++++++++++++++++ : ++++++++++++ | +++++++++
        |                 : ------------------------------------ :              |
        |                 : | getSnapshotBeforeUpdate          | :              |     2
        |                 : ------------------------------------ :              |
    +++ | +++++++++++++++ : ++++++++++++++ | +++++++++++++++++++ : ++++++++++++ | +++++++++
        v                 :                v                     :              |
    ------------------------------------------------------------ :              |
    |        React обновляет ­D­O­M и ссылки (refs)               | :              |     3
    ------------------------------------------------------------ :              |
        |                 :                |                     :              |
        v                 :                v                     :              v
    --------------------- : ------------------------------------ : ------------------------
    | componentDidMount | : |        componentDidUpdate        | : | componentWillUnmount |
    --------------------- : ------------------------------------ : ------------------------
```

Фазы:
1. Фаза **Render** - чистая и не имеет побочных эффектов. Может быть приостановлена, прервана и перезапущена самим React'ом;
2. Фаза **Pre-commit** - можно производить чтение DOM'a;
3. Фаза **Commit** - можно работать с DOM'ом, пускать побочные эффекты, намечать обновления.

<a id="Обработка-событий" href="#Обработка-событий">Обработка событий</a>
=================

Для использовании функций для обработки стандартных событий в `<html_код_компонента>` используется в нужном теге компонента, как значение необходимого свойства:

`<<тег> on<Событие> = {<функция_обработки_события>}>` - это привязывает функцию к указанному событию элемента, в эту функцию передается событие `e` -  это синтетическое событие (`SyntheticEvent`).

> `<div onClick = {(e) => {console.log(e);}}>...</div>`

На основе этого делаются произвольные события и Callback функции:

`<<тег> on<ПроизвольноеСобытие> = {<функция_обработки_события>}>`

Когда определяетcя компонент, используя ES6 класс, то общий паттерн таков: **обработчик события должен быть методом класса**. Для привязывания контекста `this` используется указаная конструкция в конструкторе класса:  
`this.<функция_обработки_события> = this.<функция_обработки_события>.bind(this);`

Теперь в свойствах компонента будет this.props.<функция_события> - которое будет содержать функцию для обратного вызова, которую необходимо будет вызвать в компоненте при указанном событии.

<a id="Контролируемые-компоненты" href="#Контролируемые-компоненты">Контролируемые компоненты</a>
=========================

Элемент ввода формы (например, `input`), значение которого контролируется React, называется "**контролируемый компонент**".

Если установлено свойство `value` для `input`, `textarea` и `select`, у которого нет `onChange` обработчика, то будет отрисовано поле только для чтения.

Если поле должно быть изменяемое, то нужно использовать `defaultValue`. А для `<input type="checkbox">` и `<input type="radio">` нужно использовать `defaultChecked`.

Для `select` выбранный `option` указывается по свойству `value` в `select`, которое должно быть равное `value` выбраного `option`. Если необходим множественный выбор, то `value` в `select` должно быть равно массиву, который состоит из значений `value` выбранных `option`.

В контролируемом компоненте, любая модификация состояния будет иметь ассоциированную функцию-обработчик. Это делает его простым для изменения или проверки данных, вводимых пользователем.

Для множественной обработки подобных полей можно воспользоваться связыванием:  
`<<тег> on<Событие>={<функция_обработки_события>.bind(this, <арг>[, ...])}>`

И тогда функция обработки будет выглядеть:  
`function <функция_обработки_события>(<арг>[, ...], e) {...}`

## <a id="Атрибут-обратного-вызова-ref" href="#Атрибут-обратного-вызова-ref">Атрибут обратного вызова `ref`</a>

Это специальный атрибут, который может быть присвоен любому компоненту. Атрибут `ref` принимает функцию обратного вызова, и вызывает ее после того, как компонент монтируется в DOM или удаляется из него. Используется для:
- анимации;
- управления фокусом, выделения текста или медиа функции;
- интеграция с другими библиотеками.

Когда атрибут `ref` используется в элементе HTML, функция обратного вызова принимает базовый элемент DOM в качестве аргумента.

Когда атрибут `ref` используется в кастомном компоненте React, функция обратного вызова принимает смонтированный экземпляр компонента в качестве аргумента.

`<<тег> ref={(input) => {this.<имя_переменной_в_классе> = input;}}>` - в переменную `<имя_переменной_в_классе> `- запишется ссылка на текущий элемент DOM или компонент.

Для прокидывания через компоненты используется, как правило, такое имя свойства: `inputRef`.

Если коллбэк атрибута `ref` определен как встроенная функция, она будет вызываться дважды во время перерисовок: сперва с `null`, а затем снова с DOM-элементом.

### <a id="Создание-ссылок--163" href="#Создание-ссылок--163">Создание ссылок (>= 16.3)</a>

`this.<имя_переменной_ссылки> = React.createRef();` - создание ссылки, как правило, они назначаются свойствам экземпляра компонента, в то время как компонент сконструирован таким образом, чтобы ссылки были доступны из любого места этого компонента.

`<<тег> ref={this.<имя_переменной_ссылки>}>` - присвоение ссылки на компонент.

`this.<имя_переменной_ссылки>.current;` - присвоит свойству `current` элемент DOM или компонента, когда компонент будет монтирован, и значение `null`, когда компонент будет демонтирован. Обновления `ref` происходят перед срабатыванием методов Жизненого Цикла `componentDidMount` или `componentDidUpdate`.

`ReactDOM.findDomNode(<компонент>)` - возвращает нативный DOM-элемент к которому относится компонент.

## <a id="Контекст" href="#Контекст">Контекст</a>

Контекст обеспечивает способ передачи данных через дерево компонентов без необходимости передавать свойства вручную на каждом уровне.

`const {Provider, Consumer} = React.createContext(<значение_по_умолчанию>);` - создает пару потребитель `Provider` и поставщик (провайдер) `Consumer`.

`<Provider[ value={<значение>}]>...</Provider>` - компонент, который позволяет потребителям подписываться на изменения контекста [принимает свойство `value`, которое должно быть передано потребителям, которые являются потомками данного провайдера]. Один провайдер может быть связан со многими потребителями. Провайдеры могут быть вложенными, чтобы переопределять значения глубже в дереве.

`<Consumer>{value => ...}</Consumer>` - компонент, который подписывается на изменения контекста. Требует функцию в качестве дочернего элемента. Функция получает текущее значение контекста и возвращает узел `React`. Аргумент `value`, переданный функции, будет равен свойству `value` ближайшего поставщика для этого контекста выше в дереве. Если для данного контекста нет провайдера, аргумент `value` будет равен значению `defaultValue`, которое было передано в `createContext()`. Все потребители перерисовываются всякий раз при изменении значения поставщика.

> `<Consumer>{theme => <Button theme={theme}/>}</Consumer>`

## <a id="Порталы" href="#Порталы">Порталы</a>

Порталы предоставляют способ отображения дочерних элементов в узел DOM, который существует вне иерархии DOM родительского компонента.

`ReactDOM.createPortal(<потомок_React>, <элемент_DOM>)` - создает портал, где `<потомок_React>` - любой отображаемый потомок React, такой как элемент, строка или фрагмент, а `<элемент_DOM>` - валидный DOM-узел в который необходимо отрисовать потомок. Используется в методе `render()` компонента.

```javascript
render() {
    return ReactDOM.createPortal(this.props.children, domNode);
}
```

Несмотря на то, что портал может быть где угодно в дереве DOM, он ведет себя как обычный дочерний элемент React во всех отношениях. Такие функции, как контекст, работают как и ранее, независимо от того, является ли дочерний элемент порталом, поскольку портал все еще существует в дереве React независимо от его положения в дереве DOM.

Это же касается и всплытия события. Событие, созданное внутри портала, будет распространяться к предкам в объемлющем дереве React, даже если они не являются предками в дереве DOM.

## <a id="Фрагменты-ReactFragment" href="#Фрагменты-ReactFragment">Фрагменты `React.Fragment`</a>

Используются для объединения DOM узлов. Для объединения множественных элементов.

```javascript
<React.Fragment>
    <Элемент />
    <Элемент />
    ...
</React.Fragment>
```

Сокращенный синтаксис:

```javascript
<>
    <Элемент />
    <Элемент />
    ...
</>
```

## <a id="ReactChildren" href="#ReactChildren">`React.Children`</a>

Представляет утилитарные функции для работы с `this.props.children`.

`React.Children.map(this.props.children, (child) => {... return ...;})` - работает аналогично функции `map` для массивов и возвращает новый массив, с исключениями, если `this.props.children` был единичный элемент, то вернется массив, если `null` или `undefined`, то `null`.

`React.Children.forEach(this.props.children, (child) => {...})` - работает аналогично функции `forEach` для массивов.

`React.Children.toArray(this.props.children)` - возвращает массив преобразованный из `this.props.children`.

## <a id="ReactcloneElement" href="#ReactcloneElement">`React.cloneElement`</a>

`React.cloneElement(<react_element>[, props][, ...children])` - возвращает клон элемента с добавленными свойствами, работает аналогично: `<element.type {...element.props} {...props}>{children}</element.type>`

## <a id="Компоненты-высшего-порядка" href="#Компоненты-высшего-порядка">Компоненты высшего порядка</a>

Компонент высшего порядка - это функция, которая принимает входной компонент и возвращает расширенную или изменённую версию этого компонента - декоратор. Обычно реализуется функцией, которая принимает компонент и использует каррирование.

```javascript
const <декоратор> = ([<аргумент>[, ...]]) => (<Компонент>) => {
    const <НовыйКомпонент> = (props) => ( // модифицированная версия компонента
        ...
        return (...);
    );
    return <НовыйКомпонент>;
};
```

Компонент авторизации:

```javascript
function withAuthentication(WrappedComponent) {
    const ModifiedComponent = (props) => {
        if (!props.isAuthenticated) {
            return <Redirect to="/login" />;
        }
        return (<WrappedComponent { ...props } />);
    };
    const mapStateToProps = (state) => ({
        isAuthenticated: state.session.isAuthenticated
    });
    return connect(mapStateToProps)(ModifiedComponent);
}
```

## <a id="Шаблон-render-props" href="#Шаблон-render-props">Шаблон "render props"</a>

**Шаблон "render props"**, или, как его ещё называют, "**функция как потомок**", позволяет достичь того же самого, что достижимо с помощью компонентов высшего порядка.

Идея использования **шаблона render props** заключается в передаче управления вашей функцией рендеринга другому компоненту, который затем возвращает управление через свойство, являющееся функцией.

Может быть использован в ситуациях, где нужна некая подходящая для повторного использования логика внутри компонента, при этом данный компонент не планируется оборачивать в компонент высшего порядка.

```javascript
class <Компонент> extends React.Component {
  constructor() {
    super();
  }
  render() {
    return this.props.children([<аргумент>[, ...]])
  }
}
const App = () => (
  <div>
    <Компонент>
      {([<аргумент>[, ...]]) => (...)}
    </Компонент>
  </div>
);
```

<a id="React-Router" href="#React-Router">React Router</a>
============

Используется для роутинга.

`const browserHistory = ReactRouter.browserHistory;` - определяет стратегию отслеживания истории. Объект `browserHistory` это синглтон.

`browserHistory.push('<путь>');` - переносит пользователя на другой URL.

```javascript
ReactDOM.render((
    <Router history={browserHistory}>
        <Route [path="<путь>"] component={<Компонент>}/> - маршрут
        [...]
        <Route [path="<путь>"] component={<Компонент>}>
            <IndexRoute component={<Компонент>} /> - корневой роутер, текущего роутера
            <вложенные_маршруты>
        </Route>
    </Router>
), document.getElementById('root'));
```
Должен помещаться в главный (корневой) элемент.

Каждый `<Route>` при совпадении URL будет выводить соответствующий компонент.

Одновременно в `'root'` будет выводиться лишь один из компонентов. Роутер переключает маршруты без запросов на сервер, при этом каждый компонент может быть самостоятельной новой страницей.

Маршруты можно вкладывать друг в друга, при этом их пути комбинируются (объединяются через `/`) по вложенности.

## <a id="Сопоставление-маршрутов" href="#Сопоставление-маршрутов">Сопоставление маршрутов</a>

Пути в роутах можно писать в таком виде:  
`<путь>/:<переменная>[/...]`

Роутер React передаст значение `:<переменная>` в качестве свойства компоненту, внутри компонента оно будет доступно как `this.props.params.<переменная>`.

## <a id="Ссылки-на-роуты" href="#Ссылки-на-роуты">Ссылки на роуты</a>

Ссылки на роуты должны оформляться в виде:

```javascript
<Link to="<путь>" [className="<класс>"] [activeClassName="<класс_активности>"]>
    <текст>
</Link>
```

<a id="Redux" href="#Redux">Redux</a>
=====

Redux-приложение это:
- состояние (state) приложения в одном месте;
- однонаправленный поток данных.

Хранилище можно рассматривать как посредника для всех изменений состояния в приложении. При использовании Redux компоненты не общаются между собой, все изменения состояния передаются через единственное хранилище.

В Redux только один объект `Store`, который "объединяет" редюсер (`reducer`) и действия (`actions`).

## <a id="Actions" href="#Actions">Actions</a>

`Actions` описывают действия - описывает факт, что что-то произошло, но не указывает, как состояние приложения должно измениться в ответ. Тип действия, описывают как константу:  
`const <ТИП_ДЕЙСТВИЯ> = '<ТИП_ДЕЙСТВИЯ>';`

`Actions` - это простой объект со свойствами:
- `type` - обозначает тип действия, задается в виде константы: `<ТИП_ДЕЙСТВИЯ>`;
- `payload` - данные, которые передаются вместе с действием;
- другие свойства.

Чтобы вызвать `actions`, необходимо написать функцию, которая в рамках `Flux`/`Redux` называется - `ActionsCreator` (создатель действия), которая вернет действие.

## <a id="Reducer" href="#Reducer">Reducer</a>

`Reducer` - редуктор, изменяет состояние приложения в ответ на указанные `Actions`.

Основной смысл в том чтобы разбить глобальное состояние на кусочки, за каждый кусочек отвечает свой `reducer`. Кусочки объединяются в Корневом Редюсере (`rootReducer`).

```javascript
function <reducer>(state, action) {
	...
    return <новое_состояние>;
}
```
Где `state` - исходное состояние, а `action` - действие.

Очень важно чтобы `state` не мутировали, а создавали каждый раз новый `state`, если он изменился.

## <a id="Точка-входа" href="#Точка-входа">Точка входа</a>

### <a id="Store" href="#Store">Store</a>

`const store = createStore(<главный_reducer>, <начальное_состояние>);` - создает хранилище из `'redux'`, с начальным `reducer` и начальным состоянием (по ум. `{}`). `Store` хранит состояние приложения. Единственный путь изменить `store` - это отправить действие (dispatch action). `Store` - это не класс. После создания хранилища Redux немедленно вызывает редукторы и использует возвращенные ими значения в качестве исходного состояния. Главный компонент тогда должен оборачивать компонент и выглядеть как:

```javascript
<Provider store={store}>
    ...
</Provider>
```

`store` - это обычный объект с несколькими методами, а именно:
- `getState();` - позволяет получить состояние приложения;
- `dispatch(<action>);`  - позволяет обновлять состояния, путем вызова (отправки) действия, возвращает то что было передано, то есть `<action>`;
- `subscribe(listener)` - регистрирует слушателей в виде функции, которые вызываются в момент изменения `store`, возвращает функцию, которую необходимо вызвать для отписки;
- `replaceReducer(nextReducer)`

```javascript
const <Обернутый_компонент> = connect(
    [<функция_соответствия_состояния>, ]
    [<функция_соответствия_действий>, ]
    [<функция_слияния>, ]
    [<опции>]
)(<Компонент>)
```

Подключает React компонент к Redux `store`. Возвращает новый присоединенный компонент, который оборачивает переданный компонент - `<Connected(<Компонент>)>` и добавляет свойство, которое указывает на метод redux `store` - `dispatch`.

`<функция_соответствия_состояния>` (`mapStateToProps`) - будет вызываться каждый раз, когда состояние хранилища изменяется, преобразует состояние - текущее состояние хранилища Redux, к свойствам для компонента, т.е. соответствие `state` (глобального хранилища) к `props`. Если будет возвращён обычный объект, то возвращённый объект объединяется со свойствами компонента. Где:
- `state` - глобальное хранилище Redux;
- `ownProps` - исходные свойства, полученные компонентом.

Должна выглядеть как:

```javascript
function <функция_соответствия_состояния>(state, ownProps) {
    ...
    return {<свойство>: <значение> [, ...]};
}
```

`<функция_соответствия_действий>` (`mapDispatchToProps`) - преобразует действия к свойствам для компонента, т.е. соответствие `actions` к `props`. Где:
- `dispatch` - `dispatch` Redux;
- `ownProps` - исходные свойства, полученные компонентом.

Должна выглядеть как:

```javascript
function <функция_соответствия_действий>(dispatch, ownProps) {
    ...
    return {
        <dispatchedAction>: () => {...}
    };
}
```

```javascript
function <функция_соответствия_действий>(dispatch) {
    ...
    return {
        pageActions: bindActionCreators(<объект_ActionsCreator>, dispatch)
    };
}
```

или

```javascript
function <функция_соответствия_действий>(dispatch) {
    ...
    return {
        <метод>: () => {
            ...
            dispatch(<действие>);
            ...
        }
        [, ...]
    };
}
```

Функция из redux - `bindActionCreators` - позволяет связать функции создания действий с текущим хранилищем, и позволит вызывать во внутренних компонентах создателей действий `this.props.<ActionsCreator>(...)`, без предоставления `dispatch` объекта.

`<функция_слияния>` (`mergeProps`) - представляет собой функцию, которая принимает следующие три параметра:
- `stateProps` - объект свойств, возвращённый из вызова `<функция_соответствия_состояния>`(`mapStateToProps()`);
- `dispatchProps` - объект свойств с генераторами действий из `<функция_соответствия_действий>`(`mapDispatchToProps()`);
- `ownProps` - исходные свойства, полученные компонентом.

Эта функция возвращает простой объект со свойствами, который будет передан заключённому в обёртку компоненту. Должна выглядеть как:

```javascript
function <функция_слияния>(stateProps, dispatchProps, ownProps) {
    ...
    return {<свойство>: <значение> [, ...]};
}
```

### <a id="Комбинирование-редюсеров" href="#Комбинирование-редюсеров">Комбинирование редюсеров</a>

Используется для назначения редюсера по ответственности за секцию состояния хранилища:

```javascript
{
    <имя_секции>: <значение>
    [, ...]
}
```

```javascript
const <новый_reducer> = combineReducers({
    <имя_секции>: <reducer>
    [, ...]
});
```

`combineReducers` - возвращает новый `reducer`, который объединяет указанные `reducer`.

Теперь, каждый редюсер возвращает исходное состояние, это состояние отправляется в соответствующий раздел (секцию) хранилища. И теперь в него каждый раз передается его секция, соответствующий раздел общего состояния.

Во время действия, вызываются все редюсеры.

## <a id="Контейнеры-и-компоненты" href="#Контейнеры-и-компоненты">Контейнеры и компоненты</a>

.                         | Компонент (глупый, презентационный) `component` | Контейнер (умный) `container`
------------------------- | ----------------------------------------------- | ---
**Цель**                  | Как это выглядит (разметка, стили) | Как это работает (получение данных, обновление состояния)
**Осведомлен о Redux**    | Нет | Да
**Для считывания данных** | Читает данные из `props` | Подписан на Redux `state` (состояние)
**Для изменения данных**  | Вызывает `callback` из `props` | Отправляет (`dispatch`) Redux действие (actions)
**Пишутся**               | Вручную | Обычно, генерируются Redux

**Презентационные компоненты** "глупые" в том смысле, что они не имеют понятия о том, откуда взялись свойства, которыми они оперируют.

Презентационные компоненты никогда не должны менять данные в свойствах самостоятельно. Фактически, любой компонент, принимающий свойства должен считать, что данные неизменны и принадлежат его родителю.

**Компоненты-контейнеры** (именуются с суффиксом Container) практически всегда являются родительскими для презентационных компонентов. В определенной степени они служат посредниками между презентационными компонентами и остальным приложением.

Компоненты-контейнеры могут создаваться точно также, как и любой другой компонент React. У них также, как у остальных компонентов, есть метод `render`, но они ничего не создают для своего рендеринга, а вместо этого возвращают результат в виде презентационного компонента.  
Умные компоненты должны обращаться к состоянию только с помощью селекторов.

### <a id="Селектор" href="#Селектор">Селектор</a>

**Селектор** - это чистая функция, принимающая в качестве аргумента глобальный стейт и возвращающая его в преобразованном виде:

```javascript
function <селектор>(store) {
    ...
    return <часть_store>;
}
```

Селекторы тесно связаны с редюсерами и расположены внутри редюсеров, экспортируемых по умолчанию. Селекторы позволяют провести некоторые расчеты по данным, прежде чем данные попадут в представление. Каждый раз, когда необходимо получить часть стейта (например в `mapStateToProps`), то должны использовать селекторы.

Главная идея состоит в том, чтобы инкапсулировать внутренний стейт приложения и скрыть его от представления. Использование селекторов позволит проводить рефакторинг, изменяя только редюсер и не вносить изменения в каждый компонент представления, который от него зависит.

Вся бизнес-логика должна находиться внутри обработчиков событий (санков), селекторов и редюсеров.

### <a id="Создание-actions" href="#Создание-actions">Создание actions</a>

Практически любое действие пользователя в интерфейсе = отправка действия (dispatch actions).

Основной алгоритм работы:
1. Приложение получило изначальное состояние (initial state);
2. Пользователь что-то сделал, отправил действие (dispatch action);
3. Соответствующий редюсер обновил часть приложения, в согласии с тем, что узнал от действия;
4. Приложение изменилось и теперь отражает новое состояние;
5. ... (все повторяется по кругу, с пункта 2)

Это и есть однонаправленный поток данных.

`store.dispatch(<action>);` - отправляет действие.

### <a id="Усилители" href="#Усилители">Усилители</a>

Усилители - это middleware функции. Суть middleware функций, взять входные данные, добавить что-то и передать дальше. Middleware - это всегда функция, которая обычно возвращают функцию, если только целью middleware не является прервать цепочку вызовов.
Они добавляются при создании хранилища:

```javascript
import { createStore, applyMiddleware } from 'redux';
const store = createStore(
    <главный_reducer>,
    <начальное_состояние>,
    applyMiddleware(<middleware> [, ...])
);
```

Где `<middleware>` должно выглядеть как:

```javascript
function <middleware>(store) {
    return function (next) {
        return function (action) {
            <действия>
            return next(action);
        };
    };
};
```

Где:
- `store` - redux-store приложения;
- `next` - функция-обертка, которая позволяет продолжить выполнение цепочки;
- `action` - действие, которое было вызвано (`store.dispatch`).

### <a id="Асинхронные-actions" href="#Асинхронные-actions">Асинхронные actions</a>

Асинхронность построена на том что на каждое асинхронное действие вызывается свое действия, все построено на комбинации действий.

#### <a id="Усилитель-redux-thunk" href="#Усилитель-redux-thunk">Усилитель: redux-thunk</a>

Используется для того чтобы можно возвращать действия как функции для асинхронных запросов.

Подключение:

```javascript
import thunk from 'redux-thunk';
const store = createStore(
    rootReducer,
    applyMiddleware(thunk)
);
```

Если **action creator** (создатель действия) возвращает не простой объект, а функцию - то он выполняет его, иначе если это простой объект, то передает его дальше. И благодаря этому усилителю внутрь функции передаются как параметры функции `dispatch`, `getState` и то что вернет функция вернет вызвавший ее `dispatch`. Использование:

```javascript
function <actionCreator>() {
    return (dispatch, getState) => {...};
}
dispatch(<actionCreator>());
```

#### <a id="Усилитель-redux-saga" href="#Усилитель-redux-saga">Усилитель: redux-saga</a>

Это библиотека нацеленная делать сайд-эффекты проще и лучше путем работы с сагами.

Саги это дизайн паттерн из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.

Подключение:

```javascript
import createSagaMiddleware from 'redux-saga';
const sagaMiddleware = createSagaMiddleware();
const store = createStore(
    rootReducer,
    applyMiddleware(sagaMiddleware)
);
```

Базируются на генераторах. Использование:

```javascript
function* <saga>() {
    yield <saga_effect>()
    ...
}
sagaMiddleware.run(<saga>); // выполняет указаную сагу
```

##### <a id="Эффекты" href="#Эффекты">Эффекты</a>

Это простые объекты, которые содержат инструкции для выполнения в middleware функциях.

```javascript
import { delay } from 'redux-saga';
import { put, takeEvery, call } from 'redux-saga/effects';
function* <action_saga>() {
    yield takeEvery('<action>', <saga>); // производит связывание саги-генератора с действием, которая вызовется по определенному действию
    yield delay(<задержка_мс>); // возвращает промис, который разрешится через определенное время
    yield put(<action>); // отправляет действие
    yield call({<функция> | <генератор>}[, <арг1>[, ...]]); // выполняет функцию, которая возвращает промис или генератор
}
sagaMiddleware.run(<action_saga>);
```

Связывание действий с сагами должно использоваться в корневой саге, которая используется в `sagaMiddleware.run`, к которой подвязываются "саго-выполнители" для действий:

```javascript
import { all } from 'redux-saga/effects';
function* <root_saga>() {
    yield all([ // запускает параллельно саги на выполнение
        <saga>()
        [, ...]
    ]);
}
sagaMiddleware.run(<root_saga>);
```