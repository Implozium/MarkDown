[Содержание](#Содержание)
==========

- [Описание](#Описание)
- [Установка](#Установка)
    - [Create React App](#Create-React-App)
    - [Установка как пакетов](#Установка-как-пакетов)
- [JSX](#JSX)
    - [Создание компонента](#Создание-компонента)
        - [Комментарии внутри JSX](#Комментарии-внутри-JSX)
        - [Отрисовка (отображение) компонента](#Отрисовка-отображение-компонента)
    - [Отрисовка группы (массива) компонентов](#Отрисовка-группы-массива-компонентов)
- [Свойства](#Свойства)
    - [Хранение элементов в переменной](#Хранение-элементов-в-переменной)
    - [Использование компонентов через переменные](#Использование-компонентов-через-переменные)
    - [If - else внутри JSX](#If---else-внутри-JSX)
- [Локальное состояние](#Локальное-состояние)
- [Обработка событий](#Обработка-событий)
- [Контролируемые компоненты](#Контролируемые-компоненты)
    - [Атрибут обратного вызова `ref`](#Атрибут-обратного-вызова-ref)
        - [Создание ссылок (>= 16.3)](#Создание-ссылок--163)
    - [Контекст](#Контекст)
    - [Порталы](#Порталы)

<a id="Описание" href="#Описание">Описание</a>
========

**React** - одна из библиотек, которая придерживаются строгих соглашений о том, как структурировать код и управлять данными вашего приложения. **JSX** является результатом одного из таких соглашений. **React** воплощает идею, что разметка и код, который генерирует ее по своей природе связаны друг с другом. В **React** компонентах это реализуется генерацией разметки прямо из **JavaScript**, используя всю мощь языка.

<a id="Установка" href="#Установка">Установка</a>
=========

## <a id="Create-React-App" href="#Create-React-App">Create React App</a>

```bash
npm install -g create-react-app
create-react-app my-app
cd my-app
npm start
```
Производит установку с помощью `create-react-app`.

```bash
npm run build
```
Это создаст production-сборку приложения в сборке / папке вашего проекта.

## <a id="Установка-как-пакетов" href="#Установка-как-пакетов">Установка как пакетов</a>

```bash
npm init
npm install --save react react-dom
```

<a id="JSX" href="#JSX">JSX</a>
===

Является синтаксическим расширением JavaScript. JSX производит React-элементы.

**JSX** нужен для JavaScript XML - разметки в стиле XML внутри компонентов React. React может работать и без JSX, но именно JSX делает компоненты более читаемыми.
- **JSX** это синтаксическая трансформация - каждая JSX ветвь соответствует JavaScript функции.
- Не требует никаких библиотек для выполнения.
- **JSX** ничего не добавляет и не изменяет в JavaScript - он просто вызывает функции.

JSX трансформирует JavaScript код в семантическую осмысленную разметку.

React определяет все возможные HTML элементы в пространстве имен `React.dom`. Это к тому же позволяет использовать полностью произвольные компоненты внутри разметки.

Для того чтобы файл с JSX стал доступен для React, в начало файла нужно вставить такой заголовок: `/** @jsx React.DOM */`

Без этого JSX не поймет что файл нужно обработать для React.

React предопределяет все HTML теги которые только есть в пространстве имен `React.DOM`. JSX трансформирует их в глобальные переменные, которые позволят использовать просто `<div>...</div>` вместо того, чтобы каждый раз указывать `var div = React.dom.div` в каждом JSX файле.

После компиляции JSX-выражения становятся регулярными JavaScript-объектами. Что значит внутри можно использовать все преимущества при создании структуры компонента в HTML подобном синтаксис, который трансформируется в простые JavaScript функции.

## <a id="Создание-компонента" href="#Создание-компонента">Создание компонента</a>

Концептуально, компоненты подобны JavaScript-функциям. Они принимают произвольные данные (называемые props) и возвращают React-элементы, описывающие что должно появиться на экране.

```JSX
class <Компонент> extends React.Component {
    render() {
        return (
            <html_код_компонента>
        );
    }
};
```

```JSX
const <Компонент> = (
    <html_код_компонента>
);
```

```JSX
function <Компонент>(props) {
    return <html_код_компонента>;
}
```
Это создаст компонент. Внутри `return` всегда должен возвращаться DOM-узел (то есть, что угодно, обернутое в один, единый, родительский тэг) или `null` для того чтобы не отображать компонент. **Компонент всегда должен называться с большой буквы**.

Компоненты могут ссылаться на другие компоненты в своём выводе (результате отрисовки). Это позволяет использовать абстракцию компонента для любого уровня детализации. Внутри компонентов можно также использовать другие компоненты в `<html_код_компонента>`:  
`<<Компонент>> <контент> </<Компонент>>`

Запись `<<Компонент>/>` эквивалентна: `<<Компонент>></<Компонент>>`.

React DOM использует соглашение об именовании свойств в camelCase нотации, вместо имен HTML-атрибутов. Т.е. для того чтобы указать CSS-классы тега необходимо использовать атрибут `className` вместо стандартного `class`.
Также можно напрямую использовать js-код, для этого его необходимо заключить в:
`{<код>}`

### <a id="Комментарии-внутри-JSX" href="#Комментарии-внутри-JSX">Комментарии внутри JSX</a>

`{/* <комментарий> */}`

### <a id="Отрисовка-отображение-компонента" href="#Отрисовка-отображение-компонента">Отрисовка (отображение) компонента</a>

```JSX
ReactDOM.render(
    <<Компонент>> <контент> </<Компонент>>,
    document.getElementById('<id>')
);
```
Это вставляет компонент внутрь указанного элемента в html.

## <a id="Отрисовка-группы-массива-компонентов" href="#Отрисовка-группы-массива-компонентов">Отрисовка группы (массива) компонентов</a>

Каждый элемент в массиве должен обладать свойством `key`, для того чтобы идентифицировать, какой элемент был изменен, добавлен или удален. Ключи должны быть предоставлены элементам внутри массива, чтобы дать элементам стабильную идентифицируемость. Ключи имеют смысл только в контексте окружающего массива, т.е. **элементы внутри вызова `map()` требуют ключей**.

```JSX
const items = <массив>.map((<элемент>) => {
    return <<Компонент> key={<ключ>}>...</<Компонент>>;
});
```

Отрисовка массива будет: `<div>{items}</div>`.

<a id="Свойства" href="#Свойства">Свойства</a>
========

В свойство компонента можно передать любой javascript примитив, объект, переменную и даже выражение. Они передаются в компонент как html атрибутты:

`<<Компонент> <свойство>={<значение>}[ ...]> <контент> </<Компонент>>`

Значения свойств доступны внутри компонента как: `this.props.<свойство>`.

Если свойству значение не присвоено, но свойство написано, то оно равно по умолчанию `true`.

Для записи свойства HTML, которое использует `-` в своем название, используется camelCase именование.

В `{this.props.children}` – хранится `<контент>`, который был передан в компонент, который может быть любым значением понятным для реакта, а именно объект, строка или функция, а значения `false`, `null`, `undefined`, и `true` игнорируются.
> `<UserList users={users}>{(user) => <li key={user.id}>Пользователь: {user.name}</li>}</UserList>`

`this.props` – иммутабельная структура, используется только для чтения.

Для вывода (отображения) значения переменной внутри JSX, нужно использовать указанный синтаксис, при этом все преобразуется в строку, перед тем как будет отрисовано:  
`{<переменная>}`

`<<Компонент> {...<объект_свойств>}> <контент> </<Компонент>>` - передача всех свойств компоненту, через объект, с помощью оператора расширения.

## <a id="Хранение-элементов-в-переменной" href="#Хранение-элементов-в-переменной">Хранение элементов в переменной</a>

`const <переменная> = <Компонент>;`  
Отрисовка компонента из переменной: `{<переменная>}`.

## <a id="Использование-компонентов-через-переменные" href="#Использование-компонентов-через-переменные">Использование компонентов через переменные</a>

`const <Компонент> = <компонент>;` - всегда должен быть с большой буквы.  
`<<Компонент> .../>`

Таким способом можно передавать компоненты через свойства.

## <a id="If---else-внутри-JSX" href="#If---else-внутри-JSX">If - else внутри JSX</a>

Оно доступно внутри JSX как `{<условие> ? <код_истины> : <код_лжи>}`.  
Только if без else `{<условие> && <код_истины>}`

```JSX
<div className="solid" tabIndex="0" customProperty="value">
</div>
```

<a id="Локальное-состояние" href="#Локальное-состояние">Локальное состояние</a>
===================

Это состояние подобно свойствам `props`, но является приватным и полностью контролируется компонентом. Локальное состояние является возможностью, доступной только для классов. Используется для динамических свойств, оно хранится в `this.state`.

Для его использования необходимо:
```JSX
class <Компонент> extends React.Component {
    constructor(props) {// props - свойства переданые при создании
        super(props);
        this.state = {};// инициализация начального состояния, можно делать только в конструкторе
    }
    // срабатывает после того, как компонент был отрисован в DOM
    componentDidMount() {}
    // вызывается сразу перед тем, как компонент будет удален из DOM
    componentWillUnmount() {}
    // компонент будет примонтирован. В данный момент нет возможности посмотреть DOM элементы
    componentWillMount() {}
    // компонент получает новые props. Этод метод не вызывается в момент первого render'a. В этот момент, старые props доступны как this.props, а новые props доступны в виде nextProps ( первого аргумента функции). Если вызывать setState внутри этого метода - не будет вызван дополнительный render
    componentWillReceiveProps(nextProps) {}
    // вызывается прямо перед render, когда новые props и state получены. В этом методе нельзя вызывать setState
    componentWillUpdate() {}
    // вызывается сразу после render. Не вызывается в момент первого render'а компонента
    componentDidUpdate() {}
    // вызывается до начала процесса повторной отрисовки, где nextProps - новые props, nextState - новые state, если вернет true, то React выполнит обновление (перерисовку) компонента, при false не будет
    shouldComponentUpdate(nextProps, nextState) {}
    render() {
        return (<html_код_компонента>);
    }
};
<Компонент>.defaultProps = <объект_свойств_по_умолчанию>;
```

Чтобы получить значение свойства из состояния в JSX используется: `{this.state.<свойство>}`.

`this.state` нельзя модифицировать вручную, для этого необходимо использовате функции готового компонента:

`this.setState({<свойство>:<значение>[, ...]}[, () => {...}])` - изменяет (обновляет) состояние компонента, при этом объединяя новое состояние с предыдущим, и перерисовывает его, каждый раз должно передаваться новый экземпляр состояния с теми свойствами, которые поменялись (а не всеми) [и вызовит callback функцию после того, как новое состояние "установится"].

`this.setState((prevState, props) => {...})` - аналогично предыдущему варианту, где функция должна возвращать новое состояние, а `prevState` - предыдущее состояние, `props` - свойтва в момент отображения.

`this.setState()` - не изменяет `this.state` немедленно, а создает очередь изменений состояния. Доступ к `this.state` после вызова метода, потенциально может вернуть имеющееся (бывшее) значение.

Нельзя вызывать `setState` в `render`: так как реакт, видит изменилось состояние - начинает перерисовывать компонент - видит что изменилось состояние - начинает перерисовывать компонент и т.д.

Вызов `setState` родителя - перерисует дочерние компоненты.

<a id="Обработка-событий" href="#Обработка-событий">Обработка событий</a>
=================

Для использовании функций для обработки стандартных событий в `<html_код_компонента>` используется в нужном теге компонента, как значение необходимого свойства:

`<<тег> on<Событие> = {<функция_обработки_события>}>` - это привязывает функцию к указанному событию элемента, в эту функцию передается событие `e` -  это синтетическое событие (`SyntheticEvent`).

> `<div onClick = {(e) => {console.log(e);}}>...</div>`

На основе этого делаются произвольные события и Callback функции:

`<<тег> on<ПроизвольноеСобытие> = {<функция_обработки_события>}>`

Когда определяетcя компонент, используя ES6 класс, то общий паттерн таков: **обработчик события должен быть методом класса**. Для привязывания контекста `this` используется указаная конструкция в конструкторе класса:  
`this.<функция_обработки_события> = this.<функция_обработки_события>.bind(this);`

Теперь в свойствах компонента будет this.props.<функция_события> - которое будет содержать функцию для обратного вызова, которую необходимо будет вызвать в компоненте при указанном событии.

<a id="Контролируемые-компоненты" href="#Контролируемые-компоненты">Контролируемые компоненты</a>
=========================

Элемент ввода формы (например, `input`), значение которого контролируется React, называется "**контролируемый компонент**".

Если установлено свойство `value` для `input`, `textarea` и `select`, у которого нет `onChange` обработчика, то будет отрисовано поле только для чтения.

Если поле должно быть изменяемо, то нужно использовать `defaultValue`. А для `<input type="checkbox">` и `<input type="radio">` нужно использовать `defaultChecked`.

Для `select` выбраный `option` указывается по свойству `value` в `select`, которое должно быть равное `value` выбраного `option`. Если необходим множественный выбор, то `value` в `select` должно быть равно массиву, который состоит из значений `value` выбраных `option`.

В контролируемом компоненте, любая модификация состояния будет иметь ассоциированную функцию-обработчик. Это делает его простым для изменения или проверки данных, вводимых пользователем.

Для множественной обработки подобных полей можно воспользоваться связыванием:  
`<<тег> on<Событие>={<функция_обработки_события>.bind(this, <арг>[, ...])}>`

И тогда функция обработки будет выглядеть:  
`function <функция_обработки_события>(<арг>[, ...], e) {...}`

## <a id="Атрибут-обратного-вызова-ref" href="#Атрибут-обратного-вызова-ref">Атрибут обратного вызова `ref`</a>

Это специальный атрибут, который может быть присвоен любому компоненту. Атрибут `ref` принимает функцию обратного вызова, и вызывает ее после того, как компонент монтируется в DOM или удаляется из него. Используется для:
- анимации;
- управления фокусом, выделения текста или медиа функции;
- интеграция с другими библиотеками.

Когда атрибут `ref` используется в элементе HTML, функция обратного вызова принимает базовый элемент DOM в качестве аргумента.

Когда атрибут `ref` используется в кастомном компоненте React, функция обратного вызова принимает смонтированный экземпляр компонента в качестве аргумента.

`<<тег> ref={(input) => {this.<имя_переменной_в_классе> = input;}}>` - в переменную `<имя_переменной_в_классе> `- запишется ссылка на текущий элемент DOM или компонент.

Для прокидывания через компоненты используется, как правило, такое имя свойства: `inputRef`.

Если коллбэк атрибута `ref` определен как встроенная функция, она будет вызываться дважды во время перерисовок: сперва с `null`, а затем снова с DOM-элементом.

### <a id="Создание-ссылок--163" href="#Создание-ссылок--163">Создание ссылок (>= 16.3)</a>

`this.<имя_переменной_ссылки> = React.createRef();` - создание ссылки, как правило, они назначаются свойствам экземпляра компонента, в то время как компонент сконструирован таким образом, чтобы ссылки были доступны из любого места этого компонента.

`<<тег> ref={this.<имя_переменной_ссылки>}>` - присвоение ссылки на компонент.

`this.<имя_переменной_ссылки>.current;` - присвоит свойству `current` элемент DOM или компонента, когда компонент будет монтирован, и значение `null`, когда компонент будет демонтирован. Обновления `ref` происходят перед срабатыванием методов Жизненого Цикла `componentDidMount` или `componentDidUpdate`.

## <a id="Контекст" href="#Контекст">Контекст</a>

Контекст обеспечивает способ передачи данных через дерево компонентов без необходимости передавать свойства вручную на каждом уровне.

`const {Provider, Consumer} = React.createContext(<значение_по_умолчанию>);` - создает пару потребитель `Provider` и поставщик (провайдер) `Consumer`.

`<Provider[ value={<значение>}]>...</Provider>` - компонент, который позволяет потребителям подписываться на изменения контекста[ принимает свойство `value`, которое должно быть передано потребителям, которые являются потомками данного провайдера]. Один провайдер может быть связан со многими потребителями. Провайдеры могут быть вложенными, чтобы переопределять значения глубже в дереве.

`<Consumer>{value => ...}</Consumer>` - компонент, который подписывается на изменения контекста. Требует функцию в качестве дочернего элемента. Функция получает текущее значение контекста и возвращает узел `React`. Аргумент `value`, переданный функции, будет равен свойству `value` ближайшего поставщика для этого контекста выше в дереве. Если для данного контекста нет провайдера, аргумент `value` будет равен значению `defaultValue`, которое было передано в `createContext()`. Все потребители перерисовываются всякий раз при изменении значения поставщика.

> `<Consumer>{theme => <Button theme={theme}/>}</Consumer>`

## <a id="Порталы" href="#Порталы">Порталы</a>

Порталы предоставляют способ отображения дочерних элементов в узел DOM, который существует вне иерархии DOM родительского компонента.

`ReactDOM.createPortal(<потомок_React>, <элемент_DOM>)` - создает портал, где `<потомок_React>` - любой отображаемый потомок React, такой как элемент, строка или фрагмент, а `<элемент_DOM>` - валидный DOM-узел в который необходимо отрисовать потомок. Используется в методе `render()` компонента.

```javascript
render() {
    return ReactDOM.createPortal(this.props.children,domNode);
}
```

Несмотря на то, что портал может быть где угодно в дереве DOM, он ведет себя как обычный дочерний элемент React во всех отношениях. Такие функции, как контекст, работают как и ранее, независимо от того, является ли дочерний элемент порталом, поскольку портал все еще существует в дереве React независимо от его положения в дереве DOM.

Это же касается и всплытия события. Событие, созданное внутри портала, будет распространяться к предкам в объемлющем дереве React, даже если они не являются предками в дереве DOM.