[Содержание](#Содержание)
==========

- [Описание](#user-content-Описание)
- [Установка](#user-content-Установка)
    - [Create React App](#user-content-Create-React-App)
    - [Установка как пакетов](#user-content-Установка-как-пакетов)
- [JSX](#user-content-JSX)
    - [Создание компонента](#user-content-Создание-компонента)
        - [Комментарии внутри JSX](#user-content-Комментарии-внутри-JSX)
        - [Отрисовка (отображение) компонента](#user-content-Отрисовка-отображение-компонента)
    - [Отрисовка группы (массива) компонентов](#user-content-Отрисовка-группы-массива-компонентов)
- [Свойства](#user-content-Свойства)
    - [Хранение элементов в переменной](#user-content-Хранение-элементов-в-переменной)
    - [Использование компонентов через переменные](#user-content-Использование-компонентов-через-переменные)
    - [If - else внутри JSX](#user-content-If---else-внутри-JSX)
    - [HTML-код](#user-content-HTML-код)
- [Локальное состояние](#user-content-Локальное-состояние)
    - [Чистый компонент `React.PureComponent`](#user-content-Чистый-компонент-ReactPureComponent)
- [Цикл жизни компонента](#user-content-Цикл-жизни-компонента)
- [Обработка событий](#user-content-Обработка-событий)
- [Контролируемые компоненты](#user-content-Контролируемые-компоненты)
    - [Атрибут обратного вызова `ref`](#user-content-Атрибут-обратного-вызова-ref)
        - [Создание ссылок (>= 16.3)](#user-content-Создание-ссылок--163)
    - [Контекст](#user-content-Контекст)
    - [Порталы](#user-content-Порталы)
    - [Фрагменты `React.Fragment`](#user-content-Фрагменты-ReactFragment)
    - [Ленивые компоненты `React.Lazy`](#user-content-Ленивые-компоненты-ReactLazy)
    - [Мемоизированный компонент `React.memo`](#user-content-Мемоизированный-компонент-Reactmemo)
    - [Перенаправление рефов `React.forwardRef`](#user-content-Перенаправление-рефов-ReactforwardRef)
    - [Перерисовка компонента](#user-content-Перерисовка-компонента)
    - [Хуки](#user-content-Хуки)
        - [Стандартные хуки](#user-content-Стандартные-хуки)
            - [Хук состояния `React.useState`](#user-content-Хук-состояния-ReactuseState)
            - [Хук эффекта `React.useEffect`](#user-content-Хук-эффекта-ReactuseEffect)
            - [Хук эффекта `React.useLayoutEffect`](#user-content-Хук-эффекта-ReactuseLayoutEffect)
            - [Хук контекста `React.useContext`](#user-content-Хук-контекста-ReactuseContext)
            - [Хук редюсера `React.useReducer`](#user-content-Хук-редюсера-ReactuseReducer)
            - [Хук колбэк `React.useCallback`](#user-content-Хук-колбэк-ReactuseCallback)
            - [Хук мемоизации `React.useMemo`](#user-content-Хук-мемоизации-ReactuseMemo)
            - [Хук ссылок `React.useRef`](#user-content-Хук-ссылок-ReactuseRef)
            - [Хук переходов `React.useTransition`](#user-content-Хук-переходов-ReactuseTransition)
                - [`React.startTransition`](#user-content-ReactstartTransition)
            - [Хук идентификаторов `React.useId`](#user-content-Хук-идентификаторов-ReactuseId)
            - [Хук отладки `React.useDebugValue`](#user-content-Хук-отладки-ReactuseDebugValue)
            - [Хук отложеного значения `React.useDeferredValue`](#user-content-Хук-отложеного-значения-ReactuseDeferredValue)
        - [Пользовательские хуки](#user-content-Пользовательские-хуки)
    - [`React.Children`](#user-content-ReactChildren)
    - [`React.createElement`](#user-content-ReactcreateElement)
    - [`React.cloneElement`](#user-content-ReactcloneElement)
    - [`React.isValidElement`](#user-content-ReactisValidElement)
    - [Компоненты высшего порядка (higher order component, HOC)](#user-content-Компоненты-высшего-порядка-higher-order-component-HOC)
    - [Шаблон "render props"](#user-content-Шаблон-render-props)
- [React Router](#user-content-React-Router)
    - [Сопоставление маршрутов](#user-content-Сопоставление-маршрутов)
    - [Ссылки на роуты](#user-content-Ссылки-на-роуты)
- [Redux](#user-content-Redux)
    - [Actions](#user-content-Actions)
    - [Reducer](#user-content-Reducer)
    - [Точка входа](#user-content-Точка-входа)
        - [Store](#user-content-Store)
        - [Комбинирование редюсеров](#user-content-Комбинирование-редюсеров)
    - [Контейнеры и компоненты](#user-content-Контейнеры-и-компоненты)
        - [Селектор](#user-content-Селектор)
        - [Создание actions](#user-content-Создание-actions)
        - [Усилители](#user-content-Усилители)
        - [Асинхронные actions](#user-content-Асинхронные-actions)
            - [Усилитель: redux-thunk](#user-content-Усилитель-redux-thunk)
            - [Усилитель: redux-saga](#user-content-Усилитель-redux-saga)
                - [Эффекты](#user-content-Эффекты)
    - [`reselect`](#user-content-reselect)
    - [Хуки](#user-content-Хуки)
- [Redux-Form](#user-content-Redux-Form)
    - [Инициализация](#user-content-Инициализация)
    - [Форма](#user-content-Форма)
    - [Многоразовые компоненты](#user-content-Многоразовые-компоненты)
        - [Сложные компоненты](#user-content-Сложные-компоненты)
        - [Множественные компоненты](#user-content-Множественные-компоненты)
    - [Создатели действий](#user-content-Создатели-действий)
- [Тестирование](#user-content-Тестирование)
    - [Блок тестирования](#user-content-Блок-тестирования)
    - [React-testing-library](#user-content-React-testing-library)
        - [react](#user-content-react)
        - [userEvent](#user-content-userEvent)
        - [Redux](#user-content-Redux)
        - [Hooks](#user-content-Hooks)
- [Паттерны](#user-content-Паттерны)
    - [Структура проекта](#user-content-Структура-проекта)

<a id="Описание" href="#Описание">Описание</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========

**React** - одна из библиотек, которая придерживаются строгих соглашений о том, как структурировать код и управлять данными вашего приложения. **JSX** является результатом одного из таких соглашений. **React** воплощает идею, что разметка и код, который генерирует ее по своей природе связаны друг с другом. В **React** компонентах это реализуется генерацией разметки прямо из **JavaScript**, используя всю мощь языка.

<a id="Установка" href="#Установка">Установка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

## <a id="Create-React-App" href="#Create-React-App">Create React App</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
npm install -g create-react-app
create-react-app my-app
cd my-app
npm start
```
Производит установку с помощью `create-react-app`.

```bash
npm run build
```
Это создаст production-сборку приложения в сборке / папке вашего проекта.

## <a id="Установка-как-пакетов" href="#Установка-как-пакетов">Установка как пакетов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
npm init
npm install --save react react-dom
```

<a id="JSX" href="#JSX">JSX</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===

Является синтаксическим расширением JavaScript. JSX производит React-элементы.

**JSX** нужен для JavaScript XML - разметки в стиле XML внутри компонентов React. React может работать и без JSX, но именно JSX делает компоненты более читаемыми.
- **JSX** это синтаксическая трансформация - каждая JSX ветвь соответствует JavaScript функции;
- не требует никаких библиотек для выполнения;
- **JSX** ничего не добавляет и не изменяет в JavaScript - он просто вызывает функции.

JSX трансформирует JavaScript код в семантическую осмысленную разметку.

React определяет все возможные HTML элементы в пространстве имен `React.dom`. Это к тому же позволяет использовать полностью произвольные компоненты внутри разметки.

Для того чтобы файл с JSX стал доступен для React, в начало файла нужно вставить такой заголовок: `/** @jsx React.DOM */`

Без этого JSX не поймет что файл нужно обработать для React.

React предопределяет все HTML теги которые только есть в пространстве имен `React.DOM`. JSX трансформирует их в глобальные переменные, которые позволят использовать просто `<div>...</div>` вместо того, чтобы каждый раз указывать `var div = React.dom.div` в каждом JSX файле.

После компиляции JSX-выражения становятся регулярными JavaScript-объектами. Что значит внутри можно использовать все преимущества при создании структуры компонента в HTML подобном синтаксис, который трансформируется в простые JavaScript функции.

## <a id="Создание-компонента" href="#Создание-компонента">Создание компонента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Концептуально, компоненты подобны JavaScript-функциям. Они принимают произвольные данные (называемые `props`) и возвращают React-элементы, описывающие что должно появиться на экране.

```JSX
class <Компонент> extends React.Component {
    render() {
        return (
            <html_код_компонента>
        );
    }
};
```

```JSX
const <Компонент> = (
    <html_код_компонента>
);
```

```JSX
function <Компонент>(props) {
    return <html_код_компонента>;
}
```
Это создаст компонент. Внутри `return` всегда должен возвращаться DOM-узел (то есть, что угодно, обернутое в один, единый, родительский тэг) или `null` для того чтобы не отображать компонент. **Компонент всегда должен называться с большой буквы**.

Компоненты могут ссылаться на другие компоненты в своем выводе (результате отрисовки). Это позволяет использовать абстракцию компонента для любого уровня детализации. Внутри компонентов можно также использовать другие компоненты в `<html_код_компонента>`:  
`<<Компонент>> <контент> </<Компонент>>`

Запись `<<Компонент>/>` эквивалентна: `<<Компонент>></<Компонент>>`.

React DOM использует соглашение об именовании свойств в camelCase нотации, вместо имен HTML-атрибутов. Т.е. для того чтобы указать CSS-классы тега необходимо использовать атрибут `className` вместо стандартного `class`.
Также можно напрямую использовать js-код, для этого его необходимо заключить в:
`{<код>}`

### <a id="Комментарии-внутри-JSX" href="#Комментарии-внутри-JSX">Комментарии внутри JSX</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`{/* <комментарий> */}`

### <a id="Отрисовка-отображение-компонента" href="#Отрисовка-отображение-компонента">Отрисовка (отображение) компонента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```JSX
ReactDOM.render(
    <<Компонент>> <контент> </<Компонент>>,
    document.getElementById('<id>'),
    [<callback>]
);
```
Это вставляет компонент внутрь указанного элемента в html.

## <a id="Отрисовка-группы-массива-компонентов" href="#Отрисовка-группы-массива-компонентов">Отрисовка группы (массива) компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Каждый элемент в массиве должен обладать свойством `key`, для того чтобы идентифицировать, какой элемент был изменен, добавлен или удален. Ключи должны быть предоставлены элементам внутри массива, чтобы дать элементам стабильную идентифицируемость. Ключи имеют смысл только в контексте окружающего массива, т.е. **элементы внутри вызова `map()` требуют ключей**.

```JSX
const items = <массив>.map((<элемент>) => {
    return <<Компонент> key={<ключ>}>...</<Компонент>>;
});
```

Отрисовка массива будет: `<div>{items}</div>`.

<a id="Свойства" href="#Свойства">Свойства</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========

В свойство компонента можно передать любой javascript примитив, объект, переменную и даже выражение. Они передаются в компонент как html атрибуты:  
`<<Компонент> <свойство>={<значение>}[ ...]> <контент> </<Компонент>>`

Значения свойств доступны внутри компонента как: `this.props.<свойство>`.

Если свойству значение не присвоено, но свойство написано, то оно равно по умолчанию `true`.

Для записи свойства HTML, которое использует `-` в своем название, используется **camelCase** именование.

В `this.props.children` - хранится `<контент>`, который был передан в компонент, который может быть любым значением понятным для реакта, а именно объект, строка или функция, а значения `false`, `null`, `undefined`, и `true` игнорируются.
> `<UserList users={users}>{(user) => <li key={user.id}>Пользователь: {user.name}</li>}</UserList>`

JSX удаляет пустые строки и пробелы в начале и конце строки. Новые строки, примыкающие к тегу будут удалены. Новые строки между строковых литералов сжимаются в один пробел.

`this.props` - иммутабельная структура, используется только для чтения.

Для вывода (отображения) значения переменной внутри JSX, нужно использовать указанный синтаксис, при этом все преобразуется в строку, перед тем как будет отрисовано:  
`{<переменная>}`

`<<Компонент> {...<объект_свойств>}> <контент> </<Компонент>>` - передача всех свойств компоненту, через объект, с помощью оператора расширения.

## <a id="Хранение-элементов-в-переменной" href="#Хранение-элементов-в-переменной">Хранение элементов в переменной</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const <переменная> = <Компонент>;`  
Отрисовка компонента из переменной: `{<переменная>}`.

## <a id="Использование-компонентов-через-переменные" href="#Использование-компонентов-через-переменные">Использование компонентов через переменные</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const <Компонент> = <компонент>;` - всегда должен быть с большой буквы.  
`<<Компонент> .../>`

Таким способом можно передавать компоненты через свойства.

## <a id="If---else-внутри-JSX" href="#If---else-внутри-JSX">If - else внутри JSX</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Оно доступно внутри JSX как `{<условие> ? <код_истины> : <код_лжи>}`.  
Только if без else `{<условие> && <код_истины>}`

```JSX
<div className="solid" tabIndex="0" customProperty="value">
    {valid && <div className="valid">Profile is valided</div>}
</div>
```

## <a id="HTML-код" href="#HTML-код">HTML-код</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<<тег> dangerouslySetInnerHTML={{__html: '<html_код>'}}/>` - производит прямую вставку HTML-кода в элемент.

<a id="Локальное-состояние" href="#Локальное-состояние">Локальное состояние</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
===================

Это состояние подобно свойствам `props`, но является приватным и полностью контролируется компонентом. Локальное состояние является возможностью, доступной только для классов. Используется для динамических свойств, оно хранится в `this.state`.

Для его использования необходимо:
```JSX
class <Компонент> extends React.Component {
    /**
     * @param {Object} props свойства переданные при создании
     */
    constructor(props) {
        super(props);
        this.state = {};// инициализация начального состояния, можно делать только в конструкторе
    }
    /**
     * срабатывает после того, как компонент был отрисован в DOM
     * тут есть возможность использовать refs (к примеру для установки фокуса или задействования других компонентов), таймауты, ajax-запросы и взаимодействие с другими библиотеками
     * можно сразу вызвать setState()
     */
    componentDidMount() {}
    /**
     * вызывается сразу перед тем, как компонент будет удален из DOM
     */
    componentWillUnmount() {}
    /**
     * компонент будет примонтирован. В данный момент нет возможности посмотреть DOM элементы
     * @deprecated
     */
    componentWillMount() {}
    /**
     * компонент получает новые props
     * этот метод не вызывается в момент первого render'a. В этот момент, старые props доступны как this.props, а новые props доступны в виде nextProps. Если вызывать setState внутри этого метода - не будет вызван дополнительный render
     * @deprecated
     * @param {Object} nextProps новые свойства
     */
    componentWillReceiveProps(nextProps) {}
    /**
     * вызывается прямо перед render, когда новые props и state получены
     в этом методе нельзя вызывать setState
     * @deprecated
     */
    componentWillUpdate() {}
    /**
     * вызывается перед каждым вызовом render
     * должен возвращать объект для обновления state или null для, чтобы показать что обновлять нечего
     * @param {Object} props текущие свойства компонента
     * @param {Object} state текущий state компонента
     * @return {?Object} объект для обновления state
     */
    static getDerivedStateFromProps(props, state) {}
    /**
     * вызывается сразу после render, когда изменение еще не принято в DOM, позволяет захватить некоторую информацию из DOM
     * то что будет возвращено передается в componentDidUpdate
     * @param {Object} prevProps предыдущие свойства компонента
     * @param {Object} prevState предыдущие state компонента
     * @return {*} значение для передачи в componentDidUpdate
     */
    getSnapshotBeforeUpdate(prevProps, prevState) {}
    /**
     * вызывается сразу после render. Не вызывается в момент первого render'а компонента
     * @param {Object} prevProps предыдущие свойства компонента
     * @param {Object} prevState предыдущие state компонента
     * @param {*} snapshot результат функции getSnapshotBeforeUpdate
     */
    componentDidUpdate(prevProps, prevState, snapshot) {}
    /**
     * вызывается после того как была схвачена ошибка в компоненте
     * @param {Object} error выброшенная ошибка
     * @param {{componentStack: *}} info объект со свойством componentStack в котором содержится информация о том компоненте, который выбросил ошибку
     */
    componentDidCatch(error, info) {}
    /**
     * вызывается перед вызовом render при возникновении ошибки
     * должен возвращать объект для обновления state или null для, чтобы показать что обновлять нечего
     * @param {Object} error выброшенная ошибка
     * @return {?Object} объект для обновления state
     */
    static getDerivedStateFromError(error) {}
    /**
     * вызывается до начала процесса повторной отрисовки
     * если вернет true, то React выполнит обновление (перерисовку) компонента, при false не будет
     * @param {Object} nextProps новые свойства компонента
     * @param {Object} nextState новые state компонента
     * @return {boolean}
     */
    shouldComponentUpdate(nextProps, nextState) {}
    render() {
        return (<html_код_компонента>);
    }
};
<Компонент>.defaultProps = <объект_свойств_по_умолчанию>;
<Компонент>.displayName = '<отображаемое_имя>';
```

Чтобы получить значение свойства из состояния в JSX используется: `{this.state.<свойство>}`.

`this.state` нельзя модифицировать вручную, для этого необходимо использовать функции готового компонента:  
`this.setState({<свойство>: <значение>[, ...]}[, () => {...}])` - изменяет (обновляет) состояние компонента, при этом объединяя новое состояние с предыдущим, и перерисовывает его, каждый раз должно передаваться новый экземпляр состояния с теми свойствами, которые поменялись (а не всеми) [и вызовет callback функцию после того, как новое состояние "установится"].

`this.setState((prevState, props) => {...}[, () => {...}])` - аналогично предыдущему варианту, где функция должна возвращать новое состояние (его обновляемую часть), а `prevState` - предыдущее состояние, `props` - свойства в момент отображения [и вызовет callback функцию после того, как новое состояние "установится"].

`this.setState()` - не изменяет `this.state` немедленно, а создает очередь изменений состояния. Доступ к `this.state` после вызова метода, потенциально может вернуть имеющееся (бывшее) значение.

Нельзя вызывать `setState` в `render`: так как реакт, видит изменилось состояние - начинает перерисовывать компонент - видит что изменилось состояние - начинает перерисовывать компонент и т.д.

Вызов `setState` родителя - перерисует дочерние компоненты.

## <a id="Чистый-компонент-ReactPureComponent" href="#Чистый-компонент-ReactPureComponent">Чистый компонент `React.PureComponent`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`React.PureComponent` похож на `React.Component`. Отличие заключается в том, что `React.Component` не реализует `shouldComponentUpdate()`, а `React.PureComponent` реализует его поверхностным сравнением пропсов и состояния.  
В нем лучше использовать "чистые" дочерние компоненты.

<a id="Цикл-жизни-компонента" href="#Цикл-жизни-компонента">Цикл жизни компонента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====================

```
    Монтирование          :               Обновление             :        Демонтирование
        |                 :                                      :              |
        v                 :                                      :              |
    ---------------       :                                      :              |
    | constructor |       :  New props set­State() force­Update()  :              |
    ---------------       :     |          |            |        :              |
        |                 :     |          |            |        :              |
        v                 :     v          v            v        :              |
    ------------------------------------------------------------ :              |
    |                getDerivedStateFromProps                  | :              |
    ------------------------------------------------------------ :              |
        |                 :     |          |            |        :              |
        |                 :     v          v            |        :              |
        |                 : -------------------------   |        :              |
        |                 : | shouldComponentUpdate |   |        :              |
        |                 : -------------------------   |        :              |
        |                 :     |          |            |        :              |
        v                 :     v          x            v        :              |
    ------------------------------------------------------------ :              |
    |                           render                         | :              |     1
    ------------------------------------------------------------ :              |
        |                 :                |                     :              |
    +++ | +++++++++++++++ : ++++++++++++++ v +++++++++++++++++++ : ++++++++++++ | +++++++++
        |                 : ------------------------------------ :              |
        |                 : | getSnapshotBeforeUpdate          | :              |     2
        |                 : ------------------------------------ :              |
    +++ | +++++++++++++++ : ++++++++++++++ | +++++++++++++++++++ : ++++++++++++ | +++++++++
        v                 :                v                     :              |
    ------------------------------------------------------------ :              |
    |        React обновляет ­D­O­M и ссылки (refs)               | :              |     3
    ------------------------------------------------------------ :              |
        |                 :                |                     :              |
        v                 :                v                     :              v
    --------------------- : ------------------------------------ : ------------------------
    | componentDidMount | : |        componentDidUpdate        | : | componentWillUnmount |
    --------------------- : ------------------------------------ : ------------------------
```

Фазы:
1. Фаза **Render** - чистая и не имеет побочных эффектов. Может быть приостановлена, прервана и перезапущена самим React'ом;
2. Фаза **Pre-commit** - можно производить чтение DOM'a;
3. Фаза **Commit** - можно работать с DOM'ом, пускать побочные эффекты, намечать обновления.

<a id="Обработка-событий" href="#Обработка-событий">Обработка событий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=================

Для использовании функций для обработки стандартных событий в `<html_код_компонента>` используется в нужном теге компонента, как значение необходимого свойства:  
`<<тег> on<Событие> = {<функция_обработки_события>}>` - это привязывает функцию к указанному событию элемента, в эту функцию передается событие `e` - это синтетическое событие (`SyntheticEvent`).

> `<div onClick = {(e) => {console.log(e);}}>...</div>`

На основе этого делаются произвольные события и callback функции:  
`<<тег> on<ПроизвольноеСобытие> = {<функция_обработки_события>}>`

Когда определяетcя компонент, используя ES6 класс, то общий паттерн таков: **обработчик события должен быть методом класса**. Для привязывания контекста `this` используется указаная конструкция в конструкторе класса:  
`this.<функция_обработки_события> = this.<функция_обработки_события>.bind(this);`

Теперь в свойствах компонента будет `this.props.<функция_события>` - которое будет содержать функцию для обратного вызова, которую необходимо будет вызвать в компоненте при указанном событии.

Используется кроссбраузерную обертка `SyntheticEvents`, представляющая синтетические события и предназначенную для унификации работы с событиями DOM. Их особености:
- унифицируют особенности различных платформ, связанные с обработкой событий;
- автоматически решают задачи по управлению памятью, так как синтетические события автоматически делегируются корневому узлу, что приводит к тому, что React-разработчикам не приходится решать задачи по управлению памятью;
- в их работе используются пулы объектов, объекты синтетических событий создаются заранее и помещаются в пул объектов. Когда надобности в событии нет, оно возвращается обратно в пул.

<a id="Контролируемые-компоненты" href="#Контролируемые-компоненты">Контролируемые компоненты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========================

Элемент ввода формы (например, `input`), значение которого контролируется React, называется "**контролируемый компонент**".

Если установлено свойство `value` для `input`, `textarea` и `select`, у которого нет `onChange` обработчика, то будет отрисовано поле только для чтения.

Если поле должно быть изменяемое, то нужно использовать `defaultValue`. А для `<input type="checkbox">` и `<input type="radio">` нужно использовать `defaultChecked`.

Для `select` выбранный `option` указывается по свойству `value` в `select`, которое должно быть равное `value` выбраного `option`. Если необходим множественный выбор, то `value` в `select` должно быть равно массиву, который состоит из значений `value` выбранных `option`.

В контролируемом компоненте, любая модификация состояния будет иметь ассоциированную функцию-обработчик. Это делает его простым для изменения или проверки данных, вводимых пользователем.

Для множественной обработки подобных полей можно воспользоваться связыванием:  
`<<тег> on<Событие>={<функция_обработки_события>.bind(this, <арг>[, ...])}>`

И тогда функция обработки будет выглядеть:  
`function <функция_обработки_события>(<арг>[, ...], e) {...}`

## <a id="Атрибут-обратного-вызова-ref" href="#Атрибут-обратного-вызова-ref">Атрибут обратного вызова `ref`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это специальный атрибут, который может быть присвоен любому компоненту. Атрибут `ref` принимает функцию обратного вызова, и вызывает ее после того, как компонент монтируется в DOM или удаляется из него. Используется для:
- анимации;
- управления фокусом, выделения текста или медиа функции;
- интеграция с другими библиотеками.

Когда атрибут `ref` используется в элементе HTML, функция обратного вызова принимает базовый элемент DOM в качестве аргумента.

Когда атрибут `ref` используется в кастомном компоненте React, функция обратного вызова принимает смонтированный экземпляр компонента в качестве аргумента.

`<<тег> ref={(input) => {this.<имя_переменной_в_классе> = input;}}>` - в переменную `<имя_переменной_в_классе> `- запишется ссылка на текущий элемент DOM или компонент.

Для прокидывания через компоненты используется, как правило, такое имя свойства: `inputRef`.

Если колбэк атрибута `ref` определен как встроенная функция, она будет вызываться дважды во время перерисовок: сперва с `null`, а затем снова с DOM-элементом.

### <a id="Создание-ссылок--163" href="#Создание-ссылок--163">Создание ссылок (>= 16.3)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`this.<имя_переменной_ссылки> = React.createRef();` - создание ссылки, как правило, они назначаются свойствам экземпляра компонента, в то время как компонент сконструирован таким образом, чтобы ссылки были доступны из любого места этого компонента.

`<<тег> ref={this.<имя_переменной_ссылки>}>` - присвоение ссылки на компонент.

`this.<имя_переменной_ссылки>.current;` - присвоит свойству `current` элемент DOM или компонента, когда компонент будет монтирован, и значение `null`, когда компонент будет демонтирован. Обновления `ref` происходят перед срабатыванием методов жизненого Цикла `componentDidMount` или `componentDidUpdate`.

`ReactDOM.findDomNode(<компонент>)` - возвращает нативный DOM-элемент к которому относится компонент.

## <a id="Контекст" href="#Контекст">Контекст</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Контекст обеспечивает способ передачи данных через дерево компонентов без необходимости передавать свойства вручную на каждом уровне.

`const { Provider, Consumer } = React.createContext(<значение_по_умолчанию>);` - создает пару поставщик (провайдер) `Provider` и потребитель `Consumer`.

`<Provider[ value={<значение>}]>...</Provider>` - компонент, который позволяет потребителям подписываться на изменения контекста [принимает свойство `value`, которое должно быть передано потребителям, которые являются потомками данного провайдера]. Один провайдер может быть связан со многими потребителями. Провайдеры могут быть вложенными, чтобы переопределять значения глубже в дереве.

`<Consumer>{value => ...}</Consumer>` - компонент, который подписывается на изменения контекста. Требует функцию в качестве дочернего элемента. Функция получает текущее значение контекста и возвращает узел `React`. Аргумент `value`, переданный функции, будет равен свойству `value` ближайшего поставщика для этого контекста выше в дереве. Если для данного контекста нет провайдера, аргумент `value` будет равен значению `defaultValue`, которое было передано в `createContext()`. Все потребители перерисовываются всякий раз при изменении значения поставщика.

> `<Consumer>{theme => <Button theme={theme}/>}</Consumer>`

В свойство класса `contextType` может быть назначен объект контекста, созданный с помощью `React.createContext()`. Это позволяет использовать ближайшее и актуальное значение указанного контекста при помощи `this.context`.

```javascript
class MyClass extends React.Component {
    render() {
        let value = this.context;
        /* ... */
    }
}
MyClass.contextType = MyContext;
```

## <a id="Порталы" href="#Порталы">Порталы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Порталы предоставляют способ отображения дочерних элементов в узел DOM, который существует вне иерархии DOM родительского компонента.

`ReactDOM.createPortal(<потомок_React>, <элемент_DOM>)` - создает портал, где `<потомок_React>` - любой отображаемый потомок React, такой как элемент, строка или фрагмент, а `<элемент_DOM>` - валидный DOM-узел в который необходимо отрисовать потомок. Используется в методе `render()` компонента.

```javascript
render() {
    return ReactDOM.createPortal(this.props.children, domNode);
}
```

Несмотря на то, что портал может быть где угодно в дереве DOM, он ведет себя как обычный дочерний элемент React во всех отношениях. Такие функции, как контекст, работают как и ранее, независимо от того, является ли дочерний элемент порталом, поскольку портал все еще существует в дереве React независимо от его положения в дереве DOM.

Это же касается и всплытия события. Событие, созданное внутри портала, будет распространяться к предкам в объемлющем дереве React, даже если они не являются предками в дереве DOM.

## <a id="Фрагменты-ReactFragment" href="#Фрагменты-ReactFragment">Фрагменты `React.Fragment`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для объединения DOM узлов. Для объединения множественных элементов.

```javascript
<React.Fragment>
    <Элемент />
    <Элемент />
    {/* ... */}
</React.Fragment>
```

Сокращенный синтаксис:
```javascript
<>
    <Элемент />
    <Элемент />
    {/* ... */}
</>
```

Сам `React.Fragment` не будет присутствовать в DOM.

## <a id="Ленивые-компоненты-ReactLazy" href="#Ленивые-компоненты-ReactLazy">Ленивые компоненты `React.Lazy`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для того чтобы рендерить динамический импорт как обычный компонент.

`const <Компонент> = React.lazy(() => import('./<Компонент>'));` - автоматически загрузит бандл, содержащий `<Компонент>`, когда этот компонент будет впервые отрендерен.

Используется только внутри компонента `Suspense`, который рендерит компонент или текст из свойства `fallback` пока подгружается код компонента `<Компонент>`:
```javascript
<Suspense fallback={<компонет_при_подгрузке_компонента>}>
    <Компонент />
<Suspense/>
```

## <a id="Мемоизированный-компонент-Reactmemo" href="#Мемоизированный-компонент-Reactmemo">Мемоизированный компонент `React.memo`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используются для того чтобы всегда рендерить одинаковый результат для одних и тех же пропсов для функциональных компонентов.

`const <МемоизированныйКомпонент> = React.memo(<Компонент>[, (props, nextProps) => { ... }]);` - автоматически поверхностно сравнивает вложенные объекты в объекте `props` [с помощью указаной функции, которая должна возвращать `true`, если `nextProps` рендерит тот же результат что и `props`, иначе возвращает `false`] и если один из них изменился, то перерендеривает компонент.

## <a id="Перенаправление-рефов-ReactforwardRef" href="#Перенаправление-рефов-ReactforwardRef">Перенаправление рефов `React.forwardRef`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`React.forwardRef((props, ref) => {})` - позволяет взять `ref` из атрибутов компонента, и передать ("перенаправить") его одному из дочерних компонентов.

## <a id="Перерисовка-компонента" href="#Перерисовка-компонента">Перерисовка компонента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Основные причины перерисовки компонентов:
- модификация состояния - влекут за собой безусловную (непредотвращаемую) перерисовку (`setState`, `useEffect`);
- перерисока предка, так как отрисовка спускается вниз по древу компонентов;
- изменение значения контекста, у всех компонентов потребляющих контекст будет вызвана перерисовка;
- изменение состояния внутри хука - влечет безусловную перерисовку компонента, который использует хук.

## <a id="Хуки" href="#Хуки">Хуки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Хуки** - это функции, с помощью которых можно "подцепиться" к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов - они дают вам возможность использовать React без классов.

**Хуки** - это функции JavaScript, которые налагают два дополнительных правила:
- **Хуки** следует вызывать только на верхнем уровне. Нельзя вызывать хуки внутри циклов, условий или вложенных функций;
- **Хуки** следует вызывать только из функциональных компонентов React. Нельзя вызывать хуки из обычных JavaScript-функций. Есть только одно исключение, откуда можно вызывать хуки - это пользовательские хуки.

**Хуки** - это способ использовать повторно логику состояния, а не само состояние, каждое обращение к хуку обеспечивает совершенно изолированное состояние.

### <a id="Стандартные-хуки" href="#Стандартные-хуки">Стандартные хуки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

#### <a id="Хук-состояния-ReactuseState" href="#Хук-состояния-ReactuseState">Хук состояния `React.useState`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для хранения состояния одного значения.

`const [<переменная>, set<Переменная>] = useState([<начальное_значение>]);` - где:
- `<переменная>` - содержит значение;
- `set<Переменная>` - функция для изменения значения: `set<Переменная>(<новое_значение>)`, может принимать функцию в качестве аргумента: `state => { return <новое_состояние>; }`, где `state` - текущее состояние, а функция должна возвращать новое значение состояния, которое полностью перепишет текущее значение на момент вызова, чтобы не потерять значения используется: `{ ...state, <обновляемые_значения>}`;
- `<начальное_значение>` - начальное значение состояния, если это функция `() => { return <начальное_состояние>; }`, то она вызовится один раз только при создании и должна вернуть начальное состояние.

> `const [count, setCount] = useState(0);`

#### <a id="Хук-эффекта-ReactuseEffect" href="#Хук-эффекта-ReactuseEffect">Хук эффекта `React.useEffect`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Хук эффекта дает возможность выполнять побочные эффекты в функциональном компоненте, выполняется асинхронно.

Он выполняет ту же роль, что и `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` в React-классах, объединив их в единый API.

По умолчанию, React запускает эффекты после каждого рендера, включая первый рендер.

```javascript
useEffect(() => { // функция обновления - установки эффекта (componentDidMount, componentDidUpdate)
    ...
    [return () => { // функция сброса эффекта (componentWillUnmount)
        ...
    };]
}[, <массив_значений_зависимостей>]);
```

Каждый раз при повторном рендере, React ставит в очередь новый эффект, который заменяет предыдущий [только если изменится любое из значений в переданном массиве значений, если передавать пустой массив, то будет эффект запустится и сбросится только один раз].

Пример:
```javascript
useEffect(() => {
    function handleStatusChange(status) {
        setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
});
```

#### <a id="Хук-эффекта-ReactuseLayoutEffect" href="#Хук-эффекта-ReactuseLayoutEffect">Хук эффекта `React.useLayoutEffect`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Хук эффекта дает возможность выполнять побочные эффекты в функциональном компоненте, выполняется синхронно после всех изменений DOM. Обновления, запланированные внутри `useLayoutEffect`, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.

Он выполняет ту же роль, что и `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` в React-классах, объединив их в единый API.

По умолчанию, React запускает эффекты после каждого рендера, включая первый рендер.

```javascript
useLayoutEffect(() => { // функция обновления - установки эффекта (componentDidMount, componentDidUpdate)
    ...
    [return () => { // функция сброса эффекта (componentWillUnmount)
        ...
    };]
}[, <массив_значений_зависимостей>]);
```

Каждый раз при повторном рендере, React ставит в очередь новый эффект, который заменяет предыдущий [только если изменится любое из значений в переданном массиве значений, если передавать пустой массив, то будет эффект запустится и сбросится только один раз].

#### <a id="Хук-контекста-ReactuseContext" href="#Хук-контекста-ReactuseContext">Хук контекста `React.useContext`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для возвращения контекста.

`const <значение> = useContext(<контекст>);` - где:
- `<контекст>` - сам объект контекста;
- `<значение>` - значение контекста.

> `const value = useContext(MyContext);`

Компонент, вызывающий `useContext`, всегда будет перерендериваться при изменении значения контекста.

#### <a id="Хук-редюсера-ReactuseReducer" href="#Хук-редюсера-ReactuseReducer">Хук редюсера `React.useReducer`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Альтернатива для `useState`, когда используется сложная логика состояния, которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего.

`const [state, dispatch] = useReducer(<reducer>, <начальное_состояние>[, <функция_инициализации>]);` - где:
- `<reducer>` - редюсер - представляет собой функцию вида:
    `function reducer(state, action) {...; return <новое_состояние>;}` - где:
    - `state` - текущее значение состояния;
    - `action` - объект действия;
- `<начальное_состояние>` - начальное значение состояния;
- `<функция_инициализации>` - функция инициализации, будет вызвана со значениями `<функция_инициализации>(<начальное_состояние>)` и должна вернуть начальное значение состояния;
- `state` - текущее значение состояния;
- `dispatch` - функция отправки действий, вызывается как: `dispatch(<действие>)`.

Пример:
```javascript
function init(initialCount) {
    return {count: initialCount};
}
function reducer(state, action) {
    switch (action.type) {
        case 'increment':
            return {count: state.count + 1};
        case 'decrement':
            return {count: state.count - 1};
        case 'reset':
            return init(action.payload);
        default:
            throw new Error();
    }
}
function Counter({initialCount}) {
    const [state, dispatch] = useReducer(reducer, initialCount, init);
    return (
        <>
            Count: {state.count}
            <button onClick={() => dispatch({type: 'reset', payload: initialCount})}>Reset</button>
            <button onClick={() => dispatch({type: 'increment'})}>+</button>
            <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        </>
    );
}
```

#### <a id="Хук-колбэк-ReactuseCallback" href="#Хук-колбэк-ReactuseCallback">Хук колбэк `React.useCallback`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для возвращения мемоизированного колбэка. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров.

```javascript
const <memoizedCallback> = useCallback(() => {
    // тело функции
}[, <массив_значений_зависимостей>]);
```

Каждый раз при повторном рендере, React создаст новый колбэк [только если изменится любое из значений в переданном массиве значений, если передавать пустой массив, то будет эффект запустится и сбросится только один раз].

`useCallback(fn, deps)` - это эквивалент `useMemo(() => fn, deps)`.

#### <a id="Хук-мемоизации-ReactuseMemo" href="#Хук-мемоизации-ReactuseMemo">Хук мемоизации `React.useMemo`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для возвращения мемоизированного значения.

```javascript
const <memoizedValue> = useMemo(() => {
    // тело функции
    return <вычисленное_значение>;
}[, <массив_значений_зависимостей>]);
```

React будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.  
Если массив не был передан, новое значение будет вычисляться при каждом рендере.

#### <a id="Хук-ссылок-ReactuseRef" href="#Хук-ссылок-ReactuseRef">Хук ссылок `React.useRef`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const refContainer = useRef(<начальное_значение>);` - возвращает изменяемый ref-объект, свойство `.current` которого инициализируется переданным аргументом (`<начальное_значение>`). Возвращенный объект будет сохраняться в течение всего времени жизни компонента.

Также он удобен для сохранения любого мутируемого значения, по аналогии с тем, как используются поля экземпляра в классах (переменные экземпляра). Мутирование свойства `.current` не вызывает повторный рендер.

Благодаря тому что может хранить любые значения, то его можно использовать в связке с `useEffect` для хранения ссылочных значений, которые передаются как параметры в пользовательский хук.

В примере не будет происходить перерасчет внутренних хуков, так как зависимости от параметра `callback` не будет у них, и они все будут ссылаться только на `savedCallback`.
```jsx
function useInterval(callback) {
    const savedCallback = useRef();
    useEffect(() => {
        savedCallback.current = callback;
    });
    // ...
}
```

#### <a id="Хук-переходов-ReactuseTransition" href="#Хук-переходов-ReactuseTransition">Хук переходов `React.useTransition`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для создания перехода, который вызовет не срочное обновление, которое может быть прервано, то есть выполнит преданную функцию отложено и если будет вызвано повторно, то будет отброшен вызов предыдущей функции.

`const [isPending, startTransition] = useTransition();` - где `isPending` будет равен `true`, если есть переход и он не завершился, а `startTransition` - функция для регистрации перехода.

##### <a id="ReactstartTransition" href="#ReactstartTransition">`React.startTransition`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`startTransition(() => {...});` - добавит переход, аналогично использованию хука.

#### <a id="Хук-идентификаторов-ReactuseId" href="#Хук-идентификаторов-ReactuseId">Хук идентификаторов `React.useId`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для генерации уникального идентификатора.

`const <идентификатор> = useId();` - создает идентификатор.

#### <a id="Хук-отладки-ReactuseDebugValue" href="#Хук-отладки-ReactuseDebugValue">Хук отладки `React.useDebugValue`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для отображения информации в React DevTools.

`useDebugValue(<значение>[, (value) => <отформатированное_value>]);` - добавляет отображение информации [с использованием функции форматирования и только при просмотре хука].

#### <a id="Хук-отложеного-значения-ReactuseDeferredValue" href="#Хук-отложеного-значения-ReactuseDeferredValue">Хук отложеного значения `React.useDeferredValue`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для получения отложенного значения, которое является копией переданного значения. Может быть предыдущим значением, если впроисходит срочное обновление и вызовется повторно с новым значением после срочных обновлений.

`const <отложенное_значение> = useDeferredValue(<значение>);` - создает отложенное значение.

### <a id="Пользовательские-хуки" href="#Пользовательские-хуки">Пользовательские хуки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Имя функции хука должно начинается с `use`. Это JavaScript-функция которая может вызывать другие хуки. Эта функция может принимать что угодно в виде параметров и возвращать тоже что-либо.

Поскольку хуки являются функциями, можно передавать информацию между ними.

Хуки внутри функций не должны использоваться внутри циклов, условных операторов или вложенных функций.

Хуки должны вызываться только из React-функций.

## <a id="ReactChildren" href="#ReactChildren">`React.Children`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Представляет утилитарные функции для работы с `this.props.children`.

`React.Children.map(this.props.children, (child) => {... return ...;})` - работает аналогично функции `map` для массивов и возвращает новый массив, с исключениями, если `this.props.children` был единичный элемент, то вернется массив, если `null` или `undefined`, то `null`.

`React.Children.forEach(this.props.children, (child) => {...})` - работает аналогично функции `forEach` для массивов.

`React.Children.toArray(this.props.children)` - возвращает массив преобразованный из `this.props.children`.

`React.Children.count(this.props.children)` - возвращает количество элементов в `this.props.children`.

`React.Children.only(this.props.children)` - возвращает один элемент из `this.props.children` если он только один, иначе выдает ошибку.

## <a id="ReactcreateElement" href="#ReactcreateElement">`React.createElement`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`React.createElement(<имя_тега>[, props][, ...children])` - возвращает созданый элемент с тегом `<имя_тега>` с добавленными свойствами и дочерними компонентами.

## <a id="ReactcloneElement" href="#ReactcloneElement">`React.cloneElement`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`React.cloneElement(<react_element>[, props][, ...children])` - возвращает клон элемента с добавленными свойствами, работает аналогично: `<element.type {...element.props} {...props}>{children}</element.type>`.

## <a id="ReactisValidElement" href="#ReactisValidElement">`React.isValidElement`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`React.isValidElement(<объект>)` - возвращает `true`, если `<объект>` является валидным React-элементом.

## <a id="Компоненты-высшего-порядка-higher-order-component-HOC" href="#Компоненты-высшего-порядка-higher-order-component-HOC">Компоненты высшего порядка (higher order component, HOC)</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Компонент высшего порядка - это функция, которая принимает входной компонент и возвращает расширенную или измененную версию этого компонента - декоратор. Обычно реализуется функцией, которая принимает компонент и использует каррирование.

```javascript
const <декоратор> = ([<аргумент>[, ...]]) => (<Компонент>) => {
    const <НовыйКомпонент> = (props) => ( // модифицированная версия компонента
        ...
        return (...);
    );
    return <НовыйКомпонент>;
};
```

К именам компонентов высшего порядка обычно добавляют префикс `with`.

Компонент авторизации:
```javascript
function withAuthentication(WrappedComponent) {
    const ModifiedComponent = (props) => {
        if (!props.isAuthenticated) {
            return <Redirect to="/login" />;
        }
        return (<WrappedComponent { ...props } />);
    };
    const mapStateToProps = (state) => ({
        isAuthenticated: state.session.isAuthenticated
    });
    return connect(mapStateToProps)(ModifiedComponent);
}
```

## <a id="Шаблон-render-props" href="#Шаблон-render-props">Шаблон "render props"</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Шаблон "render props"**, или, как его еще называют, "**функция как потомок**", позволяет достичь того же самого, что достижимо с помощью компонентов высшего порядка.

Идея использования **шаблона render props** заключается в передаче управления вашей функцией рендеринга другому компоненту, который затем возвращает управление через свойство, являющееся функцией.

Может быть использован в ситуациях, где нужна некая подходящая для повторного использования логика внутри компонента, при этом данный компонент не планируется оборачивать в компонент высшего порядка.

```javascript
class <Компонент> extends React.Component {
  constructor() {
    super();
  }
  render() {
    return this.props.children([<аргумент>[, ...]])
  }
}
const App = () => (
  <div>
    <Компонент>
      {([<аргумент>[, ...]]) => (...)}
    </Компонент>
  </div>
);
```

<a id="React-Router" href="#React-Router">React Router</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

Используется для роутинга.

`const browserHistory = ReactRouter.browserHistory;` - определяет стратегию отслеживания истории. Объект `browserHistory` это синглтон.

`browserHistory.push('<путь>');` - переносит пользователя на другой URL.

```javascript
ReactDOM.render((
    <Router history={browserHistory}>
        <Route [path="<путь>"] component={<Компонент>}/> - маршрут
        [...]
        <Route [path="<путь>"] component={<Компонент>}>
            <IndexRoute component={<Компонент>} /> - корневой роутер, текущего роутера
            <вложенные_маршруты>
        </Route>
    </Router>
), document.getElementById('root'));
```
Должен помещаться в главный (корневой) элемент.

Каждый `<Route>` при совпадении URL будет выводить соответствующий компонент.

Одновременно в `'root'` будет выводиться лишь один из компонентов. Роутер переключает маршруты без запросов на сервер, при этом каждый компонент может быть самостоятельной новой страницей.

Маршруты можно вкладывать друг в друга, при этом их пути комбинируются (объединяются через `/`) по вложенности.

## <a id="Сопоставление-маршрутов" href="#Сопоставление-маршрутов">Сопоставление маршрутов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Пути в роутах можно писать в таком виде:  
`<путь>/:<переменная>[/...]`

Роутер React передаст значение `:<переменная>` в качестве свойства компоненту, внутри компонента оно будет доступно как `this.props.params.<переменная>`.

## <a id="Ссылки-на-роуты" href="#Ссылки-на-роуты">Ссылки на роуты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Ссылки на роуты должны оформляться в виде:
```javascript
<Link to="<путь>" [className="<класс>"] [activeClassName="<класс_активности>"]>
    <текст>
</Link>
```

<a id="Redux" href="#Redux">Redux</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=====

Redux-приложение это:
- состояние (state) приложения в одном месте;
- однонаправленный поток данных.

Хранилище можно рассматривать как посредника для всех изменений состояния в приложении. При использовании Redux компоненты не общаются между собой, все изменения состояния передаются через единственное хранилище.

В Redux только один объект `Store`, который "объединяет" редюсер (`reducer`) и действия (`actions`).

Архитектура Redux предполагает наличие следующих элементов:
- наличие единственного источника истины/хранилища состояния - `store`;
- состояние изменяется только чистыми функциями, определяемыми в редукторе (`reducer`);
- редуктор изменяет состояние с помощью операций (`action`) на основании их типа (`type`) и опциональной полезной нагрузки (`payload`);
- операции отправляются в редуктор из слоя представления (`view`) пользовательского интерфейса с помощью диспетчера (`dispatcher`);
- возвращение определенной части состояния или вычисление данных на его основании осуществляется с помощью селекторов (`selector`);
- асинхронные операции по типу вызовов API выполняются с помощью преобразователей (`thunks`).

## <a id="Actions" href="#Actions">Actions</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`Actions` описывают действия - описывает факт, что что-то произошло, но не указывает, как состояние приложения должно измениться в ответ. Тип действия, описывают как константу:  
`const <ТИП_ДЕЙСТВИЯ> = '<ТИП_ДЕЙСТВИЯ>';`

`Actions` - это простой объект со свойствами:
- `type` - обозначает тип действия, задается в виде константы: `<ТИП_ДЕЙСТВИЯ>` или в виде `<домен>/<событие>`;
- `payload` - данные, которые передаются вместе с действием;
- другие свойства.

Чтобы вызвать `actions`, необходимо написать функцию, которая в рамках `Flux`/`Redux` называется - `ActionsCreator` (создатель действия), которая вернет действие.

## <a id="Reducer" href="#Reducer">Reducer</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`Reducer` - редуктор, изменяет состояние приложения в ответ на указанные `Actions`.

Основной смысл в том чтобы разбить глобальное состояние на кусочки, за каждый кусочек отвечает свой `reducer`. Кусочки объединяются в Корневом Редюсере (`rootReducer`).

```javascript
function <reducer>(state, action) {
    // ...
    return <новое_состояние>;
}
```
Где `state` - исходное состояние, а `action` - действие.

Очень важно чтобы `state` не мутировали, а создавали каждый раз новый `state`, если он изменился.

## <a id="Точка-входа" href="#Точка-входа">Точка входа</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Store" href="#Store">Store</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const store = createStore(<главный_reducer>, <начальное_состояние>);` - создает хранилище из `'redux'`, с начальным `reducer` и начальным состоянием (по ум. `{}`). `Store` хранит состояние приложения. Единственный путь изменить `store` - это отправить действие (dispatch action). `Store` - это не класс. После создания хранилища Redux немедленно вызывает редукторы и использует возвращенные ими значения в качестве исходного состояния. Главный компонент тогда должен оборачивать компонент и выглядеть как:
```javascript
import { Provider } from "react-redux";
<Provider store={store}>
    ...
</Provider>
```

`store` - это обычный объект с несколькими методами, а именно:
- `getState();` - позволяет получить состояние приложения;
- `dispatch(<action>);`  - позволяет обновлять состояния, путем вызова (отправки) действия, возвращает то что было передано, то есть `<action>`;
- `subscribe(listener)` - регистрирует слушателей в виде функции, которые вызываются в момент изменения `store`, возвращает функцию, которую необходимо вызвать для отписки;
- `replaceReducer(nextReducer)`.

```javascript
const <Обернутый_компонент> = connect(
    [<функция_соответствия_состояния>, ]
    [<функция_соответствия_действий>, ]
    [<функция_слияния>, ]
    [<опции>]
)(<Компонент>)
```

Подключает React компонент к Redux `store`. Возвращает новый присоединенный компонент, который оборачивает переданный компонент - `<Connected(<Компонент>)>` и добавляет свойство, которое указывает на метод redux `store` - `dispatch`.

`<функция_соответствия_состояния>` (`mapStateToProps`) - будет вызываться каждый раз, когда состояние хранилища изменяется, преобразует состояние - текущее состояние хранилища Redux, к свойствам для компонента, т.е. соответствие `state` (глобального хранилища) к `props`. Если будет возвращен обычный объект, то возвращенный объект объединяется со свойствами компонента. Где:
- `state` - глобальное хранилище Redux;
- `ownProps` - исходные свойства, полученные компонентом.

Должна выглядеть как:
```javascript
function <функция_соответствия_состояния>(state, ownProps) {
    ...
    return {<свойство>: <значение> [, ...]};
}
```

`<функция_соответствия_действий>` (`mapDispatchToProps`) - преобразует действия к свойствам для компонента, т.е. соответствие `actions` к `props`. Где:
- `dispatch` - `dispatch` Redux;
- `ownProps` - исходные свойства, полученные компонентом.

Должна выглядеть как:
```javascript
function <функция_соответствия_действий>(dispatch, ownProps) {
    ...
    return {
        <dispatchedAction>: () => {...}
    };
}
```

```javascript
function <функция_соответствия_действий>(dispatch) {
    ...
    return {
        pageActions: bindActionCreators(<объект_ActionsCreator>, dispatch)
    };
}
```

или

```javascript
function <функция_соответствия_действий>(dispatch) {
    ...
    return {
        <метод>: () => {
            ...
            dispatch(<действие>);
            ...
        }
        [, ...]
    };
}
```

Функция из redux - `bindActionCreators` - позволяет связать функции создания действий с текущим хранилищем, и позволит вызывать во внутренних компонентах создателей действий `this.props.<ActionsCreator>(...)`, без предоставления `dispatch` объекта.

`<функция_слияния>` (`mergeProps`) - представляет собой функцию, которая принимает следующие три параметра:
- `stateProps` - объект свойств, возвращенный из вызова `<функция_соответствия_состояния>`(`mapStateToProps()`);
- `dispatchProps` - объект свойств с генераторами действий из `<функция_соответствия_действий>`(`mapDispatchToProps()`);
- `ownProps` - исходные свойства, полученные компонентом.

Эта функция возвращает простой объект со свойствами, который будет передан заключенному в обертку компоненту. Должна выглядеть как:
```javascript
function <функция_слияния>(stateProps, dispatchProps, ownProps) {
    ...
    return {<свойство>: <значение> [, ...]};
}
```

### <a id="Комбинирование-редюсеров" href="#Комбинирование-редюсеров">Комбинирование редюсеров</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для назначения редюсера по ответственности за секцию состояния хранилища:
```javascript
{
    <имя_секции>: <значение>
    [, ...]
}
```

```javascript
const <новый_reducer> = combineReducers({
    <имя_секции>: <reducer>
    [, ...]
});
```

`combineReducers` - возвращает новый `reducer`, который объединяет указанные `reducer`.

Теперь, каждый редюсер возвращает исходное состояние, это состояние отправляется в соответствующий раздел (секцию) хранилища. И теперь в него каждый раз передается его секция, соответствующий раздел общего состояния.

Во время действия, вызываются все редюсеры.

## <a id="Контейнеры-и-компоненты" href="#Контейнеры-и-компоненты">Контейнеры и компоненты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

.                         | Компонент (глупый, презентационный) `component` | Контейнер (умный) `container`
------------------------- | ----------------------------------------------- | ---
**Цель**                  | Как это выглядит (разметка, стили) | Как это работает (получение данных, обновление состояния)
**Осведомлен о Redux**    | Нет | Да
**Для считывания данных** | Читает данные из `props` | Подписан на Redux `state` (состояние)
**Для изменения данных**  | Вызывает `callback` из `props` | Отправляет (`dispatch`) Redux действие (actions)
**Пишутся**               | Вручную | Обычно, генерируются Redux

**Презентационные компоненты** "глупые" в том смысле, что они не имеют понятия о том, откуда взялись свойства, которыми они оперируют.

Презентационные компоненты никогда не должны менять данные в свойствах самостоятельно. Фактически, любой компонент, принимающий свойства должен считать, что данные неизменны и принадлежат его родителю.

**Компоненты-контейнеры** (именуются с суффиксом Container) практически всегда являются родительскими для презентационных компонентов. В определенной степени они служат посредниками между презентационными компонентами и остальным приложением.

Компоненты-контейнеры могут создаваться точно также, как и любой другой компонент React. У них также, как у остальных компонентов, есть метод `render`, но они ничего не создают для своего рендеринга, а вместо этого возвращают результат в виде презентационного компонента.  
Умные компоненты должны обращаться к состоянию только с помощью селекторов.

### <a id="Селектор" href="#Селектор">Селектор</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Селектор** - это чистая функция, принимающая в качестве аргумента глобальный стейт и возвращающая его в преобразованном виде:
```javascript
function <селектор>(store) {
    ...
    return <часть_store>;
}
```

Селекторы тесно связаны с редюсерами и расположены внутри редюсеров, экспортируемых по умолчанию. Селекторы позволяют провести некоторые расчеты по данным, прежде чем данные попадут в представление. Каждый раз, когда необходимо получить часть стейта (например в `mapStateToProps`), то должны использовать селекторы.

Главная идея состоит в том, чтобы инкапсулировать внутренний стейт приложения и скрыть его от представления. Использование селекторов позволит проводить рефакторинг, изменяя только редюсер и не вносить изменения в каждый компонент представления, который от него зависит.

По возможности селекторы должны возвращать данные из глобального стейта, а не новые данные. При возвращании новых данных лучше иметь оригинальные данные для их сверки, если они не равны, то затем использовать новые данные из селектора.

Вся бизнес-логика должна находиться внутри обработчиков событий (санков), селекторов и редюсеров.

### <a id="Создание-actions" href="#Создание-actions">Создание actions</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Практически любое действие пользователя в интерфейсе = отправка действия (dispatch actions).

Основной алгоритм работы:
1. Приложение получило изначальное состояние (initial state);
2. Пользователь что-то сделал, отправил действие (dispatch action);
3. Соответствующий редюсер обновил часть приложения, в согласии с тем, что узнал от действия;
4. Приложение изменилось и теперь отражает новое состояние;
5. ... (все повторяется по кругу, с пункта 2)

Это и есть однонаправленный поток данных.

`store.dispatch(<action>);` - отправляет действие.

### <a id="Усилители" href="#Усилители">Усилители</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Усилители - это middleware функции. Суть middleware функций, взять входные данные, добавить что-то и передать дальше. Middleware - это всегда функция, которая обычно возвращают функцию, если только целью middleware не является прервать цепочку вызовов.
Они добавляются при создании хранилища:
```javascript
import { createStore, applyMiddleware } from 'redux';
const store = createStore(
    <главный_reducer>,
    <начальное_состояние>,
    applyMiddleware(<middleware> [, ...])
);
```

Где `<middleware>` должно выглядеть как:
```javascript
function <middleware>(store) {
    return function (next) {
        return function (action) {
            <действия>
            return next(action);
        };
    };
};
```

Где:
- `store` - redux-store приложения;
- `next` - функция-обертка, которая позволяет продолжить выполнение цепочки;
- `action` - действие, которое было вызвано (`store.dispatch`).

### <a id="Асинхронные-actions" href="#Асинхронные-actions">Асинхронные actions</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Асинхронность построена на том что на каждое асинхронное действие вызывается свое действия, все построено на комбинации действий.

#### <a id="Усилитель-redux-thunk" href="#Усилитель-redux-thunk">Усилитель: redux-thunk</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для того чтобы можно возвращать действия как функции для асинхронных запросов.

Подключение:
```javascript
import thunk from 'redux-thunk';
const store = createStore(
    rootReducer,
    applyMiddleware(thunk)
);
```

Если **action creator** (создатель действия) возвращает не простой объект, а функцию - то он выполняет его, иначе если это простой объект, то передает его дальше. И благодаря этому усилителю внутрь функции передаются как параметры функции `dispatch`, `getState` и то что вернет функция вернет вызвавший ее `dispatch`. Использование:
```javascript
function <actionCreator>() {
    return (dispatch, getState) => {...};
}
dispatch(<actionCreator>());
```

#### <a id="Усилитель-redux-saga" href="#Усилитель-redux-saga">Усилитель: redux-saga</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это библиотека нацеленная делать сайд-эффекты проще и лучше путем работы с сагами.

Саги это дизайн паттерн из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.

Подключение:
```javascript
import createSagaMiddleware from 'redux-saga';
const sagaMiddleware = createSagaMiddleware();
const store = createStore(
    rootReducer,
    applyMiddleware(sagaMiddleware)
);
```

Базируются на генераторах. Использование:
```javascript
function* <saga>() {
    yield <saga_effect>()
    ...
}
sagaMiddleware.run(<saga>); // выполняет указаную сагу
```

##### <a id="Эффекты" href="#Эффекты">Эффекты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Это простые объекты, которые содержат инструкции для выполнения в middleware функциях.

```javascript
import { delay } from 'redux-saga';
import { put, takeEvery, call } from 'redux-saga/effects';
function* <action_saga>() {
    yield takeEvery('<action>', <saga>); // производит связывание саги-генератора с действием, которая вызовется по определенному действию
    yield delay(<задержка_мс>); // возвращает промис, который разрешится через определенное время
    yield put(<action>); // отправляет действие
    yield call({<функция> | <генератор>}[, <арг1>[, ...]]); // выполняет функцию, которая возвращает промис или генератор
}
sagaMiddleware.run(<action_saga>);
```

Связывание действий с сагами должно использоваться в корневой саге, которая используется в `sagaMiddleware.run`, к которой подвязываются "саго-выполнители" для действий:
```javascript
import { all } from 'redux-saga/effects';
function* <root_saga>() {
    yield all([ // запускает параллельно саги на выполнение
        <saga>()
        [, ...]
    ]);
}
sagaMiddleware.run(<root_saga>);
```

## <a id="reselect" href="#reselect">`reselect`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для мемоизации при возвращении новых данных используется эта библиотека:
```javascript
import { createSelector } from 'reselect';
const <selector1> = createSelector(
    (state[, <арг1>[, ...]]) => <часть_state_или_новое_отображение>, // должна быть чистой функцией, которая фозвращает часть state или новое отображение части state [, каждая функция принимает все переданные аргументы]
    /* ... */
    (<результат_1_функции>[, ...]) => <суммарное_отображение> // на основании результатов вызова всех предыдущих функций, должно возвращать суммарное отображение
);
// альтернативное использование
const <selector2> = createSelector(
    [
        (state[, <арг1>[, ...]]) => <часть_state_или_новое_отображение>,
        /* ... */
    ]
    (<результат_1_функции>[, ...]) => <суммарное_отображение>
);
const result = <selector1>(state[, <арг1>[, ...]]); // использование
```

## <a id="Хуки" href="#Хуки">Хуки</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const result = useSelector(state => <часть_state>);` - возвращает часть хранилища. Для удобства может принимать селектор из библиотеки `reselect`.

`const dispatch = useDispatch();` - возвращает `dispatch`.

`const store = useStore();` - возвращает `store` со всеми его методами.

<a id="Redux-Form" href="#Redux-Form">Redux-Form</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========

Используется для управления состоянием форм в в приложении React.

## <a id="Инициализация" href="#Инициализация">Инициализация</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

В корневом файле для всех редюсеров.
```jsx
...
import { reducer as formReducer } from 'redux-form';
...
const reducers = {
    ...
    form: formReducer,
};
const reducer = combineReducers(reducers);
export reducer;
```

## <a id="Форма" href="#Форма">Форма</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Базовая конструкция:
```jsx
import React, { Component } from 'react';
import {
    Field,
    reduxForm,
} from 'redux-form';
class <КлассФормы> extends Component {
    render() {
        const {
            handleSubmit, // функция обработчик формы - запускает валидации (синхронные и асинхронные) и если форма валидная, то вызывает this.props.onSubmit(values), может принимать в качестве первого параметра функцию обработки формы (values) => {}, вместо использования this.props.onSubmit
            initialValues, // объект с начальными значениями формы, где ключ - name элемента, а значение - его value
            reset, // функция, которая сбрасывает значения формы до начальных значений
            // функции создатели действий - отправляются через <actionCreator>()
            resetSection, // функция, которая сбрасывает значения секции формы до начальных значений, вызывается resetSection(<имя_секции>)
            // функции создатели действий - отправляются через <actionCreator>()
            blur, // функция, которая уводит фокус с элемента и изменяет его значение, вызывается blur(<имя_элемента>, <значение>)
            change, // функция, которая изменяет значение элемента, вызывается change(<имя_элемента>, <значение>)
            touch, // функция, которая помечает элемент, как "тронутый" для показа его ошибок, вызывается touch(<имя_элемента>)
            untouch, // функция, которая помечает элемент, как не "тронутый" для скрытия его ошибок, вызывается untouch(<имя_элемента>)
            pristine, // равно true, если форма не изменялась
            valid, // равно true, если форма проходит успешно все валидации
        } = this.props;
        return (
            <form onSubmit={handleSubmit}>
                <Field
                    name="<имя_элемента>"
                    component={<Компонент> | "input"}
                    <свойство1>={<значение>}
                />
                {*...*}
                <button type="submit" label="submit">Submit</button>
            </form>
        );
    }
}
// используется для украшения компонента <КлассФормы>
<КлассФормы> = reduxForm({
    form: '<имя_формы>', // имя формы в хранилище state (state.form.<имя_формы>)
    /**
     * Вызовется при сабмите формы, общеформенный валидатор
     * @param {Object.<string, string|Object>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @return {Object.<string, string|Object>} объект со значениями ошибок для полей формы, где ключ - name элемента, а значение - его ошибка
     */
    validate: (values) => {
        const errors = {};
        return errors;
    },
    /**
     * Вызовется при сабмите формы, общеформенный валидатор для предупреждений
     * @param {Object.<string, string|Object>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @return {Object.<string, string|Object>} объект со значениями предупреждений для полей формы, где ключ - name элемента, а значение - его предупреждение
     */
    warn: (values) => {
        const warnings = {};
        return warnings;
    },
    /**
     * Вызовется при сабмите формы, общеформенный асинхронный валидатор
     * @param {Object.<string, string>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     * @param {function(*): *} dispatch redux dispatch
     * @return {Promise} объект со значениями ошибок для полей формы, где ключ - name элемента, а значение - его ошибка
     */
    asyncValidate: (values, dispatch) => {
        return new Promise((res, rej) => {
            const errors = {};
            throw errors;
        });
    },
})(<КлассФормы>);
export default <КлассФормы>;
```

Если используется одинаковое имя `form` у форм, то используется общая для них форма.

Использование формы:
```jsx
import React, { Component } from 'react';
import { SubmissionError } from 'redux-form';
import <КлассФормы> from '<путь_к_форме>';
class App extends Component {
    /**
     * Вызовется при сабмите формы
     * @param {Object.<string, string>} values объект со значениями формы, где ключ - name элемента, а значение - его value
     */
    submit(values) {
        // внутри можно сделать асинхронные проверки и выбросить исключения с ошибками
        return new Promise((res, rej) => {
            throw new SubmissionError({
                <имя> : "<текст_ошибки>",
            });
        });
    }
    render() {
        return (
            <<КлассФормы>
                onSubmit={this.submit}
                initialValues={<объект_с_начальными_значениями>}
            />
        );
    }
}
```

## <a id="Многоразовые-компоненты" href="#Многоразовые-компоненты">Многоразовые компоненты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для обвертки полей используется `Field` из `redux-form`. Его структура:
```jsx
/**
 * Функция по валидированию
 * @param {string} value значение поля
 * @param {Object.<string, string>} allValues объект со значениями формы, где ключ - name элемента, а значение - его value
 * @param {Object.<string, string>} props объект со свойствами элемента, где ключ - имя свойства, а значение - его значение
 * @param {string} name имя поля
 * @return {string?} текст ошибки или ничего в случае ее отсутствия
 */
function <функция_проверки1>(value, allValues, props, name) {
    return '<текст_ошибки>';
}
/**
 * Функция по нормализации
 * @param {string} value значение поля
 * @param {string} previousValue предыдущее значение поля
 * @param {Object.<string, string>} allValues объект со значениями формы, где ключ - name элемента, а значение - его value
 * @param {Object.<string, string>} previousAllValues объект с предыдущими значениями формы, где ключ - name элемента, а значение - его value
 * @param {string} name имя поля
 * @return {string} новое нормализированое значение
 */
function <функция_нормализации>(value, previousValue, allValues, previousAllValues, name) {
    return '<нормализированое_значение>';
}
/**
 * Функция по парсингу значения для хранилища
 * @param {string} value значение поля
 * @param {string} name имя поля
 * @return {string} новое значение
 */
function <функция_парсинга>(value, name) {
    return '<значение>';
}
/**
 * Функция по форматированию изначального значения из хранилища
 * @param {string} value значение поля
 * @param {string} name имя поля
 * @return {string} новое значение
 */
function <функция_форматирования>(value, name) {
    return '<значение>';
}
<Field
    name="<имя_элемента>"
    component={<Компонент> | "input"}
    validate={[<функция_проверки1>]}
    normalize={<функция_нормализации>}
    parse={<функция_парсинга>}
    format={<функция_форматирования>}
    <свойство1>={<значение>}
/>
```

Все свойства, которые передаются в компонент `Field` передаются в компонент, который указан в атрибуте `component`, как `props`.

Структура компонента:
```jsx
/**
 * @param {Object} props объект со свойствами
 *
 * @param {Object} props.meta объект с метасвойствами
 * @param {boolean} props.meta.touched true, если значение изменилось
 * @param {string} props.meta.error текст ошибки
 * @param {string} props.meta.warning текст предупреждения
 * @param {boolean} props.meta.active true, если это поле имеет фокус
 * @param {string} props.meta.form имя формы элемента
 * @param {function} props.meta.dispatch dispatch
 * @param {string} props.meta.initial начальное значение элемента
 * @param {boolean} props.meta.invalid true, если это поле не прошло валидацию
 *
 * @param {Object} props.input объект со свойствами для деструктуризации для input
 * @param {boolean} props.input.checked true, если значение есть
 * @param {string} props.input.name имя поля
 * @param {function (Event, string=, string=, string=): void} props.input.onChange функция вызываемая при изменении поля
 * @param {*} props.input.value значение поля
 */
export const <Компонент> = ({
    meta: {
        touched,
        error,
        warning,
        active,
        form,
        dispatch,
        initial,
        invalid,
    },
    input: {
        checked,
        name,
        onChange,
        value,
    },
    ...other,
}) => {
    return ();
};
```

### <a id="Сложные-компоненты" href="#Сложные-компоненты">Сложные компоненты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Сложный компонент состоит из `Field`, которые используются в компоненте `FormSection`.

Структура сложного компонента:
```jsx
class <СложныйКомпонент> extends React.Component {
    render() {
        return <div>
                <Field
                    name="<имя_элемента>"
                    component={<Компонент> | "input"}
                    <свойство1>={<значение>}
                />
                {/*...*/}
        </div>
    }
}
```

Использование:
```jsx
import { FormSection } from 'redux-form';
class <КлассФормы> extends React.Component {
    render() {
        return <form onSubmit={...}>
            <FormSection name="<имя_секции1>">
                <СложныйКомпонент/>
            </FormSection>
            <FormSection name="<имя_секции2>">
                <СложныйКомпонент/>
            </FormSection>
        </form>
    }
}
```

Тогда при сабмите формы, список полей `values` будет в виде:
```js
{
    <имя_элемента1>: <значение>,
    <имя_элемента2>: <значение>,
    <имя_секции1>: {
        <имя_элемента1>: <значение>,
        <имя_элемента2>: <значение>
    },
    <имя_секции2>: {
        <имя_элемента1>: <значение>,
        <имя_элемента2>: <значение>
    },
}
```

### <a id="Множественные-компоненты" href="#Множественные-компоненты">Множественные компоненты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Реализуются с помощью `FieldArray`. Он используется для объединения блоков в массив.

Структура сложного компонента:
```jsx
class <СложныйКомпонент> extends React.Component {
    render() {
        const {
            fields, // список для управления элементами массива
        } = this.props;
        return <div>
            {fields.map((elemName, i, fields) => ( // elemName - сформированое вложеное имя элемента, i - номер по порядку, fields - ссылка на fields из props
                <div key={i}>
                    <Field
                        name={`${elemName}.<имя_элемента1>`}
                        component={<Компонент> | "input"}
                        <свойство1>={<значение>}
                    />
                    <Field
                        name={`${elemName}.<имя_элемента1>`}
                        component={<Компонент> | "input"}
                        <свойство1>={<значение>}
                    />
                    {/*производит удаление элемента из массив*/}
                    <button type="button" onClick={() => fields.remove(i)}>
                    Remove
                    </button>
                    <hr/>
                </div>
            ))}
            <div>
                {/*производит добавление элемента в массив*/}
                <button type="button" onClick={() => fields.push({})}>
                Add
                </button>
            </div>
        </div>
    }
}
```

Использование:
```jsx
import { FieldArray } from 'redux-form';
class <КлассФормы> extends React.Component {
    render() {
        return <form onSubmit={...}>
            <FieldArray
                name={'<имя_массива>'}
                component={<СложныйКомпонент>}
            />
        </form>
    }
}
```



## <a id="Создатели-действий" href="#Создатели-действий">Создатели действий</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```js
import {
    // функции создатели действий - отправляются через dispatch(<actionCreator>())
    blur, // функция, которая уводит фокус с элемента и изменяет его значение, вызывается blur(<имя_формы>, <имя_элемента>, <значение>)
    change, // функция, которая изменяет значение элемента, вызывается change(<имя_формы>, <имя_элемента>, <значение>)
    touch, // функция, которая помечает элемент, как "тронутый" для показа его ошибок, вызывается touch(<имя_формы>, <имя_элемента>)
    untouch, // функция, которая помечает элемент, как не "тронутый" для скрытия его ошибок, вызывается untouch(<имя_формы>, <имя_элемента>)
} from 'redux-form';
```

<a id="Тестирование" href="#Тестирование">Тестирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

Используется библиотека Jest для запуска тестов.

## <a id="Блок-тестирования" href="#Блок-тестирования">Блок тестирования</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Файлы с тестами именуются по такому формату: `<имя_файла>.test.js`.

```javascript
import React from "react";
import { render, unmountComponentAtNode } from "react-dom";
import { act } from "react-dom/test-utils";
import <Компонент> from "./<имя_файла>";
let container = null;
beforeEach(() => {
    // подготавливается DOM-элемент, куда будем происходить рендер
    container = document.createElement("div");
    document.body.appendChild(container);
});
afterEach(() => {
    // удаляется DOM-элемент при завершении теста, для очистки
    unmountComponentAtNode(container);
    container.remove();
    container = null;
});
it("<имя_теста>", () => {
    // рендер компонента
    // вспомогательная функция, которая проверяет, что все обновления,
    // связанные с этими "блоками", выполнены и применены к DOM
    // до проверки предполагаемого вывода
    act(() => {
        render(<<Компонент> />, container);
    });
    // проверки компонета
    expect(container.textContent).toBe("<значение>");
});
```

Пример тестов:
```javascript
it("renders with or without a name", () => {
    act(() => {
        render(<Hello />, container);
    });
    expect(container.textContent).toBe("Hey, stranger");
    act(() => {
        render(<Hello name="Jenny" />, container);
    });
    expect(container.textContent).toBe("Hello, Jenny!");
    act(() => {
        render(<Hello name="Margaret" />, container);
    });
    expect(container.textContent).toBe("Hello, Margaret!");
});
```

## <a id="React-testing-library" href="#React-testing-library">React-testing-library</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Используется для тестирования компонентов.

Базовое строение теста:
```javascript
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import <Компонент> from './<имя_файла>';
test("<имя_теста>", () => {
    // рендер компонента
    render(<<Компонент> />);
    // проверки компонета
    expect(screen.getByLabelText<HTMLSelectElement>('From')).toBeInTheDocument();
});
```

`expect` - используется для проверки утверждений.

Основные выражения:
- `toBeNull()` - ожидание, что элемент будет равен `null`;
- `toBeInTheDocument()` - ожидание, что элемент будет есть в DOM;
- `toBeTruthy()` - ожидание, что значение истино;
- `toHaveTextContent('<содержимое>')` - ожидание, что в элементе будет содержимое;
- `toBe(<значение>)` - ожидание, что значение будет равно указаному значению.

Отрицание вводится префиксом: `.not`.

> `expect(screen.getByText<HTMLSpanElement>(/balance/i)).not.toHaveTextContent('10');`

### <a id="react" href="#react">react</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`render` - используется для рендера компонента.

`screen` - объект с помошью которого можно получить доступ к DOM-дереву.

Основные методы поиска:
- префикс:
    - `getBy` - поиск элементов, которые присутсвуют на странице - возвращает элемент;
    - `queryBy` - поиск элементов, которых нет на странице;
    - `findBy` - поиск элементов, которые зависят от асинхронного кода - возвращает промис, который разрешиться когда элемент появится.
- метод поиска:
    - `Text`;
    - `Role` - поиск по логической роли элемента;
    - `LabelText`;
    - `PlaceholderText`;
    - `AltText`;
    - `DisplayValue`;
    - `TestId` - поиск по атрибуту `data-testid`;
    - `Title`.
- модификатор:
    - `All` - для поиска всех элементов.

Поиск: `screen.<префикс>[<модификатор>][<метод_поиска>][<<тип>>]('<строка_поиска>')` (или регулярное выражение):
> `await screen.findByText<HTMLInputElement>(/Hello/)`

### <a id="userEvent" href="#userEvent">userEvent</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Позволяет производить взаимодействия с элементами DOM.

Основные методы взаимодействия:
- `click(<элемент>)` - нажимает на элемент;
- `dblClick(<элемент>)` - дважды нажимает на элемент;
- `type(<элемент>, '<текст>')` - вводит текст;
- `clear(<элемент>)` - очищает поле ввода (только `<input/>` и `<select/>`);
- `tab()` - нажимает на tab;
- `hover(<элемент>)` - наводит мышку;
- `unhover(<элемент>)` - убирает наведения мышки;
- `upload(<элемент>, <файл>)` - згружает файла;
- `selectOptions(<элемент>, <идентификатор>)` - выбирает из выпадающего списка (`<select />`);
- `deselectOptions(<элемент>)` - убрирает выбор;
- `paste(<элемент>)` - вставляет из буфера обмена;
- `keyboard(<элемент>, <клавиша>)` - нажимает клавишу.

> `userEvent.type(screen.getByLabelText<HTMLInputElement>('Amount'), '10');`

Альтернатива использования - это `fireEvent`, которая использует более низкоуровневую абстракцию.

> `fireEvent.change(screen.getByLabelText<HTMLInputElement>('Amount'), {target: { value: '10' }});`

### <a id="Redux" href="#Redux">Redux</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для тестирования Redux-компонентов, используется конструкция:
```tsx
const renderWithRedux = (
    component: JSX.Element,
    { initialState,
        store = createStore(reducer, initialState)
    }: {initialState?: WalletItem[]; store?: any } = {},
) => {
    return {
        ...render((
            <Provider store={store}>
            {component}
            </Provider>,
        store
    };
}
```

Где у возвращаемого `store` можно использовать `store.getState()` для доступа к хранилищу Redux.

### <a id="Hooks" href="#Hooks">Hooks</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для тестирования хуков используется `renderHook`:
```js
import { renderHook, act } from '@testing-library/react-hooks';
import <хук> from '<путь>';
test('<имя_теста>', () => {
    const { result, rerender } = renderHook(
        (<props>) => <хук>([<аргумент1>[, ...]]),
        {
            initialProps: <props>,
        }
    );
    rerender(<props>); // перерендер хука с новыми аргументами
    // выполнение действий с хуком по изменению его
    act(() => {
        result.current.<метод>(...);
    });
    expect(result.current.<свойство>).toBe(<значение>);
});
```

Пример:
```js
test('should reset counter to updated initial value', () => {
    const { result, rerender } = renderHook(({ initialValue }) => useCounter(initialValue), {
        initialProps: { initialValue: 0 }
    });
    rerender({ initialValue: 10 });
    act(() => {
        result.current.reset();
    });
    expect(result.current.count).toBe(10);
});
```

<a id="Паттерны" href="#Паттерны">Паттерны</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========

## <a id="Структура-проекта" href="#Структура-проекта">Структура проекта</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
project
|-- src // распологает исходный код
    |-- API // содержит методы для взаимодействия с внешним API, парсеры для данных и адаптеры к ним, а также моки
        |-- index.ts
    |-- components // содержит базовые компоненты
        |-- Component1.tsx
        |-- Component2
            |-- index.tsx // все внутреннии компоненты доступны наружу через этот файл
            |-- Part1OfComponent2.tsx
        |-- ...
    |-- hocs // содержит компоненты высшего порядка (HOC)
        |-- withHOC1.tsx
        |-- ...
    |-- hooks // содержит общие хуки по проекту
        |-- useHook1.tsx
        |-- ...
    |-- pages // содержит страницы приложения
        |-- Page1.tsx
        |-- ...
    |-- store // содержит хранилище с данными для приложения, должно работать вне зависимости от самого приложения реакта, содержит функции для взаимодействия с API
        |-- index.ts
        |-- ...
    |-- utils // содержит вспомогательные функции, структуры, классы для работы приложения
        |-- util1.ts
    |-- App.tsx // главный компонент, в котором подключается и используется все что нужно для проекта
    |-- types.ts // содержит описание всех общих типов в приложении
|-- index.tsx // входная точка в проект
|-- package.json
```