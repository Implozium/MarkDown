[Содержание](#Содержание)
==========

- [Описание](#Описание)
- [Установка](#Установка)
    - [Подключение через `<script>`](#Подключение-через-script)
- [Основы](#Основы)
    - [Экземпляр Vue](#Экземпляр-Vue)
    - [Диаграмма жизненного цикла](#Диаграмма-жизненного-цикла)
    - [Синтаксис шаблонов](#Синтаксис-шаблонов)
        - [Интерполяции](#Интерполяции)
        - [Директивы](#Директивы)
            - [Условные директивы](#Условные-директивы)
            - [Отображение перебираемых объектов с помощью директивы `v-for`](#Отображение-перебираемых-объектов-с-помощью-директивы-v-for)
            - [Директива обработки событий `v-on`](#Директива-обработки-событий-v-on)
    - [Работа с формами](#Работа-с-формами)
- [Основы компонентов](#Основы-компонентов)
    - [Слоты](#Слоты)
        - [Входные параметры слота](#Входные-параметры-слота)
    - [События компонента](#События-компонента)
        - [Вызов событий компонента](#Вызов-событий-компонента)
        - [Прослушивание событий компонента](#Прослушивание-событий-компонента)
    - [Динамическое переключение компонентов](#Динамическое-переключение-компонентов)
    - [Алиас компонета](#Алиас-компонета)
    - [Доступы](#Доступы)
- [Правила описания компонентов](#Правила-описания-компонентов)
    - [Порядок опций компонента/экземпляра](#Порядок-опций-компонентаэкземпляра)
    - [Порядок атрибутов элемента](#Порядок-атрибутов-элемента)
- [Анимирование](#Анимирование)
- [Примеси](#Примеси)
    - [Слияние опций](#Слияние-опций)
    - [Глобальные примеси](#Глобальные-примеси)
- [Пользовательские директивы](#Пользовательские-директивы)
- [Плагины](#Плагины)
- [Vuex](#Vuex)
    - [Установка](#Установка)
    - [Подключение](#Подключение)
    - [Структура](#Структура)
    - [Модули](#Модули)
    - [Структура](#Структура)

<a id="Описание" href="#Описание">Описание</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
========

**Vue** (произносится */vjuː/*, примерно как **view**) - это прогрессивный фреймворк для создания пользовательских интерфейсов. **Vue** создан пригодным для постепенного внедрения. Его ядро в первую очередь решает задачи уровня представления (view), что упрощает интеграцию с другими библиотеками и существующими проектами.

<a id="Установка" href="#Установка">Установка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=========

## <a id="Подключение-через-script" href="#Подключение-через-script">Подключение через `<script>`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<script src="https://cdn.jsdelivr.net/npm/vue"></script>` - для прототипов.  
`<script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>` - для релиза.

<a id="Основы" href="#Основы">Основы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
======

## <a id="Экземпляр-Vue" href="#Экземпляр-Vue">Экземпляр Vue</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`const vm = new Vue(<опции>)` - создание экземпляра `Vue`. Переменную с экземпляром `Vue` традиционно именуют `vm` (сокращенно от **ViewModel**). Где `<опции>` представляют собой объект со свойствами:
- `data` - объект с данными, **Vue** добавляет все свойства, найденные в опции `data`, в систему реактивности **Vue**, это означает что если изменять свойство `data.<свойство>`, то изменится и свойство `vm.<свойство>` и наоборот. Чтобы свойсво было реактивным, оно должно существовать в объекте изначально;
- `el` - строка селектора куда будет отрисован экземпляр;

Свойства и методы экземпляра (их имена начинаются с префикса `$`, чтобы отличаться от пользовательских свойств):
- `$data` - ссылка на изначальный объект из опций `data`;
- `$el` - DOM-элемент селектора из опций `el`;

```javascript
const vm = new Vue({
    /**
     * Объект с данными, **Vue** добавляет все свойства, найденные в опции `data`,
     * в систему реактивности **Vue**, это означает что если изменять свойство
     * `data.<свойство>`, то изменится и свойство `vm.<свойство>` и наоборот.
     * Чтобы свойсво было реактивным, оно должно существовать в объекте изначально
     * @type {{}}
     */
    data: {},
    /**
     * Строка селектора куда будет отрисован экземпляр
     * @type {string=}
     */
    el: '',
    /**
     * Объект для определения вычисляемых свойств. При изменении свойств,
     * вычисляемые свойства вычислятся из функций. Могут быть изменяемыми.
     * При этом вычисляемые свойства кэшируются, основываясь на своих реактивных зависимостях
     * @type {Object.<string, {get: function (), set: function (string)} | function ()>=}
     */
    computed: {
        "property": function () {
            // `this` указывает на экземпляр vm
            return '<newValue>' || {};
        },
        "property2": {
            get: function () {
                // `this` указывает на экземпляр vm
                return '<newValue>' || {};
            },
            set: function (newValue) { // где newValue - новое значение
                // `this` указывает на экземпляр vm
            }
        }
    },
    /**
     * Объект для слежения за свойствами.
     * Будут вызваны указаные функции при изменении указаного свойства или подсвойства свойства и т.д.
     * @type {Object.<string, {handler: function (*, *), deep: boolean, immediate: boolean} | string | function () | *[]>=}
     */
    watch: {
        "property": function (value, oldValue) { // где value - текущее значение, уже измененное, oldValue - старое значение
            // `this` указывает на экземпляр vm
        },
        "property.subproperty": function (value, oldValue) { // где value - текущее значение, уже измененное, oldValue - старое значение
            // `this` указывает на экземпляр vm
        }
        "property2": "<имя_метода>", // при изменении свойства будет вызван метод
        "property": {
            handler: function (value, oldValue) { // обработчик, где value - текущее значение, уже измененное, oldValue - старое значение
                // `this` указывает на экземпляр vm
            },
            deep: true, // будет наблюдать за всеми свойствами объекта, независимо от глубины их вложенности
            immediate: true, // обработчик будет вызван сразу же после начала наблюдения
        }
    },
    /**
     * Объект для методов.
     * @type {Object.<string, function (Event) | function (*)>=}
     */
    methods: {
        name: function (event) {
            // `this` указывает на экземпляр vm
        }
    },
    /**
     * Объект для объявления локальных компонентов,
     * которые будут видны только внутри этого компонента, при этом
     * локально зарегистрированные компоненты не будут доступны в дочерних компонентах
     * @type {Object.<string, object>=}
     */
    components: {
        'component-1': {
            // опции компонента
        }
    },
    /**
     * Хук, который выполнится после создания экземпляра
     * @type {function ()=}
     */
    created: function () {
        // `this` указывает на экземпляр vm
    },
});
```

## <a id="Диаграмма-жизненного-цикла" href="#Диаграмма-жизненного-цикла">Диаграмма жизненного цикла</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

![](../assets/Vue/lifecycle.png)

## <a id="Синтаксис-шаблонов" href="#Синтаксис-шаблонов">Синтаксис шаблонов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Шаблоны могут как находится в DOM-дереве, так и в `<script type="text/x-template"><текст_шаблона></script>`.

### <a id="Интерполяции" href="#Интерполяции">Интерполяции</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`{{ <имя_свойства> }}` - выражение в фигурных скобках будет заменено значением свойства `<имя_свойства>` соответствующего объекта данных и оно будет обновлено при любом изменении этого свойства.  
Можно указывать любое выражение JavaScript, которое возвращает данные. Из глобальных объектов доступны только объекты `Math` и `Date`.

> `{{ message.split('').reverse().join('') }}`

### <a id="Директивы" href="#Директивы">Директивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

**Директивы** - это специальные атрибуты с префиксом `v-`. В качестве значения они принимают одно выражение JavaScript (за исключением `v-for`). Директива реактивно применяет к DOM изменения при обновлении значения этого выражения. Значение директивы интерполируется и в глобальной видимости у него доступны все свойства объекта данных, т.е. `<имя_свойства>` - будет заменено на значение этого свойства.

При использовании директивы `v-once` у элемента, это свойство будет отрисовано **только раз** и не будет обновляться.

> `<span v-once>Это сообщение никогда не изменится: {{ msg }}</span>`

При использовании директивы `v-html="<имя_свойства>"` у элемента, это свойство будет **интерпретированно как обычный HTML** и вставленно внутрь этого элемента.

> `<p>Директива v-html: <span v-html="rawHtml"></span></p>`

Для указания **значений атрибутов** используется директива `v-bind:<имя_атрибута>="<имя_свойства>"` у элемента. Для логических атрибутов действеут такое правило, если значение будет `null`, `undefined` или `false`, то атрибут не добавится в элемент. Можно использовать динамические аргументы: `v-bind:[<имя_свойства>]="<имя_свойства>"`. Для сокращения используется вместо `v-bind:` - `:`. При этом значение атрибутов вычисляется динамически.

> `<button v-bind:disabled="isButtonDisabled">Кнопка</button>`  
> `<a v-bind:[attributeName]="url"> ... </a>`

Для передачи всех свойств из объекта используется конструкция: `v-bind="<имя_свойства>"`.

> `<blog-post v-bind="post"></blog-post>` для `post: {id: 1, title: 'My Journey with Vue'}`
> будет равно `<blog-post v-bind:id="post.id" v-bind:title="post.title"></blog-post>`

Для указания **классов** используется директива `v-bind:class="{<имя_класса>: <имя_свойства>}"` или `v-bind:class="<имя_свойства_объекта_классов>"` или `v-bind:class="[<имя_свойства1>[, ...]]"` у элемента. При истинном значении ключа `<имя_класса>` указанный `<имя_класса>` будет добавлен к элементу, при ложном удален.

> `<div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>`  
> `<div class="static" v-bind:class="classObject"></div>`  
> `<div v-bind:class="[activeClass, errorClass]"></div>`  
> `<div v-bind:class="[{ active: isActive }, errorClass]"></div>`

Для указания **inline-стилей** используется директива `v-bind:style="{<имя_css_свойсва>: <имя_свойства>}"` или `v-bind:style="<имя_свойства_css_свойсв>"` у элемента.

> `<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>`  
> `<div v-bind:style="styleObject"></div>`

#### <a id="Условные-директивы" href="#Условные-директивы">Условные директивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

При использовании директивы `v-if="<имя_свойства>"` у элемента, **Vue** удалит или вставит элемент в зависимости от истинности значения выражения `<имя_свойства>`.

> `<p v-if="seen">Сейчас меня видно</p>`

Для группировки используется псевдоэлемент `<template>`, который служит невидимой оберткой и сам в результатах отрисовки не появляется.

Для указания блока **else if** для `v-if` используется директива `v-else-if`. Элемент с директивой `v-else-if` должен следовать сразу за элементом с директивой `v-if` или `v-else-if`, иначе он не будет распознан.  
Для указания блока **иначе** для `v-if` используется директива `v-else`. Элемент с директивой `v-else` должен следовать сразу за элементом с директивой `v-if` или `v-else-if`, иначе он не будет распознан.

```html
<template v-if="ok">
    <h1>Заголовок</h1>
    <p>Абзац 1</p>
    <p>Абзац 2</p>
</template>
<div v-else-if="type === 'C'">
    <p>Абзац C</p>
</div>
<div v-else>
    <p>Абзац 2</p>
</div>
```

При использовании директивы `v-show="<имя_свойства>"` у элемента, **Vue** скроет или покажет элемент в зависимости от истинности значения выражения `<имя_свойства>`, при этом элемент будет всегда оставаться в DOM, а изменяться будет лишь свойство `display` в его параметрах CSS.

> `<h1 v-show="ok">Привет!</h1>`

#### <a id="Отображение-перебираемых-объектов-с-помощью-директивы-v-for" href="#Отображение-перебираемых-объектов-с-помощью-директивы-v-for">Отображение перебираемых объектов с помощью директивы `v-for`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для массивов используется директива `v-for="<имя_элемента_массива> in <имя_свойства>"` или `v-for="(<имя_элемента_массива>, <индекс>) in <имя_свойства>"` у элемента. Где `<имя_элемента_массива>` - ссылка на текущий элемент массива. Вместо `in` разделителем можно использовать `of`, как в итераторах JavaScript.

Рекомендуется всегда указывать атрибут `key` с `v-for`, через директиву `v-bind:key="<имя_элемента_массива>.<ключ>"`, кроме случаев когда итерируемый контент DOM прост, или используется стратегия обновления по умолчанию для улучшения производительности.

```html
<li v-for="(item, index) in items" v-bind:key="item.id">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
</li>
```

Для объектов аналогично используется директива `v-for="<имя_значения_ключа_объекта> in <имя_свойства>"` или `v-for="(<имя_значения_ключа_объекта>, <имя_ключа_объекта>) in <имя_свойства>"` или `v-for="(<имя_значения_ключа_объекта>, <имя_ключа_объекта>, <индекс>) in <имя_свойства>"` у элемента. Где `<имя_значения_ключа_объекта>` - ссылка на текущие значение объекта.

```html
<div v-for="(value, name, index) in object">
    {{ index }}. {{ name }}: {{ value }}
</div>
```

Для изменения значений элемента массива или ключей объекта используется (также для добавления нового ключа):  
`Vue.set(vm.<имя_свойства>, <индекс_ключ>, <значение>)` или для массива `vm.<имя_свойства>.splice(<индекс>, 1, <значение>)` вместо `vm.<имя_свойства>[<индекс_ключ>] = <значения>`.

Для удаления ключа используется:  
`Vue.delete(vm.<имя_свойства>, <индекс_ключ>)`

Подобно использованию с `v-if`, также можно использовать тег `<template>` с директивой `v-for` для отображения блока из нескольких элементов.

Когда присутствуют вместе на одном элементе, `v-for` имеет больший приоритет, чем `v-if`. Поэтому `v-if` будет выполняться для каждой итерации цикла.

```html
<li v-for="todo in todos" v-if="!todo.isComplete">
    {{ todo }}
</li>
```

#### <a id="Директива-обработки-событий-v-on" href="#Директива-обработки-событий-v-on">Директива обработки событий `v-on`</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для указания **функций обработки событий** используется директива `v-on:<имя-события>[<имя_модификатора>]="<имя_метода>"` у элемента, где `<имя-события>` может быть нативным событием или собственным. Можно использовать динамические аргументы: `v-on:[<имя_свойства>]="<имя_метода>"`. Для сокращения используется вместо `v-on:` - `@`. Специальная переменная `$event` передает в метод оригинальное событие DOM или первое значение события, которое было передано в методе `$emit('<событие>', <значение>)`.

> `<a v-on:click.prevent="doSomething"> ... </a>`  
> `<a v-on:[eventName]="doSomething"> ... </a>`  
> `<button v-on:click="say('hi', $event)">Скажи hi</button>`  

Модификаторы событий:
- `.stop` - предотвращает всплытие события;
- `.prevent` - убирает действие по умолчанию;
- `.capture` - указывает перехватывать все события внутренних компонентов в этом методе;
- `.self` - только при наступлении события у указаного элемента;
- `.once` - вызов обработчика только единождый;
- `.passive` - предотвращает вызов `event.preventDefault()`;
- `.native` - для подписывания на нативное событие.

Для передачи всех обработчиков событий из объекта используется конструкция: `v-on="<имя_свойства>"`. Свойство `$listeners` содержит все слушатели событий.

> `<input v-bind="$attrs" v-bind:value="value" v-on="inputListeners">`

Когда `vm` уничтожается, все слушатели событий автоматически удаляются. Нет необходимости волноваться, что придется прибираться за собой.

## <a id="Работа-с-формами" href="#Работа-с-формами">Работа с формами</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для двунаправленного связывания данных с элементами форм `input`, `textarea` и `select` используется директива `v-model="<имя_свойства>"`.  
`v-model` игнорирует начальное значение атрибутов `value`, `checked` или `selected` на любых элементах форм. Данные экземпляра **Vue** всегда считаются источником истины. Внутренне `v-model` использует разные свойства и генерирует разные события для различных элементов ввода:
- элементы для ввода текста и многострочного текста используют свойство `value` и событие `input`;
- чекбоксы и радиокнопки используют свойство `checked` и событие `change`;
- выпадающие списки используют свойство `value` и событие `change`.

Аналогично директивам: `v-bind:value="<имя_свойства>" v-on:input="<имя_свойства> = $event.target.value"`

```html
<input v-model="message" placeholder="отредактируй меня">
<p>Введенное сообщение: {{ message }}</p>
```

```html
<div>
    <input type="checkbox" id="jack" value="Джек" v-model="checkedNames">
    <label for="jack">Джек</label>
    <input type="checkbox" id="john" value="Джон" v-model="checkedNames">
    <label for="john">Джон</label>
    <br>
    <span>Отмеченные имена: {{ checkedNames }}</span>
</div>
```

Для радиокнопок и выпадающих списков в качестве `v-model` обычно используются статические строки, а для чекбоксов - булевые значения.

Для чекбокса можно указать атрибуты `true-value="<значение_при_выборе>"` и `false-value="<значение_при_сбросе>"`

> `<input type="checkbox" v-model="toggle" true-value="да" false-value="нет">`

Через директиву `v-bind:value="<имя_свойства>"` можно задать значение из свойства.

Модификаторы для `v-model`:
- `.lazy` - синхронизация будет только по событию `change`;
- `.number` - автоматически приводит значение к числу, если не получается, то возвращается оригинальная строка;
- `.trim` - автоматически обрезает пробелы в начале и в конце строки.

<a id="Основы-компонентов" href="#Основы-компонентов">Основы компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==================

**Компоненты** - это переиспользуемые экземпляры Vue со своим именем.

Компоненты принимают те же опции что и `new Vue`, такие как `data`, `computed`, `watch`, `methods`, хуки жизненного цикла.

Компоненты должны именоваться с высшего уровня (часто наиболее общих слов) и заканчиваться описательными дополняющими словами.

Стиль именования компонентов в JS/JSX всегда должен быть **PascalCase**, хотя они могут быть в **kebab-case** внутри строк для простых приложений, которые используют только глобальную регистрацию компонентов через Vue.component.

Объявление:
```javascript
Vue.component('<имя-компонента>', {
    /**
     * Автоматически устанавливается при регистрации - имя компонента
     * @type {string=}
     */
    name: '<имя-компонента>',
    /**
     * Функция по созданию объекта изначальных данных
     * @type {function (): {}}
     */
    data: function () {
        // `this` указывает на экземпляр vm и содержит переданые входные параметры
        return {};
    },
    /**
     * Содержит массив входных параметров, которые будут переданы в компонент
     * оно становится свойством экземпляра компонента.
     * Если имя записано в параметре в виде *camelCase*,
     * то оно должно быть в HTML в kebab-case.
     * Может быть в виде объекта, где ключ - имя параметра, а значение - его тип
     * @type {string[] | Object.<string, Function | Function[] | {type: Function, required: boolean, default: function (): {} | *, validator: function (*): boolean}>}
     */
    props: ['<параметр-1>'],
    props: {
        '<параметр-1>': Number,
        '<параметр-2>': [Number, Boolean],
        '<параметр-3>': {
            type: Boolean, // тип
            required: true, // обязательность параметра
            default: '<значение>', // значение по умолчанию
            default: function () {
                return {};
            }, // значение по умолчанию для объектов или массивов должно возвращать новый экземпляр
            validator: function (value) {
                return true; // должно возвращать `true`, если `value` проходит валидацию
            } // функция валидации переданого параметра
        },
    },
    /*
     * Отключает наследование атрибутов
     */
    inheritAttrs: false,
    /**
     * Используется для двунаправленного связывания события и изменяемого свойства
     * при использовании `v-model` для связывания
     * @type {{prop: string, event: string}=}
     */
    model: {
        prop: '<имя_параметра>',
        event: '<тип_события>',
    },
    /**
     * Функция по предоставлению данных или методов всем компонентам-потомкам
     * @type {function (): {}=}
     */
    provide: function () {
        // `this` указывает на экземпляр vm и содержит переданые входные параметры
        return {};
    },
    /**
     * Содержит массив входных свойств, которые будут предоставленны компонентом родителем
     * @type {string[]=>}
     */
    inject: ['<свойство-1>'],
    /**
     * Содержит массив примесей из опций компонентов
     * @type {object[]=>}
     */
    mixins: [],
    /**
     * Содержит текст шаблона для отрисовки. Должен содержать только один корневой элемент
     * `<slot><!--<значение_по_умолчанию>--></slot>` - содержит содержимое внутри компонетна
     * @type {string}
     */
    template: '<текст_шаблона>',
    /**
     * при значении true превращает компонент в функциональный компонент, то есть не имеющий собственного состояния data и своего экземпляра this. Это сильно ускоряет их отрисовку.
     * @type {boolean}
     */
    functional: false
});
```

Все входные параметры образуют одностороннюю привязку между дочерним свойством и родительским: когда родительское свойство обновляется - оно будет передаваться дочернему, но не наоборот. Каждый раз, когда обновляется родительский компонент, все входные параметры дочернего компонента будут обновлены актуальными значениями. Это означает, что не надо изменять входной параметр внутри дочернего компонента.

Входные параметры должны всегда использовать **camelCase** при определении, но **kebab-case** в шаблонах и JSX.

Для большинства атрибутов значение, предоставляемое компоненту, будет заменять значение, заданное компонентом, но не для атрибутов `class` и `style`, так как оба значения будут объединены в итоговое.

Свойство `$attrs` - содержит имена атрибутов и значения, переданные компоненту в виде объекта.

Модификатор `.sync` для `v-bind` обеспечивает двустороннюю привязку входных параметров. Но это не работает с вычисляемыми выражениями.

**Все в родительском шаблоне компилируется в области видимости родительского компонента; все в дочернем шаблоне компилируется в области видимости дочернего компонента.**

Использование:
```html
<div id="components">
    <имя-компонента <параметр-1>="<значение>">содержимое1</имя-компонента>
    <имя-компонента <параметр-1>="<значение>">содержимое2</имя-компонента>
</div>
```

Элементы с несколькими атрибутами должны располагаться на нескольких строках, по одному атрибуту на строку.

```javascript
new Vue({el: '#components'});
```

Для передачи параметра и директивы `v-for` используется директива `v-bind:<параметр>="<значение>"`.

> `<blog-post v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title"></blog-post>`

Структура компонента в модулях:
```vue
<template>
    <!-- html-код компонента -->
</template>
<script>
// код компонента
export default {
    /* опции компонента */
};
</script>
<style scoped>
    /* CSS-стили компонента */
</style>
```

## <a id="Слоты" href="#Слоты">Слоты</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Слот - представляет собой содержимое тега, которое передали в него, задаются в виде:  
`<slot><значение_по_умолчанию></slot>`.

При отрисовке компонента `<slot></slot>` будет заменен на содержимое тега. Слоты могут содержать любой код шаблона, в том числе HTML.

Директива `v-slot:<имя_слота>` на `<template>` используется для указания содержимого для именованного слота:  
`<template v-slot:<имя_слота>>[<значение_по_умолчанию>]</template>`  
Это будет отрисовано в слот: `<slot name="<имя_слота>">[<значение_по_умолчанию>]</slot>`

Все внутри элементов `<template>` будет передаваться в соответствующие слоты. Любое содержимое, не обернутое в `<template>` с использованием `v-slot`, предназначается для слота по умолчанию `default`.

```html
<имя-компонента>
    <template v-slot:<имя_слота>>
        <!--<содержимое_слота>-->
    </template>
</имя-компонента>
```

### <a id="Входные-параметры-слота" href="#Входные-параметры-слота">Входные параметры слота</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Чтобы сделать параметр `<параметр>` доступным для содержимого слота в родительском компоненте, необходимо добавить привязку параметра `<параметр>` в качестве атрибута на элементе `<slot>` `v-bind:<параметр>="<имя_свойства>"` и тогда атрибуты, привязанные к элементу `<slot>`, можно использовать `v-slot:<имя_слота>="<имя_свойства>"` в `<template>` со значением, чтобы указать имя для предоставленных слоту входных параметров. Можно использовать динамические аргументы: `v-slot:[<имя_свойства>]="<имя_метода>"`. Для сокращения используется вместо `v-slot:` - `#`.

```html
<template v-slot:default="slotProps">
    <!--переопределение-->
    {{ slotProps.user.firstName }}
</template>
<!--...-->
<slot v-bind:user="user">
    <!--по умолчанию-->
    {{ user.lastName }}
</slot>
```

В случаях, когда только слоту по умолчанию предоставляется содержимое, тег компонента можно использовать в качестве шаблона слота вместо `<template>`. Это позволяет использовать `v-slot` непосредственно на компоненте.

```html
<имя-компонента v-slot="slotProps">
    <!--<содержимое_слота>-->
</имя-компонента>
```

Сокращенный синтаксис для слота по умолчанию нельзя смешивать с именованными слотами.

Можно также использовать деструктурирование во входных параметрах слота.

## <a id="События-компонента" href="#События-компонента">События компонента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

### <a id="Вызов-событий-компонента" href="#Вызов-событий-компонента">Вызов событий компонента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Для этого используется `v-on:<имя-события>[<имя_модификатора>]="$emit('<имя-события>'[, <параметр1>[, ...]])"` - производит генерацию события `<имя-события>` с указаными параметрами, тогда значение этого параметра будет содержаться в переменной `$event` или быть первым параметром в функции обработчике. Также можно использовать в методах компонента `this.$emit('<имя-события>'[, <параметр1>[, ...]]`.

Рекомендуется всегда использовать **kebab-case** для имен событий.

При использовании на компоненте директивы `v-model` делает следующее:
```html
<имя-компонента
    v-bind:value="<имя_свойства>"
    v-on:input="<имя_свойства> = $event"
></имя-компонента>
```

### <a id="Прослушивание-событий-компонента" href="#Прослушивание-событий-компонента">Прослушивание событий компонента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`this.$on('<имя-события>', function () {...})` - добавляет обработчик на прослушивание события `<имя-события>`.  
`this.$once('<имя-события>', function () {...})` - добавляет обработчик на прослушивание события `<имя-события>` только один раз.  
`this.$off('<имя-события>', function () {...})` - убирает обработчик на прослушивание события `<имя-события>`.

## <a id="Динамическое-переключение-компонентов" href="#Динамическое-переключение-компонентов">Динамическое переключение компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<component v-bind:is="<имя_свойства_имени_компонента>"></component>` - будет отображен только указаный компонент в значении, может быть:
- именем зарегистрированного компонента;
- объектом с настройками компонента.

> `<component v-bind:is="currentTabComponent"></component>`

Элемент `<keep-alive>` позволяет кешировать компоненты, а не пересоздовать их с нуля при отображении.

## <a id="Алиас-компонета" href="#Алиас-компонета">Алиас компонета</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`<<тег> is="<имя_компонента>"></<тег>>` - указаный тег `<тег>` будет считаться компонетном `<имя_компонента>`.

> `<tr is="blog-post-row"></tr>`

## <a id="Доступы" href="#Доступы">Доступы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

`$root` - ссылка на корневой экземпляр.  
> `this.$root.map`

`$parent` - ссылка на родительский экземпляр текущего экземпляра.  
> `this.$parent.map`

`$refs` - объект ссылок на дочерние компоненты и элементы.  
`this.$refs.<ссылка>` будет равен дочернему компоненту которому с помощью атрибута `ref="<ссылка>"` назначена ссылка.  
`$refs` заполняются только после того, как компонент был отрисован, и они не реактивны.
> `<base-input ref="usernameInput"></base-input>`  
> `<input ref="input">`

<a id="Правила-описания-компонентов" href="#Правила-описания-компонентов">Правила описания компонентов</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============================

## <a id="Порядок-опций-компонентаэкземпляра" href="#Порядок-опций-компонентаэкземпляра">Порядок опций компонента/экземпляра</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- **Побочные эффекты** (вызывает эффекты вне компонента):
    - `el`
- **Глобальная осведомлённость** (требует знаний вне компонента):
    - `name`
    - `parent`
- **Тип компонента** (изменяет тип компонента):
    - `functional`
- **Модификаторы шаблона** (изменение способа компиляции шаблонов):
    - `delimiters`
    - `comments`
- **Зависимости шаблона** (ресурсы, используемые в шаблоне):
    - `components`
    - `directives`
    - `filters`
- **Композиция** (объединение свойств в опциях):
    - `extends`
    - `mixins`
- **Интерфейс** (интерфейс компонента):
    - `inheritAttrs`
    - `model`
    - `props`
    - `propsData`
- **Локальное состояние** (локальные реактивные свойства):
    - `data`
    - `computed`
- **События** (коллбэки вызываемые реактивными событиями):
    - `watch`
- **События хуков жизненного цикла** (в порядке их вызова):
    - `beforeCreate`
    - `created`
    - `beforeMount`
    - `mounted`
    - `beforeUpdate`
    - `updated`
    - `activated`
    - `deactivated`
    - `beforeDestroy`
    - `destroyed`
- **Нереактивные свойства** (свойства экземпляра независимые от системы реактивности):
    - `methods`
- **Отрисовка** (декларативное описание вывода компонента):
    - `template`
    - `render`
    - `renderError`

## <a id="Порядок-атрибутов-элемента" href="#Порядок-атрибутов-элемента">Порядок атрибутов элемента</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

- **Определение** (предоставляет параметры компонента):
    - `is`
- **Отображение списка** (создаёт несколько вариантов одного элемента):
    - `v-for`
- **Условия** (указывается отрисовывается/отображается ли элемент):
    - `v-if`
    - `v-else-if`
    - `v-else`
    - `v-show`
    - `v-cloak`
- **Модификаторы отрисовки** (изменяют способ отрисовки элемента):
    - `v-pre`
    - `v-once`
- **Глобальная осведомлённость** (требует знаний вне компонента):
    - `id`
- **Уникальные атрибуты** (атрибуты, требующие уникальных значений):
    - `ref`
    - `key`
    - `slot`
- **Двусторонняя привязка** (объединение привязки и событий):
    - `v-model`
- **Другие атрибуты** (все неуказанные связанные или несвязанные атрибуты):
- **События** (обработчики событий компонента):
    - `v-on`
- **Содержимое** (перезаписывает содержимое элемента):
    - `v-html`
    - `v-text`

<a id="Анимирование" href="#Анимирование">Анимирование</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
============

<a id="Примеси" href="#Примеси">Примеси</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

Примеси (mixins) - это инструмент повторного использования кода в компонентах Vue. Объект примеси может содержать любые опции компонентов. При использовании компонентом примеси, все опции примеси *"подмешиваются"* к собственным опциям компонента.

## <a id="Слияние-опций" href="#Слияние-опций">Слияние опций</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Объект `data` претерпевает рекурсивное слияние с объектом `data` компонента, который имеет приоритет в случаях конфликтов.

Функции **хуков** с одинаковыми именами объединяются в массив, чтобы все они вызывались. **Хуки** примеси будут вызываться перед собственными хуками компонента.

Опции, ожидающие значения в форме объектов, такие как `methods`, `components` и `directives` будут объединены. В случае конфликта, приоритет имеют опции компонента.

## <a id="Глобальные-примеси" href="#Глобальные-примеси">Глобальные примеси</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Оказывает вляиние на все экземпляры Vue, создаваемые в дальнейшем. Используется с теме же параметрами что и простая примесь: `Vue.mixin(<параметры>)`.

<a id="Пользовательские-директивы" href="#Пользовательские-директивы">Пользовательские директивы</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
==========================

Позволяют объявить собственные директивы `v-<имя-директивы>`.

```javascript
Vue.directive('<имя-директивы>', {
    
    /**
     * Описывает строение директивы `v-<имя-директивы>:<аргумент>.<модификатор>="<значение>"`
    * @typedef Binding
    * @type {object}
    * @property {string} name название директивы, без указания префикса `v-`
    * @property {*} value вычисленное выражение значения переданное в директиву `="<значение>"`
    * @property {*=} oldValue предыдущее вычисленное значение переданное в директиву, только для хуков `update` и `componentUpdated`
    * @property {string} expression выражение-строка, переданное в директиву `="<значение>"`
    * @property {string} arg аргумент, переданный в директиву, в случае его наличия `:<аргумент>`
    * @property {Object.<string, boolean>} modifiers объект, содержащий модификаторы `.<модификатор>`, если они есть
    */
    /**
     * Вызывается однократно, при первичном связывании директивы с элементом
     * @type {function(HTMLElement, Binding, VNode=, VNode=)=>}
     */
    bind: function (el, binding, vnode, oldVnode) {},
    /**
     * Вызывается после вставки связанного элемента внутрь элемента родителя
     * при этом может быть что сам родитель может на этот момент и не принадлежать еще
     * основному дереву элементов
     * @type {function(HTMLElement, Binding, VNode=, VNode=)=>}
     */
    inserted: function (el, binding, vnode, oldVnode) {},
    /**
     * Вызывается после обновления VNode компонента-контейнера,
     * но, возможно, до обновления дочерних элементов.
     * Значение директивы к этому моменту может измениться, а может и нет
     * @type {function(HTMLElement, Binding, VNode=, VNode=)=>}
     */
    update: function (el, binding, vnode, oldVnode) {},
    /**
     * Вызывается после обновления как VNode компонента-контейнера,
     * так и VNode его потомков
     * @type {function(HTMLElement, Binding, VNode=, VNode=)=>}
     */
    componentUpdated: function (el, binding, vnode, oldVnode) {},
    /**
     * Вызывается однократно, при отвязывании директивы от элемента
     * @type {function(HTMLElement, Binding, VNode=, VNode=)=>}
     */
    unbind: function (el, binding, vnode, oldVnode) {},
});
```

<a id="Плагины" href="#Плагины">Плагины</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
=======

Плагины позволяют добавить во `Vue` некоторую глобальную функциональность. Плагины делятся на нескольких типов:
- добавляют глобальные методы и/или свойства;
- добавляют глобальные объекты: директивы/фильтры/переходы и т.д.;
- добавляют опции компонентам через глобальную примесь;
- добавляют методы экземпляра `Vue` через `Vue.prototype`;
- библиотеки, предоставляющие собственные API и комбинирующие вышеперечисленные возможности.

Для использования плагина необходимо вызвать глобальный метод `Vue.use(<плагин>[, <опции>])`. Его нужно вызывать перед `new Vue()`.

Строение плагина:
```javascript
const <Plugin> = {
    /**
     * Метод установки плагина
     * @param {{}} Vue экземпляр Vue
     * @param {{}=} options опции переданые плагину
     */
    install(Vue, options) {
        // добавление глобального метода или свойства
        Vue.<имя_глобального_метода> = function () {/*...*/};
        // добавление глобального объекта
        Vue.directive('<имя-компонента>', <параметры>);
        // добавление глобальных опций компонентам
        Vue.mixin(<параметры>);
        // добавление метода экземпляра
        Vue.prototype.$myMethod = function (methodOptions) {/*...*/};
    }
}
```

<a id="Vuex" href="#Vuex">Vuex</a> [<a id="Содержание" href="#Содержание">Содержание</a>]
====

**Vuex** - паттерн управления состоянием + библиотека для приложений на Vue.js. Он служит централизованным хранилищем данных для всех компонентов приложения с правилами, гарантирующими, что состояние может быть изменено только предсказуемым образом.

## <a id="Установка" href="#Установка">Установка</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```bash
npm install vuex --save
```

## <a id="Подключение" href="#Подключение">Подключение</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```javascript
import Vuex from 'vuex';
Vue.use(Vuex);
new Vue({
    // ...
    // Это указывает хранилище в опции "store", что обеспечит
    // доступ к нему также и во всех дочерних компонентах через `this.$store`
    store: new Vuex.Store(options/*<опциии>*/),
    // ...
}).$mount('#main');
```

## <a id="Структура" href="#Структура">Структура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Vuex использует единое дерево состояния - когда один объект содержит все глобальное состояние приложения и служит "единственным источником истины". Это также означает, что в приложении будет только одно такое хранилище.

```javascript
const store = new Vuex.Store({
    // Описывает хранилище
    state: {
        //...
        '<свойство1>': {/*...*/}
    },
    // Геттеры для получения частей хранилища
    getters: {
        /**
         * Возвращает часть хранилища
         * @param {{}} state хранилище (локальное)
         * @param {{}=} getters объект геттеров (локальных)
         * @param {{}=} rootState хранилище (глобальное)
         * @param {{}=} rootGetters объект геттеров (глобальных)
         * @return {*}
         */
        '<геттер1>': (state, getters, rootState, rootGetters) => {
            return '<newValue>';
        },
        /**
         * Возвращает функцию, которая возвращает часть хранилища
         * @param {{}} state хранилище (локальное)
         * @param {{}=} getters объект геттеров (локальных)
         * @param {{}=} rootState хранилище (глобальное)
         * @param {{}=} rootGetters объект геттеров (глобальных)
         * @return {Function}
         */
        '<геттер2>': (state, getters, rootState, rootGetters) => (arg1/*, ...*/) => {
            return '<newValue>';
        }
    },
    // Мутации для изменения хранилища
    mutations: {
        /**
         *
         * @param {{}} state
         * @param {*} arg1 аргумент вызова, при объектном вызове будет содержать весь объект мутации
         */
        ['<мутация1>'](state, arg1/*, ...*/) {
            // меняет состояние хранилища
        }
    },
    // Действия для инициаций мутаций
    actions: {
        /**
         *
         * @param {Object} context объект контекста, содержащий те же методы и свойства что и сам экземпляр хранилища
         * @param {function (string, ...*): *} context.dispatch
         * @param {function (string, ...*): *} context.commit
         * @param {{}} context.state хранилище (локальное)
         * @param {{}=} context.rootState хранилище (глобальное)
         * @param {{}=} context.getters объект геттеров (локальных)
         * @param {{}=} context.rootGetters объект других геттеров (глобальных)
         * @param {*} arg1 аргумент вызова, при объектном вызове будет содержать весь объект действия
         * @return {*}
         */
        ['<действие1>'](context, arg1/*, ...*/) {
            // вызываtn мутации или действия
        }
    },
    // Содержит модули, для доступа к ним используется `store.<модуль1>`
    modules: {
        '<модуль1>': {/*...*/}
    },
});
```

Главное: **обработчики мутаций обязаны быть синхронными**.

Действия могут использоваться для асинхронных операций.

Иногда мутации именуются через константы для следования Flux-подхода.

`dispatch` - может обрабатывать `Promise`, возвращаемый обработчиком действия, и также возвращает `Promise`.

Для использования части хранилища в компоненте, проще просто вернуть часть состояния хранилища в вычисляемом свойстве: `this.$store[<часть>]`.

```javascript
import { mapState, mapGetters, mapMutations, mapActions } from 'vuex';
export default {
    // ...
    computed: {
        // ...
        ['<свое_свойство1>']() { /* ... */ },
        ['<свойство_из_хранилища1>']() {
            return this.$store['<часть>'];
        },
        // Подмешивание результата mapState с вычисляемыми свойствами
        ...mapState({
            // Стрелочные функции
            '<свойство1>': state => state['<часть>'],
            // Передача строки '<часть>' аналогична записи `state => state['<часть>']`
            '<свойство2>': '<часть>',
            // Для доступа к локальному состоянию через `this`, необходимо использовать обычную функцию
            ['<свойство3>'](state) {
                return '<newValue>';
            }
        }),
        // Подмешивание результата mapGetters с вычисляемыми свойствами
        ...mapGetters({
            '<свойство1>': '<часть>',
        })
    },
    methods: {
        // ...
        // Проксирует `this.<метод1>([<арг1>[, ...]])`
        // в `this.$store.commit('<мутация>'[<арг1>[, ...]])`
        ...mapMutations({
            ['<метод1>']: '<мутация>',
        }),
        // Проксирует `this.<метод2>([<арг1>[, ...]])`
        // в `this.$store.dispatch('<действие>'[<арг1>[, ...]])`
        ...mapActions({
            ['<метод2>']: '<действие>',
        }),
    },
}
```

Для использования геттеров хранилища в компоненте в вычисляемом свойстве используется: `this.$store.getters.<геттер>` или если геттер метод, то `this.$store.getters.<геттер>(/*...*/)`.

Для изменения хранилища используются мутации: `this.$store.commit('<мутация>'[, <арг1>[, ...]][, { root: true }])` или:
```javascript
this.$store.commit({
    type: '<мутация>'
    [, <свойство1>: <значение>
    [, ...]]
}[, { root: true }]);
```

Действия поддерживают тот же формат что и мутации для передачи нагрузки, а также объектный синтаксис. Вызываются: `this.$store.dispatch('<действие>'[, <арг1>[, ...]][, { root: true }])`. При этом `dispatch` возвращает то что возвращает само действие.

Для вызова частей из модуля используется структура `'<модуль>/<часть>'`.

## <a id="Модули" href="#Модули">Модули</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

Каждый модуль может содержать собственное состояние, мутации, действия, геттеры и даже встроенные подмодули - их структура фрактальна:
```javascript
const moduleA = {
    state: {/*...*/},
    mutations: {/*...*/},
    actions: {/*...*/},
    getters: {/*...*/},
    modules: {/*...*/},
    // Устанавливает пространство имен
    namespaced: true,
}
```

Первым аргументом, который получают мутации и геттеры, будет **локальное состояние модуля**. Аналогично, `context.state` в действиях также указывает на локальное состояние модуля, а корневое - доступно в `context.rootState`.

При установленном **пространстве имен**, когда модуль будет зарегистрирован, все его геттеры, действия и мутации будут автоматически связаны с этим пространством имен, основываясь на пути по которому зарегистрирован модуль: `getters['<модуль>/<геттер>']`.

Геттеры и действия с собственным пространством имен будут получать свои локальные `getters`, `dispatch` и `commit`.

## <a id="Структура" href="#Структура">Структура</a> [<a id="Содержание" href="#Содержание">Содержание</a>]

```
    store
    ├── index.js          # здесь собираются модули и экспортируется хранилище
    ├── actions.js        # корневые действия
    ├── mutations.js      # корневые мутации
    └── modules
        ├── <модуль1>.js  # модуль 1
        └── <модуль2>.js  # модуль 2
```