[Содержание](#Содержание)
==========

- [Описание](#Описание)
- [Установка](#Установка)
    - [Подключение через `<script>`](#Подключение-через-script)
- [Основы](#Основы)
    - [Экземпляр Vue](#Экземпляр-Vue)
    - [Диаграмма жизненного цикла](#Диаграмма-жизненного-цикла)
    - [Синтаксис шаблонов](#Синтаксис-шаблонов)
        - [Интерполяции](#Интерполяции)
        - [Директивы](#Директивы)
            - [Условные директивы](#Условные-директивы)
            - [Отображение перебираемых объектов с помощью директивы `v-for`](#Отображение-перебираемых-объектов-с-помощью-директивы-v-for)
            - [Директива обработки событий `v-on`](#Директива-обработки-событий-v-on)
    - [Работа с формами](#Работа-с-формами)
- [Основы компонентов](#Основы-компонентов)
    - [Вызов событий компонента](#Вызов-событий-компонента)
    - [Динамическое переключение компонентов](#Динамическое-переключение-компонентов)
    - [Алиас компонета](#Алиас-компонета)

<a id="Описание" href="#Описание">Описание</a>
========

**Vue** (произносится */vjuː/*, примерно как **view**) - это прогрессивный фреймворк для создания пользовательских интерфейсов. **Vue** создан пригодным для постепенного внедрения. Его ядро в первую очередь решает задачи уровня представления (view), что упрощает интеграцию с другими библиотеками и существующими проектами.

<a id="Установка" href="#Установка">Установка</a>
=========

## <a id="Подключение-через-script" href="#Подключение-через-script">Подключение через `<script>`</a>

`<script src="https://cdn.jsdelivr.net/npm/vue"></script>` - для прототипов.  
`<script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>` - для релиза.

<a id="Основы" href="#Основы">Основы</a>
======

## <a id="Экземпляр-Vue" href="#Экземпляр-Vue">Экземпляр Vue</a>

`const vm = new Vue(<опции>)` - создание экземпляра `Vue`. Переменную с экземпляром `Vue` традиционно именуют `vm` (сокращённо от **ViewModel**). Где `<опции>` представляют собой объект со свойствами:
- `data` - объект с данными, **Vue** добавляет все свойства, найденные в опции `data`, в систему реактивности **Vue**, это означает что если изменять свойство `data.<свойство>`, то изменится и свойство `vm.<свойство>` и наоборот. Чтобы свойсво было реактивным, оно должно существовать в объекте изначально;
- `el` - строка селектора куда будет отрисован экземпляр;

Свойства и методы экземпляра (их имена начинаются с префикса `$`, чтобы отличаться от пользовательских свойств):
- `$data` - ссылка на изначальный объект из опций `data`;
- `$el` - DOM-элемент селектора из опций `el`;

```javascript
const vm = new Vue({
    /**
     * Объект с данными, **Vue** добавляет все свойства, найденные в опции `data`,
     * в систему реактивности **Vue**, это означает что если изменять свойство
     * `data.<свойство>`, то изменится и свойство `vm.<свойство>` и наоборот.
     * Чтобы свойсво было реактивным, оно должно существовать в объекте изначально
     * @type {Object}
     */
    data: {},
    /**
     * Строка селектора куда будет отрисован экземпляр
     * @type {string=}
     */
    el: '',
    /**
     * Объект для определения вычисляемых свойств. При изменении свойств,
     * вычисляемые свойства вычислятся из функций. Могут быть изменяемыми.
     * При этом вычисляемые свойства кэшируются, основываясь на своих реактивных зависимостях
     * @type {Object.<string, function (): *|{get: function (): *, set: function (string)}>=}
     */
    computed: {
        property: function () {
            // `this` указывает на экземпляр vm
            return '<newValue>' || {};
        },
        property2: {
            get: function () {
                // `this` указывает на экземпляр vm
                return '<newValue>' || {};
            },
            set: function (newValue) {
                // `this` указывает на экземпляр vm
            }
        }
    },
    /**
     * Объект для слежения за свойствами.
     * Будут вызваны указаные функции при изменении указаного свойства.
     * @type {Object.<string, function ()>=}
     */
    watch: {
        property: function () {
            // `this` указывает на экземпляр vm
        }
    },
    /**
     * Объект для методов.
     * @type {Object.<string, function (Event)|function (*)>=}
     */
    methods: {
        name: function (event) {
            // `this` указывает на экземпляр vm
        }
    },
    /**
     * Хук, который выполнится после создания экземпляра
     * @type {function ()=}
     */
    created: function () {
        // `this` указывает на экземпляр vm
    },
})
```

## <a id="Диаграмма-жизненного-цикла" href="#Диаграмма-жизненного-цикла">Диаграмма жизненного цикла</a>

![](../assets/Vue/lifecycle.png)

## <a id="Синтаксис-шаблонов" href="#Синтаксис-шаблонов">Синтаксис шаблонов</a>

Шаблоны могут как находится в DOM-дереве, так и в `<script type="text/x-template"><текст_шаблона></script>`.

### <a id="Интерполяции" href="#Интерполяции">Интерполяции</a>

`{{ <имя_свойства> }}` - выражение в фигурных скобках будет заменено значением свойства `<имя_свойства>` соответствующего объекта данных и оно будет обновлено при любом изменении этого свойства.  
Можно указывать любое выражение JavaScript, которое возвращает данные. Из глобальных объектов доступны только объекты `Math` и `Date`.

> `{{ message.split('').reverse().join('') }}`

### <a id="Директивы" href="#Директивы">Директивы</a>

**Директивы** - это специальные атрибуты с префиксом `v-`. В качестве значения они принимают одно выражение JavaScript (за исключением `v-for`). Директива реактивно применяет к DOM изменения при обновлении значения этого выражения.

При использовании директивы `v-once` у элемента, это свойство будет отрисовано **только раз** и не будет обновляться.

> `<span v-once>Это сообщение никогда не изменится: {{ msg }}</span>`

При использовании директивы `v-html="<имя_свойства>"` у элемента, это свойство будет **интерпретированно как обычный HTML** и вставленно внутрь этого элемента.

> `<p>Директива v-html: <span v-html="rawHtml"></span></p>`

Для указания **значений атрибутов** используется директива `v-bind:<имя_атрибута>="<имя_свойства>"` у элемента. Для логических атрибутов действеут такое правило, если значение будет `null`, `undefined` или `false`, то атрибут не добавится в элемент. Можно использовать динамические аргументы: `v-bind:[<имя_свойства>]="<имя_свойства>"`. Для сокращения используется вместо `v-bind:` `:`.

> `<button v-bind:disabled="isButtonDisabled">Кнопка</button>`  
> `<a v-bind:[attributeName]="url"> ... </a>`

Для указания **классов** используется директива `v-bind:class="{<имя_класса>: <имя_свойства>}"` или `v-bind:class="<имя_свойства_объекта_классов>"` или `v-bind:class="[<имя_свойства1>[, ...]]"` у элемента. При истинном значении ключа `<имя_класса>` указанный `<имя_класса>` будет добавлен к элементу, при ложном удален.

> `<div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>`  
> `<div class="static" v-bind:class="classObject"></div>`  
> `<div v-bind:class="[activeClass, errorClass]"></div>`

Для указания **inline-стилей** используется директива `v-bind:style="{<имя_css_свойсва>: <имя_свойства>}"` или `v-bind:style="<имя_свойства_css_свойсв>"` у элемента.

> `<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>`  
> `<div v-bind:style="styleObject"></div>`

#### <a id="Условные-директивы" href="#Условные-директивы">Условные директивы</a>

При использовании директивы `v-if="<имя_свойства>"` у элемента, **Vue** удалит или вставит элемент в зависимости от истинности значения выражения `<имя_свойства>`.

> `<p v-if="seen">Сейчас меня видно</p>`

Для группировки используется псевдоэлемент `<template>`, который служит невидимой обёрткой и сам в результатах отрисовки не появляется.

Для указания блока **else if** для `v-if` используется директива `v-else-if`. Элемент с директивой `v-else-if` должен следовать сразу за элементом с директивой `v-if` или `v-else-if`, иначе он не будет распознан.  
Для указания блока **иначе** для `v-if` используется директива `v-else`. Элемент с директивой `v-else` должен следовать сразу за элементом с директивой `v-if` или `v-else-if`, иначе он не будет распознан.

```html
<template v-if="ok">
    <h1>Заголовок</h1>
    <p>Абзац 1</p>
    <p>Абзац 2</p>
</template>
<div v-else-if="type === 'C'">
    <p>Абзац C</p>
</div>
<div v-else>
    <p>Абзац 2</p>
</div>
```

При использовании директивы `v-show="<имя_свойства>"` у элемента, **Vue** скроет или покажет элемент в зависимости от истинности значения выражения `<имя_свойства>`, при этом элемент будет всегда оставаться в DOM, а изменяться будет лишь свойство `display` в его параметрах CSS.

> `<h1 v-show="ok">Привет!</h1>`

#### <a id="Отображение-перебираемых-объектов-с-помощью-директивы-v-for" href="#Отображение-перебираемых-объектов-с-помощью-директивы-v-for">Отображение перебираемых объектов с помощью директивы `v-for`</a>

Для массивов используется директива `v-for="<имя_элемента_массива> in <имя_свойства>"` или `v-for="(<имя_элемента_массива>, <индекс>) in <имя_свойства>"` у элемента. Где `<имя_элемента_массива>` - ссылка на текущий элемент массива. Вместо `in` разделителем можно использовать `of`, как в итераторах JavaScript.

Рекомендуется всегда указывать атрибут `key` с `v-for`, через директиву `v-bind:key="<имя_элемента_массива>.<ключ>"`, кроме случаев когда итерируемый контент DOM прост, или используется стратегия обновления по умолчанию для улучшения производительности.

```html
<li v-for="(item, index) in items" v-bind:key="item.id">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
</li>
```

Для объектов аналогично используется директива `v-for="<имя_значения_ключа_объекта> in <имя_свойства>"` или `v-for="(<имя_значения_ключа_объекта>, <имя_ключа_объекта>) in <имя_свойства>"` или `v-for="(<имя_значения_ключа_объекта>, <имя_ключа_объекта>, <индекс>) in <имя_свойства>"` у элемента. Где `<имя_значения_ключа_объекта>` - ссылка на текущие значение объекта.

```html
<div v-for="(value, name, index) in object">
    {{ index }}. {{ name }}: {{ value }}
</div>
```

Для изменения значений элемента массива или ключей объекта используется `Vue.set(vm.<имя_свойства>, <индекс_ключ>, <значения>)` или для массива `vm.<имя_свойства>.splice(<индекс>, 1, <значения>)` вместо `vm.<имя_свойства>[<индекс_ключ>] = <значения>`.

Подобно использованию с `v-if`, также можно использовать тег `<template>` с директивой `v-for` для отображения блока из нескольких элементов.

Когда присутствуют вместе на одном элементе, `v-for` имеет больший приоритет, чем `v-if`. Поэтому `v-if` будет выполняться для каждой итерации цикла.



```html
<li v-for="todo in todos" v-if="!todo.isComplete">
    {{ todo }}
</li>
```

#### <a id="Директива-обработки-событий-v-on" href="#Директива-обработки-событий-v-on">Директива обработки событий `v-on`</a>

Для указания **функций обработки событий** используется директива `v-on:<имя_события>[<имя_модификатора>]="<имя_метода>"` у элемента, где `<имя_события>` может быть нативным событием или собственным. Можно использовать динамические аргументы: `v-on:[<имя_свойства>]="<имя_метода>"`. Для сокращения используется вместо `v-on:` `@`. Специальная переменная `$event` передает в метод оригинальное событие DOM.

> `<a v-on:click.prevent="doSomething"> ... </a>`  
> `<a v-on:[eventName]="doSomething"> ... </a>`  
> `<button v-on:click="say('hi', $event)">Скажи hi</button>`  

Модификаторы событий:
- `.stop` - предотвращает всплытие события;
- `.prevent` - убирает действие по умолчанию;
- `.capture` - указывает перехватывать все события внутренних компонентов в этом методе;
- `.self` - только при наступлении события у указаного элемента;
- `.once` - вызов обработчика только единождый;
- `.passive` - предотвращает вызов `event.preventDefault()`.

Когда `vm` уничтожается, все слушатели событий автоматически удаляются. Нет необходимости волноваться, что придётся прибираться за собой.

## <a id="Работа-с-формами" href="#Работа-с-формами">Работа с формами</a>

Для двунаправленного связывания данных с элементами форм `input`, `textarea` и `select` используется директива `v-model="<имя_свойства>"`.  
`v-model` игнорирует начальное значение атрибутов `value`, `checked` или `selected` на любых элементах форм. Данные экземпляра **Vue** всегда считаются источником истины. Внутренне `v-model` использует разные свойства и генерирует разные события для различных элементов ввода:
- элементы для ввода текста и многострочного текста используют свойство `value` и событие `input`;
- чекбоксы и радиокнопки используют свойство `checked` и событие `change`;
- выпадающие списки используют свойство `value` и событие `change`.

Аналогично директивам: `v-bind:value="<имя_свойства>" v-on:input="<имя_свойства> = $event.target.value"`

```html
<input v-model="message" placeholder="отредактируй меня">
<p>Введённое сообщение: {{ message }}</p>
```

```html
<div>
    <input type="checkbox" id="jack" value="Джек" v-model="checkedNames">
    <label for="jack">Джек</label>
    <input type="checkbox" id="john" value="Джон" v-model="checkedNames">
    <label for="john">Джон</label>
    <br>
    <span>Отмеченные имена: {{ checkedNames }}</span>
</div>
```

Для радиокнопок и выпадающих списков в качестве `v-model` обычно используются статические строки, а для чекбоксов - булевые значения.

Для чекбокса можно указать атрибуты `true-value="<значение_при_выборе>"` и `false-value="<значение_при_сбросе>"`

> `<input type="checkbox" v-model="toggle" true-value="да" false-value="нет">`

Через директиву `v-bind:value="<имя_свойства>"` можно задать значение из свойства.

Модификаторы:
- `.lazy` - синхронизация будет только по событию `change`;
- `.number` - автоматически приводит значение к числу, если не получается, то возвращается оригинальная строка;
- `.trim` - автоматически обрезает пробелы в начале и в конце строки.

<a id="Основы-компонентов" href="#Основы-компонентов">Основы компонентов</a>
==================

**Компоненты** - это переиспользуемые экземпляры Vue со своим именем.

Компоненты принимают те же опции что и `new Vue`, такие как `data`, `computed`, `watch`, `methods`, хуки жизненного цикла.

Объявление:
```javascript
Vue.component('<имя-компонента>', {
    /**
     * Объект изначальных данных
     * @type {function (): Object}
     */
    data: function () {
        return {}
    },
    /**
     * Содержит массив входных параметров, которые будут переданы в компонент
     * оно становится свойством экземпляра компонента
     * @type {string[]}
     */
    props: ['<параметр1>'],
    /**
     * Содержит текст шаблона для отрисовки.
     * Должен содержать только один корневой элемент
     * `<slot></slot>` - содержит содержимое внутри компонетна
     * @type {string}
     */
    template: '<текст_шаблона>'
})
```

Использование:
```html
<div id="components">
    <имя-компонента <параметр1>="<значение>">содержимое1</имя-компонента>
    <имя-компонента <параметр1>="<значение>">содержимое2</имя-компонента>
</div>
```

```javascript
new Vue({el: '#components'});
```

Для передачи параметра и директивы `v-for` используется директива `v-bind:<параметр>="<значение>"`.

> `<blog-post v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title"></blog-post>`

## <a id="Вызов-событий-компонента" href="#Вызов-событий-компонента">Вызов событий компонента</a>

Для этого используется `v-on:<имя_события>[<имя_модификатора>]="$emit('<имя_события>'[, <параметр1>[, ...]])"` - производит генерацию события `<имя_события>` с указаными параметрами, тогда значение этого параметра будет содержаться в переменной `$event` или быть первым параметром в функции обработчике. Также можно использовать в методах компонента `this.emit('<имя_события>'[, <параметр1>[, ...]]`

При использовании на компоненте директивы `v-model` делает следующее:
```html
<имя-компонента
    v-bind:value="<имя_свойства>"
    v-on:input="<имя_свойства> = $event"
></имя-компонента>
```

## <a id="Динамическое-переключение-компонентов" href="#Динамическое-переключение-компонентов">Динамическое переключение компонентов</a>

`<component v-bind:is="<имя_свойства_имени_компонента>"></component>` - будет отображен только указаный компонент в значении, может быть:
- именем зарегистрированного компонента;
- объектом с настройками компонента.

> `<component v-bind:is="currentTabComponent"></component>`

## <a id="Алиас-компонета" href="#Алиас-компонета">Алиас компонета</a>

`<<тег> is="<имя_компонента>"></<тег>>` - указаный тег `<тег>` будет считаться компонетном `<имя_компонента>`.

> `<tr is="blog-post-row"></tr>`